{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Info</p> <p>The docs are being rewritten. See here for the old docs.</p> <p>The purpose of <code>msl-equipment</code> is to manage information about equipment and to interface with equipment for computer control. The information that is managed is focused on testing and calibration laboratories that are accredited for the ISO/IEC 17025 standard, but the information may also be selectively specified for laboratories that are not required to meet the standard. See the Getting Started page to learn how information is managed and how equipment is controlled.</p>"},{"location":"#install","title":"Install","text":"<p>The <code>msl-equipment</code> repository is organised as a workspace project that is split across multiple packages: <code>msl-equipment</code>, msl-equipment-resources, msl-equipment-validate, and msl-equipment-webapp.</p> <p>The core package is <code>msl-equipment</code> and it is available through the Python Package Index. It can be installed using a variety of package managers</p> pipuvpoetrypdm <pre><code>pip install msl-equipment\n</code></pre> <pre><code>uv add msl-equipment\n</code></pre> <pre><code>poetry add msl-equipment\n</code></pre> <pre><code>pdm add msl-equipment\n</code></pre>"},{"location":"#dependencies","title":"Dependencies","text":"<p>The <code>msl-equipment</code> package depends on the following packages: msl-loadlib, numpy, pyserial, pyzmq</p> <p>The following packages are optional dependencies that may be installed to interface with equipment: msl-equipment-resources, NI-DAQmx, PyVISA, PyVISA-py</p>"},{"location":"license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2017 - 2025, Measurement Standards Laboratory of New Zealand\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#020-2025-03-28","title":"0.2.0 (2025-03-28)","text":"<p>Added:</p> <ul> <li>support for Python 3.12 and 3.13</li> <li><code>find-equipment</code> console script</li> <li><code>msl.equipment.connection_gpib.ConnectionGPIB</code> class</li> <li><code>msl.equipment.resources.greisinger.gmh3000.GMH3000</code> resource</li> <li><code>msl.equipment.resources.isotech.millik.MilliK</code> resource</li> <li><code>msl.equipment.resources.vaisala.ptu300.PTU300</code> resource</li> <li><code>msl.equipment.resources.vaisala.ptb330.PTB330</code> resource</li> </ul> <p>Fixed:</p> <ul> <li>issue #9 \u2014 Missing functions from Avantes AvaSpec DLL</li> <li>issue #8 \u2014 Invalid URL for LXI XML identification document</li> </ul> <p>Removed:</p> <ul> <li>support for Python 2.7, 3.5, 3.6 and 3.7</li> </ul>"},{"location":"release-notes/#010-2023-06-18","title":"0.1.0 (2023-06-18)","text":"<p>Initial release.</p> <p>It is also the last release to support Python 2.7, 3.5, 3.6 and 3.7</p>"},{"location":"validate/","title":"Validate","text":"<p>You may use any XML validating tool to validate equipment registers and connection files against the schema; however, some of the values of the XML elements are not completely validated by the schema alone. For example, the value of an element in an equipment register could be the SHA-256 checksum of a file. The schema will validate that the SHA-256 checksum value has the correct string length and that the checksum only contains the allowed alphanumeric characters, but, the schema does not validate that the checksum value is correct for the associated file. For these additional validation steps, another tool must be used. The <code>msl-equipment-validate</code> command-line tool validates the XML files against the schema and also provides the additional validation steps.</p>"},{"location":"validate/#validate-install","title":"Install","text":"<p><code>msl-equipment-validate</code> is available on PyPI and can be installed with a variety of Python package managers.</p> pippipxuv <pre><code>pip install msl-equipment-validate\n</code></pre> <pre><code>pipx install msl-equipment-validate\n</code></pre> <pre><code>uv tool install msl-equipment-validate\n</code></pre> <p>This will install a command-line tool that you can use to validate the content of equipment registers and connection files.</p> <p>If you used a package manager that does not automatically add the <code>msl-equipment-validate</code> executable to your PATH environment variable (without activating a virtual environment), you may want to add the directory to where the <code>msl-equipment-validate</code> executable is located to your PATH. This will allow you to validate XML documents from any directory without having to first activate a virtual environment.</p>"},{"location":"validate/#command-alias","title":"Command alias","text":"<p>You may also want to create a command alias, since the executable name <code>msl-equipment-validate</code> is rather long. The following assigns an alias <code>check</code> for the <code>msl-equipment-validate</code> executable, but you should pick an alias that you prefer.</p> UnixWindows <p>Add the following to your <code>.bashrc</code> (or <code>.zshrc</code>) file</p> <pre><code>alias check=\"msl-equipment-validate\"\n</code></pre> <p>You can create an alias in your PowerShell profile script. To determine where this file is located, run the following command from your terminal, e.g., PowerShell or Windows Terminal (not Command Prompt)</p> <pre><code>echo $PROFILE\n</code></pre> <p>Open (or create) the <code>Microsoft.PowerShell_profile.ps1</code> file that was displayed in the previous command in a text editor and add the following line</p> <pre><code>Set-Alias check C:\\Update\\to\\be\\the\\path\\to\\msl-equipment-validate.exe\n</code></pre> <p>save it then open a new terminal (or run <code>. $PROFILE</code> in the current terminal to reload the PowerShell profile).</p> <p>Caution</p> <p>If you get an error that the profile script cannot be loaded because running scripts is disabled on this system, run the following command in an elevated (admin) terminal</p> <pre><code>Set-ExecutionPolicy -ExecutionPolicy RemoteSigned\n</code></pre> <p>then restart the terminal.</p>"},{"location":"validate/#validate-usage","title":"Usage","text":"<p>The tool first validates XML files against the schema and once there are no schema-related issues continues to process the additional validation steps (correct SHA-256 checksum values, tables are well formatted, equations contain valid syntax, etc.), therefore, it is possible that the number of issues found increases after the schema-related issues are fixed.</p> <p>To see the help for the tool run</p> <pre><code>msl-equipment-validate --help\n</code></pre> <p>To recursively validate all XML files (that are used by <code>msl-equipment</code>) in the current working directory and all sub directories, run the command without arguments</p> <pre><code>msl-equipment-validate\n</code></pre> <p>or specify specific files to validate</p> <pre><code>msl-equipment-validate my/equipment/register.xml my/equipment/connections.xml\n</code></pre> <p>or specify a specific folder to validate</p> <pre><code>msl-equipment-validate my/equipment\n</code></pre> <p>If the <code>msl-equipment</code> package is also installed, you can use its command-line interface to validate documents. (Note the removal of the hyphen between <code>equipment</code> and <code>validate</code>.)</p> <pre><code>msl-equipment validate\n</code></pre> <p>or to display the help</p> <pre><code>msl-equipment help validate\n</code></pre>"},{"location":"validate/#validate-release-notes","title":"Release Notes","text":""},{"location":"validate/#unreleased","title":"unreleased","text":""},{"location":"webapp/","title":"Web Application","text":"<p>Info</p> <p>Development on the web application has not started.</p> <p>The web application provides a server for running a website that allows people to search for equipment records with equipment registers and (maybe) to add equipment records to a register.</p>"},{"location":"webapp/#install","title":"Install","text":"<p>Eventually...</p> <pre><code>pip install msl-equipment-webapp\n</code></pre>"},{"location":"api/","title":"API Overview","text":"<p>Although this package contains many classes and functions, the classes that you may typically create instances of are</p> <ul> <li>Config \u2014 if you want to load equipment registers and communicate with equipment</li> <li>Connection \u2014 if you are only interested in communicating with equipment</li> <li>Register \u2014 if you only want to load an equipment register</li> </ul> <p>and there are enumeration classes and a Readings class.</p> <p>Interfaces are available to communicate with equipment, Backends may be used to interface with equipment using external packages and possibly Resources may be available.</p> <p>Tip</p> <p>You do not need to create instances of these communication classes. Calling the Equipment.connect() or Connection.connect() method will automatically use the correct object for communication.</p> <p>If you are using type annotations and/or an editor that supports code completion, you can annotate the type of the returned object to get support for these features, for example,</p> <pre><code>from msl.equipment import GPIB, Connection\n\ndevice: GPIB = Connection(\"GPIB::22\").connect()\n</code></pre> <p>The MSLConnectionError and MSLTimeoutError classes are raised if there are issues when communicating with equipment.</p>"},{"location":"api/#command-line-interface","title":"Command Line Interface","text":"<p>A command-line interface is also available to find equipment, validate XML files against the schema or start the web application. Validation and the web application require that the <code>msl-equipment-validate</code> and <code>msl-equipment-webapp</code> packages are installed.</p> <p>To see the help, run</p> <pre><code>msl-equipment help\n</code></pre> <p>or to display the help for a specific command</p> <pre><code>msl-equipment help find\n</code></pre>"},{"location":"api/#find","title":"find","text":"<p>Run the <code>find</code> command to find equipment (and serial ports) that are available.</p> <pre><code>msl-equipment find\n</code></pre> <p>This will display a description about the type of interface, the equipment that was found for each interface and the address(es) that may be used to connect to the equipment.</p> <pre><code>ASRL Ports\n  COM1 [Communications Port (COM1)]\n  COM2 [Communications Port (COM2)]\n  COM3 [Intel(R) Active Management Technology - SOL (COM3)]\nGPIB Devices\n  GPIB0::5::INSTR\nLXI Devices\n  315W Multi Range Triple Output PSU [webserver: http://169.254.100.2]\n    TCPIP::169.254.100.2::9221::SOCKET\n    TCPIP::169.254.100.2::inst0::INSTR\n  34465A Digital Multimeter [webserver: http://169.254.100.3]\n    TCPIP::169.254.100.3::5025::SOCKET\n    TCPIP::169.254.100.3::hislip0::INSTR\n    TCPIP::169.254.100.3::inst0::INSTR\nVXI11 Devices\n  34972A Data Acquisition / Switch Unit [webserver: http://10.12.102.15]\n    TCPIP::10.12.102.15::5025::SOCKET\n    TCPIP::10.12.102.15::inst0::INSTR\n  E5810 (00-21-B3-1F-01-CD) [webserver: http://10.12.102.31]\n    TCPIP::10.12.102.31::inst0::INSTR\n  E5810 (43:8E:5A:06:23:EE) [webserver: http://10.12.102.2]\n    TCPIP::10.12.102.2::inst0::INSTR\n</code></pre>"},{"location":"api/config/","title":"Config","text":"<p>A configuration file is useful when you want to perform a measurement.</p>"},{"location":"api/config/#msl.equipment.config.Config","title":"Config","text":"<pre><code>Config(source: XMLSource)\n</code></pre> <p>Load a configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>XMLSource</code> <p>A path-like or file-like object containing the configuration data.</p> required Source code in <code>src/msl/equipment/config.py</code> <pre><code>def __init__(self, source: XMLSource) -&gt; None:  # noqa: C901\n    \"\"\"Load a configuration file.\n\n    Args:\n        source: A [path-like][path-like object] or [file-like][file-like object]\n            object containing the configuration data.\n    \"\"\"\n    logger.debug(\"load configuration %s\", source)\n    self._source: XMLSource = source\n    self._root: Element[str] = parse(source).getroot()  # noqa: S314\n    self._registers: dict[str, Register] | None = None\n    self._config_equipment: ConfigEquipment = ConfigEquipment(self)\n\n    element = self.find(\"gpib_library\")\n    if element is not None and element.text:\n        os.environ[\"GPIB_LIBRARY\"] = element.text\n        logger.debug(\"update GPIB_LIBRARY=%s\", element.text)\n\n    element = self.find(\"pyvisa_library\")\n    if element is not None and element.text:\n        os.environ[\"PYVISA_LIBRARY\"] = element.text\n        logger.debug(\"update PyVISA_LIBRARY=%s\", element.text)\n\n    path_elements = self.findall(\"path\")\n    if path_elements:\n        paths: list[str] = []\n        os_paths: set[str] = set(os.environ[\"PATH\"].split(os.pathsep))\n        for element in path_elements:\n            path = element.text\n            if not path or not os.path.isdir(path):  # noqa: PTH112\n                logger.warning(\"skipped append to PATH: %r\", path)\n            elif element.attrib.get(\"recursive\", \"false\").lower() == \"true\":\n                for directory, _, _ in os.walk(path):\n                    if directory not in os_paths and directory not in paths:\n                        paths.append(directory)\n                        logger.debug(\"append to PATH: %r\", path)\n            elif path not in os_paths and path not in paths:\n                paths.append(path)\n                logger.debug(\"append to PATH: %r\", path)\n\n        os.environ[\"PATH\"] += os.pathsep + os.pathsep.join(paths)\n\n    for element in self.findall(\"connections\"):\n        connections.add(*_sources(element.text, \"connections\"))\n</code></pre>"},{"location":"api/config/#msl.equipment.config.Config.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: ConfigEquipment\n</code></pre> <p>Returns the <code>&lt;equipment/&gt;</code> elements in the configuration file like a sequence of Equipment items.</p> <p>Using the returned object you can access Equipment items by index (based on the order that <code>&lt;equipment/&gt;</code> elements are defined in the configuration file), by the <code>eid</code> attribute value or by the <code>name</code> attribute value. You can also iterate over the Equipment items in the sequence.</p> <p>See here for examples.</p>"},{"location":"api/config/#msl.equipment.config.Config.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>The path to the configuration file.</p>"},{"location":"api/config/#msl.equipment.config.Config.registers","title":"registers  <code>property</code>","text":"<pre><code>registers: dict[str, Register]\n</code></pre> <p>Returns all equipment registers that are specified in the configuration file.</p> <p>The key in the returned dict is the team value of the corresponding Register.</p>"},{"location":"api/config/#msl.equipment.config.Config.root","title":"root  <code>property</code>","text":"<pre><code>root: Element[str]\n</code></pre> <p>The root element (the first node) in the configuration file.</p>"},{"location":"api/config/#msl.equipment.config.Config.attrib","title":"attrib","text":"<pre><code>attrib(path: str) -&gt; dict[str, bool | float | str]\n</code></pre> <p>Get the attributes of the first matching element by tag name or path.</p> <p>If possible, the value is converted to a bool (<code>true</code> or <code>false</code> case-insensitive), an int or a float, otherwise the value remains a str.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Either an element tag name or an XPath.</p> required <p>Returns:</p> Type Description <code>dict[str, bool | float | str]</code> <p>The attributes of the matching <code>path</code> element.</p> Source code in <code>src/msl/equipment/config.py</code> <pre><code>def attrib(self, path: str) -&gt; dict[str, bool | float | str]:\n    \"\"\"Get the attributes of the first matching element by tag name or path.\n\n    If possible, the value is converted to a [bool][] (`true` or `false` case-insensitive),\n    an [int][] or a [float][], otherwise the value remains a [str][].\n\n    Args:\n        path: Either an element tag name or an XPath.\n\n    Returns:\n        The attributes of the matching `path` element.\n    \"\"\"\n    element = self.find(path)\n    if element is None:\n        return {}\n    return {k: to_primitive(v) for k, v in element.attrib.items()}\n</code></pre>"},{"location":"api/config/#msl.equipment.config.Config.find","title":"find","text":"<pre><code>find(path: str) -&gt; Element[str] | None\n</code></pre> <p>Find the first matching element by tag name or path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Either an element tag name or an XPath.</p> required <p>Returns:</p> Type Description <code>Element[str] | None</code> <p>The element or <code>None</code> if an element was not found at <code>path</code>.</p> Source code in <code>src/msl/equipment/config.py</code> <pre><code>def find(self, path: str) -&gt; Element[str] | None:\n    \"\"\"Find the first matching element by tag name or path.\n\n    Args:\n        path: Either an element tag name or an XPath.\n\n    Returns:\n        The element or `None` if an element was not found at `path`.\n    \"\"\"\n    return self._root.find(path)\n</code></pre>"},{"location":"api/config/#msl.equipment.config.Config.findall","title":"findall","text":"<pre><code>findall(path: str) -&gt; list[Element[str]]\n</code></pre> <p>Find all matching sub-elements by tag name or path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Either an element tag name or an XPath.</p> required <p>Returns:</p> Type Description <code>list[Element[str]]</code> <p>All matching elements in document order.</p> Source code in <code>src/msl/equipment/config.py</code> <pre><code>def findall(self, path: str) -&gt; list[Element[str]]:\n    \"\"\"Find all matching sub-elements by tag name or path.\n\n    Args:\n        path: Either an element tag name or an XPath.\n\n    Returns:\n        All matching elements in document order.\n    \"\"\"\n    return self._root.findall(path)\n</code></pre>"},{"location":"api/config/#msl.equipment.config.Config.value","title":"value","text":"<pre><code>value(\n    path: str, default: None = None\n) -&gt; bool | float | str | None\n</code></pre><pre><code>value(path: str, default: bool) -&gt; bool\n</code></pre><pre><code>value(path: str, default: int) -&gt; int\n</code></pre><pre><code>value(path: str, default: float) -&gt; float\n</code></pre><pre><code>value(path: str, default: str) -&gt; str\n</code></pre> <pre><code>value(\n    path: str, default: bool | float | str | None = None\n) -&gt; bool | float | str | None\n</code></pre> <p>Gets the value (text) associated with the first matching element.</p> <p>If possible, the value is converted to a bool (<code>true</code> or <code>false</code> case-insensitive), an int or a float, otherwise the value remains a str.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Either an element tag name or an XPath.</p> required <code>default</code> <code>bool | float | str | None</code> <p>The default value if an element cannot be found.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | float | str | None</code> <p>The value of the element or <code>default</code> if an element was not found at <code>path</code>.</p> Source code in <code>src/msl/equipment/config.py</code> <pre><code>def value(self, path: str, default: bool | float | str | None = None) -&gt; bool | float | str | None:  # noqa: FBT001\n    \"\"\"Gets the value (text) associated with the first matching element.\n\n    If possible, the value is converted to a [bool][] (`true` or `false` case-insensitive),\n    an [int][] or a [float][], otherwise the value remains a [str][].\n\n    Args:\n        path: Either an element tag name or an XPath.\n        default: The default value if an element cannot be found.\n\n    Returns:\n        The value of the element or `default` if an element was not found at `path`.\n    \"\"\"\n    element = self.find(path)\n    if element is None:\n        return default\n    if element.text is None:\n        return None\n    return to_primitive(element.text)\n</code></pre>"},{"location":"api/config/#msl.equipment.config.ConfigEquipment","title":"ConfigEquipment","text":"<pre><code>ConfigEquipment(cfg: Config)\n</code></pre> <p>Access <code>&lt;equipment/&gt;</code> elements in a configuration file like a sequence of Equipment items.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>Config</code> <p>The configuration instance.</p> required Source code in <code>src/msl/equipment/config.py</code> <pre><code>def __init__(self, cfg: Config) -&gt; None:\n    \"\"\"Access `&lt;equipment/&gt;` elements in a configuration file like a sequence of [Equipment][] items.\n\n    Args:\n        cfg: The configuration instance.\n    \"\"\"\n    self._cfg: Config = cfg\n    self._elements: list[Element[str]] = cfg.findall(\"equipment\")\n    self._equipment: dict[str, Equipment] = {}  # key=eid\n    self._index_map: dict[int, str] = {i: e.attrib[\"eid\"] for i, e in enumerate(self._elements)}\n    self._name_map: dict[str, str] = {\n        e.attrib[\"name\"]: e.attrib[\"eid\"] for e in self._elements if e.attrib.get(\"name\")\n    }\n</code></pre>"},{"location":"api/config/#msl.equipment.config.ConfigEquipment.eids","title":"eids  <code>property</code>","text":"<pre><code>eids: tuple[str, ...]\n</code></pre> <p>Returns the value of the <code>eid</code> attribute for each <code>&lt;equipment/&gt;</code> element in a configuration file.</p>"},{"location":"api/config/#msl.equipment.config.ConfigEquipment.names","title":"names  <code>property</code>","text":"<pre><code>names: tuple[str, ...]\n</code></pre> <p>Returns the value of the <code>name</code> attribute for each <code>&lt;equipment/&gt;</code> element in a configuration file.</p>"},{"location":"api/connection/","title":"Connection","text":""},{"location":"api/connection/#msl.equipment.schema.Connection","title":"Connection","text":"<pre><code>Connection(\n    address: str,\n    *,\n    backend: (\n        Literal[\"MSL\", \"PyVISA\", \"NIDAQ\"] | Backend\n    ) = MSL,\n    eid: str = \"\",\n    manufacturer: str = \"\",\n    model: str = \"\",\n    serial: str = \"\",\n    **properties: Any\n)\n</code></pre> <p>Information about how to interface with equipment.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The VISA-style address of the connection (see here for examples).</p> required <code>backend</code> <code>Literal['MSL', 'PyVISA', 'NIDAQ'] | Backend</code> <p>The backend to use to communicate with the equipment.</p> <code>MSL</code> <code>eid</code> <code>str</code> <p>The equipment id to associate with the Connection instance.</p> <code>''</code> <code>manufacturer</code> <code>str</code> <p>The name of the manufacturer of the equipment.</p> <code>''</code> <code>model</code> <code>str</code> <p>The model number of the equipment.</p> <code>''</code> <code>serial</code> <code>str</code> <p>The serial number (or unique identifier) of the equipment.</p> <code>''</code> <code>properties</code> <code>Any</code> <p>Additional key-value pairs to use when communicating with the equipment. For example, the baud_rate and parity values for an RS-232 connection.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(\n    self,\n    address: str,\n    *,\n    backend: Literal[\"MSL\", \"PyVISA\", \"NIDAQ\"] | Backend = Backend.MSL,\n    eid: str = \"\",\n    manufacturer: str = \"\",\n    model: str = \"\",\n    serial: str = \"\",\n    **properties: _Any,  # noqa: ANN401\n) -&gt; None:\n    \"\"\"Information about how to interface with equipment.\n\n    Args:\n        address: The VISA-style address of the connection (see [here][address-syntax] for examples).\n        backend: The [backend][msl.equipment.enumerations.Backend] to use to communicate with the equipment.\n        eid: The [equipment id][msl.equipment.schema.Equipment.id] to associate with the [Connection][] instance.\n        manufacturer: The name of the manufacturer of the equipment.\n        model: The model number of the equipment.\n        serial: The serial number (or unique identifier) of the equipment.\n        properties: Additional key-value pairs to use when communicating with the equipment.\n            For example, the _baud_rate_ and _parity_ values for an _RS-232_ connection.\n    \"\"\"\n    self.address: str = address\n    \"\"\"The VISA-style address of the connection (see [here][address-syntax] for examples).\"\"\"\n\n    self.backend: Backend = Backend(backend)\n    \"\"\"The [backend][msl.equipment.enumerations.Backend] that is used to communicate with the equipment.\"\"\"\n\n    self.eid: str = eid\n    \"\"\"The [equipment id][msl.equipment.schema.Equipment.id] associated with the [Connection][] instance.\"\"\"\n\n    self.manufacturer: str = manufacturer\n    \"\"\"The name of the manufacturer of the equipment.\"\"\"\n\n    self.model: str = model\n    \"\"\"The model number of the equipment.\"\"\"\n\n    # check for a properties key being explicitly defined and the value is a dict\n    properties = (  # pyright: ignore[reportUnknownVariableType]\n        properties[\"properties\"]\n        if (\"properties\" in properties and isinstance(properties[\"properties\"], dict))\n        else properties\n    )\n\n    self.properties: dict[str, _Any] = properties\n    \"\"\"Additional key-value pairs to use when communicating with the equipment.\n\n    For example, the *baud_rate* and *parity* values for an *RS-232* connection.\n    \"\"\"\n\n    self.serial: str = serial\n    \"\"\"The serial number (or unique identifier) of the equipment.\"\"\"\n</code></pre>"},{"location":"api/connection/#msl.equipment.schema.Connection.address","title":"address  <code>instance-attribute</code>","text":"<pre><code>address: str = address\n</code></pre> <p>The VISA-style address of the connection (see here for examples).</p>"},{"location":"api/connection/#msl.equipment.schema.Connection.backend","title":"backend  <code>instance-attribute</code>","text":"<pre><code>backend: Backend = Backend(backend)\n</code></pre> <p>The backend that is used to communicate with the equipment.</p>"},{"location":"api/connection/#msl.equipment.schema.Connection.eid","title":"eid  <code>instance-attribute</code>","text":"<pre><code>eid: str = eid\n</code></pre> <p>The equipment id associated with the Connection instance.</p>"},{"location":"api/connection/#msl.equipment.schema.Connection.manufacturer","title":"manufacturer  <code>instance-attribute</code>","text":"<pre><code>manufacturer: str = manufacturer\n</code></pre> <p>The name of the manufacturer of the equipment.</p>"},{"location":"api/connection/#msl.equipment.schema.Connection.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model: str = model\n</code></pre> <p>The model number of the equipment.</p>"},{"location":"api/connection/#msl.equipment.schema.Connection.properties","title":"properties  <code>instance-attribute</code>","text":"<pre><code>properties: dict[str, Any] = properties\n</code></pre> <p>Additional key-value pairs to use when communicating with the equipment.</p> <p>For example, the baud_rate and parity values for an RS-232 connection.</p>"},{"location":"api/connection/#msl.equipment.schema.Connection.serial","title":"serial  <code>instance-attribute</code>","text":"<pre><code>serial: str = serial\n</code></pre> <p>The serial number (or unique identifier) of the equipment.</p>"},{"location":"api/connection/#msl.equipment.schema.Connection.connect","title":"connect","text":"<pre><code>connect() -&gt; Any\n</code></pre> <p>Connect to the equipment for computer control.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def connect(self) -&gt; _Any:  # noqa: ANN401\n    \"\"\"Connect to the equipment for computer control.\"\"\"\n    equipment = Equipment(\n        id=self.eid,\n        manufacturer=self.manufacturer,\n        model=self.model,\n        serial=self.serial,\n        connection=self,\n    )\n    return equipment.connect()\n</code></pre>"},{"location":"api/enumerations/","title":"enumerations","text":"<p>Enumeration constants.</p>"},{"location":"api/enumerations/#msl.equipment.enumerations.Backend","title":"Backend","text":"<p>               Bases: <code>Enum</code></p> <p>The backend library to use for communication with the equipment.</p> <p>Attributes:</p> Name Type Description <code>MSL</code> <code>str</code> <p>\"MSL\"</p> <code>PyVISA</code> <code>str</code> <p>\"PyVISA\"</p> <code>NIDAQ</code> <code>str</code> <p>\"NIDAQ\"</p>"},{"location":"api/enumerations/#msl.equipment.enumerations.DataBits","title":"DataBits","text":"<p>               Bases: <code>IntEnum</code></p> <p>The number of data bits to use for Serial communication.</p> <p>Attributes:</p> Name Type Description <code>FIVE</code> <code>int</code> <p>5</p> <code>SIX</code> <code>int</code> <p>6</p> <code>SEVEN</code> <code>int</code> <p>7</p> <code>EIGHT</code> <code>int</code> <p>8</p>"},{"location":"api/enumerations/#msl.equipment.enumerations.Parity","title":"Parity","text":"<p>               Bases: <code>Enum</code></p> <p>The parity type to use for Serial communication.</p> <p>Attributes:</p> Name Type Description <code>NONE</code> <code>str</code> <p>\"N\"</p> <code>ODD</code> <code>str</code> <p>\"O\"</p> <code>EVEN</code> <code>str</code> <p>\"E\"</p> <code>MARK</code> <code>str</code> <p>\"M\"\"</p> <code>SPACE</code> <code>str</code> <p>\"S\"</p>"},{"location":"api/enumerations/#msl.equipment.enumerations.StopBits","title":"StopBits","text":"<p>               Bases: <code>Enum</code></p> <p>The number of stop bits to use for Serial communication.</p> <p>Attributes:</p> Name Type Description <code>ONE</code> <code>int</code> <p>1</p> <code>ONE_POINT_FIVE</code> <code>float</code> <p>1.5</p> <code>TWO</code> <code>int</code> <p>2</p>"},{"location":"api/exceptions/","title":"exceptions","text":""},{"location":"api/exceptions/#msl.equipment.interfaces.message_based.MSLConnectionError","title":"MSLConnectionError","text":"<pre><code>MSLConnectionError(interface: Interface, message: str)\n</code></pre> <p>               Bases: <code>OSError</code></p> <p>Base class for connection-related exceptions.</p> <p>Parameters:</p> Name Type Description Default <code>interface</code> <code>Interface</code> <p>An interface subclass.</p> required <code>message</code> <code>str</code> <p>A message to append to the generic error message.</p> required Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def __init__(self, interface: Interface, message: str) -&gt; None:\n    \"\"\"Base class for connection-related exceptions.\n\n    Args:\n        interface: An interface subclass.\n        message: A message to append to the generic error message.\n    \"\"\"\n    logger.debug(\"%r %s\", interface, message)\n    super().__init__(f\"{interface!r}\\n{message}\")\n</code></pre>"},{"location":"api/exceptions/#msl.equipment.interfaces.message_based.MSLTimeoutError","title":"MSLTimeoutError","text":"<pre><code>MSLTimeoutError(interface: MessageBased, message: str = '')\n</code></pre> <p>               Bases: <code>TimeoutError</code></p> <p>A timeout exception for I/O operations.</p> <p>Parameters:</p> Name Type Description Default <code>interface</code> <code>MessageBased</code> <p>A message-based interface subclass.</p> required <code>message</code> <code>str</code> <p>An optional message to append to the generic timeout error message.</p> <code>''</code> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def __init__(self, interface: MessageBased, message: str = \"\") -&gt; None:\n    \"\"\"A timeout exception for I/O operations.\n\n    Args:\n        interface: A message-based interface subclass.\n        message: An optional message to append to the generic timeout error message.\n    \"\"\"\n    msg = f\"Timeout occurred after {interface.timeout} second(s). {message}\"\n    logger.debug(\"%r %s\", interface, msg)\n    super().__init__(f\"{interface!r}\\n{msg}\")\n</code></pre>"},{"location":"api/readings/","title":"Readings","text":"<p>The Readings class may be used after requesting measurement data from equipment. It calculates the mean, standard deviation and the standard deviation of the mean and provides a user-friendly way to display the information.</p> <p>Suppose we have a Connection to a digital multimeter, <code>dmm</code>, and we fetch some readings</p> <pre><code>&gt;&gt;&gt; data = dmm.query(\"FETCH?\")\n&gt;&gt;&gt; data\n' 8.000167847E+00, 8.000164032E+00, 8.000163241E+00, 8.000165864E+00, 8.000164893E+00\\r\\n'\n</code></pre> <p>We can create a Readings instance from the fetched data and then get statistical information about the data</p> <pre><code>&gt;&gt;&gt; from msl.equipment import Readings\n&gt;&gt;&gt; r = Readings(data)\n&gt;&gt;&gt; r.mean\n8.0001651754\n&gt;&gt;&gt; r.std\n1.784701179552952e-06\n&gt;&gt;&gt; r.std_mean\n7.981426314008917e-07\n&gt;&gt;&gt; len(r)\n5\n</code></pre> <p>We can treat the readings as a numpy ndarray and call ndarray attributes</p> <pre><code>&gt;&gt;&gt; print(r.max())\n8.000167847\n&gt;&gt;&gt; print(r.min())\n8.000163241\n</code></pre> <p>or access the numpy ndarray directly</p> <pre><code>&gt;&gt;&gt; r.data\narray([8.00016785, 8.00016403, 8.00016324, 8.00016586, 8.00016489])\n</code></pre> <p>Unpacking the Readings instance returns the mean and the standard deviation of the mean</p> <pre><code>&gt;&gt;&gt; mean, std_mean = r\n&gt;&gt;&gt; mean\n8.0001651754\n&gt;&gt;&gt; std_mean\n7.981426314008917e-07\n</code></pre> <p>When converting the Readings to a string, the custom format specification is used and it displays the value (mean) with the uncertainty (standard deviation of the mean)</p> <pre><code>&gt;&gt;&gt; f\"{r}\" # use the default options\n'8.00016518(80)'\n&gt;&gt;&gt; f\"{r:.2B}\" # equivalent to previous\n'8.00016518(80)'\n&gt;&gt;&gt; f\"{r:.3PU}\"  # retain 3 digits, +/- mode, unicode style\n'8.000165175\u00b10.000000798'\n</code></pre>"},{"location":"api/readings/#format-specification","title":"Format Specification","text":"<p>The format specification is similar to the built-in Python specification, but with additional options (mode, style and si). The number of significant digits for the value (mean) and the uncertainty (standard deviation of the mean) can be controlled, based on the uncertainty.</p> <p>The grammar for the format specification is defined as,</p> <pre><code>[[fill]align][sign][z][#][0][width][grouping][.digits][type][mode][style][si]\n</code></pre> <p>where we note the use of digits (not precision) and the additional mode, style and si options. digits refers to the number of significant digits to retain in the uncertainty. The mode option specifies how the value and the uncertainty are separated: <code>B</code> (bracket mode, default) or <code>P</code> (plus-minus sign). There are two style options: <code>L</code> (\\(\\LaTeX\\)) or <code>U</code> (unicode). The si option can only be <code>S</code> and if it is specified the appropriate SI prefix symbol replaces the Base-10 component.</p> <p>We can also create a Readings instance by specifying the mean, standard deviation and size keyword arguments</p> <pre><code>&gt;&gt;&gt; r = Readings(mean=3.4562e-6, std=4.218e-8, size=10)\n&gt;&gt;&gt; r.mean\n3.4562e-06\n&gt;&gt;&gt; r.std\n4.218e-08\n&gt;&gt;&gt; r.std_mean  # 4.218e-8 / sqrt(10)\n1.3338487170590222e-08\n</code></pre> <p>Here are some examples on how to use the custom format specification</p> <pre><code>&gt;&gt;&gt; f\"{r}\"  # default is to retain 2 digits with bracket mode\n'0.000003456(13)'\n&gt;&gt;&gt; f\"{r:P}\"  # +/- mode\n'0.000003456+/-0.000000013'\n&gt;&gt;&gt; f\"{r:PU}\"  # +/- mode, unicode style\n'0.000003456\u00b10.000000013'\n&gt;&gt;&gt; f\"{r:e}\"  # exponent form\n'3.456(13)e-06'\n&gt;&gt;&gt; f\"{r:S}\" # SI prefix\n'3.456(13) u'\n&gt;&gt;&gt; f\"{r:US}\" # unicode style, SI prefix\n'3.456(13) \u00b5'\n&gt;&gt;&gt; f\"{r:.1eU}\" # 1 digit, exponent form, unicode style\n'3.46(1)\u00d710\u207b\u2076'\n&gt;&gt;&gt; f\"{r:eL}\" # exponent form, LaTeX style\n'3.456\\\\left(13\\\\right)\\\\times10^{-6}'\n&gt;&gt;&gt; f\"{r:=^+30.4e}\"  # fill with '=', align center, include + sign, 30 characters in total, 4 digits, exponent form\n'======+3.45620(1334)e-06======'\n</code></pre> <p>If the standard deviation of the mean is zero, the uncertainty component is not included in the output and the format applies only to the mean</p> <pre><code>&gt;&gt;&gt; r = Readings(mean=3.4562e-6, std=0, size=10)\n&gt;&gt;&gt; f\"{r}\"  # default is 2 decimal places in floating-point, f, notation\n'0.00'\n&gt;&gt;&gt; f\"{r:e}\"\n'3.46e-06'\n&gt;&gt;&gt; f\"{r:.4e}\"  # 4 decimals (uses built-in specification since no custom options are used)\n'3.4562e-06'\n&gt;&gt;&gt; f\"{r:.4eUS}\"  # 4 digits (uses custom specification since custom options are included)\n'3.456 \u00b5'\n</code></pre>"},{"location":"api/readings/#msl.equipment.readings.Readings","title":"Readings","text":"<pre><code>Readings(\n    data: (\n        str | Sequence[str | float] | NDArray[number] | None\n    ) = None,\n    *,\n    mean: float | None = None,\n    std: float | None = None,\n    size: int | None = None,\n    overload: float | None = 1e30,\n    delimiter: str | None = \",\"\n)\n</code></pre> <p>A formatting-friendly convenience class for measurement data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | Sequence[str | float] | NDArray[number] | None</code> <p>The measurement data.</p> <code>None</code> <code>mean</code> <code>float | None</code> <p>If specified, then the mean is not calculated from the <code>data</code>.</p> <code>None</code> <code>std</code> <code>float | None</code> <p>If specified, then the standard deviation is not calculated from the <code>data</code>.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>If specified, then the number of items is not determined from the <code>data</code>.</p> <code>None</code> <code>overload</code> <code>float | None</code> <p>For some devices, like a digital multimeter, if the input signal is greater than the range can measure, the device returns a large value (e.g., 9.9E+37) to indicate a measurement overload. If the absolute value of the mean is greater than <code>overload</code> then the mean and standard deviation become <code>NaN</code>. Setting <code>overload</code> to <code>None</code> disables this check.</p> <code>1e+30</code> <code>delimiter</code> <code>str | None</code> <p>The character used to separate values (only used if <code>data</code> is of type str). The value <code>None</code> corresponds to whitespace.</p> <code>','</code> Source code in <code>src/msl/equipment/readings.py</code> <pre><code>def __init__(\n    self,\n    data: str | Sequence[str | float] | NDArray[np.number] | None = None,\n    *,\n    mean: float | None = None,\n    std: float | None = None,\n    size: int | None = None,\n    overload: float | None = 1e30,\n    delimiter: str | None = \",\",\n) -&gt; None:\n    \"\"\"A formatting-friendly convenience class for measurement data.\n\n    Args:\n        data: The measurement data.\n        mean: If specified, then the mean is not calculated from the `data`.\n        std: If specified, then the standard deviation is not calculated from the `data`.\n        size: If specified, then the number of items is not determined from the `data`.\n        overload: For some devices, like a digital multimeter, if the input signal is\n            greater than the range can measure, the device returns a large value\n            (e.g., 9.9E+37) to indicate a measurement overload. If the absolute value of\n            the mean is greater than `overload` then the mean and standard deviation become\n            `NaN`. Setting `overload` to `None` disables this check.\n        delimiter: The character used to separate values (only used if `data` is of type [str][]).\n            The value `None` corresponds to whitespace.\n    \"\"\"\n    if data is not None and any(a is not None for a in (mean, std, size)):\n        msg = \"Cannot specify data and the mean, std or size\"\n        raise ValueError(msg)\n\n    self._data: NDArray[np.float64]\n    if isinstance(data, str):\n        stripped = data.strip()\n        if stripped:\n            self._data = np.loadtxt(StringIO(stripped), dtype=float, delimiter=delimiter)\n        else:\n            self._data = np.empty(0)\n    elif isinstance(data, np.ndarray):\n        self._data = data.astype(np.float64)\n    elif data is None:\n        self._data = np.empty(0)\n    else:\n        self._data = np.asarray(data, dtype=float)\n\n    self._size: int = self._data.size if size is None else size\n    self._overload: float | None = None if overload is None else float(overload)\n    self._std: float | None = std\n\n    self._mean: float | None\n    if mean is not None:\n        self._mean = self._check_overload(mean)\n    else:\n        self._mean = None\n</code></pre>"},{"location":"api/readings/#msl.equipment.readings.Readings.data","title":"data  <code>property</code>","text":"<pre><code>data: NDArray[float64]\n</code></pre> <p>Returns the data.</p>"},{"location":"api/readings/#msl.equipment.readings.Readings.mean","title":"mean  <code>property</code>","text":"<pre><code>mean: float\n</code></pre> <p>Returns the mean.</p>"},{"location":"api/readings/#msl.equipment.readings.Readings.overload","title":"overload  <code>property</code>","text":"<pre><code>overload: float | None\n</code></pre> <p>Returns the overload value.</p>"},{"location":"api/readings/#msl.equipment.readings.Readings.std","title":"std  <code>property</code>","text":"<pre><code>std: float\n</code></pre> <p>Returns the sample standard deviation (uses \\(N-1\\) in the denominator).</p>"},{"location":"api/readings/#msl.equipment.readings.Readings.std_mean","title":"std_mean  <code>property</code>","text":"<pre><code>std_mean: float\n</code></pre> <p>Returns the standard deviation of the mean.</p>"},{"location":"api/types/","title":"types","text":"<p>Custom type annotations.</p>"},{"location":"api/types/#msl.equipment._types.AvaSpecCallback","title":"AvaSpecCallback  <code>module-attribute</code>","text":"<pre><code>AvaSpecCallback = Callable[\n    [_Pointer[c_int32], _Pointer[c_int32]], None\n]\n</code></pre> <p>Callback handler for the AvaSpec SDK.</p>"},{"location":"api/types/#msl.equipment._types.EnumType","title":"EnumType  <code>module-attribute</code>","text":"<pre><code>EnumType = TypeVar('EnumType', bound=Enum)\n</code></pre> <p>An Enum subclass.</p>"},{"location":"api/types/#msl.equipment._types.MessageDataType","title":"MessageDataType  <code>module-attribute</code>","text":"<pre><code>MessageDataType = (\n    type[int] | type[float] | type[number] | str\n)\n</code></pre> <p>Data type to use to read(write) bytes from(to) equipment.</p> <p>The data type to use to convert each element in a Sequence1D to. If the corresponding MessageFormat is <code>ascii</code> then the data type value must be of type str and it is used as the <code>format_spec</code> argument in format to first convert each element in Sequence1D to a string, and then it is encoded (e.g., <code>'.2e'</code> converts each element to scientific notation with two digits after the decimal point). If the data type includes a byte-order character, it is ignored. For all other values of MessageFormat, the data type can be any object that numpy dtype supports (e.g., <code>'H'</code>, <code>'uint16'</code> and ushort are equivalent values to convert each element to an unsigned short). If a byte-order character is specified then it is used, otherwise the native byte order of the CPU architecture is used. See struct-format-strings for more details.</p>"},{"location":"api/types/#msl.equipment._types.MessageFormat","title":"MessageFormat  <code>module-attribute</code>","text":"<pre><code>MessageFormat = Literal['ascii', 'hp', 'ieee'] | None\n</code></pre> <p>Format to use to read(write) bytes from(to) equipment.</p> <p>Possible values are:</p> <ul> <li> <p><code>None</code> \u2014 do not use a header.</p> <p>Format</p> <p><code>&lt;byte&gt;&lt;byte&gt;&lt;byte&gt;...</code></p> </li> <li> <p><code>ascii</code> \u2014 comma-separated ASCII characters, see the         <code>&lt;PROGRAM DATA SEPARATOR&gt;</code> standard that is defined in Section 7.4.2.2 of         IEEE 488.2-1992.</p> <p>Format</p> <p><code>&lt;string&gt;,&lt;string&gt;,&lt;string&gt;,...</code></p> </li> <li> <p><code>ieee</code> \u2014 arbitrary block data for <code>SCPI</code> messages, see the         <code>&lt;DEFINITE LENGTH ARBITRARY BLOCK RESPONSE DATA&gt;</code> standard that is defined in         Section 8.7.9 of IEEE 488.2-1992.</p> <p>Format</p> <p><code>#&lt;length of num bytes value&gt;&lt;num bytes&gt;&lt;byte&gt;&lt;byte&gt;&lt;byte&gt;...</code></p> </li> <li> <p><code>hp</code> \u2014 the HP-IB data transfer standard, i.e., the <code>FORM#</code> command         option. See the programming guide for an         HP 8530A         for more details.</p> <p>Format</p> <p><code>#A&lt;num bytes as uint16&gt;&lt;byte&gt;&lt;byte&gt;&lt;byte&gt;...</code></p> </li> </ul>"},{"location":"api/types/#msl.equipment._types.NKTDeviceStatusCallback","title":"NKTDeviceStatusCallback  <code>module-attribute</code>","text":"<pre><code>NKTDeviceStatusCallback = Callable[\n    [str, int, int, int, int], None\n]\n</code></pre> <p>Callback handler for the NKT SDK when the status of a device changes.</p>"},{"location":"api/types/#msl.equipment._types.NKTPortStatusCallback","title":"NKTPortStatusCallback  <code>module-attribute</code>","text":"<pre><code>NKTPortStatusCallback = Callable[\n    [str, int, int, int, int], None\n]\n</code></pre> <p>Callback handler for the NKT SDK when the status of a port changes.</p>"},{"location":"api/types/#msl.equipment._types.NKTRegisterStatusCallback","title":"NKTRegisterStatusCallback  <code>module-attribute</code>","text":"<pre><code>NKTRegisterStatusCallback = Callable[\n    [str, int, int, int, int, int, int], None\n]\n</code></pre> <p>Callback handler for the NKT SDK when the status of a register changes.</p>"},{"location":"api/types/#msl.equipment._types.NumpyArray1D","title":"NumpyArray1D  <code>module-attribute</code>","text":"<pre><code>NumpyArray1D = ndarray[tuple[int], dtype[number]]\n</code></pre> <p>A 1-dimensional numpy ndarray of numbers.</p>"},{"location":"api/types/#msl.equipment._types.PathLike","title":"PathLike  <code>module-attribute</code>","text":"<pre><code>PathLike = Union[str, bytes, PathLike[str], PathLike[bytes]]\n</code></pre> <p>A path-like object.</p>"},{"location":"api/types/#msl.equipment._types.Sequence1D","title":"Sequence1D  <code>module-attribute</code>","text":"<pre><code>Sequence1D = Sequence[float] | NumpyArray1D\n</code></pre> <p>A 1-dimensional sequence of numbers.</p>"},{"location":"api/types/#msl.equipment._types.XMLSource","title":"XMLSource  <code>module-attribute</code>","text":"<pre><code>XMLSource = Union[\n    int, PathLike, SupportsRead[bytes] | SupportsRead[str]\n]\n</code></pre> <p>A path-like object or a file-like object for parsing XML content.</p>"},{"location":"api/types/#msl.equipment._types.SupportsRead","title":"SupportsRead","text":"<p>               Bases: <code>Protocol[_T_co]</code></p> <p>A file-like object that has a <code>read</code> method.</p>"},{"location":"api/types/#msl.equipment._types.SupportsRead.read","title":"read","text":"<pre><code>read(size: int | None = -1) -&gt; _T_co\n</code></pre> <p>Read from the stream.</p> Source code in <code>src/msl/equipment/_types.py</code> <pre><code>def read(self, size: int | None = -1, /) -&gt; _T_co:\n    \"\"\"Read from the stream.\"\"\"\n    ...\n</code></pre>"},{"location":"api/backends/","title":"Backends","text":"<p>The following classes may be used to interface with equipment using external packages</p> <ul> <li>NIDAQ \u2014 Use the NIDAQmx package to establish a connection to the equipment</li> <li>PyVISA \u2014 Use the PyVISA package to establish a connection to the equipment</li> </ul>"},{"location":"api/backends/nidaq/","title":"NIDAQ","text":""},{"location":"api/backends/nidaq/#msl.equipment.interfaces.nidaq.NIDAQ","title":"NIDAQ","text":"<pre><code>NIDAQ(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Use NI-DAQmx as the backend to communicate with the equipment.</p> <p>The backend value must be equal to <code>NIDAQ</code> to use this class for the communication backend.</p> <p>The returned object from calling the connect method is equivalent to importing the NI-DAQmx package, e.g.,</p> <pre><code>from msl.equipment import Backend, Connection\n\nconnection = Connection(address=\"Dev1\", backend=Backend.NIDAQ)\nnidaqmx = connection.connect()\n\nwith nidaqmx.Task() as task:\n    task.ai_channels.add_ai_voltage_chan(f\"{nidaqmx.address}/ai0\")\n    voltage = task.read()\n</code></pre> <p>is equivalent to</p> <pre><code>import nidaqmx\n\nwith nidaqmx.Task() as task:\n    task.ai_channels.add_ai_voltage_chan(\"Dev1/ai0\")\n    voltage = task.read()\n</code></pre> <p>You can also combine the packages, use <code>msl-equipment</code> for managing information about the equipment and directly use <code>nidaqmx</code> for the connection. If you use this combination, the editor you use to develop your code may have better support for features like code completion and type checking.</p> <pre><code>import nidaqmx\nfrom msl.equipment import Config\n\n# config.xml contains &lt;equipment eid=\"MSLE.0.142\" name=\"daq\" manufacturer=\"NI\"/&gt;\n# and specifies where the equipment registers are and the connections file.\ncfg = Config(\"config.xml\")\nequipment = cfg.equipment[\"daq\"]\naddress = equipment.connection.address\n\nwith nidaqmx.Task() as task:\n    task.ai_channels.add_ai_voltage_chan(f\"{address}/ai0\")\n    voltage = task.read()\n\n    # You could now use the `equipment` instance to apply a correction to the `voltage`\n</code></pre> <p>See the examples on the NI-DAQmx repository to learn how to use the <code>nidaqmx</code> package.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>src/msl/equipment/interfaces/nidaq.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Use [NI-DAQmx] as the backend to communicate with the equipment.\n\n    The [backend][msl.equipment.schema.Connection.backend] value must be equal\n    to `NIDAQ` to use this class for the communication backend.\n\n    The returned object from calling the [connect][msl.equipment.schema.Equipment.connect]\n    method is equivalent to importing the [NI-DAQmx] package, e.g.,\n\n    ```python\n    from msl.equipment import Backend, Connection\n\n    connection = Connection(address=\"Dev1\", backend=Backend.NIDAQ)\n    nidaqmx = connection.connect()\n\n    with nidaqmx.Task() as task:\n        task.ai_channels.add_ai_voltage_chan(f\"{nidaqmx.address}/ai0\")\n        voltage = task.read()\n    ```\n\n    is equivalent to\n\n    ```python\n    import nidaqmx\n\n    with nidaqmx.Task() as task:\n        task.ai_channels.add_ai_voltage_chan(\"Dev1/ai0\")\n        voltage = task.read()\n    ```\n\n    You can also combine the packages, use `msl-equipment` for managing information\n    about the equipment and directly use `nidaqmx` for the connection. If you use this\n    combination, the editor you use to develop your code may have better support for\n    features like code completion and type checking.\n\n    ```python\n    import nidaqmx\n    from msl.equipment import Config\n\n    # config.xml contains &lt;equipment eid=\"MSLE.0.142\" name=\"daq\" manufacturer=\"NI\"/&gt;\n    # and specifies where the equipment registers are and the connections file.\n    cfg = Config(\"config.xml\")\n    equipment = cfg.equipment[\"daq\"]\n    address = equipment.connection.address\n\n    with nidaqmx.Task() as task:\n        task.ai_channels.add_ai_voltage_chan(f\"{address}/ai0\")\n        voltage = task.read()\n\n        # You could now use the `equipment` instance to apply a correction to the `voltage`\n    ```\n\n    See the [examples](https://github.com/ni/nidaqmx-python/tree/master/examples)\n    on the [NI-DAQmx repository](https://github.com/ni/nidaqmx-python) to learn\n    how to use the `nidaqmx` package.\n\n    [NI-DAQmx]: https://nidaqmx-python.readthedocs.io/en/stable/index.html\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"\n    super().__init__(equipment)\n\n    if nidaqmx is None:  # pragma: no branch\n        msg = \"nidaqmx is not installed, run: pip install nidaqmx\"\n        raise RuntimeError(msg)\n</code></pre>"},{"location":"api/backends/nidaq/#msl.equipment.interfaces.nidaq.NIDAQ.address","title":"address  <code>property</code>","text":"<pre><code>address: str\n</code></pre> <p>Returns the address of the Connection.</p>"},{"location":"api/backends/nidaq/#msl.equipment.interfaces.nidaq.NIDAQ.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/backends/nidaq/#msl.equipment.interfaces.nidaq.NIDAQ.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the equipment.</p> <p>This method can be overridden in the subclass if the subclass must implement tasks that need to be performed in order to safely disconnect from the equipment.</p> <p>For example,</p> <ul> <li>to clean up system resources from memory (e.g., if using a manufacturer's SDK)</li> <li>to configure the equipment to be in a state that is safe for people   working in the lab when the equipment is not in use</li> </ul> <p>Tip</p> <p>This method gets called automatically when the Interface instance gets garbage collected, which happens when the reference count is 0.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from the equipment.\n\n    This method can be overridden in the subclass if the subclass must implement\n    tasks that need to be performed in order to safely disconnect from the equipment.\n\n    For example,\n\n    * to clean up system resources from memory (e.g., if using a manufacturer's SDK)\n    * to configure the equipment to be in a state that is safe for people\n      working in the lab when the equipment is not in use\n\n    !!! tip\n        This method gets called automatically when the [Interface][msl.equipment.schema.Interface]\n        instance gets garbage collected, which happens when the reference count is 0.\n    \"\"\"\n    logger.debug(\"Disconnected from %r\", self)\n</code></pre>"},{"location":"api/backends/pyvisa/","title":"PyVISA","text":""},{"location":"api/backends/pyvisa/#msl.equipment.interfaces.pyvisa.PyVISA","title":"PyVISA","text":"<pre><code>PyVISA(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Use PyVISA as the backend to communicate with the equipment.</p> <p>The backend value must be equal to <code>PyVISA</code> to use this class for the communication backend.</p> <p>The <code>PYVISA_LIBRARY</code> environment variable is used (if it exists) to create the ResourceManager. This environment variable can be defined in a configuration file or by defining the environment variable in your code before connecting to the equipment using PyVISA for the first time. The default value is <code>@ivi</code> if this environment variable is not defined.</p> <p>The returned object using <code>msl-equipment</code> to connect to the equipment is equivalent to calling open_resource, e.g.,</p> <pre><code>from msl.equipment import Backend, Connection\n\nconnection = Connection(\"GPIB::12\", backend=Backend.PyVISA)\ninst = connection.connect()\nprint(inst.query(\"*IDN?\"))\n</code></pre> <p>is equivalent to</p> <pre><code>import pyvisa\n\nrm = pyvisa.ResourceManager()\ninst = rm.open_resource(\"GPIB::12\")\nprint(inst.query(\"*IDN?\"))\n</code></pre> <p>You can also combine the packages, use <code>msl-equipment</code> for managing information about the equipment and directly use <code>pyvisa</code> for the connection. If you use this combination, the editor you use to develop your code may have better support for features like code completion and type checking.</p> <pre><code>import pyvisa\nfrom msl.equipment import Config\n\n# config.xml contains &lt;equipment eid=\"MSLE.0.063\" name=\"dmm\"/&gt;\n# and specifies where the equipment registers are and the connections file.\ncfg = Config(\"config.xml\")\nequipment = cfg.equipment[\"dmm\"]\n\nrm = pyvisa.ResourceManager()\ninst = rm.open_resource(equipment.connection.address)\ndata = inst.query(\"READ?\")\n\n# You could now use the `equipment` instance to apply a correction to the `data`\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>src/msl/equipment/interfaces/pyvisa.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Use [PyVISA] as the backend to communicate with the equipment.\n\n    The [backend][msl.equipment.schema.Connection.backend] value must be equal to\n    `PyVISA` to use this class for the communication backend.\n\n    The `PYVISA_LIBRARY` environment variable is used (if it exists) to create the\n    [ResourceManager][pyvisa.highlevel.ResourceManager]. This environment variable\n    can be defined in a [configuration file][config-xml-example] or by defining the\n    environment variable in your code before connecting to the equipment using\n    [PyVISA][msl.equipment.interfaces.pyvisa.PyVISA] for the first time. The default\n    value is `@ivi` if this environment variable is not defined.\n\n    The returned object using `msl-equipment` to connect to the equipment is equivalent\n    to calling [open_resource][pyvisa.highlevel.ResourceManager.open_resource], e.g.,\n\n    ```python\n    from msl.equipment import Backend, Connection\n\n    connection = Connection(\"GPIB::12\", backend=Backend.PyVISA)\n    inst = connection.connect()\n    print(inst.query(\"*IDN?\"))\n    ```\n\n    is equivalent to\n\n    ```python\n    import pyvisa\n\n    rm = pyvisa.ResourceManager()\n    inst = rm.open_resource(\"GPIB::12\")\n    print(inst.query(\"*IDN?\"))\n    ```\n\n    You can also combine the packages, use `msl-equipment` for managing information\n    about the equipment and directly use `pyvisa` for the connection. If you use this\n    combination, the editor you use to develop your code may have better support for\n    features like code completion and type checking.\n\n    ```python\n    import pyvisa\n    from msl.equipment import Config\n\n    # config.xml contains &lt;equipment eid=\"MSLE.0.063\" name=\"dmm\"/&gt;\n    # and specifies where the equipment registers are and the connections file.\n    cfg = Config(\"config.xml\")\n    equipment = cfg.equipment[\"dmm\"]\n\n    rm = pyvisa.ResourceManager()\n    inst = rm.open_resource(equipment.connection.address)\n    data = inst.query(\"READ?\")\n\n    # You could now use the `equipment` instance to apply a correction to the `data`\n    ```\n\n    [PyVISA]: https://pyvisa.readthedocs.io/en/stable/\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"\n    self._resource: Resource | None = None\n    super().__init__(equipment)\n\n    if pyvisa is None:  # pragma: no branch\n        msg = \"pyvisa is not installed, run: pip install pyvisa\"  # type: ignore[unreachable]\n        raise RuntimeError(msg)\n\n    assert equipment.connection is not None  # noqa: S101\n    kwargs = _prepare_kwargs(equipment.connection.properties)\n\n    if PyVISA.rm is None:\n        PyVISA.rm = pyvisa.ResourceManager()\n\n    self._resource = PyVISA.rm.open_resource(equipment.connection.address, **kwargs)\n</code></pre>"},{"location":"api/backends/pyvisa/#msl.equipment.interfaces.pyvisa.PyVISA.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/backends/pyvisa/#msl.equipment.interfaces.pyvisa.PyVISA.rm","title":"rm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rm: ResourceManager | None = None\n</code></pre> <p>PyVISA Resource Manager.</p>"},{"location":"api/backends/pyvisa/#msl.equipment.interfaces.pyvisa.PyVISA.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Calls pyvisa.resources.Resource.close.</p> Source code in <code>src/msl/equipment/interfaces/pyvisa.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Calls [pyvisa.resources.Resource.close][].\"\"\"\n    if self._resource is not None:\n        self._resource.close()\n        logger.debug(\"Disconnected from %s\", self)\n        self._resource = None\n    super().disconnect()\n</code></pre>"},{"location":"api/interfaces/","title":"Interfaces","text":"<p>Generic interface classes for computer control</p> <ul> <li>Interface \u2014 Base class for all interfaces</li> <li>MessageBased \u2014 Base class for all message-based interfaces</li> </ul>"},{"location":"api/interfaces/#msl.equipment.schema.Interface","title":"Interface","text":"<pre><code>Interface(equipment: Equipment)\n</code></pre> <p>Base class for all interfaces.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Base class for all interfaces.\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"\n    # __str__ and __repr__ can be called often for logging message, cache the values\n    self._str: str = f\"{self.__class__.__name__}&lt;{equipment.manufacturer}|{equipment.model}|{equipment.serial}&gt;\"\n    self._repr: str = self._str  # updated later\n\n    self._equipment: Equipment = equipment\n\n    if equipment.connection is None:\n        msg = f\"A Connection is not associated with {equipment}\"\n        raise TypeError(msg)\n\n    self._repr = self._repr[:-1] + f\" at {equipment.connection.address}&gt;\"\n    logger.debug(\"Connecting to %r\", self)\n</code></pre>"},{"location":"api/interfaces/#msl.equipment.schema.Interface.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/#msl.equipment.schema.Interface.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the equipment.</p> <p>This method can be overridden in the subclass if the subclass must implement tasks that need to be performed in order to safely disconnect from the equipment.</p> <p>For example,</p> <ul> <li>to clean up system resources from memory (e.g., if using a manufacturer's SDK)</li> <li>to configure the equipment to be in a state that is safe for people   working in the lab when the equipment is not in use</li> </ul> <p>Tip</p> <p>This method gets called automatically when the Interface instance gets garbage collected, which happens when the reference count is 0.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from the equipment.\n\n    This method can be overridden in the subclass if the subclass must implement\n    tasks that need to be performed in order to safely disconnect from the equipment.\n\n    For example,\n\n    * to clean up system resources from memory (e.g., if using a manufacturer's SDK)\n    * to configure the equipment to be in a state that is safe for people\n      working in the lab when the equipment is not in use\n\n    !!! tip\n        This method gets called automatically when the [Interface][msl.equipment.schema.Interface]\n        instance gets garbage collected, which happens when the reference count is 0.\n    \"\"\"\n    logger.debug(\"Disconnected from %r\", self)\n</code></pre>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased","title":"MessageBased","text":"<pre><code>MessageBased(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Base class for equipment that use message-based communication.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for message-based communication.</p> <p>Connection Properties:</p> Name Type Description <code>encoding</code> <code>str</code> <p>Encoding to used for read and write operations. Default: <code>utf-8</code></p> <code>max_read_size</code> <code>int</code> <p>Maximum number of bytes that can be read. Default: <code>1048576</code> (1 MB)</p> <code>read_termination</code> <code>bytes | str</code> <p>Termination character(s) to use for read messages. Default: <code>\\n</code></p> <code>rstrip</code> <code>bool</code> <p>Whether to remove trailing whitespace from read messages. Default: <code>False</code></p> <code>termination</code> <code>bytes | str</code> <p>Sets both <code>read_termination</code> and <code>write_termination</code> to the same termination character(s).</p> <code>timeout</code> <code>float | None</code> <p>Timeout, in seconds, for read and write operations. Default: <code>None</code></p> <code>write_termination</code> <code>bytes | str</code> <p>Termination character(s) to use for write messages. Default: <code>\\r\\n</code></p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    r\"\"\"Base class for equipment that use message-based communication.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following\n    _properties_ for message-based communication.\n\n    Attributes: Connection Properties:\n        encoding (str): Encoding to used for\n            [read][msl.equipment.interfaces.message_based.MessageBased.read] and\n            [write][msl.equipment.interfaces.message_based.MessageBased.write] operations.\n            _Default: `utf-8`_\n        max_read_size (int): Maximum number of bytes that can be\n            [read][msl.equipment.interfaces.message_based.MessageBased.read].\n            _Default: `1048576` (1 MB)_\n        read_termination (bytes | str): Termination character(s) to use for\n            [read][msl.equipment.interfaces.message_based.MessageBased.read] messages.\n            _Default: `\\n`_\n        rstrip (bool): Whether to remove trailing whitespace from\n            [read][msl.equipment.interfaces.message_based.MessageBased.read] messages.\n            _Default: `False`_\n        termination (bytes | str): Sets both `read_termination` and `write_termination`\n            to the same termination character(s).\n        timeout (float | None): Timeout, in seconds, for\n            [read][msl.equipment.interfaces.message_based.MessageBased.read] and\n            [write][msl.equipment.interfaces.message_based.MessageBased.write] operations.\n            _Default: `None`_\n        write_termination (bytes | str): Termination character(s) to use for\n            [write][msl.equipment.interfaces.message_based.MessageBased.write] messages.\n            _Default: `\\r\\n`_\n    \"\"\"\n    super().__init__(equipment)\n    assert equipment.connection is not None  # noqa: S101\n\n    self._encoding: str = \"utf-8\"\n    self._read_termination: bytes | None = None\n    self._write_termination: bytes | None = None\n    self._max_read_size: int = 1048576  # 1 &lt;&lt; 20 (1 MB)\n    self._timeout: float | None = None\n    self._rstrip: bool = False\n\n    p = equipment.connection.properties\n\n    self.max_read_size = p.get(\"max_read_size\", self._max_read_size)\n    self.timeout = p.get(\"timeout\", self._timeout)\n    self.encoding = p.get(\"encoding\", self._encoding)\n    self.rstrip = p.get(\"rstrip\", self._rstrip)\n\n    if \"termination\" in p:\n        self.read_termination = p[\"termination\"]\n        self.write_termination = p[\"termination\"]\n    else:\n        self.read_termination = p.get(\"read_termination\", b\"\\n\")\n        self.write_termination = p.get(\"write_termination\", b\"\\r\\n\")\n</code></pre>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.read_termination","title":"read_termination  <code>property</code> <code>writable</code>","text":"<pre><code>read_termination: bytes | None\n</code></pre> <p>The termination character sequence that is used for a read operation.</p> <p>Reading stops when the equipment stops sending data or the <code>read_termination</code> character sequence is detected. If you set the <code>read_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.write_termination","title":"write_termination  <code>property</code> <code>writable</code>","text":"<pre><code>write_termination: bytes | None\n</code></pre> <p>The termination character sequence that is appended to write messages.</p> <p>If you set the <code>write_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the equipment.</p> <p>This method can be overridden in the subclass if the subclass must implement tasks that need to be performed in order to safely disconnect from the equipment.</p> <p>For example,</p> <ul> <li>to clean up system resources from memory (e.g., if using a manufacturer's SDK)</li> <li>to configure the equipment to be in a state that is safe for people   working in the lab when the equipment is not in use</li> </ul> <p>Tip</p> <p>This method gets called automatically when the Interface instance gets garbage collected, which happens when the reference count is 0.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from the equipment.\n\n    This method can be overridden in the subclass if the subclass must implement\n    tasks that need to be performed in order to safely disconnect from the equipment.\n\n    For example,\n\n    * to clean up system resources from memory (e.g., if using a manufacturer's SDK)\n    * to configure the equipment to be in a state that is safe for people\n      working in the lab when the equipment is not in use\n\n    !!! tip\n        This method gets called automatically when the [Interface][msl.equipment.schema.Interface]\n        instance gets garbage collected, which happens when the reference count is 0.\n    \"\"\"\n    logger.debug(\"Disconnected from %r\", self)\n</code></pre>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"api/interfaces/gpib/","title":"GPIB","text":""},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB","title":"GPIB","text":"<pre><code>GPIB(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MessageBased</code></p> <p>Base class for GPIB communication.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for the GPIB communication protocol, as well as the properties defined in MessageBased.</p> <p>Connection Properties:</p> Name Type Description <code>eos_mode</code> <code>int</code> <p>Specifies the end-of-string character and mode (see eos for details). Default: <code>0</code></p> <code>send_eoi</code> <code>bool</code> <p>Whether to enable (<code>True</code>) or disable (<code>False</code>) the assertion of the EOI signal. Default: <code>True</code></p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Base class for GPIB communication.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for the GPIB communication protocol, as well as the _properties_ defined in\n    [MessageBased][msl.equipment.interfaces.message_based.MessageBased].\n\n    Attributes: Connection Properties:\n        eos_mode (int): Specifies the end-of-string character and mode\n            (see [eos](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibeos.html) for details).\n            _Default: `0`_\n        send_eoi (bool): Whether to enable (`True`) or disable (`False`) the assertion of the EOI signal.\n            _Default: `True`_\n    \"\"\"\n    self._own: bool = True\n    self._handle: int = -1\n    super().__init__(equipment)\n\n    assert equipment.connection is not None  # noqa: S101\n    info = parse_gpib_address(equipment.connection.address)\n    if not info:\n        msg = f\"Invalid GPIB address {equipment.connection.address!r}\"\n        raise ValueError(msg)\n\n    props = equipment.connection.properties\n    _ = props.setdefault(\"read_termination\", None)\n\n    _load_library(self._error_check)\n    assert GPIB.gpib_library is not None  # noqa: S101\n    self._lib: Any = GPIB.gpib_library.lib\n\n    if info.name:\n        # a board or device object from a name in a gpib.conf file\n        self._handle = self._get_ibfind_handle(info.name)\n    elif info.pad is None:\n        # a board object with the given board number\n        self._handle = info.board\n        self._own = False\n    else:\n        # a device object\n        send_eoi = int(props.get(\"send_eoi\", 1))\n        eos_mode = int(props.get(\"eos_mode\", 0))\n        sad = 0 if info.sad is None else info.sad\n        if sad != 0 and sad &lt; 0x60:  # noqa: PLR2004\n            sad += 0x60\n        info.sad = sad\n        timeout = _convert_timeout(props.get(\"timeout\", None))\n        self._handle = self._get_ibdev_handle(info.board, info.pad, sad, timeout, send_eoi, eos_mode)\n\n    # keep this reference assignment after the if/else condition since the\n    # value of the secondary address may have been updated\n    self._address_info: ParsedGPIBAddress = info\n\n    # check if the handle corresponds to a system controller (INTFC)\n    self._is_board: bool\n    try:\n        self._is_board = bool(self.ask(0xA))  # IbaSC = 0xa\n    except MSLConnectionError:\n        # asking IbaSC for a GPIB device raises EHDL error\n        self._is_board = False\n\n    if not self._is_board:\n        self._set_interface_timeout()\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.handle","title":"handle  <code>property</code>","text":"<pre><code>handle: int\n</code></pre> <p>Returns the handle of the instantiated board or device.</p>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.read_termination","title":"read_termination  <code>property</code> <code>writable</code>","text":"<pre><code>read_termination: bytes | None\n</code></pre> <p>The termination character sequence that is used for the read method.</p> <p>By default, reading stops when the EOI line is asserted.</p>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.write_termination","title":"write_termination  <code>property</code> <code>writable</code>","text":"<pre><code>write_termination: bytes | None\n</code></pre> <p>The termination character sequence that is appended to write messages.</p> <p>If you set the <code>write_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.ask","title":"ask","text":"<pre><code>ask(option: int, *, handle: int | None = None) -&gt; int\n</code></pre> <p>Get a configuration setting (board or device).</p> <p>This method is the ibask function, it should not be confused with the query method.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>int</code> <p>A configuration setting to get the value of.</p> required <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The value of the configuration setting.</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def ask(self, option: int, *, handle: int | None = None) -&gt; int:\n    \"\"\"Get a configuration setting (board or device).\n\n    This method is the [ibask](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibask.html)\n    function, it should not be confused with the [query][msl.equipment.interfaces.message_based.MessageBased.query]\n    method.\n\n    Args:\n        option: A configuration setting to get the value of.\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The value of the configuration setting.\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    setting = c_int()\n    self._lib.ibask(handle, option, byref(setting))\n    return setting.value\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.clear","title":"clear","text":"<pre><code>clear(*, handle: int | None = None) -&gt; int\n</code></pre> <p>Send the clear command (device).</p> <p>This method is the ibclr function.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def clear(self, *, handle: int | None = None) -&gt; int:\n    \"\"\"Send the clear command (device).\n\n    This method is the [ibclr](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibclr.html) function.\n\n    Args:\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibclr(handle)\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.command","title":"command","text":"<pre><code>command(data: bytes, *, handle: int | None = None) -&gt; int\n</code></pre> <p>Write command bytes (board).</p> <p>This method is the ibcmd function.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The commands to write to the bus.</p> required <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def command(self, data: bytes, *, handle: int | None = None) -&gt; int:\n    \"\"\"Write command bytes (board).\n\n    This method is the [ibcmd](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibcmd.html) function.\n\n    Args:\n        data: The [commands](https://linux-gpib.sourceforge.io/doc_html/gpib-protocol.html#REFERENCE-COMMAND-BYTES)\n            to write to the bus.\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibcmd(handle, data, len(data))\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.config","title":"config","text":"<pre><code>config(\n    option: int, value: int, *, handle: int | None = None\n) -&gt; int\n</code></pre> <p>Change configuration settings (board or device).</p> <p>This method is the ibconfig function.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>int</code> <p>A configuration setting to change the value of.</p> required <code>value</code> <code>int</code> <p>The new configuration setting value.</p> required <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def config(self, option: int, value: int, *, handle: int | None = None) -&gt; int:\n    \"\"\"Change configuration settings (board or device).\n\n    This method is the [ibconfig](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibconfig.html)\n    function.\n\n    Args:\n        option: A configuration setting to change the value of.\n        value: The new configuration setting value.\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibconfig(handle, option, value)\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.control_atn","title":"control_atn","text":"<pre><code>control_atn(\n    state: int, *, handle: int | None = None\n) -&gt; int\n</code></pre> <p>Set the state of the ATN line (board).</p> <p>This method mimics the PyVISA-py implementation.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>The state of the ATN line or the active controller. Allowed values are:</p> <ul> <li>0: ATN_DEASSERT</li> <li>1: ATN_ASSERT</li> <li>2: ATN_DEASSERT_HANDSHAKE</li> <li>3: ATN_ASSERT_IMMEDIATE</li> </ul> required <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def control_atn(self, state: int, *, handle: int | None = None) -&gt; int:\n    \"\"\"Set the state of the ATN line (board).\n\n    This method mimics the PyVISA-py implementation.\n\n    Args:\n        state: The state of the ATN line or the active controller. Allowed values are:\n\n            * 0: ATN_DEASSERT\n            * 1: ATN_ASSERT\n            * 2: ATN_DEASSERT_HANDSHAKE\n            * 3: ATN_ASSERT_IMMEDIATE\n\n    Args:\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    ibsta: int\n    if handle is None:\n        handle = self._handle\n    if state == ATN_DEASSERT:\n        ibsta = self._lib.ibgts(handle, 0)\n        return ibsta\n    if state == ATN_ASSERT:\n        ibsta = self._lib.ibcac(handle, 0)\n        return ibsta\n    if state == ATN_DEASSERT_HANDSHAKE:\n        ibsta = self._lib.ibgts(handle, 1)\n        return ibsta\n    if state == ATN_ASSERT_IMMEDIATE:\n        ibsta = self._lib.ibcac(handle, 1)\n        return ibsta\n\n    msg = f\"Invalid ATN {state=}\"\n    raise MSLConnectionError(self, message=msg)\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.control_ren","title":"control_ren","text":"<pre><code>control_ren(\n    state: int, *, handle: int | None = None\n) -&gt; int\n</code></pre> <p>Controls the state of the GPIB Remote Enable (REN) interface line.</p> <p>Optionally the remote/local state of the device is also controlled.</p> <p>This method mimics the PyVISA-py implementation.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>Specifies the state of the REN line and optionally the device remote/local state. Allowed values are:</p> <ul> <li>0: REN_DEASSERT</li> <li>1: REN_ASSERT</li> <li>2: REN_DEASSERT_GTL</li> <li>3: REN_ASSERT_ADDRESS</li> <li>4: REN_ASSERT_LLO</li> <li>5: REN_ASSERT_ADDRESS_LLO</li> <li>6: REN_ADDRESS_GTL</li> </ul> required <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def control_ren(self, state: int, *, handle: int | None = None) -&gt; int:\n    \"\"\"Controls the state of the GPIB Remote Enable (REN) interface line.\n\n    Optionally the remote/local state of the device is also controlled.\n\n    This method mimics the PyVISA-py implementation.\n\n    Args:\n        state: Specifies the state of the REN line and optionally the device remote/local state.\n            Allowed values are:\n\n            * 0: REN_DEASSERT\n            * 1: REN_ASSERT\n            * 2: REN_DEASSERT_GTL\n            * 3: REN_ASSERT_ADDRESS\n            * 4: REN_ASSERT_LLO\n            * 5: REN_ASSERT_ADDRESS_LLO\n            * 6: REN_ADDRESS_GTL\n\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n\n    ibsta = 0\n    if self._is_board and state not in (REN_ASSERT, REN_DEASSERT, REN_ASSERT_LLO):\n        msg = f\"Invalid REN {state=} for INTFC\"\n        raise MSLConnectionError(self, message=msg)\n\n    if state == REN_DEASSERT_GTL:\n        ibsta = self.command(b\"\\x01\", handle=handle)  # GTL = 0x1\n\n    if state in (REN_DEASSERT, REN_DEASSERT_GTL):\n        ibsta = self.remote_enable(state=False, handle=handle)\n\n    if state == REN_ASSERT_LLO:\n        ibsta = self.command(b\"\\x11\", handle=handle)  # LLO = 0x11\n    elif state == REN_ADDRESS_GTL:\n        ibsta = self.command(b\"\\x01\", handle=handle)  # GTL = 0x1\n    elif state == REN_ASSERT_ADDRESS_LLO:\n        pass\n    elif state in (REN_ASSERT, REN_ASSERT_ADDRESS):\n        ibsta = self.remote_enable(state=True, handle=handle)\n        if not self._is_board and state == REN_ASSERT_ADDRESS:\n            assert self._address_info.pad is not None  # noqa: S101\n            ibsta = int(self.listener(self._address_info.pad, sad=self._address_info.sad or 0, handle=handle))\n\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.count","title":"count","text":"<pre><code>count() -&gt; int\n</code></pre> <p>Get the number of bytes sent or received.</p> <p>This method is the ibcntl function.</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def count(self) -&gt; int:\n    \"\"\"Get the number of bytes sent or received.\n\n    This method is the [ibcntl](https://linux-gpib.sourceforge.io/doc_html/reference-globals-ibcnt.html) function.\n    \"\"\"\n    return int(self._lib.ibcntl())\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Close the GPIB connection.</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Close the GPIB connection.\"\"\"\n    if self._own and self._handle &gt; 0:\n        with contextlib.suppress(MSLConnectionError):\n            _ = self.online(state=False, handle=self._handle)\n        self._handle = -1\n        super().disconnect()\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.interface_clear","title":"interface_clear","text":"<pre><code>interface_clear(*, handle: int | None = None) -&gt; int\n</code></pre> <p>Perform interface clear (board).</p> <p>Resets the GPIB bus by asserting the interface clear (IFC) bus line for a duration of at least 100 microseconds.</p> <p>This method is the ibsic function.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def interface_clear(self, *, handle: int | None = None) -&gt; int:\n    \"\"\"Perform interface clear (board).\n\n    Resets the GPIB bus by asserting the *interface clear* (IFC) bus line for a duration of at\n    least 100 microseconds.\n\n    This method is the [ibsic](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibsic.html)\n    function.\n\n    Args:\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibsic(handle)\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.lines","title":"lines","text":"<pre><code>lines(*, handle: int | None = None) -&gt; int\n</code></pre> <p>Returns the status of the control and handshaking bus lines (board).</p> <p>This method is the iblines function.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def lines(self, *, handle: int | None = None) -&gt; int:\n    \"\"\"Returns the status of the control and handshaking bus lines (board).\n\n    This method is the [iblines](https://linux-gpib.sourceforge.io/doc_html/reference-function-iblines.html)\n    function.\n\n    Args:\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    status = c_short()\n    self._lib.iblines(handle, byref(status))\n    return status.value\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.listener","title":"listener","text":"<pre><code>listener(\n    pad: int, sad: int = 0, *, handle: int | None = None\n) -&gt; bool\n</code></pre> <p>Check if a listener is present (board or device).</p> <p>This method is the ibln function.</p> <p>Parameters:</p> Name Type Description Default <code>pad</code> <code>int</code> <p>Primary address of the GPIB device.</p> required <code>sad</code> <code>int</code> <p>Secondary address of the GPIB device.</p> <code>0</code> <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether a listener is present.</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def listener(self, pad: int, sad: int = 0, *, handle: int | None = None) -&gt; bool:\n    \"\"\"Check if a listener is present (board or device).\n\n    This method is the [ibln](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibln.html)\n    function.\n\n    Args:\n        pad: Primary address of the GPIB device.\n        sad: Secondary address of the GPIB device.\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        Whether a listener is present.\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    listener = c_short()\n    self._lib.ibln(handle, pad, sad, byref(listener))\n    return bool(listener.value)\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.local","title":"local","text":"<pre><code>local(*, handle: int | None = None) -&gt; int\n</code></pre> <p>Go to local mode (board or device).</p> <p>This method is the ibloc function.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> Return <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def local(self, *, handle: int | None = None) -&gt; int:\n    \"\"\"Go to local mode (board or device).\n\n    This method is the [ibloc](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibloc.html)\n    function.\n\n    Args:\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Return:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibloc(handle)\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.online","title":"online","text":"<pre><code>online(*, state: bool, handle: int | None = None) -&gt; int\n</code></pre> <p>Close or reinitialize descriptor (board or device).</p> <p>This method is the ibonl function.</p> <p>If you want to close the connection for the GPIB board or device that was instantiated, use disconnect.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>If <code>False</code>, closes the connection. If <code>True</code>, then all settings associated with the descriptor (GPIB address, end-of-string mode, timeout, etc.) are reset to their default values. The default values are the settings the descriptor had when it was first obtained.</p> required <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def online(self, *, state: bool, handle: int | None = None) -&gt; int:\n    \"\"\"Close or reinitialize descriptor (board or device).\n\n    This method is the [ibonl](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibonl.html)\n    function.\n\n    If you want to close the connection for the GPIB board or device that was instantiated,\n    use [disconnect][msl.equipment.interfaces.gpib.GPIB.disconnect].\n\n    Args:\n        state: If `False`, closes the connection. If `True`, then all settings associated with the\n            descriptor (GPIB address, end-of-string mode, timeout, etc.) are reset to their *default*\n            values. The *default* values are the settings the descriptor had when it was first obtained.\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibonl(handle, int(state))\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.pass_control","title":"pass_control","text":"<pre><code>pass_control(\n    *,\n    handle: int | None = None,\n    name: str | None = None,\n    board: int | None = None,\n    pad: int = 0,\n    sad: int = NO_SEC_ADDR\n) -&gt; int\n</code></pre> <p>Set a GPIB board or device to become the controller-in-charge (CIC).</p> <p>This method is the ibpct function.</p> <p>If no arguments are specified, the instantiated class becomes the CIC.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. If specified, <code>name</code>, <code>board</code>, <code>pad</code> and <code>sad</code> are ignored.</p> <code>None</code> <code>name</code> <code>str | None</code> <p>The name of a GPIB board or device. If specified, <code>board</code>, <code>pad</code> and <code>sad</code> are ignored.</p> <code>None</code> <code>board</code> <code>int | None</code> <p>Index of the GPIB interface board.</p> <code>None</code> <code>pad</code> <code>int</code> <p>Primary address of the GPIB device.</p> <code>0</code> <code>sad</code> <code>int</code> <p>Secondary address of the GPIB device.</p> <code>NO_SEC_ADDR</code> <p>Returns:</p> Type Description <code>int</code> <p>The handle of the board or device that became CIC.</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def pass_control(\n    self,\n    *,\n    handle: int | None = None,\n    name: str | None = None,\n    board: int | None = None,\n    pad: int = 0,\n    sad: int = NO_SEC_ADDR,\n) -&gt; int:\n    \"\"\"Set a GPIB board or device to become the controller-in-charge (CIC).\n\n    This method is the [ibpct](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibpct.html)\n    function.\n\n    If no arguments are specified, the instantiated class becomes the CIC.\n\n    Args:\n        handle: Board or device descriptor. If specified, `name`, `board`, `pad` and `sad` are ignored.\n        name: The name of a GPIB board or device. If specified, `board`, `pad` and `sad` are ignored.\n        board: Index of the GPIB interface board.\n        pad: Primary address of the GPIB device.\n        sad: Secondary address of the GPIB device.\n\n    Returns:\n        The handle of the board or device that became CIC.\n    \"\"\"\n    if handle is not None:\n        pass\n    elif name is not None:\n        handle = self._get_ibfind_handle(name)\n    elif board is not None:\n        handle = self._get_ibdev_handle(board, pad, sad, 13, 1, 0)  # T10s = 13\n    else:\n        handle = self._handle\n\n    self._lib.ibpct(handle)\n    return handle\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.remote_enable","title":"remote_enable","text":"<pre><code>remote_enable(\n    *, state: bool, handle: int | None = None\n) -&gt; int\n</code></pre> <p>Set remote enable (board).</p> <p>This method is the ibsre function.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>If <code>True</code>, the board asserts the REN line. Otherwise, the REN line is not asserted. The board must be the system controller.</p> required <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns: The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def remote_enable(self, *, state: bool, handle: int | None = None) -&gt; int:\n    \"\"\"Set remote enable (board).\n\n    This method is the [ibsre](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibsre.html)\n    function.\n\n    Args:\n        state: If `True`, the board asserts the REN line. Otherwise, the REN line is not asserted.\n            The board must be the system controller.\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns: The status value (`ibsta`).\n    \"\"\"\n    # ibsre was removed from ni4882.dll, use ibconfig instead (IbcSRE = 0xb)\n    ibsta: int = self.config(0xB, int(state), handle=handle)\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.serial_poll","title":"serial_poll","text":"<pre><code>serial_poll(*, handle: int | None = None) -&gt; int\n</code></pre> <p>Read status byte / serial poll (device).</p> <p>This method is the ibrsp function.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status byte.</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def serial_poll(self, *, handle: int | None = None) -&gt; int:\n    \"\"\"Read status byte / serial poll (device).\n\n    This method is the [ibrsp](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibrsp.html)\n    function.\n\n    Args:\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status byte.\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    status = create_string_buffer(1)\n    self._lib.ibrsp(handle, status)\n    return ord(status.value)\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.spoll_bytes","title":"spoll_bytes","text":"<pre><code>spoll_bytes(*, handle: int | None = None) -&gt; int\n</code></pre> <p>Get the length of the serial poll bytes queue (device).</p> <p>This method is the ibspb function.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def spoll_bytes(self, *, handle: int | None = None) -&gt; int:\n    \"\"\"Get the length of the serial poll bytes queue (device).\n\n    This method is the [ibspb](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibspb.html)\n    function.\n\n    Args:\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    length = c_short()\n    self._lib.ibspb(handle, byref(length))\n    return length.value\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.status","title":"status","text":"<pre><code>status() -&gt; int\n</code></pre> <p>Returns the status value ibsta.</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def status(self) -&gt; int:\n    \"\"\"Returns the status value [ibsta](https://linux-gpib.sourceforge.io/doc_html/reference-globals-ibsta.html).\"\"\"\n    return int(self._lib.ThreadIbsta())\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.trigger","title":"trigger","text":"<pre><code>trigger(*, handle: int | None = None) -&gt; int\n</code></pre> <p>Trigger device.</p> <p>This method is the ibtrg function.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def trigger(self, *, handle: int | None = None) -&gt; int:\n    \"\"\"Trigger device.\n\n    This method is the [ibtrg](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibtrg.html)\n    function.\n\n    Args:\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibtrg(handle)\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.version","title":"version","text":"<pre><code>version() -&gt; str\n</code></pre> <p>Returns the version of the GPIB library (linux only).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def version(self) -&gt; str:\n    \"\"\"Returns the version of the GPIB library (linux only).\"\"\"\n    try:\n        version = c_char_p()\n        self._lib.ibvers(byref(version))\n        assert version.value is not None  # noqa: S101\n        return version.value.decode()\n    except AttributeError:\n        return \"\"\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.wait","title":"wait","text":"<pre><code>wait(mask: int, *, handle: int | None = None) -&gt; int\n</code></pre> <p>Wait for an event (board or device).</p> <p>This method is the ibwait function.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>int</code> <p>Wait until one of the conditions specified in <code>mask</code> is true.</p> required <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def wait(self, mask: int, *, handle: int | None = None) -&gt; int:\n    \"\"\"Wait for an event (board or device).\n\n    This method is the [ibwait](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibwait.html)\n    function.\n\n    Args:\n        mask: Wait until one of the conditions specified in `mask` is true.\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibwait(handle, mask)\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.wait_for_srq","title":"wait_for_srq","text":"<pre><code>wait_for_srq(*, handle: int | None = None) -&gt; int\n</code></pre> <p>Wait for the SRQ line to be asserted (board or device).</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def wait_for_srq(self, *, handle: int | None = None) -&gt; int:\n    \"\"\"Wait for the SRQ line to be asserted (board or device).\n\n    Args:\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    return self.wait(0x1000, handle=handle)  # SRQI = 0x1000\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.write_async","title":"write_async","text":"<pre><code>write_async(\n    message: bytes, *, handle: int | None = None\n) -&gt; int\n</code></pre> <p>Write a message asynchronously (board or device).</p> <p>This method is the ibwrta function.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes</code> <p>The data to send.</p> required <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def write_async(self, message: bytes, *, handle: int | None = None) -&gt; int:\n    \"\"\"Write a message asynchronously (board or device).\n\n    This method is the [ibwrta](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibwrta.html) function.\n\n    Args:\n        message: The data to send.\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibwrta(handle, message, len(message))\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/hislip/","title":"HiSLIP","text":""},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP","title":"HiSLIP","text":"<pre><code>HiSLIP(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MessageBased</code></p> <p>Base class for the HiSLIP communication protocol.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for the HiSLIP communication protocol, as well as the properties defined in MessageBased.</p> <p>Connection Properties:</p> Name Type Description <code>buffer_size</code> <code>int</code> <p>The maximum number of bytes to read at a time. Default: <code>4096</code></p> <code>lock_timeout</code> <code>float</code> <p>The timeout (in seconds) to wait for a lock (0 means wait forever). Default: <code>0</code></p> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Base class for the [HiSLIP] communication protocol.\n\n    [HiSLIP]: https://www.ivifoundation.org/downloads/Protocol%20Specifications/IVI-6.1_HiSLIP-2.0-2020-04-23.pdf\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for the HiSLIP communication protocol, as well as the _properties_ defined in\n    [MessageBased][msl.equipment.interfaces.message_based.MessageBased].\n\n    Attributes: Connection Properties:\n        buffer_size (int): The maximum number of bytes to read at a time. _Default: `4096`_\n        lock_timeout (float): The timeout (in seconds) to wait for a lock (0 means wait forever). _Default: `0`_\n    \"\"\"\n    super().__init__(equipment)\n\n    assert equipment.connection is not None  # noqa: S101\n\n    info = parse_hislip_address(equipment.connection.address)\n    if info is None:\n        msg = f\"Invalid HiSLIP address {equipment.connection.address!r}\"\n        raise ValueError(msg)\n\n    self._info: ParsedHiSLIPAddress = info\n\n    # HiSLIP does not support termination characters\n    self.write_termination = None  # pyright: ignore[reportUnannotatedClassAttribute]\n    self.read_termination = None  # pyright: ignore[reportUnannotatedClassAttribute]\n\n    props = equipment.connection.properties\n    self._buffer_size: int = props.get(\"buffer_size\", 4096)\n    self._lock_timeout: float = props.get(\"lock_timeout\", 0)\n    self.lock_timeout = self._lock_timeout\n\n    self._sync: SyncClient\n    self._async: AsyncClient\n    self._connect()\n    self._set_interface_timeout()\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.asynchronous","title":"asynchronous  <code>property</code>","text":"<pre><code>asynchronous: AsyncClient\n</code></pre> <p>The reference to the asynchronous client.</p>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.lock_timeout","title":"lock_timeout  <code>property</code> <code>writable</code>","text":"<pre><code>lock_timeout: float\n</code></pre> <p>The time, in seconds, to wait to acquire a lock.</p> <p>Setting the value to \u22640 (or <code>None</code>) means wait forever.</p>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.synchronous","title":"synchronous  <code>property</code>","text":"<pre><code>synchronous: SyncClient\n</code></pre> <p>The reference to the synchronous client.</p>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Send the <code>clear</code> command to the device.</p> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Send the `clear` command to the device.\"\"\"\n    # IVI-6.1: IVI High-Speed LAN Instrument Protocol (HiSLIP)\n    # 23 April 2020 (Revision 2.0)\n    # Section 6.12: Device Clear Transaction\n    #\n    # This Connection class does not use the asynchronous client in an\n    # asynchronous manner, therefore there should not be any pending\n    # requests that need to be waited on to finish\n    acknowledged = self._async.async_device_clear()\n    _ = self._sync.device_clear_complete(acknowledged.feature_bitmap)\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Close the connection to the HiSLIP server.</p> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Close the connection to the HiSLIP server.\"\"\"\n    if not hasattr(self, \"_async\"):\n        return\n\n    if self._async.socket is None and self._sync.socket is None:\n        return\n\n    self._async.close()\n    self._sync.close()\n    super().disconnect()\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.lock","title":"lock","text":"<pre><code>lock(lock_string: str = '') -&gt; bool\n</code></pre> <p>Acquire the device's lock.</p> <p>Parameters:</p> Name Type Description Default <code>lock_string</code> <code>str</code> <p>An ASCII string that identifies this lock. If not specified, then an exclusive lock is requested, otherwise the string indicates an identification of a shared-lock request.</p> <code>''</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether acquiring the lock was successful.</p> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def lock(self, lock_string: str = \"\") -&gt; bool:\n    \"\"\"Acquire the device's lock.\n\n    Args:\n        lock_string: An ASCII string that identifies this lock. If not specified, then\n            an exclusive lock is requested, otherwise the string indicates an\n            identification of a shared-lock request.\n\n    Returns:\n        Whether acquiring the lock was successful.\n    \"\"\"\n    status = self._async.async_lock_request(timeout=self._lock_timeout, lock_string=lock_string)\n    return status.success\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.lock_status","title":"lock_status","text":"<pre><code>lock_status() -&gt; tuple[bool, int]\n</code></pre> <p>Request the lock status from the HiSLIP server.</p> <p>Returns:</p> Type Description <code>tuple[bool, int]</code> <p>Whether the HiSLIP server has an exclusive lock with a client and the number of HiSLIP clients that have a lock with the HiSLIP server.</p> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def lock_status(self) -&gt; tuple[bool, int]:\n    \"\"\"Request the lock status from the HiSLIP server.\n\n    Returns:\n        Whether the HiSLIP server has an exclusive lock with a client and\n            the number of HiSLIP clients that have a lock with the HiSLIP server.\n    \"\"\"\n    reply = self._async.async_lock_info()\n    return reply.exclusive, reply.num_locks\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.read_stb","title":"read_stb","text":"<pre><code>read_stb() -&gt; int\n</code></pre> <p>Read the status byte from the device.</p> <p>Returns:</p> Type Description <code>int</code> <p>The status byte.</p> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def read_stb(self) -&gt; int:\n    \"\"\"Read the status byte from the device.\n\n    Returns:\n        The status byte.\n    \"\"\"\n    reply = self._async.async_status_query(self._sync)\n    return reply.status\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.reconnect","title":"reconnect","text":"<pre><code>reconnect(max_attempts: int = 1) -&gt; None\n</code></pre> <p>Reconnect to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>max_attempts</code> <code>int</code> <p>The maximum number of attempts to try to reconnect with the equipment. If &lt;1, keep trying until a connection is successful. If the maximum number of attempts has been reached then an exception is raise.</p> <code>1</code> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def reconnect(self, max_attempts: int = 1) -&gt; None:\n    \"\"\"Reconnect to the equipment.\n\n    Args:\n        max_attempts: The maximum number of attempts to try to reconnect with the equipment.\n            If &amp;lt;1, keep trying until a connection is successful. If the maximum number\n            of attempts has been reached then an exception is raise.\n    \"\"\"\n    attempt = 0\n    while True:\n        attempt += 1\n        try:\n            return self._connect()\n        except (MSLConnectionError, MSLTimeoutError):\n            if 0 &lt; max_attempts &lt;= attempt:\n                raise\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.remote_local_control","title":"remote_local_control","text":"<pre><code>remote_local_control(request: int) -&gt; None\n</code></pre> <p>Send a GPIB-like remote/local control request.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>int</code> <p>The request to perform.</p> <ul> <li>0 \u2014 Disable remote, <code>VI_GPIB_REN_DEASSERT</code></li> <li>1 \u2014 Enable remote, <code>VI_GPIB_REN_ASSERT</code></li> <li>2 \u2014 Disable remote and go to local, <code>VI_GPIB_REN_DEASSERT_GTL</code></li> <li>3 \u2014 Enable Remote and go to remote, <code>VI_GPIB_REN_ASSERT_ADDRESS</code></li> <li>4 \u2014 Enable remote and lock out local, <code>VI_GPIB_REN_ASSERT_LLO</code></li> <li>5 \u2014 Enable remote, go to remote, and set local lockout, <code>VI_GPIB_REN_ASSERT_ADDRESS_LLO</code></li> <li>6 \u2014 Go to local without changing REN or lockout state, <code>VI_GPIB_REN_ADDRESS_GTL</code></li> </ul> required Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def remote_local_control(self, request: int) -&gt; None:\n    \"\"\"Send a GPIB-like remote/local control request.\n\n    Args:\n        request: The request to perform.\n\n            * 0 &amp;mdash; Disable remote, `VI_GPIB_REN_DEASSERT`\n            * 1 &amp;mdash; Enable remote, `VI_GPIB_REN_ASSERT`\n            * 2 &amp;mdash; Disable remote and go to local, `VI_GPIB_REN_DEASSERT_GTL`\n            * 3 &amp;mdash; Enable Remote and go to remote, `VI_GPIB_REN_ASSERT_ADDRESS`\n            * 4 &amp;mdash; Enable remote and lock out local, `VI_GPIB_REN_ASSERT_LLO`\n            * 5 &amp;mdash; Enable remote, go to remote, and set local lockout, `VI_GPIB_REN_ASSERT_ADDRESS_LLO`\n            * 6 &amp;mdash; Go to local without changing REN or lockout state, `VI_GPIB_REN_ADDRESS_GTL`\n    \"\"\"\n    _ = self._async.async_remote_local_control(request, self._sync.message_id)\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.trigger","title":"trigger","text":"<pre><code>trigger() -&gt; None\n</code></pre> <p>Send the trigger message (emulates a GPIB Group Execute Trigger event).</p> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def trigger(self) -&gt; None:\n    \"\"\"Send the trigger message (emulates a GPIB Group Execute Trigger event).\"\"\"\n    self._sync.trigger()\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.unlock","title":"unlock","text":"<pre><code>unlock() -&gt; bool\n</code></pre> <p>Release the lock acquired by lock.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether releasing the lock was successful.</p> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def unlock(self) -&gt; bool:\n    \"\"\"Release the lock acquired by [lock][msl.equipment.interfaces.hislip.HiSLIP.lock].\n\n    Returns:\n        Whether releasing the lock was successful.\n    \"\"\"\n    status = self._async.async_lock_release(self._sync.message_id)\n    return status.success\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"api/interfaces/prologix/","title":"Prologix","text":""},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix","title":"Prologix","text":"<pre><code>Prologix(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Use Prologix hardware to establish a connection.</p> <p>For the GPIB-ETHERNET Controller, the format of the address string is <code>Prologix::HOST::1234::PAD[::SAD]</code>, where <code>HOST</code> is the hostname or IP address of the Prologix hardware, <code>1234</code> is the ethernet port that is open on the Prologix hardware, PAD (Primary GPIB Address) is an integer value between 0 and 30, and SAD (Secondary GPIB Address) is an integer value between 96 and 126 (SAD is optional). For example,</p> <ul> <li><code>Prologix::192.168.1.110::1234::6</code></li> <li><code>Prologix::192.168.1.110::1234::6::96</code></li> <li><code>Prologix::prologix-00-21-69-01-31-04::1234::6</code>     (typically, the hostname is <code>prologix-&lt;MAC Address&gt;</code>)</li> </ul> <p>For the GPIB-USB Controller, the format of the address string is <code>Prologix::PORT::PAD[::SAD]</code>, where <code>PORT</code> is the name of the serial port of the Prologix hardware, <code>PAD</code> (Primary GPIB Address) is an integer value between 0 and 30, and SAD (Secondary GPIB Address) is an integer value between 96 and 126 (SAD is optional). For example,</p> <ul> <li><code>Prologix::COM3::6</code></li> <li><code>Prologix::/dev/ttyUSB0::6::112</code></li> </ul> <p>Alternatively, to clearly separate the Prologix hardware address from the GPIB address you may include <code>GPIB::</code> in the address, for example,</p> <ul> <li><code>Prologix::192.168.1.110::1234::GPIB::6</code></li> <li><code>Prologix::COM3::GPIB::22::96</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for using Prologix hardware, as well as the properties defined in, Serial (for a GPIB-USB Controller) and in Socket (for a GPIB-ETHERNET Controller).</p> <p>Connection Properties:</p> Name Type Description <code>eoi</code> <code>int</code> <p>Whether to use the End or Identify line, either <code>0</code> (disable) or <code>1</code> (enable).</p> <code>eos</code> <code>int</code> <p>GPIB termination character(s): 0 (CR+LF), 1 (CR), 2 (LF) or 3 (no termination).</p> <code>eot_char</code> <code>int</code> <p>A user-specified character to append to network output when <code>eot_enable</code> is set to 1 and EOI is detected. Must be an ASCII value &lt;256, e.g., <code>eot_char=42</code> appends <code>*</code> (ASCII 42) when EOI is detected.</p> <code>eot_enable</code> <code>int</code> <p>Enables (1) or disables (0) the appending of a user-specified character, <code>eot_char</code>.</p> <code>mode</code> <code>int</code> <p>Configure the Prologix hardware to be a CONTROLLER (1) or DEVICE (0). Default: <code>1</code></p> <code>read_tmo_ms</code> <code>int</code> <p>The inter-character timeout value, in milliseconds, to be used in the read command and the spoll command, i.e., the delay since the last character was read. The <code>read_tmo_ms</code> timeout value is not to be confused with the total time for which data is read. The <code>read_tmo_ms</code> value must be between 1 and 3000 milliseconds.</p> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Use [Prologix](https://prologix.biz/) hardware to establish a connection.\n\n    For the GPIB-ETHERNET Controller, the format of the [address][msl.equipment.schema.Connection.address]\n    string is `Prologix::HOST::1234::PAD[::SAD]`, where `HOST` is the hostname or IP address of the Prologix\n    hardware, `1234` is the ethernet port that is open on the Prologix hardware, PAD (Primary GPIB Address)\n    is an integer value between 0 and 30, and SAD (Secondary GPIB Address) is an integer value between\n    96 and 126 (SAD is optional). For example,\n\n    * `Prologix::192.168.1.110::1234::6`\n    * `Prologix::192.168.1.110::1234::6::96`\n    * `Prologix::prologix-00-21-69-01-31-04::1234::6` &lt;br/&gt;\n       (typically, the hostname is `prologix-&lt;MAC Address&gt;`)\n\n    For the GPIB-USB Controller, the format of the [address][msl.equipment.schema.Connection.address]\n    string is `Prologix::PORT::PAD[::SAD]`, where `PORT` is the name of the serial port of the Prologix\n    hardware, `PAD` (Primary GPIB Address) is an integer value between 0 and 30, and SAD (Secondary\n    GPIB Address) is an integer value between 96 and 126 (SAD is optional). For example,\n\n    * `Prologix::COM3::6`\n    * `Prologix::/dev/ttyUSB0::6::112`\n\n    Alternatively, to clearly separate the Prologix hardware address from the GPIB address you may include\n    `GPIB::` in the address, for example,\n\n    * `Prologix::192.168.1.110::1234::GPIB::6`\n    * `Prologix::COM3::GPIB::22::96`\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for using Prologix hardware, as well as the _properties_ defined in,\n    [Serial][msl.equipment.interfaces.serial.Serial] (for a GPIB-USB Controller) and in\n    [Socket][msl.equipment.interfaces.socket.Socket] (for a GPIB-ETHERNET Controller).\n\n    Attributes: Connection Properties:\n        eoi (int): Whether to use the End or Identify line, either `0` (disable) or `1` (enable).\n        eos (int): GPIB termination character(s): 0 (CR+LF), 1 (CR), 2 (LF) or 3 (no termination).\n        eot_char (int): A user-specified character to append to network output when `eot_enable`\n            is set to 1 and EOI is detected. Must be an ASCII value &amp;lt;256, e.g., `eot_char=42`\n            appends `*` (ASCII 42) when EOI is detected.\n        eot_enable (int): Enables (1) or disables (0) the appending of a user-specified character, `eot_char`.\n        mode (int): Configure the Prologix hardware to be a CONTROLLER (1) or DEVICE (0). _Default: `1`_\n        read_tmo_ms (int): The inter-character timeout value, in milliseconds, to be used in the _read_\n            command and the _spoll_ command, i.e., the delay since the last character was read. The\n            `read_tmo_ms` timeout value is not to be confused with the total time for which data is\n            read. The `read_tmo_ms` value must be between 1 and 3000 milliseconds.\n    \"\"\"\n    self._addr: str = \"\"\n    super().__init__(equipment)\n\n    assert equipment.connection is not None  # noqa: S101\n    info = parse_prologix_address(equipment.connection.address)\n    if info is None:\n        msg = f\"Invalid Prologix address {equipment.connection.address!r}\"\n        raise ValueError(msg)\n\n    pad = info.pad\n    if pad &lt; MIN_PAD_ADDRESS or pad &gt; MAX_PAD_ADDRESS:\n        msg = f\"Invalid primary GPIB address {pad}, must be in the range [{MIN_PAD_ADDRESS}, {MAX_PAD_ADDRESS}]\"\n        raise ValueError(msg)\n\n    sad = info.sad\n    if sad is not None and (sad &lt; MIN_SAD_ADDRESS or sad &gt; MAX_SAD_ADDRESS):\n        msg = f\"Invalid secondary GPIB address {sad}, must be in the range [{MIN_SAD_ADDRESS}, {MAX_SAD_ADDRESS}]\"\n        raise ValueError(msg)\n\n    self._addr = f\"++addr {pad}\" if sad is None else f\"++addr {pad} {sad}\"\n    self._query_auto: bool = True\n    self._hw_address: str = info.hw_address\n\n    props = equipment.connection.properties\n\n    try:\n        self._controller: Serial | Socket = Prologix._controllers[self._hw_address]\n    except KeyError:\n        address = f\"TCP::{self._hw_address}::{info.enet_port}\" if info.enet_port else f\"ASRL{self._hw_address}\"\n        e = Equipment(connection=Connection(address, **props))\n        self._controller = PrologixEthernet(e) if info.enet_port else PrologixUSB(e)\n        Prologix._controllers[self._hw_address] = self._controller\n        Prologix._selected_addresses[self._hw_address] = \"\"\n\n    # default is CONTROLLER mode\n    mode = props.get(\"mode\", 1)\n    _ = self._controller.write(f\"++mode {mode}\")\n\n    # set the options provided by the user\n    for option in [\"eoi\", \"eos\", \"eot_enable\", \"eot_char\", \"read_tmo_ms\"]:\n        value = props.get(option)\n        if value is not None:\n            _ = self._controller.write(f\"++{option} {value}\")\n\n    self._ensure_gpib_address_selected()\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.controller","title":"controller  <code>property</code>","text":"<pre><code>controller: Serial | Socket\n</code></pre> <p>The connection to the Prologix Controller for this equipment.</p> <p>The returned type depends on whether a GPIB-USB or a GPIB-ETHERNET Controller is used to communicate with the equipment.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.query_auto","title":"query_auto  <code>property</code> <code>writable</code>","text":"<pre><code>query_auto: bool\n</code></pre> <p>Whether to send <code>++auto 1</code> before and <code>++auto 0</code> after a query to the Prologix Controller.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.read_termination","title":"read_termination  <code>property</code> <code>writable</code>","text":"<pre><code>read_termination: bytes | None\n</code></pre> <p>The termination character sequence that is used for a read operation.</p> <p>Reading stops when the equipment stops sending data or the <code>read_termination</code> character sequence is detected. If you set the <code>read_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, to use for the connection to the Prologix hardware.</p> <p>This timeout value is not to be confused with the <code>read_tmo_ms</code> command that Prologix Controllers accept. To set the inter-character delay, i.e., the delay since the last character was read or for the spoll command, write the <code>++read_tmo_ms &lt;time&gt;</code> message to the Controller.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.write_termination","title":"write_termination  <code>property</code> <code>writable</code>","text":"<pre><code>write_termination: bytes | None\n</code></pre> <p>The termination character sequence that is appended to write messages.</p> <p>If you set the <code>write_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the equipment.</p> <p>Calling this method does not close the underlying Serial or Socket connection to the Prologix Controller since the connection to the Prologix Controller may still be required to send messages to other GPIB devices that are attached to the Controller.</p> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Disconnect from the equipment.\n\n    Calling this method does not close the underlying [Serial][msl.equipment.interfaces.serial.Serial]\n    or [Socket][msl.equipment.interfaces.socket.Socket] connection to the Prologix Controller since\n    the connection to the Prologix Controller may still be required to send messages to other GPIB\n    devices that are attached to the Controller.\n    \"\"\"\n    if self._addr:\n        self._addr = \"\"\n        super().disconnect()\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.group_execute_trigger","title":"group_execute_trigger","text":"<pre><code>group_execute_trigger(*addresses: int) -&gt; int\n</code></pre> <p>Send the Group Execute Trigger command to equipment at the specified addresses.</p> <p>Up to 15 addresses may be specified. If no address is specified then the Group Execute Trigger command is issued to the currently-addressed equipment.</p> <p>Parameters:</p> Name Type Description Default <code>addresses</code> <code>int</code> <p>The primary (and optional secondary) GPIB addresses. If a secondary address is specified then it must follow its corresponding primary address, for example,</p> <ul> <li>group_execute_trigger(1, 11, 17) \u2192 primary, primary, primary</li> <li>group_execute_trigger(3, 96, 12, 21) \u2192 primary, secondary, primary, primary</li> </ul> <code>()</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def group_execute_trigger(self, *addresses: int) -&gt; int:\n    \"\"\"Send the Group Execute Trigger command to equipment at the specified addresses.\n\n    Up to 15 addresses may be specified. If no address is specified then the\n    Group Execute Trigger command is issued to the currently-addressed equipment.\n\n    Args:\n        addresses: The primary (and optional secondary) GPIB addresses. If a secondary address is\n            specified then it must follow its corresponding primary address, for example,\n\n            * group_execute_trigger(1, 11, 17) &amp;#8594; primary, primary, primary\n            * group_execute_trigger(3, 96, 12, 21) &amp;#8594; primary, secondary, primary, primary\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    command = \"++trg\"\n    if addresses:\n        command += \" \" + \" \".join(str(a) for a in addresses)\n    return self._controller.write(command)\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as an numpy.ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def query(\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.prologix.Prologix.write]\n    followed by a [read][msl.equipment.interfaces.prologix.Prologix.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as an [numpy.ndarray][], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    self._ensure_gpib_address_selected()\n\n    if self._query_auto:\n        _ = self._controller.write(b\"++auto 1\")\n\n    reply = self._controller.query(message, delay=delay, decode=decode, dtype=dtype, fmt=fmt, size=size)  # type: ignore[arg-type]\n\n    if self._query_auto:\n        _ = self._controller.write(b\"++auto 0\")\n\n    return reply\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>See MessageBased.read() for more details.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    See [MessageBased.read()][msl.equipment.interfaces.message_based.MessageBased.read] for more details.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    self._ensure_gpib_address_selected()\n    return self._controller.read(decode=decode, dtype=dtype, fmt=fmt, size=size)  # type: ignore[arg-type]\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    self._ensure_gpib_address_selected()\n    return self._controller.write(message, data=data, fmt=fmt, dtype=dtype)\n</code></pre>"},{"location":"api/interfaces/sdk/","title":"SDK","text":""},{"location":"api/interfaces/sdk/#msl.equipment.interfaces.sdk.SDK","title":"SDK","text":"<pre><code>SDK(\n    equipment: Equipment,\n    *,\n    libtype: LibType | None = None,\n    path: PathLike | None = None\n)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Base class for equipment that use the manufacturer's Software Development Kit (SDK).</p> <p>You can use the configuration file to add the directory that the SDK is located at to the <code>PATH</code> environment variable.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <code>libtype</code> <code>LibType | None</code> <p>The library type. See LoadLibrary for more details.</p> <code>None</code> <code>path</code> <code>PathLike | None</code> <p>The path to the SDK. Specifying this value will take precedence over the address value.</p> <code>None</code> Source code in <code>src/msl/equipment/interfaces/sdk.py</code> <pre><code>def __init__(self, equipment: Equipment, *, libtype: LibType | None = None, path: PathLike | None = None) -&gt; None:\n    \"\"\"Base class for equipment that use the manufacturer's Software Development Kit (SDK).\n\n    You can use the [configuration file][config-xml-example] to add the directory that the SDK\n    is located at to the `PATH` environment variable.\n\n    Args:\n        equipment: An [Equipment][] instance.\n        libtype: The library type. See [LoadLibrary][msl.loadlib.load_library.LoadLibrary] for more details.\n        path: The path to the SDK. Specifying this value will take precedence over the\n            [address][msl.equipment.schema.Connection.address] value.\n    \"\"\"\n    super().__init__(equipment)\n\n    if path is None:\n        assert equipment.connection is not None  # noqa: S101\n        info = parse_sdk_address(equipment.connection.address)\n        if info is None:\n            msg = f\"Invalid SDK interface address {equipment.connection.address!r}\"\n            raise ValueError(msg)\n        path = info.path\n\n    self._load_library: LoadLibrary = LoadLibrary(path, libtype)\n    self._sdk: Any = self._load_library.lib\n</code></pre>"},{"location":"api/interfaces/sdk/#msl.equipment.interfaces.sdk.SDK.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/sdk/#msl.equipment.interfaces.sdk.SDK.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>str \u2014 The path to the library file.</p>"},{"location":"api/interfaces/sdk/#msl.equipment.interfaces.sdk.SDK.sdk","title":"sdk  <code>property</code>","text":"<pre><code>sdk: Any\n</code></pre> <p>lib \u2014 The reference to the SDK object.</p>"},{"location":"api/interfaces/sdk/#msl.equipment.interfaces.sdk.SDK.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Cleanup references to the SDK library.</p> Source code in <code>src/msl/equipment/interfaces/sdk.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Cleanup references to the SDK library.\"\"\"\n    if hasattr(self, \"_sdk\") and self._sdk is not None:\n        self._load_library.cleanup()\n        self._sdk = None\n        super().disconnect()\n</code></pre>"},{"location":"api/interfaces/serial/","title":"Serial","text":""},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial","title":"Serial","text":"<pre><code>Serial(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MessageBased</code></p> <p>Base class for equipment that is connected through a serial port.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for the serial communication protocol, as well as the properties defined in MessageBased. The DataBits, Parity and StopBits enumeration names and values may also be used. For properties that specify an alias, you may also use the alternative name as the property name. See serial.Serial for more details.</p> <p>Connection Properties:</p> Name Type Description <code>baud_rate</code> <code>int</code> <p>The baud rate (alias: baudrate). Default: <code>9600</code></p> <code>data_bits</code> <code>int</code> <p>The number of data bits, e.g. 5, 6, 7, 8 (alias: bytesize). Default: <code>8</code></p> <code>dsr_dtr</code> <code>bool</code> <p>Whether to enable hardware (DSR/DTR) flow control (alias: dsrdtr). Default: <code>False</code></p> <code>inter_byte_timeout</code> <code>float | None</code> <p>The inter-character timeout. Default: <code>None</code></p> <code>parity</code> <code>str</code> <p>Parity checking, e.g. 'even', 'odd'. Default: <code>none</code></p> <code>rts_cts</code> <code>bool</code> <p>Whether to enable hardware (RTS/CTS) flow control (alias: rtscts). Default: <code>False</code></p> <code>stop_bits</code> <code>int | float</code> <p>The number of stop bits, e.g. 1, 1.5, 2 (alias: stopbits). Default: <code>1</code></p> <code>xon_xoff</code> <code>bool</code> <p>Whether to enable software flow control (alias: xonxoff). Default: <code>False</code></p> Source code in <code>src/msl/equipment/interfaces/serial.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Base class for equipment that is connected through a serial port.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for the serial communication protocol, as well as the _properties_ defined in\n    [MessageBased][msl.equipment.interfaces.message_based.MessageBased]. The\n    [DataBits][msl.equipment.enumerations.DataBits], [Parity][msl.equipment.enumerations.Parity]\n    and [StopBits][msl.equipment.enumerations.StopBits] enumeration names and values may also\n    be used. For properties that specify an _alias_, you may also use the alternative name as\n    the property name. See [serial.Serial][] for more details.\n\n    Attributes: Connection Properties:\n        baud_rate (int): The baud rate (_alias:_ baudrate). _Default: `9600`_\n        data_bits (int): The number of data bits, e.g. 5, 6, 7, 8 (_alias:_ bytesize). _Default: `8`_\n        dsr_dtr (bool): Whether to enable hardware (DSR/DTR) flow control (_alias:_ dsrdtr). _Default: `False`_\n        inter_byte_timeout (float | None): The inter-character timeout. _Default: `None`_\n        parity (str): Parity checking, e.g. 'even', 'odd'. _Default: `none`_\n        rts_cts (bool): Whether to enable hardware (RTS/CTS) flow control (_alias:_ rtscts). _Default: `False`_\n        stop_bits (int | float): The number of stop bits, e.g. 1, 1.5, 2 (_alias:_ stopbits). _Default: `1`_\n        xon_xoff (bool): Whether to enable software flow control (_alias:_ xonxoff). _Default: `False`_\n    \"\"\"\n    super().__init__(equipment)\n\n    assert equipment.connection is not None  # noqa: S101\n    info = parse_serial_address(equipment.connection.address)\n    if info is None:\n        msg = f\"Invalid serial address {equipment.connection.address!r}\"\n        raise ValueError(msg)\n\n    self._serial: serial.Serial = _init_serial(info.port, equipment.connection.properties)\n    self._set_interface_timeout()\n\n    try:\n        self._serial.open()\n    except serial.SerialException as e:\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.read_termination","title":"read_termination  <code>property</code> <code>writable</code>","text":"<pre><code>read_termination: bytes | None\n</code></pre> <p>The termination character sequence that is used for a read operation.</p> <p>Reading stops when the equipment stops sending data or the <code>read_termination</code> character sequence is detected. If you set the <code>read_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.serial","title":"serial  <code>property</code>","text":"<pre><code>serial: Serial\n</code></pre> <p>Returns the reference to the serial instance.</p>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.write_termination","title":"write_termination  <code>property</code> <code>writable</code>","text":"<pre><code>write_termination: bytes | None\n</code></pre> <p>The termination character sequence that is appended to write messages.</p> <p>If you set the <code>write_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Close the serial port.</p> Source code in <code>src/msl/equipment/interfaces/serial.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Close the serial port.\"\"\"\n    if hasattr(self, \"_serial\") and self._serial.is_open:\n        self._serial.close()\n        super().disconnect()\n</code></pre>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"api/interfaces/socket/","title":"Socket","text":""},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket","title":"Socket","text":"<pre><code>Socket(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MessageBased</code></p> <p>Base class for equipment that is connected through a socket.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for the socket communication protocol, as well as the properties defined in MessageBased.</p> <p>Connection Properties:</p> Name Type Description <code>buffer_size</code> <code>int</code> <p>The maximum number of bytes to read at a time. Default: <code>4096</code></p> Source code in <code>src/msl/equipment/interfaces/socket.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Base class for equipment that is connected through a socket.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for the socket communication protocol, as well as the _properties_ defined in\n    [MessageBased][msl.equipment.interfaces.message_based.MessageBased].\n\n    Attributes: Connection Properties:\n        buffer_size (int): The maximum number of bytes to read at a time. _Default: `4096`_\n    \"\"\"\n    super().__init__(equipment)\n\n    assert equipment.connection is not None  # noqa: S101\n\n    info = parse_socket_address(equipment.connection.address)\n    if info is None:\n        msg = f\"Invalid socket address {equipment.connection.address!r}\"\n        raise ValueError(msg)\n\n    self._info: ParsedSocketAddress = info\n\n    props = equipment.connection.properties\n    self._buffer_size: int = props.get(\"buffer_size\", 4096)\n    self._byte_buffer: bytearray = bytearray()\n\n    typ: int = socket.SOCK_DGRAM if equipment.connection.address.startswith(\"UDP\") else socket.SOCK_STREAM\n    self._is_stream: bool = typ == socket.SOCK_STREAM\n    self._socket: socket.socket = socket.socket(family=socket.AF_INET, type=typ)\n    self._connect()\n</code></pre>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.read_termination","title":"read_termination  <code>property</code> <code>writable</code>","text":"<pre><code>read_termination: bytes | None\n</code></pre> <p>The termination character sequence that is used for a read operation.</p> <p>Reading stops when the equipment stops sending data or the <code>read_termination</code> character sequence is detected. If you set the <code>read_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.socket","title":"socket  <code>property</code>","text":"<pre><code>socket: socket\n</code></pre> <p>Returns a reference to the underlying socket.</p>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.write_termination","title":"write_termination  <code>property</code> <code>writable</code>","text":"<pre><code>write_termination: bytes | None\n</code></pre> <p>The termination character sequence that is appended to write messages.</p> <p>If you set the <code>write_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Close the socket.</p> Source code in <code>src/msl/equipment/interfaces/socket.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Close the socket.\"\"\"\n    if hasattr(self, \"_socket\") and self._socket.fileno() != -1:\n        self._socket.close()\n        super().disconnect()\n</code></pre>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.reconnect","title":"reconnect","text":"<pre><code>reconnect(max_attempts: int = 1) -&gt; None\n</code></pre> <p>Reconnect to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>max_attempts</code> <code>int</code> <p>The maximum number of attempts to try to reconnect with the equipment. If &lt;1, keep trying until a connection is successful. If the maximum number of attempts has been reached then an exception is raise.</p> <code>1</code> Source code in <code>src/msl/equipment/interfaces/socket.py</code> <pre><code>def reconnect(self, max_attempts: int = 1) -&gt; None:\n    \"\"\"Reconnect to the equipment.\n\n    Args:\n        max_attempts: The maximum number of attempts to try to reconnect with the equipment.\n            If &amp;lt;1, keep trying until a connection is successful. If the maximum number\n            of attempts has been reached then an exception is raise.\n    \"\"\"\n    self._socket.close()\n    self._socket = socket.socket(family=self._socket.family, type=self._socket.type)\n\n    attempt = 0\n    while True:\n        attempt += 1\n        try:\n            return self._connect()\n        except (MSLConnectionError, MSLTimeoutError):\n            if 0 &lt; max_attempts &lt;= attempt:\n                raise\n</code></pre>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"api/interfaces/vxi11/","title":"VXI11","text":""},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11","title":"VXI11","text":"<pre><code>VXI11(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MessageBased</code></p> <p>Base class for the VXI-11 communication protocol.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for the VXI-11 communication protocol, as well as the properties defined in MessageBased.</p> <p>Connection Properties:</p> Name Type Description <code>buffer_size</code> <code>int</code> <p>The maximum number of bytes to read at a time. Default: <code>4096</code></p> <code>lock_timeout</code> <code>float</code> <p>The timeout (in seconds) to wait for a lock (0 means wait forever). Default: <code>0</code></p> <code>port</code> <code>int</code> <p>The port to use instead of calling the RPC Port Mapper function.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Base class for the [VXI-11](http://www.vxibus.org/specifications.html) communication protocol.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for the [VXI-11](http://www.vxibus.org/specifications.html) communication protocol, as well\n    as the _properties_ defined in [MessageBased][msl.equipment.interfaces.message_based.MessageBased].\n\n    Attributes: Connection Properties:\n        buffer_size (int): The maximum number of bytes to read at a time. _Default: `4096`_\n        lock_timeout (float): The timeout (in seconds) to wait for a lock (0 means wait forever). _Default: `0`_\n        port (int): The port to use instead of calling the RPC Port Mapper function.\n    \"\"\"\n    # the following must be defined before calling super()\n    self._core_client: CoreClient | None = None\n    self._abort_client: AsyncClient | None = None\n    self._lock_timeout: float = 0  # updated in lock_timeout.setter\n    super().__init__(equipment)\n\n    assert equipment.connection is not None  # noqa: S101\n    info = parse_vxi_address(equipment.connection.address)\n    if info is None:\n        msg = f\"Invalid VXI-11 address {equipment.connection.address!r}\"\n        raise ValueError(msg)\n\n    self._info: ParsedVXI11Address = info\n\n    props = equipment.connection.properties\n    self._buffer_size: int = props.get(\"buffer_size\", 4096)\n    self._core_port: int = props.get(\"port\", -1)  # updated in _connect if -1\n    self._abort_port: int = -1  # updated in _connect\n    self._max_recv_size: int = -1  # updated in _connect\n    self._link_id: int = -1  # updated in _connect\n    self._io_timeout_ms: int = -1  # updated in _set_interface_timeout\n    self._lock_timeout_ms: int = -1  # updated in lock_timeout.setter\n    self.lock_timeout = props.get(\"lock_timeout\", 0)\n\n    # A non-empty read_termination value is applied by default in\n    # MessageBased if the user did not specify one. Set it back\n    # to None if a read-termination character was not explicitly specified.\n    if \"read_termination\" not in props and \"termination\" not in props:\n        self.read_termination = None  # pyright: ignore[reportUnannotatedClassAttribute]\n\n    # VXI-11 does not support write-termination characters\n    self.write_termination = None  # pyright: ignore[reportUnannotatedClassAttribute]\n\n    self._connect()\n    self._set_interface_timeout()\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.lock_timeout","title":"lock_timeout  <code>property</code> <code>writable</code>","text":"<pre><code>lock_timeout: float\n</code></pre> <p>The time, in seconds, to wait to acquire a lock.</p> <p>Setting the value to \u22640 (or <code>None</code>) means wait forever.</p>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.socket","title":"socket  <code>property</code>","text":"<pre><code>socket: socket | None\n</code></pre> <p>Returns the reference to the underlying socket.</p>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.abort","title":"abort","text":"<pre><code>abort() -&gt; None\n</code></pre> <p>Stop an in-progress request.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def abort(self) -&gt; None:\n    \"\"\"Stop an in-progress request.\"\"\"\n    if self._abort_client is None:\n        self._abort_client = AsyncClient(self._info.host)\n        self._abort_client.connect(self._abort_port, timeout=self.timeout)\n    self._abort_client.device_abort(self._link_id)\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Send the <code>clear</code> command to the device.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Send the `clear` command to the device.\"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.device_clear(\n        lid=self._link_id,\n        flags=self._init_flag(),\n        lock_timeout=self._lock_timeout_ms,\n        io_timeout=self._io_timeout_ms,\n    )\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.create_intr_chan","title":"create_intr_chan","text":"<pre><code>create_intr_chan(\n    host_addr: int,\n    host_port: int,\n    prog_num: int,\n    prog_vers: int,\n    prog_family: int,\n) -&gt; None\n</code></pre> <p>Inform the network instrument server to establish an interrupt channel.</p> <p>Parameters:</p> Name Type Description Default <code>host_addr</code> <code>int</code> <p>Address of the host servicing the interrupt.</p> required <code>host_port</code> <code>int</code> <p>Valid port number on the client.</p> required <code>prog_num</code> <code>int</code> <p>Program number.</p> required <code>prog_vers</code> <code>int</code> <p>Program version number.</p> required <code>prog_family</code> <code>int</code> <p>The underlying socket protocol family type (<code>IPPROTO_TCP</code> or <code>IPPROTO_UDP</code>).</p> required Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def create_intr_chan(self, host_addr: int, host_port: int, prog_num: int, prog_vers: int, prog_family: int) -&gt; None:\n    \"\"\"Inform the network instrument server to establish an interrupt channel.\n\n    Args:\n        host_addr: Address of the host servicing the interrupt.\n        host_port: Valid port number on the client.\n        prog_num: Program number.\n        prog_vers: Program version number.\n        prog_family: The underlying socket protocol family type (`IPPROTO_TCP` or `IPPROTO_UDP`).\n    \"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.create_intr_chan(\n        host_addr=host_addr, host_port=host_port, prog_num=prog_num, prog_vers=prog_vers, prog_family=prog_family\n    )\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.destroy_intr_chan","title":"destroy_intr_chan","text":"<pre><code>destroy_intr_chan() -&gt; None\n</code></pre> <p>Inform the network instrument server to close its interrupt channel.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def destroy_intr_chan(self) -&gt; None:\n    \"\"\"Inform the network instrument server to close its interrupt channel.\"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.destroy_intr_chan()\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.destroy_link","title":"destroy_link","text":"<pre><code>destroy_link() -&gt; None\n</code></pre> <p>Destroy the link with the device.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def destroy_link(self) -&gt; None:\n    \"\"\"Destroy the link with the device.\"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.destroy_link(self._link_id)\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Unlink and close the sockets.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Unlink and close the sockets.\"\"\"\n    if self._abort_client is None and self._core_client is None:\n        return\n\n    if self._abort_client is not None:\n        self._abort_client.close()\n        self._abort_client = None\n\n    if self._core_client is not None:\n        if self._link_id != -1:\n            with contextlib.suppress(ConnectionError):\n                self._core_client.destroy_link(self._link_id)\n            self._link_id = -1\n\n        self._core_client.close()\n        self._core_client = None\n\n    super().disconnect()\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.docmd","title":"docmd","text":"<pre><code>docmd(cmd: int, value: float, fmt: str) -&gt; bytes\n</code></pre> <p>Allows for a variety of commands to be executed.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>int</code> <p>An IEEE 488 command messages. For example, to send the Group Execute Trigger command, GET, the value of <code>cmd</code> is <code>0x08</code>.</p> required <code>value</code> <code>float</code> <p>The value to use with <code>cmd</code>. Can be of type bool, int or float.</p> required <code>fmt</code> <code>str</code> <p>How to format <code>value</code>. See format-characters for more details. Do not include the byte-order character. Network (big-endian) order is always used.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The results defined by <code>cmd</code>.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def docmd(self, cmd: int, value: float, fmt: str) -&gt; bytes:\n    \"\"\"Allows for a variety of commands to be executed.\n\n    Args:\n        cmd: An IEEE 488 command messages. For example, to send the Group Execute Trigger\n            command, _GET_, the value of `cmd` is `0x08`.\n        value: The value to use with `cmd`. Can be of type [bool][], [int][] or [float][].\n        fmt: How to format `value`. See [format-characters][] for more details. Do not\n            include the byte-order character. Network (big-endian) order is always used.\n\n    Returns:\n        The results defined by `cmd`.\n    \"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    # always use network (big-endian) byte order\n    s = Struct(\"!\" + fmt.lstrip(\"@=&lt;&gt;!\"))\n    return self._core_client.device_docmd(\n        lid=self._link_id,\n        flags=self._init_flag(),\n        io_timeout=self._io_timeout_ms,\n        lock_timeout=self._lock_timeout_ms,\n        cmd=cmd,\n        network_order=True,\n        size=s.size,\n        data=s.pack(value),\n    )\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.enable_sqr","title":"enable_sqr","text":"<pre><code>enable_sqr(*, state: bool, handle: bytes) -&gt; None\n</code></pre> <p>Enable or disable the sending of <code>device_intr_srq</code> RPCs by the network instrument server.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>Whether to enable or disable interrupts.</p> required <code>handle</code> <code>bytes</code> <p>Host specific data (maximum length is 40 characters).</p> required Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def enable_sqr(self, *, state: bool, handle: bytes) -&gt; None:\n    \"\"\"Enable or disable the sending of `device_intr_srq` RPCs by the network instrument server.\n\n    Args:\n        state: Whether to enable or disable interrupts.\n        handle: Host specific data (maximum length is 40 characters).\n    \"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.device_enable_srq(lid=self._link_id, state=state, handle=handle)\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.local","title":"local","text":"<pre><code>local() -&gt; None\n</code></pre> <p>Place the device in a local state wherein all programmable local controls are enabled.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def local(self) -&gt; None:\n    \"\"\"Place the device in a local state wherein all programmable local controls are enabled.\"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.device_local(\n        lid=self._link_id,\n        flags=self._init_flag(),\n        lock_timeout=self._lock_timeout_ms,\n        io_timeout=self._io_timeout_ms,\n    )\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.lock","title":"lock","text":"<pre><code>lock() -&gt; None\n</code></pre> <p>Acquire the device's lock.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def lock(self) -&gt; None:\n    \"\"\"Acquire the device's lock.\"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.device_lock(lid=self._link_id, flags=self._init_flag(), lock_timeout=self._lock_timeout_ms)\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.read_stb","title":"read_stb","text":"<pre><code>read_stb() -&gt; int\n</code></pre> <p>Read the status byte from the device.</p> <p>Returns:</p> Type Description <code>int</code> <p>The status byte.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def read_stb(self) -&gt; int:\n    \"\"\"Read the status byte from the device.\n\n    Returns:\n        The status byte.\n    \"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    return self._core_client.device_readstb(\n        lid=self._link_id,\n        flags=self._init_flag(),\n        lock_timeout=self._lock_timeout_ms,\n        io_timeout=self._io_timeout_ms,\n    )\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.reconnect","title":"reconnect","text":"<pre><code>reconnect(max_attempts: int = 1) -&gt; None\n</code></pre> <p>Reconnect to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>max_attempts</code> <code>int</code> <p>The maximum number of attempts to try to reconnect with the equipment. If &lt;1, keep trying until a connection is successful. If the maximum number of attempts has been reached then an exception is raise.</p> <code>1</code> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def reconnect(self, max_attempts: int = 1) -&gt; None:\n    \"\"\"Reconnect to the equipment.\n\n    Args:\n        max_attempts: The maximum number of attempts to try to reconnect with the equipment.\n            If &amp;lt;1, keep trying until a connection is successful. If the maximum number\n            of attempts has been reached then an exception is raise.\n    \"\"\"\n    attempt = 0\n    while True:\n        attempt += 1\n        try:\n            return self._connect()\n        except (MSLConnectionError, MSLTimeoutError):\n            if 0 &lt; max_attempts &lt;= attempt:\n                raise\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.remote","title":"remote","text":"<pre><code>remote() -&gt; None\n</code></pre> <p>Place the device in a remote state wherein all programmable local controls are disabled.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def remote(self) -&gt; None:\n    \"\"\"Place the device in a remote state wherein all programmable local controls are disabled.\"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.device_remote(\n        lid=self._link_id,\n        flags=self._init_flag(),\n        lock_timeout=self._lock_timeout_ms,\n        io_timeout=self._io_timeout_ms,\n    )\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.trigger","title":"trigger","text":"<pre><code>trigger() -&gt; None\n</code></pre> <p>Send a trigger to the device.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def trigger(self) -&gt; None:\n    \"\"\"Send a trigger to the device.\"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.device_trigger(\n        lid=self._link_id,\n        flags=self._init_flag(),\n        lock_timeout=self._lock_timeout_ms,\n        io_timeout=self._io_timeout_ms,\n    )\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.unlock","title":"unlock","text":"<pre><code>unlock() -&gt; None\n</code></pre> <p>Release the lock acquired by lock.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def unlock(self) -&gt; None:\n    \"\"\"Release the lock acquired by [lock][msl.equipment.interfaces.vxi11.VXI11.lock].\"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.device_unlock(self._link_id)\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"api/interfaces/zeromq/","title":"ZeroMQ","text":""},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ","title":"ZeroMQ","text":"<pre><code>ZeroMQ(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MessageBased</code></p> <p>Base class for equipment that use the ZeroMQ communication protocol.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for the ZeroMQ communication protocol, as well as the properties defined in MessageBased. The ZeroMQ protocol does not use termination characters, so if termination characters are specified the value is ignored and is set to <code>None</code>.</p> <p>Connection Properties:</p> Name Type Description <code>protocol</code> <code>str</code> <p>ZeroMQ protocol (<code>tcp</code>, <code>udp</code>, <code>pgm</code>, <code>inproc</code>, <code>ipc</code>) Default: <code>tcp</code></p> <code>socket_type</code> <code>int | str</code> <p>ZeroMQ socket type. Default: <code>REQ</code></p> Source code in <code>src/msl/equipment/interfaces/zeromq.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Base class for equipment that use the [ZeroMQ](https://zeromq.org/) communication protocol.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for the [ZeroMQ](https://zeromq.org/) communication protocol, as well as the _properties_\n    defined in [MessageBased][msl.equipment.interfaces.message_based.MessageBased].\n    The [ZeroMQ](https://zeromq.org/) protocol does not use termination characters, so if\n    termination characters are specified the value is ignored and is set to `None`.\n\n    Attributes: Connection Properties:\n        protocol (str): ZeroMQ protocol (`tcp`, `udp`, `pgm`, `inproc`, `ipc`) _Default: `tcp`_\n        socket_type (int | str): ZeroMQ [socket type][zmq.SocketType]. _Default: `REQ`_\n    \"\"\"\n    super().__init__(equipment)\n\n    assert equipment.connection is not None  # noqa: S101\n\n    address = parse_zmq_address(equipment.connection.address)\n    if address is None:\n        msg = f\"Invalid ZeroMQ address {equipment.connection.address!r}\"\n        raise ValueError(msg)\n\n    p = equipment.connection.properties\n    socket_type = to_enum(p.get(\"socket_type\", \"REQ\"), SocketType, to_upper=True)\n    protocol: str = p.get(\"protocol\", \"tcp\")\n\n    # ZeroMQ does not use termination characters\n    self.read_termination = None  # pyright: ignore[reportUnannotatedClassAttribute]\n    self.write_termination = None  # pyright: ignore[reportUnannotatedClassAttribute]\n\n    self._context: Context[SyncSocket] = zmq.Context()\n    self._socket: SyncSocket = self._context.socket(socket_type)\n    self._set_interface_timeout()\n    self._set_interface_max_read_size()\n\n    # Calling zmq.Socket.connect() does not verify that the host:port value until the\n    # socket is used to write/read bytes. An error raised here would be for an an invalid\n    # ZeroMQ addr value\n    try:\n        _ = self._socket.connect(f\"{protocol}://{address.host}:{address.port}\")\n    except zmq.ZMQError as e:\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n</code></pre>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.socket","title":"socket  <code>property</code>","text":"<pre><code>socket: SyncSocket\n</code></pre> <p>Returns a reference to the underlying socket.</p>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Close the socket connection and terminate the context.</p> Source code in <code>src/msl/equipment/interfaces/zeromq.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Close the socket connection and terminate the context.\"\"\"\n    if hasattr(self, \"_socket\") and not self._socket.closed:\n        self._context.set(zmq.BLOCKY, 0)\n        self._socket.setsockopt(zmq.LINGER, 0)\n        self._socket.close()\n        self._context.term()\n        super().disconnect()\n</code></pre>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Three concepts are used by <code>msl-equipment</code></p> <ol> <li>Equipment registers \u2014 to comply with the ISO/IEC 17025 standard</li> <li>Connections \u2014 to interface with equipment for computer control</li> <li>Configuration files \u2014 define requirements for a measurement (links items 1 and 2 together)</li> </ol> <p>You do not need to use all three concepts for your application. You can choose to only use the equipment-register classes to help manage information about the equipment in your laboratory and use a different Python package to communicate with equipment. Similarly, you can choose to use one of the supported backends for communication. You can choose to ignore the equipment registers concept and solely use the package to communicate with equipment. You can also choose to not use <code>msl-equipment</code> at all, but just use the Schema to create equipment registers that comply with ISO/IEC 17025. Since an equipment register is written in the eXtensible Markup Language (XML) file format, it may be parsed by many programming languages. This allows people to share a common equipment register but use different programming languages to read information from the same equipment register.</p>"},{"location":"getting-started/configuration-files/","title":"Configuration Files","text":"<p>A configuration file is useful when you want to perform a measurement. You can use it to specify</p> <ul> <li>equipment that is required to perform the measurement</li> <li>locations of the equipment registers and connections that the equipment can be found in</li> <li>user-specific information that the measurement procedure requires for data acquisition.</li> </ul> <p>A configuration file uses the eXtensible Markup Language (XML) file format to specify this information.</p>"},{"location":"getting-started/configuration-files/#config-xml-example","title":"XML Example","text":"<p>The following illustrates an example configuration file.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;config&gt; &lt;!-- The name of the root tag can be anything you want. --&gt;\n\n  &lt;!-- OPTIONAL: Set the path to a GPIB library file (for GPIB communication).\n\n    This creates/overwrites the value of the GPIB_LIBRARY environment variable.\n    Specifying this element is only necessary if the default file location is\n    not automatically found or if you want to use a different GPIB library\n    instead of the default library.\n  --&gt;\n  &lt;gpib_library&gt;/opt/gpib/libgpib.so.0&lt;/gpib_library&gt;\n\n  &lt;!-- OPTIONAL: Set the PyVISA backend library to use for PyVISA communication.\n\n    This creates/overwrites the value of the PYVISA_LIBRARY environment\n    variable. Possible values are:\n      @ivi (PyVISA &gt;=1.11, default)\n      @ni  (PyVISA &lt; 1.11)\n      @py  (PyVISA-py)\n      @sim (PyVISA-sim)\n  --&gt;\n  &lt;pyvisa_library&gt;@py&lt;/pyvisa_library&gt;\n\n  &lt;!-- OPTIONAL: Add paths to where library files are located.\n\n    The paths are appended to the PATH environment variable. If a\n    recursive=\"true\" attribute is included, then recursively adds the\n    specified directory and all sub-directories to PATH. Adding &lt;path&gt;\n    elements is useful if communication to equipment requires the\n    manufacturer's Software Development Kit (SDK). The &lt;path&gt; element\n    may be specified multiple times.\n  --&gt;\n  &lt;path&gt;C:\\Program Files\\Manufacturer\\lib&lt;/path&gt;\n  &lt;path recursive=\"true\"&gt;D:\\code\\SDKs&lt;/path&gt;\n\n  &lt;!-- Specify the equipment that is required to perform the measurement.\n\n    The `eid` attribute (equipment ID from an equipment register) is mandatory,\n    and the `name` attribute is optional. If you define a `name`, you can access\n    the equipment by its name instead of the index number based on the order\n    that &lt;equipment/&gt; elements are defined in the configuration file. You can\n    also access the equipment by its `eid` value. All other attributes are\n    ignored by msl-equipment. Additional attributes may be helpful for a person\n    to know what the equipment is when they read the configuration file.\n\n    Not all &lt;equipment/&gt; elements that are defined need to be for communication\n    purposes. Cables, amplifiers, filters and adaptors can all be important\n    equipment that may be required to perform a measurement. Defining this kind\n    of equipment is useful to have access to during data acquisition since you\n    can save the &lt;equipment/&gt; information (or just the equipment IDs) to the\n    output file.\n   --&gt;\n  &lt;equipment eid=\"MSLE.M.092\" name=\"dmm\" comment=\"borrowed from Kibble lab\"/&gt;\n  &lt;equipment eid=\"MSLE.O.103\" name=\"photodiode\" manufacturer=\"MSL\" std=\"B03\"/&gt;\n  &lt;equipment eid=\"MSLE.O.061\" name=\"monochromator\"/&gt;\n\n  &lt;!-- Equipment registers that the equipment above can be found in.\n\n    The value can be a single XML file or a directory that contains multiple\n    XML files (if your register spans multiple files). If a directory, the\n    specified directory and all sub-directories will be searched for equipment\n    registers.\n\n    The value supports the ~ character to represent the users HOME directory.\n    The &lt;register&gt; element can be specified multiple times.\n  --&gt;\n  &lt;register&gt;~\\Equipment\\register.xml&lt;/register&gt;\n  &lt;register&gt;M:\\Mass\\Register&lt;/register&gt;\n\n  &lt;!-- Connection files for equipment that require computer control.\n\n    The value can be a single XML file or a directory that contains multiple\n    XML files. If a directory, the specified directory and all sub-directories\n    will be searched for connection files.\n\n    The value supports the ~ character to represent the users HOME directory.\n    The &lt;connections&gt; element can be specified multiple times.\n  --&gt;\n  &lt;connections&gt;C:\\DATA\\Connections\\transmittance.xml&lt;/connections&gt;\n\n  &lt;!-- USER SPECIFIC: You may define your own elements. --&gt;\n  &lt;max_temperature unit=\"\u00b0C\"&gt;30&lt;/max_temperature&gt;\n  &lt;auto_zero&gt;true&lt;/auto_zero&gt;\n  &lt;nd_filter&gt;OD: 2.0&lt;/nd_filter&gt;\n  &lt;smtp&gt;\n    &lt;host&gt;smtp.server.nz&lt;/host&gt;\n    &lt;port&gt;25&lt;/port&gt;\n    &lt;recipient&gt;me@measurement.govt.nz&lt;/recipient&gt;\n    &lt;recipient&gt;you@measurement.govt.nz&lt;/recipient&gt;\n  &lt;/smtp&gt;\n\n&lt;/config&gt;\n</code></pre>"},{"location":"getting-started/configuration-files/#config-python-example","title":"Python Example","text":"<p>The Config class is used to load a configuration file</p> <pre><code>&gt;&gt;&gt; from msl.equipment import Config\n&gt;&gt;&gt; cfg = Config(\"tests/resources/config.xml\")\n</code></pre> <p>You can then access the equipment registers,</p> <pre><code>&gt;&gt;&gt; for team, register in cfg.registers.items():\n...    print(f\"{team}:\", register)\nMass: Register(team='Mass' (3 equipment))\nLight: Register(team='Light' (4 equipment))\n</code></pre> <p>iterate over and access <code>&lt;equipment/&gt;</code> elements that have been defined in the configuration file to access the Equipment instances,</p> <pre><code>&gt;&gt;&gt; for equipment in cfg.equipment:\n...     print(equipment.id)\nMSLE.M.092\nMSLE.O.103\nMSLE.O.061\n&gt;&gt;&gt; cfg.equipment[0].id  # use the index\n'MSLE.M.092'\n&gt;&gt;&gt; cfg.equipment[\"MSLE.M.092\"].id  # use the equipment id\n'MSLE.M.092'\n&gt;&gt;&gt; cfg.equipment[\"dmm\"].id  # use the name attribute\n'MSLE.M.092'\n</code></pre> <p>access XML elements defined in the configuration file by using the tag name or the path to the element,</p> <pre><code>&gt;&gt;&gt; cfg.attrib(\"max_temperature\")\n{'unit': '\u00b0C'}\n&gt;&gt;&gt; cfg.find(\"max_temperature\")\n&lt;Element 'max_temperature' at ...&gt;\n&gt;&gt;&gt; cfg.findall(\"smtp/recipient\")\n[&lt;Element 'recipient' at ...&gt;, &lt;Element 'recipient' at ...&gt;]\n</code></pre> <p>and if the value of an XML element is a boolean (<code>true</code>, <code>false</code> case-insensitive) an integer or a floating-point number, you can use the value method to convert the text value to the appropriate Python data type (otherwise the text value will remain as a string).</p> <pre><code>&gt;&gt;&gt; cfg.value(\"auto_zero\")\nTrue\n&gt;&gt;&gt; cfg.value(\"max_temperature\") / 2\n15.0\n&gt;&gt;&gt; cfg.value(\"nd_filter\")\n'OD: 2.0'\n</code></pre>"},{"location":"getting-started/connections/","title":"Connections","text":"<p>The information about how to interface with equipment for computer control is based on the definitions in the Schema and may either be saved in the eXtensible Markup Language (XML) file format or in a Python module. When using the XML format, you would specify the XML file that contains the connection information as a <code>&lt;connections&gt;</code> element in your configuration file. When the configuration file is loaded (via Config), it links a Connection instance with the corresponding Equipment instance based on the equipment id.</p>"},{"location":"getting-started/connections/#connections-xml","title":"XML Schema","text":"<p>Schema definition for connection information. See this section for details on how to validate the contents of a connections XML file against the schema.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;xsd:schema version=\"1.0.0\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"&gt;\n    &lt;xsd:element name=\"connections\"&gt;\n        &lt;xsd:complexType&gt;\n            &lt;xsd:sequence minOccurs=\"0\" maxOccurs=\"unbounded\"&gt;\n                &lt;xsd:element name=\"connection\"&gt;\n                    &lt;xsd:complexType&gt;\n                        &lt;xsd:all&gt;\n                            &lt;xsd:element name=\"eid\" type=\"xsd:string\"&gt;\n                                &lt;xsd:annotation&gt;\n                                    &lt;xsd:documentation&gt;\n                                        The equipment ID from an equipment register.\n                                    &lt;/xsd:documentation&gt;\n                                &lt;/xsd:annotation&gt;\n                            &lt;/xsd:element&gt;\n                            &lt;xsd:element name=\"address\" type=\"xsd:string\"&gt;\n                                &lt;xsd:annotation&gt;\n                                    &lt;xsd:documentation&gt;\n                                        The VISA-style address to use for the connection.\n                                    &lt;/xsd:documentation&gt;\n                                &lt;/xsd:annotation&gt;\n                            &lt;/xsd:element&gt;\n                            &lt;xsd:element name=\"backend\" minOccurs=\"0\"&gt;\n                                &lt;xsd:annotation&gt;\n                                    &lt;xsd:documentation&gt;\n                                        The backend package to use to communicate with the equipment.\n                                        Default is MSL if not defined.\n                                    &lt;/xsd:documentation&gt;\n                                &lt;/xsd:annotation&gt;\n                                &lt;xsd:simpleType&gt;\n                                    &lt;xsd:restriction base=\"xsd:string\"&gt;\n                                        &lt;xsd:enumeration value=\"MSL\"/&gt;\n                                        &lt;xsd:enumeration value=\"PyVISA\"/&gt;\n                                        &lt;xsd:enumeration value=\"NIDAQ\"/&gt;\n                                    &lt;/xsd:restriction&gt;\n                                &lt;/xsd:simpleType&gt;\n                            &lt;/xsd:element&gt;\n                            &lt;xsd:element name=\"manufacturer\" type=\"xsd:string\" minOccurs=\"0\"&gt;\n                                &lt;xsd:annotation&gt;\n                                    &lt;xsd:documentation&gt;\n                                        The name of the manufacturer of the equipment.\n                                    &lt;/xsd:documentation&gt;\n                                &lt;/xsd:annotation&gt;\n                            &lt;/xsd:element&gt;\n                            &lt;xsd:element name=\"model\" type=\"xsd:string\" minOccurs=\"0\"&gt;\n                                &lt;xsd:annotation&gt;\n                                    &lt;xsd:documentation&gt;\n                                        The model number of the equipment.\n                                    &lt;/xsd:documentation&gt;\n                                &lt;/xsd:annotation&gt;\n                            &lt;/xsd:element&gt;\n                            &lt;xsd:element name=\"serial\" type=\"xsd:string\" minOccurs=\"0\"&gt;\n                                &lt;xsd:annotation&gt;\n                                    &lt;xsd:documentation&gt;\n                                        The serial number (or unique identifier) of the equipment.\n                                    &lt;/xsd:documentation&gt;\n                                &lt;/xsd:annotation&gt;\n                            &lt;/xsd:element&gt;\n                            &lt;xsd:element name=\"properties\" minOccurs=\"0\"&gt;\n                                &lt;xsd:annotation&gt;\n                                    &lt;xsd:documentation&gt;\n                                        Additional name-value pairs that are required to communicate with the equipment.\n                                    &lt;/xsd:documentation&gt;\n                                &lt;/xsd:annotation&gt;\n                                &lt;xsd:complexType&gt;\n                                    &lt;xsd:sequence&gt;\n                                        &lt;xsd:any processContents=\"skip\" minOccurs=\"0\" maxOccurs=\"unbounded\"/&gt;\n                                    &lt;/xsd:sequence&gt;\n                                &lt;/xsd:complexType&gt;\n                            &lt;/xsd:element&gt;\n                        &lt;/xsd:all&gt;\n                    &lt;/xsd:complexType&gt;\n                &lt;/xsd:element&gt;\n            &lt;/xsd:sequence&gt;\n        &lt;/xsd:complexType&gt;\n    &lt;/xsd:element&gt;\n&lt;/xsd:schema&gt;\n</code></pre>"},{"location":"getting-started/connections/#connections-xml-example","title":"Example","text":"<p>Example XML file to specify connection information. Only the <code>&lt;eid&gt;</code> and <code>&lt;address&gt;</code> elements are required, all other elements are optional.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;connections&gt;\n    &lt;connection&gt;\n        &lt;eid&gt;MSLE.M.041&lt;/eid&gt;\n        &lt;address&gt;TCPIP::192.168.1.10::hislip0&lt;/address&gt;\n    &lt;/connection&gt;\n    &lt;connection&gt;\n        &lt;eid&gt;MSLE.M.023&lt;/eid&gt;\n        &lt;address&gt;ASRL/dev/ttyS1&lt;/address&gt;\n        &lt;backend&gt;PyVISA&lt;/backend&gt;\n        &lt;manufacturer&gt;Manufacturer&lt;/manufacturer&gt;\n        &lt;model&gt;Model&lt;/model&gt;\n        &lt;serial&gt;Serial&lt;/serial&gt;\n        &lt;properties&gt;\n            &lt;baud_rate&gt;19200&lt;/baud_rate&gt;\n            &lt;read_termination&gt;\\r&lt;/read_termination&gt;\n            &lt;write_termination&gt;\\r&lt;/write_termination&gt;\n            &lt;timeout&gt;10&lt;/timeout&gt;\n        &lt;/properties&gt;\n    &lt;/connection&gt;\n&lt;/connections&gt;\n</code></pre>"},{"location":"getting-started/connections/#address-syntax","title":"Address Syntax","text":"<p>The following are examples of VISA-style addresses that may be used to connect to equipment.</p> Interface Address Description GPIB GPIB::10 GPIB device at board=0 (default), primary address=10, no secondary address GPIB GPIB0::voltmeter GPIB device at board=0, interface name=\"voltmeter\" (see gpib.conf for more details about the \"name\" option) GPIB GPIB1::6::97::INSTR GPIB device at board=1, primary address=6, secondary address=97 GPIB GPIB2::INTFC GPIB interface at board=2 HiSLIP TCPIP::dev.company.com::hislip0 A HiSLIP LAN instrument, host=dev.company.com HiSLIP TCPIP::10.12.114.50::hislip0,5000::INSTR A HiSLIP LAN instrument, host=10.12.114.50, port=5000 PROLOGIX Prologix::192.168.1.110::1234::6 The GPIB-ETHERNET Controller, host=192.168.1.110, port=1234, primary GPIB address=6 PROLOGIX Prologix::192.168.1.70::1234::6::112 The GPIB-ETHERNET Controller, host=192.168.1.70, port=1234, primary GPIB address=6, secondary GPIB address=112 PROLOGIX Prologix::192.168.1.70::1234::GPIB::6::112 The GPIB-ETHERNET Controller, host=192.168.1.70, port=1234, primary GPIB address=6, secondary GPIB address=112 PROLOGIX Prologix::COM3::6 The GPIB-USB Controller, port=COM3, primary GPIB address=6 PROLOGIX Prologix::COM3::GPIB::6 The GPIB-USB Controller, port=COM3, primary GPIB address=6 PROLOGIX Prologix::/dev/ttyS0::4::96 The GPIB-USB Controller, port=/dev/ttyS0, primary GPIB address=4, secondary GPIB address=96 SDK SDK::C:/Manufacturer/library.dll Specify the full path to the SDK SDK SDK::library.dll Specify only the filename if the path to where the SDK file is located has been added to the <code>PATH</code> environment variable SERIAL COM2 A serial port on Windows SERIAL ASRL/dev/ttyS1 A serial port on Linux SERIAL ASRL2::INSTR Compatible with National Instruments syntax SERIAL ASRLCOM2 Compatible with PyVISA-py syntax SOCKET TCP::192.168.1.100::5000 Use the TCP protocol, host=192.168.1.100, port=5000 SOCKET UDP::192.168.1.100::5000 Use the UDP protocol, host=192.168.1.100, port=5000 SOCKET TCPIP::192.168.1.100::5000::SOCKET Compatible with National Instruments syntax VXI-11 TCPIP::dev.company.com::INSTR A VXI-11.3 LAN instrument, host=dev.company.com (uses the default LAN Device Name inst0) VXI-11 TCPIP::10.6.56.21::gpib0,2::INSTR A VXI-11.2 GPIB device, host=10.6.56.21, gpib address=2 VXI-11 TCPIP::192.168.1.100 A VXI-11.3 LAN instrument, host=192.168.1.100 (default values for board 0 and LAN device name inst0 are used) ZMQ ZMQ::192.168.20.90::5555 Use the ZeroMQ messaging library to connect to a device, host=192.168.20.90, port=5555 <p>National Instruments also provides examples if you are using PyVISA as the backend.</p>"},{"location":"getting-started/connections/#connections-interfaces","title":"Interfaces","text":"<p>The following interface classes are available</p> <ul> <li>GPIB \u2014 Base class for GPIB communication</li> <li>HiSLIP \u2014 Base class for the HiSLIP communication protocol</li> <li>Prologix \u2014 Use Prologix hardware to establish a connection</li> <li>SDK \u2014 Use the Software Development Kit (SDK) provided by the manufacturer</li> <li>Serial \u2014 Base class for equipment that is connected through a serial port</li> <li>Socket \u2014 Base class for equipment that is connected through a socket</li> <li>VXI11 \u2014 Base class for the VXI-11 communication protocol</li> <li>ZeroMQ \u2014 Communicate via the ZeroMQ protocol</li> </ul>"},{"location":"getting-started/connections/#connections-backend","title":"Backends","text":"<p>When a Connection instance is created, the <code>backend</code> keyword argument decides which backend to use when interfacing with the equipment. There are different Backends to choose from: <code>MSL</code> (default), <code>PyVISA</code> or <code>NIDAQ</code>.</p> <p>The interface class can be used if the <code>backend</code> is <code>MSL</code>. The corresponding interface classes for the external backends are PyVISA and NIDAQ.</p>"},{"location":"getting-started/connections/#connections-python-module","title":"Python Module","text":"<p>If you are primarily interested in using <code>msl-equipment</code> for interfacing with equipment (and not the Equipment Registers aspect), the simplest approach is to create Connection instances in a module and call the connect method.</p> <pre><code>from msl.equipment import Connection\n\ndevice = Connection(\"COM3\").connect()\nprint(device.query(\"*IDN?\"))\n</code></pre> <p>If you have multiple equipment that you want to communicate with and you also want to include some additional metadata so that you can keep track of which device is associated with the corresponding address, you could do something like the following.</p> <pre><code>from msl.equipment import Connection\n\n# Assign custom names to associate with each equipment\nconnections = {\n    \"alice\": Connection(\"GPIB::22\", model=\"3458A\"),\n    \"bob\": Connection(\"COM3\", manufacturer=\"HP\", model=\"34401A\"),\n\n    # not used below but is available to use for another day\n    \"eve\": Connection(\"SDK::company.dll\", model=\"Scope-20\", resolution=\"16bit\"),\n}\n\n# Connect to the equipment using the names that were assigned\nalice = connections[\"alice\"].connect()\nbob = connections[\"bob\"].connect()\n\n# Query the identity\nprint(alice.query(\"ID?\"))\nprint(bob.query(\"*IDN?\"))\n</code></pre>"},{"location":"getting-started/equipment-registers/","title":"Equipment Registers","text":"<p>Laboratories that use equipment for traceable calibration measurements are required to manage information about the equipment by following the ISO/IEC 17025 standard. This information is saved in files that are referred to as equipment registers.</p> <p>An equipment register is based on the definitions in the Schema and may either be saved in the eXtensible Markup Language (XML) file format or in a Python module. Using the XML format is the preferred way to save the information since XML files can be easily validated against the Schema to ensure data integrity and it allows for equipment registers to be parsed by many programming languages. An equipment register can be saved in a single XML file or distributed across multiple XML files.</p> <p>The Schema Classes section of the documentation shows how an equipment register can be used in a Python program. The Register class loads an equipment register, or when using a configuration file the registers attribute provides access to multiple equipment registers.</p>"},{"location":"getting-started/equipment-registers/#er-schema","title":"XML Schema","text":"<p>The documentation for the equipment-register schema is available here and development of the schema is performed in the repository.</p> <p>Currently, the schema is targeting equipment that is located at the Measurement Standards Laboratory of New Zealand (in particular, enumeration values and pattern-string matches). If you work at a calibration laboratory and are interested in using the schema within your Quality Management System, please contact us or open an issue.</p> <p>See this section for details on how to validate the contents of an equipment register against the schema.</p>"},{"location":"getting-started/equipment-registers/#er-python-module","title":"Python Module","text":"<p>You may save the information about the equipment you are using in Python modules instead of in XML files.</p> <pre><code>from datetime import date\n\nfrom msl.equipment import (\n    CompletedTask,\n    Component,\n    Connection,\n    Equation,\n    Equipment,\n    Evaluable,\n    Maintenance,\n    Measurand,\n    Range,\n    Report,\n)\n\nequipment = Equipment(\n    manufacturer=\"HP\",\n    model=\"3458A\",\n    connection=Connection(\"GPIB::22\"),\n    maintenance=Maintenance(\n        completed=(\n            CompletedTask(\n                task=\"Clean fan\",\n                due_date=date(2025, 3, 4),\n                completed_date=date(2025, 3, 5),\n                performed_by=\"John\",\n            ),\n        )\n    ),\n    calibrations=(\n        Measurand(\n            quantity=\"Voltage DC\",\n            calibration_interval=1,\n            components=(\n                Component(\n                    reports=(\n                        Report(\n                            id=\"Report No.\",\n                            report_issue_date=date(2024, 8, 13),\n                            measurement_start_date=date(2024, 8, 5),\n                            measurement_stop_date=date(2024, 8, 6),\n                            equations=(\n                                Equation(\n                                    value=Evaluable(\n                                        equation=\"0.9999862*v + 1.024e-5\",\n                                        variables=(\"v\",),\n                                        ranges={\"v\": Range(1, 10)}\n                                    ),\n                                    uncertainty=Evaluable(equation=\"3.2e-6\"),\n                                    unit=\"V\",\n                                ),\n                            ),\n                        ),\n                    )\n                ),\n            ),\n        ),\n    ),\n)\n\n# Connect to the digital multimeter and query its identity\ndmm = equipment.connect()\nprint(dmm.query(\"ID?\"))\n\n# Configure the multimeter, fetch voltage readings, convert to float(s)\nvoltages = ...\n\n# Apply the calibration equation to correct the voltage readings\ncorrection = equipment.latest_report().equation\nprint(correction.value(v=voltages))\nprint(correction.uncertainty(v=voltages))\n</code></pre>"},{"location":"resources/","title":"Resources","text":"<p>Resources are custom classes for interfacing with specific equipment. In previous releases of <code>msl-equipment</code> (versions &lt; 1.0), the resources were automatically bundled with <code>msl-equipment</code>. As of v1.0, the resources are maintained in another package, <code>msl-equipment-resources</code>, that must be installed separately.</p> <p>Some of the resources might not work in your application because the resource might depend on an external dependency, e.g., the Software Development Kit (SDK) provided by a manufacturer, and this external dependency might not be available for your operating system.</p> <p>Attention</p> <p>Companies that sell equipment that are used for scientific research are identified in this guide in order to illustrate how to adequately use <code>msl-equipment-resources</code> in your application. Such identification is not intended to imply recommendation or endorsement by the Measurement Standards Laboratory of New Zealand, nor is it intended to imply that the companies identified are necessarily the best for the purpose.</p>"},{"location":"resources/#install","title":"Install","text":"<p>Installing <code>msl-equipment-resources</code> will also install <code>msl-equipment</code></p> <pre><code>pip install msl-equipment-resources\n</code></pre>"},{"location":"resources/#create-a-new-resource","title":"Create a new resource","text":"<p>TODO...</p>"},{"location":"resources/#multiple-interfaces","title":"Multiple interfaces","text":"<p>If the equipment supports multiple interfaces for message-based protocols (e.g., Socket, Serial, GPIB, ...) you can create a resource that inherits from the MultiMessageBased class. Upon calling super in the subclass, the connection is established with the appropriate protocol class.</p>"},{"location":"resources/multi_message_based/","title":"MultiMessageBased","text":"<p>A resource that supports multiple interfaces for message-based communication.</p>"},{"location":"resources/multi_message_based/#msl.equipment_resources.multi_message_based.MultiMessageBased","title":"MultiMessageBased","text":"<pre><code>MultiMessageBased(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MessageBased</code></p> <p>A resource that supports multiple interfaces for message-based communication.</p> <p>A Connection instance supports the same properties as MessageBased.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/multi_message_based.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"A resource that supports multiple interfaces for message-based communication.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the same _properties_ as\n    [MessageBased][msl.equipment.interfaces.message_based.MessageBased].\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"\n    self._connected: bool = False\n    super().__init__(equipment)\n\n    c = equipment.connection\n    assert c is not None  # noqa: S101\n\n    try:\n        # Let the address (not the manufacturer/model) decide which interface to use\n        self._interface: MessageBased = Connection(c.address, **c.properties).connect()\n    except MSLConnectionError as e:\n        lines = str(e).splitlines()\n        raise MSLConnectionError(self, message=\"\\n\".join(lines[1:])) from None\n\n    self._connected = True\n    self._set_interface_max_read_size()\n    self._set_interface_timeout()\n</code></pre>"},{"location":"resources/multi_message_based/#msl.equipment_resources.multi_message_based.MultiMessageBased.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"resources/multi_message_based/#msl.equipment_resources.multi_message_based.MultiMessageBased.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"resources/multi_message_based/#msl.equipment_resources.multi_message_based.MultiMessageBased.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"resources/multi_message_based/#msl.equipment_resources.multi_message_based.MultiMessageBased.read_termination","title":"read_termination  <code>property</code> <code>writable</code>","text":"<pre><code>read_termination: bytes | None\n</code></pre> <p>The termination character sequence that is used for a read operation.</p> <p>Reading stops when the equipment stops sending data or the <code>read_termination</code> character sequence is detected. If you set the <code>read_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"resources/multi_message_based/#msl.equipment_resources.multi_message_based.MultiMessageBased.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"resources/multi_message_based/#msl.equipment_resources.multi_message_based.MultiMessageBased.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"resources/multi_message_based/#msl.equipment_resources.multi_message_based.MultiMessageBased.write_termination","title":"write_termination  <code>property</code> <code>writable</code>","text":"<pre><code>write_termination: bytes | None\n</code></pre> <p>The termination character sequence that is appended to write messages.</p> <p>If you set the <code>write_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"resources/multi_message_based/#msl.equipment_resources.multi_message_based.MultiMessageBased.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the equipment.</p> Source code in <code>packages/resources/src/msl/equipment_resources/multi_message_based.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Disconnect from the equipment.\"\"\"\n    if self._connected:\n        self._interface.disconnect()\n        super().disconnect()\n        self._connected = False\n</code></pre>"},{"location":"resources/multi_message_based/#msl.equipment_resources.multi_message_based.MultiMessageBased.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"resources/multi_message_based/#msl.equipment_resources.multi_message_based.MultiMessageBased.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"resources/multi_message_based/#msl.equipment_resources.multi_message_based.MultiMessageBased.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"resources/aim-tti/mx_series/","title":"MX Series DC Power Supply","text":"<p>Connect to an MX100QP, MX100TP, MX103QP or MX180TP DC power supply from Aim and Thurlby Thandar Instruments.</p>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries","title":"MXSeries","text":"<pre><code>MXSeries(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MultiMessageBased</code></p> <p>Connect to an MX100QP, MX100TP, MX103QP or MX180TP DC power supply.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Connect to an MX100QP, MX100TP, MX103QP or MX180TP DC power supply from [Aim and Thurlby Thandar Instruments].\n\n    [Aim and Thurlby Thandar Instruments]: https://www.aimtti.com/\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"  # noqa: E501\n    super().__init__(equipment)\n    self.rstrip: bool = True\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.read_termination","title":"read_termination  <code>property</code> <code>writable</code>","text":"<pre><code>read_termination: bytes | None\n</code></pre> <p>The termination character sequence that is used for a read operation.</p> <p>Reading stops when the equipment stops sending data or the <code>read_termination</code> character sequence is detected. If you set the <code>read_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.write_termination","title":"write_termination  <code>property</code> <code>writable</code>","text":"<pre><code>write_termination: bytes | None\n</code></pre> <p>The termination character sequence that is appended to write messages.</p> <p>If you set the <code>write_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Send the clear command, <code>*CLS</code>.</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Send the clear command, `*CLS`.\"\"\"\n    _ = self.write(\"*CLS\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.decrement_current","title":"decrement_current","text":"<pre><code>decrement_current(channel: int) -&gt; None\n</code></pre> <p>Decrement the current limit by step size of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def decrement_current(self, channel: int) -&gt; None:\n    \"\"\"Decrement the current limit by step size of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n    \"\"\"\n    self._write_and_check(f\"DECI{channel}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.decrement_voltage","title":"decrement_voltage","text":"<pre><code>decrement_voltage(\n    channel: int, *, verify: bool = True\n) -&gt; None\n</code></pre> <p>Decrement the voltage by step size of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>verify</code> <code>bool</code> <p>Whether to verify that the output voltage has stabilized at the decremented voltage before returning to the calling program.</p> <code>True</code> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def decrement_voltage(self, channel: int, *, verify: bool = True) -&gt; None:\n    \"\"\"Decrement the voltage by step size of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        verify: Whether to verify that the output voltage has stabilized at\n            the decremented voltage before returning to the calling program.\n    \"\"\"\n    v = \"V\" if verify else \"\"\n    self._write_and_check(f\"DECV{channel}{v}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the equipment.</p> Source code in <code>packages/resources/src/msl/equipment_resources/multi_message_based.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Disconnect from the equipment.\"\"\"\n    if self._connected:\n        self._interface.disconnect()\n        super().disconnect()\n        self._connected = False\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.event_status_register","title":"event_status_register","text":"<pre><code>event_status_register() -&gt; int\n</code></pre> <p>Read and clear the standard event status register.</p> <p>Returns:</p> Type Description <code>int</code> <p>The event status register value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def event_status_register(self) -&gt; int:\n    \"\"\"Read and clear the standard event status register.\n\n    Returns:\n        The event status register value.\n    \"\"\"\n    return int(self.query(\"*ESR?\"))\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.get_current","title":"get_current","text":"<pre><code>get_current(channel: int) -&gt; float\n</code></pre> <p>Get the output current of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The output current (in Amps).</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def get_current(self, channel: int) -&gt; float:\n    \"\"\"Get the output current of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n\n    Returns:\n        The output current (in Amps).\n    \"\"\"\n    reply = self._query_and_check(f\"I{channel}O?\")\n    return float(reply[:-1])  # the reply ends with 'A'\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.get_current_limit","title":"get_current_limit","text":"<pre><code>get_current_limit(channel: int) -&gt; float\n</code></pre> <p>Get the current limit of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The current limit (in Amps).</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def get_current_limit(self, channel: int) -&gt; float:\n    \"\"\"Get the current limit of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n\n    Returns:\n        The current limit (in Amps).\n    \"\"\"\n    reply = self._query_and_check(f\"I{channel}?\")\n    return float(reply[2:])\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.get_current_step_size","title":"get_current_step_size","text":"<pre><code>get_current_step_size(channel: int) -&gt; float\n</code></pre> <p>Get the current limit step size of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The current limit step size (in Amps).</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def get_current_step_size(self, channel: int) -&gt; float:\n    \"\"\"Get the current limit step size of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n\n    Returns:\n        The current limit step size (in Amps).\n    \"\"\"\n    reply = self._query_and_check(f\"DELTAI{channel}?\")\n    return float(reply[7:])\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.get_over_current_protection","title":"get_over_current_protection","text":"<pre><code>get_over_current_protection(channel: int) -&gt; float | None\n</code></pre> <p>Get the over-current protection trip point of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>If the trip point is enabled then returns the trip point value in Amps.</p> <code>float | None</code> <p>Otherwise, returns <code>None</code> if the over-current protection is disabled.</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def get_over_current_protection(self, channel: int) -&gt; float | None:\n    \"\"\"Get the over-current protection trip point of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n\n    Returns:\n        If the trip point is enabled then returns the trip point value in Amps.\n        Otherwise, returns `None` if the over-current protection is disabled.\n    \"\"\"\n    reply = self._query_and_check(f\"OCP{channel}?\")\n    if reply.endswith(\"OFF\"):\n        return None\n    return float(reply[3:])\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.get_over_voltage_protection","title":"get_over_voltage_protection","text":"<pre><code>get_over_voltage_protection(channel: int) -&gt; float | None\n</code></pre> <p>Get the over-voltage protection trip point of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>If the trip point is enabled then returns the trip point value in Volts.</p> <code>float | None</code> <p>Otherwise, returns <code>None</code> if the over-voltage protection is disabled.</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def get_over_voltage_protection(self, channel: int) -&gt; float | None:\n    \"\"\"Get the over-voltage protection trip point of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n\n    Returns:\n        If the trip point is enabled then returns the trip point value in Volts.\n        Otherwise, returns `None` if the over-voltage protection is disabled.\n    \"\"\"\n    reply = self._query_and_check(f\"OVP{channel}?\")\n    if reply.endswith(\"OFF\"):\n        return None\n    return float(reply[3:])\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.get_voltage","title":"get_voltage","text":"<pre><code>get_voltage(channel: int) -&gt; float\n</code></pre> <p>Get the output voltage of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The output voltage (in Volts).</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def get_voltage(self, channel: int) -&gt; float:\n    \"\"\"Get the output voltage of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n\n    Returns:\n        The output voltage (in Volts).\n    \"\"\"\n    reply = self._query_and_check(f\"V{channel}O?\")\n    return float(reply[:-1])  # the reply ends with 'V'\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.get_voltage_range","title":"get_voltage_range","text":"<pre><code>get_voltage_range(channel: int) -&gt; int\n</code></pre> <p>Get the output voltage range index of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The output voltage range index. See the manual for more details.</p> <code>int</code> <p>For example, 2 \u2192 35V/3A.</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def get_voltage_range(self, channel: int) -&gt; int:\n    \"\"\"Get the output voltage range index of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n\n    Returns:\n        The output voltage range index. See the manual for more details.\n        For example, 2 &amp;#8594; 35V/3A.\n    \"\"\"\n    return int(self._query_and_check(f\"VRANGE{channel}?\"))\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.get_voltage_setpoint","title":"get_voltage_setpoint","text":"<pre><code>get_voltage_setpoint(channel: int) -&gt; float\n</code></pre> <p>Get the set-point voltage of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The set-point voltage (in Volts).</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def get_voltage_setpoint(self, channel: int) -&gt; float:\n    \"\"\"Get the set-point voltage of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n\n    Returns:\n        The set-point voltage (in Volts).\n    \"\"\"\n    reply = self._query_and_check(f\"V{channel}?\")\n    return float(reply[2:])\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.get_voltage_step_size","title":"get_voltage_step_size","text":"<pre><code>get_voltage_step_size(channel: int) -&gt; float\n</code></pre> <p>Get the voltage step size of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The voltage step size (in Volts).</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def get_voltage_step_size(self, channel: int) -&gt; float:\n    \"\"\"Get the voltage step size of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n\n    Returns:\n        The voltage step size (in Volts).\n    \"\"\"\n    reply = self._query_and_check(f\"DELTAV{channel}?\")\n    return float(reply[7:])\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.get_voltage_tracking_mode","title":"get_voltage_tracking_mode","text":"<pre><code>get_voltage_tracking_mode() -&gt; int\n</code></pre> <p>Get the voltage tracking mode of the unit.</p> <p>Returns:</p> Type Description <code>int</code> <p>The voltage tracking mode. See the manual for more details.</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def get_voltage_tracking_mode(self) -&gt; int:\n    \"\"\"Get the voltage tracking mode of the unit.\n\n    Returns:\n        The voltage tracking mode. See the manual for more details.\n    \"\"\"\n    return int(self._query_and_check(\"CONFIG?\"))\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.increment_current","title":"increment_current","text":"<pre><code>increment_current(channel: int) -&gt; None\n</code></pre> <p>Increment the current limit by the step size of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def increment_current(self, channel: int) -&gt; None:\n    \"\"\"Increment the current limit by the step size of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n    \"\"\"\n    self._write_and_check(f\"INCI{channel}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.increment_voltage","title":"increment_voltage","text":"<pre><code>increment_voltage(\n    channel: int, *, verify: bool = True\n) -&gt; None\n</code></pre> <p>Increment the voltage by the step size of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>verify</code> <code>bool</code> <p>Whether to verify that the output voltage has stabilized at the incremented voltage before returning to the calling program.</p> <code>True</code> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def increment_voltage(self, channel: int, *, verify: bool = True) -&gt; None:\n    \"\"\"Increment the voltage by the step size of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        verify: Whether to verify that the output voltage has stabilized at\n            the incremented voltage before returning to the calling program.\n    \"\"\"\n    v = \"V\" if verify else \"\"\n    self._write_and_check(f\"INCV{channel}{v}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.is_output_on","title":"is_output_on","text":"<pre><code>is_output_on(channel: int) -&gt; bool\n</code></pre> <p>Check if the output channel is on or off.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the output channel is on or off.</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def is_output_on(self, channel: int) -&gt; bool:\n    \"\"\"Check if the output channel is on or off.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n\n    Returns:\n        Whether the output channel is on or off.\n    \"\"\"\n    reply = self._query_and_check(f\"OP{channel}?\")\n    return reply == \"1\"\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.recall","title":"recall","text":"<pre><code>recall(channel: int, index: int) -&gt; None\n</code></pre> <p>Recall the settings of the output channel from the store.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>index</code> <code>int</code> <p>The store index number, can be 0-49.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def recall(self, channel: int, index: int) -&gt; None:\n    \"\"\"Recall the settings of the output channel from the store.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        index: The store index number, can be 0-49.\n    \"\"\"\n    self._write_and_check(f\"RCL{channel} {index}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.recall_all","title":"recall_all","text":"<pre><code>recall_all(index: int) -&gt; None\n</code></pre> <p>Recall the settings for all output channels from the store.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The store index number, can be 0-49.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def recall_all(self, index: int) -&gt; None:\n    \"\"\"Recall the settings for all output channels from the store.\n\n    Args:\n        index: The store index number, can be 0-49.\n    \"\"\"\n    self._write_and_check(f\"*SAV {index}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Send the reset command, <code>*RST</code>.</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Send the reset command, `*RST`.\"\"\"\n    _ = self.write(\"*RST\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.reset_trip","title":"reset_trip","text":"<pre><code>reset_trip() -&gt; None\n</code></pre> <p>Attempt to clear all trip conditions.</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def reset_trip(self) -&gt; None:\n    \"\"\"Attempt to clear all trip conditions.\"\"\"\n    _ = self.write(\"TRIPRST\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.save","title":"save","text":"<pre><code>save(channel: int, index: int) -&gt; None\n</code></pre> <p>Save the present settings of the output channel to the store.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>index</code> <code>int</code> <p>The store index number, can be 0-49.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def save(self, channel: int, index: int) -&gt; None:\n    \"\"\"Save the present settings of the output channel to the store.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        index: The store index number, can be 0-49.\n    \"\"\"\n    self._write_and_check(f\"SAV{channel} {index}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.save_all","title":"save_all","text":"<pre><code>save_all(index: int) -&gt; None\n</code></pre> <p>Save the settings of all output channels to the store.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The store index number, can be 0-49.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def save_all(self, index: int) -&gt; None:\n    \"\"\"Save the settings of all output channels to the store.\n\n    Args:\n        index: The store index number, can be 0-49.\n    \"\"\"\n    self._write_and_check(f\"*RCL {index}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.set_current_limit","title":"set_current_limit","text":"<pre><code>set_current_limit(channel: int, value: float) -&gt; None\n</code></pre> <p>Set the current limit of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>value</code> <code>float</code> <p>The current limit (in Amps).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def set_current_limit(self, channel: int, value: float) -&gt; None:\n    \"\"\"Set the current limit of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        value: The current limit (in Amps).\n    \"\"\"\n    self._write_and_check(f\"I{channel} {value}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.set_current_meter_averaging","title":"set_current_meter_averaging","text":"<pre><code>set_current_meter_averaging(\n    channel: int,\n    mode: Literal[\"ON\", \"OFF\", \"LOW\", \"MED\", \"HIGH\"],\n) -&gt; None\n</code></pre> <p>Set the current meter measurement averaging of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>mode</code> <code>Literal['ON', 'OFF', 'LOW', 'MED', 'HIGH']</code> <p>Averaging mode.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def set_current_meter_averaging(self, channel: int, mode: Literal[\"ON\", \"OFF\", \"LOW\", \"MED\", \"HIGH\"]) -&gt; None:\n    \"\"\"Set the current meter measurement averaging of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        mode: Averaging mode.\n    \"\"\"\n    self._write_and_check(f\"DAMPING{channel} {mode}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.set_current_step_size","title":"set_current_step_size","text":"<pre><code>set_current_step_size(channel: int, size: float) -&gt; None\n</code></pre> <p>Set the current limit step size of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>size</code> <code>float</code> <p>The current limit step size, in Amps.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def set_current_step_size(self, channel: int, size: float) -&gt; None:\n    \"\"\"Set the current limit step size of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        size: The current limit step size, in Amps.\n    \"\"\"\n    self._write_and_check(f\"DELTAI{channel} {size}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.set_multi_off_action","title":"set_multi_off_action","text":"<pre><code>set_multi_off_action(\n    channel: int, action: Literal[\"QUICK\", \"NEVER\", \"DELAY\"]\n) -&gt; None\n</code></pre> <p>Set the Multi-Off action of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>action</code> <code>Literal['QUICK', 'NEVER', 'DELAY']</code> <p>The Multi-Off action.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def set_multi_off_action(self, channel: int, action: Literal[\"QUICK\", \"NEVER\", \"DELAY\"]) -&gt; None:\n    \"\"\"Set the Multi-Off action of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        action: The Multi-Off action.\n    \"\"\"\n    self._write_and_check(f\"OFFACTION{channel} {action}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.set_multi_off_delay","title":"set_multi_off_delay","text":"<pre><code>set_multi_off_delay(channel: int, delay: int) -&gt; None\n</code></pre> <p>Set the Multi-Off delay, in milliseconds, of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>delay</code> <code>int</code> <p>The turn-off delay (in milliseconds).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def set_multi_off_delay(self, channel: int, delay: int) -&gt; None:\n    \"\"\"Set the Multi-Off delay, in milliseconds, of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        delay: The turn-off delay (in milliseconds).\n    \"\"\"\n    self._write_and_check(f\"OFFDELAY{channel} {delay}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.set_multi_on_action","title":"set_multi_on_action","text":"<pre><code>set_multi_on_action(\n    channel: int, action: Literal[\"QUICK\", \"NEVER\", \"DELAY\"]\n) -&gt; None\n</code></pre> <p>Set the Multi-On action of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>action</code> <code>Literal['QUICK', 'NEVER', 'DELAY']</code> <p>The Multi-On action.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def set_multi_on_action(self, channel: int, action: Literal[\"QUICK\", \"NEVER\", \"DELAY\"]) -&gt; None:\n    \"\"\"Set the Multi-On action of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        action: The Multi-On action.\n    \"\"\"\n    self._write_and_check(f\"ONACTION{channel} {action}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.set_multi_on_delay","title":"set_multi_on_delay","text":"<pre><code>set_multi_on_delay(channel: int, delay: int) -&gt; None\n</code></pre> <p>Set the Multi-On delay, in milliseconds, of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>delay</code> <code>int</code> <p>The turn-on delay (in milliseconds).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def set_multi_on_delay(self, channel: int, delay: int) -&gt; None:\n    \"\"\"Set the Multi-On delay, in milliseconds, of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        delay: The turn-on delay (in milliseconds).\n    \"\"\"\n    self._write_and_check(f\"ONDELAY{channel} {delay}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.set_over_current_protection","title":"set_over_current_protection","text":"<pre><code>set_over_current_protection(\n    channel: int,\n    *,\n    enable: bool,\n    value: float | None = None\n) -&gt; None\n</code></pre> <p>Set the over-current protection trip point of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>enable</code> <code>bool</code> <p>Whether to enable or disable the over-current protection trip point.</p> required <code>value</code> <code>float | None</code> <p>If the trip point is enabled then you must specify a value (in Amps).</p> <code>None</code> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def set_over_current_protection(self, channel: int, *, enable: bool, value: float | None = None) -&gt; None:\n    \"\"\"Set the over-current protection trip point of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        enable: Whether to enable or disable the over-current protection trip point.\n        value: If the trip point is enabled then you must specify a value (in Amps).\n    \"\"\"\n    if enable:\n        if value is None:\n            msg = \"Must specify the trip point value if the trip point is enabled\"\n            raise ValueError(msg)\n        command = f\"OCP{channel} ON;OCP{channel} {value}\"\n    else:\n        command = f\"OCP{channel} OFF\"\n    self._write_and_check(command)\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.set_over_voltage_protection","title":"set_over_voltage_protection","text":"<pre><code>set_over_voltage_protection(\n    channel: int,\n    *,\n    enable: bool,\n    value: float | None = None\n) -&gt; None\n</code></pre> <p>Set the over-voltage protection trip point of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>enable</code> <code>bool</code> <p>Whether to enable or disable the over-voltage protection trip point.</p> required <code>value</code> <code>float | None</code> <p>If the trip point is enabled then you must specify a value (in Volts).</p> <code>None</code> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def set_over_voltage_protection(self, channel: int, *, enable: bool, value: float | None = None) -&gt; None:\n    \"\"\"Set the over-voltage protection trip point of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        enable: Whether to enable or disable the over-voltage protection trip point.\n        value: If the trip point is enabled then you must specify a value (in Volts).\n    \"\"\"\n    if enable:\n        if value is None:\n            msg = \"Must specify the trip point value if the trip point is enabled\"\n            raise ValueError(msg)\n        command = f\"OVP{channel} ON;OVP{channel} {value}\"\n    else:\n        command = f\"OVP{channel} OFF\"\n    self._write_and_check(command)\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.set_voltage","title":"set_voltage","text":"<pre><code>set_voltage(\n    channel: int, value: float, *, verify: bool = True\n) -&gt; None\n</code></pre> <p>Set the output voltage of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>value</code> <code>float</code> <p>The value (in Volts).</p> required <code>verify</code> <code>bool</code> <p>Whether to verify that the output voltage has stabilized at <code>value</code> before returning to the calling program.</p> <code>True</code> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def set_voltage(self, channel: int, value: float, *, verify: bool = True) -&gt; None:\n    \"\"\"Set the output voltage of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        value: The value (in Volts).\n        verify: Whether to verify that the output voltage has stabilized at `value`\n            before returning to the calling program.\n    \"\"\"\n    command = f\"V{channel}V {value}\" if verify else f\"V{channel} {value}\"\n    self._write_and_check(command)\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.set_voltage_range","title":"set_voltage_range","text":"<pre><code>set_voltage_range(channel: int, index: int) -&gt; None\n</code></pre> <p>Set the output voltage range of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>index</code> <code>int</code> <p>The output voltage range index. See the manual for more details. For example, 2 \u2192 35V/3A.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def set_voltage_range(self, channel: int, index: int) -&gt; None:\n    \"\"\"Set the output voltage range of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        index: The output voltage range index. See the manual for more details.\n            For example, 2 &amp;#8594; 35V/3A.\n    \"\"\"\n    self._write_and_check(f\"VRANGE{channel} {index}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.set_voltage_step_size","title":"set_voltage_step_size","text":"<pre><code>set_voltage_step_size(channel: int, size: float) -&gt; None\n</code></pre> <p>Set the voltage step size of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>size</code> <code>float</code> <p>The voltage step size (in Volts).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def set_voltage_step_size(self, channel: int, size: float) -&gt; None:\n    \"\"\"Set the voltage step size of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        size: The voltage step size (in Volts).\n    \"\"\"\n    self._write_and_check(f\"DELTAV{channel} {size}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.set_voltage_tracking_mode","title":"set_voltage_tracking_mode","text":"<pre><code>set_voltage_tracking_mode(mode: int) -&gt; None\n</code></pre> <p>Set the voltage tracking mode of the unit.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>int</code> <p>The voltage tracking mode. See the manual for more details.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def set_voltage_tracking_mode(self, mode: int) -&gt; None:\n    \"\"\"Set the voltage tracking mode of the unit.\n\n    Args:\n        mode: The voltage tracking mode. See the manual for more details.\n    \"\"\"\n    self._write_and_check(f\"CONFIG {mode}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.turn_off","title":"turn_off","text":"<pre><code>turn_off(channel: int) -&gt; None\n</code></pre> <p>Turn the output channel off.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def turn_off(self, channel: int) -&gt; None:\n    \"\"\"Turn the output channel off.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n    \"\"\"\n    self._write_and_check(f\"OP{channel} 0\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.turn_off_multi","title":"turn_off_multi","text":"<pre><code>turn_off_multi(\n    options: dict[int, bool | int] | None = None,\n) -&gt; None\n</code></pre> <p>Turn multiple output channels off (the Multi-Off feature).</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>dict[int, bool | int] | None</code> <p>Set the Multi-Off option for each output channel before setting Multi-Off. If not specified then uses the pre-programmed options. If a particular output channel is not included in <code>options</code> then uses the pre-programmed option for that channel. The keys are the output channel number and the value can be <code>False</code> (set the channel to <code>NEVER</code>, see the manual for more details), <code>True</code> (set the channel to <code>QUICK</code>, see the manual for more details) or a delay in milliseconds (as an int). Examples,</p> <ul> <li><code>{1: False}</code> \u2192 channel 1 does not turn off</li> <li><code>{2: 100}</code> \u2192 channel 2 has a 100-ms delay</li> <li><code>{1: 100, 3: True}</code> \u2192 channel 1 has a 100-ms delay and channel 3 turns off immediately</li> <li><code>{1: 100, 2: 200, 3: 300}</code> \u2192 channel 1 has a 100-ms delay, channel 2 has a 200-ms delay     and channel 3 has a 300-ms delay</li> </ul> <code>None</code> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def turn_off_multi(self, options: dict[int, bool | int] | None = None) -&gt; None:\n    \"\"\"Turn multiple output channels off (the Multi-Off feature).\n\n    Args:\n        options: Set the Multi-Off option for each output channel before setting Multi-Off.\n            If not specified then uses the pre-programmed options. If a particular output\n            channel is not included in `options` then uses the pre-programmed option for\n            that channel. The keys are the output channel number and the value can be\n            `False` (set the channel to `NEVER`, see the manual for more details),\n            `True` (set the channel to `QUICK`, see the manual for more details) or a\n            delay in milliseconds (as an [int][]). Examples,\n\n            * `{1: False}` &amp;#8594; channel 1 does not turn off\n            * `{2: 100}` &amp;#8594; channel 2 has a 100-ms delay\n            * `{1: 100, 3: True}` &amp;#8594; channel 1 has a 100-ms delay and channel 3 turns off immediately\n            * `{1: 100, 2: 200, 3: 300}` &amp;#8594; channel 1 has a 100-ms delay, channel 2 has a 200-ms delay\n                and channel 3 has a 300-ms delay\n    \"\"\"\n    if options:\n        for channel, value in options.items():\n            if isinstance(value, bool):\n                self.set_multi_off_action(channel, \"QUICK\" if value else \"NEVER\")\n            else:\n                self.set_multi_off_action(channel, \"DELAY\")\n                self.set_multi_off_delay(channel, value)\n                time.sleep(0.1)  # otherwise the power supply may not set the delay properly\n    self._write_and_check(\"OPALL 0\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.turn_on","title":"turn_on","text":"<pre><code>turn_on(channel: int) -&gt; None\n</code></pre> <p>Turn the output channel on.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def turn_on(self, channel: int) -&gt; None:\n    \"\"\"Turn the output channel on.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n    \"\"\"\n    self._write_and_check(f\"OP{channel} 1\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.turn_on_multi","title":"turn_on_multi","text":"<pre><code>turn_on_multi(\n    options: dict[int, bool | int] | None = None,\n) -&gt; None\n</code></pre> <p>Turn multiple output channels on (the Multi-On feature).</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>dict[int, bool | int] | None</code> <p>Set the Multi-On option for each output channel before setting Multi-On. If not specified then uses the pre-programmed options. If a particular output channel is not included in <code>options</code> then uses the pre-programmed option for that channel. The keys are the output channel number and the value can be <code>False</code> (set the channel to <code>NEVER</code>, see the manual for more details), <code>True</code> (set the channel to <code>QUICK</code>, see the manual for more details) or a delay in milliseconds (as an int). Examples,</p> <ul> <li><code>{1: False}</code> \u2192 channel 1 does not turn on</li> <li><code>{2: 100}</code> \u2192 channel 2 has a 100-ms delay</li> <li><code>{1: 100, 3: True}</code> \u2192` channel 1 has a 100-ms delay and channel 3 turns on immediately</li> <li><code>{1: 100, 2: 200, 3: 300}</code> \u2192 channel 1 has a 100-ms delay, channel 2 has a 200-ms delay     and channel 3 has a 300-ms delay</li> </ul> <code>None</code> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def turn_on_multi(self, options: dict[int, bool | int] | None = None) -&gt; None:\n    \"\"\"Turn multiple output channels on (the Multi-On feature).\n\n    Args:\n        options: Set the Multi-On option for each output channel before setting Multi-On.\n            If not specified then uses the pre-programmed options. If a particular output\n            channel is not included in `options` then uses the pre-programmed option for\n            that channel. The keys are the output channel number and the value can be\n            `False` (set the channel to `NEVER`, see the manual for more details),\n            `True` (set the channel to `QUICK`, see the manual for more details) or a\n            delay in milliseconds (as an [int][]). Examples,\n\n            * `{1: False}` &amp;#8594; channel 1 does not turn on\n            * `{2: 100}` &amp;#8594; channel 2 has a 100-ms delay\n            * `{1: 100, 3: True}` &amp;#8594;` channel 1 has a 100-ms delay and channel 3 turns on immediately\n            * `{1: 100, 2: 200, 3: 300}` &amp;#8594; channel 1 has a 100-ms delay, channel 2 has a 200-ms delay\n                and channel 3 has a 300-ms delay\n    \"\"\"\n    if options:\n        for channel, value in options.items():\n            if isinstance(value, bool):\n                self.set_multi_on_action(channel, \"QUICK\" if value else \"NEVER\")\n            else:\n                self.set_multi_on_action(channel, \"DELAY\")\n                self.set_multi_on_delay(channel, value)\n                time.sleep(0.1)  # otherwise the power supply may not set the delay properly\n    self._write_and_check(\"OPALL 1\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"resources/avantes/avaspec/","title":"AvaSpec SDK","text":"<p>Wrapper around the <code>avaspec</code> SDK from Avantes.</p> <p>The wrapper was written using v9.7.0.0 of the SDK. The <code>avaspec</code> SDK may require a Visual C++ Redistributable Package to be installed (on Windows).</p> <p>The main class is AvaSpec and the Enums and Structs are available once the <code>avantes</code> module is imported, for example,</p> <pre><code>from msl.equipment.resources import avantes\n\ncfg = avantes.MeasConfigType()\ncfg.m_IntegrationTime = 5  # in milliseconds\ncfg.m_NrAverages = 1  # number of averages\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec","title":"AvaSpec","text":"<pre><code>AvaSpec(equipment: Equipment)\n</code></pre> <p>               Bases: <code>SDK</code></p> <p>Wrapper around the <code>avaspec</code> SDK from Avantes.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for the AvaSpec wrapper.</p> <p>Connection Properties:</p> Name Type Description <code>port_id</code> <code>int</code> <p>One of <code>-1</code> (Ethernet+USB), <code>0</code> (USB) or <code>256</code> (Ethernet). Default: <code>-1</code></p> <code>activate</code> <code>bool</code> <p>Whether to automatically activate the connection. Default: <code>True</code></p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Wrapper around the `avaspec` SDK from Avantes.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for the AvaSpec wrapper.\n\n    Attributes: Connection Properties:\n        port_id (int): One of `-1` (Ethernet+USB), `0` (USB) or `256` (Ethernet). _Default: `-1`_\n        activate (bool): Whether to automatically activate the connection. _Default: `True`_\n    \"\"\"\n    self._handle: int | None = None\n    super().__init__(equipment, libtype=\"windll\" if IS_WINDOWS else \"cdll\")\n\n    functions: dict[\n        str, tuple[type[c_int32 | c_bool], Callable[..., int | None], list[tuple[str, type[_CDataType]]]]\n    ] = {\n        \"AVS_Init\": (c_int32, self._err_check, [(\"a_Port\", c_int16)]),\n        \"AVS_Done\": (c_int32, self._err_check, []),\n        \"AVS_GetNrOfDevices\": (c_int32, self._log_errcheck, []),\n        \"AVS_UpdateUSBDevices\": (c_int32, self._log_errcheck, []),\n        \"AVS_UpdateETHDevices\": (\n            c_int32,\n            self._err_check,\n            [\n                (\"a_ListSize\", c_uint32),\n                (\"a_pRequiredSize\", POINTER(c_uint32)),\n                (\"a_pList\", POINTER(BroadcastAnswerType)),\n            ],\n        ),\n        \"AVS_GetList\": (\n            c_int32,\n            self._err_check,\n            [\n                (\"a_ListSize\", c_uint32),\n                (\"a_pRequiredSize\", POINTER(c_uint32)),\n                (\"a_pList\", POINTER(AvsIdentityType)),\n            ],\n        ),\n        \"AVS_Activate\": (c_int32, self._err_check, [(\"a_pDeviceId\", POINTER(AvsIdentityType))]),\n        \"AVS_ActivateConn\": (c_int32, self._err_check, [(\"a_pDeviceId\", POINTER(AvsIdentityType))]),\n        \"AVS_ActivateConnCb\": (c_int32, self._err_check, [(\"a_pDeviceId\", POINTER(AvsIdentityType))]),\n        \"AVS_Deactivate\": (c_bool, self._check_bool, [(\"a_hDevice\", c_int32)]),\n        \"AVS_GetHandleFromSerial\": (c_int32, self._err_check, [(\"a_pSerial\", c_char_p)]),\n        \"AVS_GetStatusBySerial\": (\n            c_int32,\n            self._err_check,\n            [(\"a_pSerial\", c_char_p), (\"a_status\", POINTER(c_int32))],\n        ),\n        \"AVS_Register\": (c_bool, self._check_bool, [(\"a_Hwnd\", c_void_p)]),\n        \"AVS_Measure\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_hWnd\", c_void_p), (\"a_Nmsr\", c_int16)],\n        ),\n        \"AVS_MeasureCallback\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"__Done\", MeasureCallback), (\"a_Nmsr\", c_int16)],\n        ),\n        \"AVS_PrepareMeasure\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_pMeasConfig\", POINTER(MeasConfigType))],\n        ),\n        \"AVS_StopMeasure\": (c_int32, self._err_check, [(\"a_hDevice\", c_int32)]),\n        \"AVS_PollScan\": (c_int32, self._err_check, [(\"a_hDevice\", c_int32)]),\n        \"AVS_GetScopeData\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_pTimeLabel\", POINTER(c_uint32)), (\"a_pSpectrum\", POINTER(c_double))],\n        ),\n        \"AVS_GetSaturatedPixels\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_pSaturated\", POINTER(c_ubyte))],\n        ),\n        \"AVS_GetLambda\": (c_int32, self._err_check, [(\"a_hDevice\", c_int32), (\"a_pWaveLength\", POINTER(c_double))]),\n        \"AVS_GetNumPixels\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_pNumPixels\", POINTER(c_uint16))],\n        ),\n        \"AVS_GetParameter\": (\n            c_int32,\n            self._err_check,\n            [\n                (\"a_hDevice\", c_int32),\n                (\"a_Size\", c_uint32),\n                (\"a_pRequiredSize\", POINTER(c_uint32)),\n                (\"a_pDeviceParm\", POINTER(DeviceConfigType)),\n            ],\n        ),\n        \"AVS_SetParameter\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_pDeviceParm\", POINTER(DeviceConfigType))],\n        ),\n        \"AVS_GetVersionInfo\": (\n            c_int32,\n            self._err_check,\n            [\n                (\"a_hDevice\", c_int32),\n                (\"a_pFPGAVersion\", c_char_p),\n                (\"a_pFirmwareVersion\", c_char_p),\n                (\"a_pDLLVersion\", c_char_p),\n            ],\n        ),\n        \"AVS_GetDLLVersion\": (c_int32, self._err_check, [(\"a_pVersionString\", c_char_p)]),\n        \"AVS_SetSyncMode\": (c_int32, self._err_check, [(\"a_hDevice\", c_int32), (\"a_Enable\", c_ubyte)]),\n        \"AVS_SetPrescanMode\": (c_int32, self._err_check, [(\"a_hDevice\", c_int32), (\"a_Prescan\", c_bool)]),\n        \"AVS_UseHighResAdc\": (c_int32, self._err_check, [(\"a_hDevice\", c_int32), (\"a_Enable\", c_bool)]),\n        \"AVS_GetAnalogIn\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_AnalogInId\", c_ubyte), (\"a_pAnalogIn\", POINTER(c_float))],\n        ),\n        \"AVS_GetDigIn\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_DigInId\", c_ubyte), (\"a_pDigIn\", POINTER(c_ubyte))],\n        ),\n        \"AVS_SetAnalogOut\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_PortId\", c_ubyte), (\"a_Value\", c_float)],\n        ),\n        \"AVS_SetDigOut\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_PortId\", c_ubyte), (\"a_Status\", c_ubyte)],\n        ),\n        \"AVS_SetPwmOut\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_PortId\", c_ubyte), (\"a_Freq\", c_ulong), (\"a_Duty\", c_ubyte)],\n        ),\n        \"AVS_GetDarkPixelData\": (\n            c_int32,\n            self._check_bool,\n            [(\"a_hDevice\", c_int32), (\"a_pDarkData\", POINTER(c_double))],\n        ),\n        \"AVS_GetComPortName\": (\n            c_int32,\n            self._check_bool,\n            [(\"a_pDeviceId\", POINTER(AvsIdentityType)), (\"a_pIp\", c_char_p), (\"a_size\", POINTER(c_int32))],\n        ),\n        \"AVS_GetComType\": (\n            c_int32,\n            self._err_check,\n            [(\"a_pDeviceId\", POINTER(AvsIdentityType)), (\"a_type\", POINTER(c_int32))],\n        ),\n        \"AVS_SetSensitivityMode\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_SensitivityMode\", c_uint32)],\n        ),\n        \"AVS_GetIpConfig\": (\n            c_int32,\n            self._check_bool,\n            [(\"a_hDevice\", c_int32), (\"a_Data\", POINTER(EthernetSettingsType))],\n        ),\n        \"AVS_SuppressStrayLight\": (\n            c_int32,\n            self._err_check,\n            [\n                (\"a_hDevice\", c_int32),\n                (\"a_Multifactor\", c_float),\n                (\"a_pSrcSpectrum\", POINTER(c_double)),\n                (\"a_pDestSpectrum\", POINTER(c_double)),\n            ],\n        ),\n        \"AVS_Heartbeat\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_pHbReq\", POINTER(c_uint32)), (\"a_pHbResp\", POINTER(HeartbeatRespType))],\n        ),\n        \"AVS_ResetDevice\": (c_int32, self._err_check, [(\"a_hDevice\", c_int32)]),\n        \"AVS_GetOemParameter\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_pOemData\", POINTER(OemDataType))],\n        ),\n        \"AVS_SetOemParameter\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_pOemData\", POINTER(OemDataType))],\n        ),\n    }\n\n    for key, value in functions.items():\n        try:\n            attr = getattr(self.sdk, key)\n        except AttributeError as e:  # noqa: PERF203\n            logger.debug(\"%s: %s\", self.__class__.__name__, e)\n        else:\n            attr.restype, attr.errcheck = value[:2]\n            attr.argtypes = [typ for _, typ in value[2]]\n\n    assert equipment.connection  # noqa: S101\n    props = equipment.connection.properties\n    _ = self.init(props.get(\"port_id\", -1))\n    if props.get(\"activate\", True):\n        self.activate()\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>str \u2014 The path to the library file.</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.sdk","title":"sdk  <code>property</code>","text":"<pre><code>sdk: Any\n</code></pre> <p>lib \u2014 The reference to the SDK object.</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.activate","title":"activate","text":"<pre><code>activate() -&gt; None\n</code></pre> <p>Activates the spectrometer for communication.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def activate(self) -&gt; None:\n    \"\"\"Activates the spectrometer for communication.\"\"\"\n    out = AvaSpec.find(path=self.path)\n    if not out:\n        raise MSLConnectionError(self, \"Cannot activate. No devices found.\")\n\n    for item in out:\n        if item.SerialNumber.decode() == self.equipment.serial:\n            self._handle = int(self.sdk.AVS_Activate(item))\n            if self._handle == INVALID_AVS_HANDLE_VALUE:\n                raise MSLConnectionError(self, \"Invalid handle\")\n            _handles.append(self._handle)\n            return\n\n    msg = f\"Did not find the Avantes serial number {self.equipment.serial!r} in the list of devices.\"\n    raise MSLConnectionError(self, msg)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.deactivate","title":"deactivate","text":"<pre><code>deactivate() -&gt; None\n</code></pre> <p>Closes communication with the spectrometer.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def deactivate(self) -&gt; None:\n    \"\"\"Closes communication with the spectrometer.\"\"\"\n    if self._handle in _handles:\n        self.sdk.AVS_Deactivate(self._handle)\n        _handles.remove(self._handle)\n        self._handle = None\n        super().disconnect()\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Calls deactivate.</p> <p>Also calls done (if there are no additional connections open to other spectrometers).</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Calls [deactivate][msl.equipment_resources.avantes.avaspec.AvaSpec.deactivate].\n\n    Also calls [done][msl.equipment_resources.avantes.avaspec.AvaSpec.done] (if there\n    are no additional connections open to other spectrometers).\n    \"\"\"\n    self.deactivate()\n    if not _handles:\n        self.done()\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.done","title":"done","text":"<pre><code>done() -&gt; None\n</code></pre> <p>Closes communication with all spectrometers and releases internal storage.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def done(self) -&gt; None:\n    \"\"\"Closes communication with all spectrometers and releases internal storage.\"\"\"\n    if hasattr(self, \"_sdk\") and self._sdk is not None:\n        self.sdk.AVS_Done()\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.find","title":"find  <code>staticmethod</code>","text":"<pre><code>find(\n    path: str = \"avaspecx64\",\n    port_id: int = -1,\n    nmax: int = 16,\n) -&gt; list[AvsIdentityType]\n</code></pre> <p>Returns device information for each spectrometer that is connected.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the AvaSpec SDK.</p> <code>'avaspecx64'</code> <code>port_id</code> <code>int</code> <p>ID of port to be used. One of:</p> <ul> <li><code>-1</code>: Use both Ethernet (AS7010) and USB ports</li> <li><code>0</code>: Use USB port</li> <li><code>1..255</code>: Not supported in v9.7 of the SDK</li> <li><code>256</code>: Use Ethernet port (AS7010)</li> </ul> <code>-1</code> <code>nmax</code> <code>int</code> <p>The maximum number of devices that can be in the list.</p> <code>16</code> <p>Returns:</p> Type Description <code>list[AvsIdentityType]</code> <p>The information about the devices.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>@staticmethod\ndef find(path: str = \"avaspecx64\", port_id: int = -1, nmax: int = 16) -&gt; list[AvsIdentityType]:\n    \"\"\"Returns device information for each spectrometer that is connected.\n\n    Args:\n        path: The path to the AvaSpec SDK.\n        port_id: ID of port to be used. One of:\n\n            * `-1`: Use both Ethernet (AS7010) and USB ports\n            * `0`: Use USB port\n            * `1..255`: Not supported in v9.7 of the SDK\n            * `256`: Use Ethernet port (AS7010)\n\n        nmax: The maximum number of devices that can be in the list.\n\n    Returns:\n        The information about the devices.\n    \"\"\"\n    lib = LoadLibrary(path, libtype=\"windll\" if IS_WINDOWS else \"cdll\").lib\n\n    ret = lib.AVS_Init(port_id)\n    if ret == 0:\n        return []\n\n    size = nmax * sizeof(AvsIdentityType)\n    required_size = c_uint32()\n    types = (AvsIdentityType * nmax)()\n\n    lib.AVS_GetList.argtypes = [c_uint32, POINTER(c_uint32), POINTER(AvsIdentityType)]\n    n = lib.AVS_GetList(size, required_size, types)\n    if n &gt;= 0:\n        return [types[i] for i in range(n)]\n\n    error_name, msg = ERROR_CODES.get(n, (\"UNKNOWN_ERROR\", f\"Unknown error [code={n}]\"))\n    msg = f\"{error_name}: {msg}\"\n    raise RuntimeError(msg)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_analog_in","title":"get_analog_in","text":"<pre><code>get_analog_in(analog_id: int) -&gt; float\n</code></pre> <p>Get the status of the specified analog input.</p> <p>Parameters:</p> Name Type Description Default <code>analog_id</code> <code>int</code> <p>The identifier of the analog input to get.</p> <ul> <li> <p>AS5216:</p> <ul> <li>0 = thermistor on optical bench (NIR 2.0 / NIR2.2 / NIR 2.5 / TEC)</li> <li>1 = 1V2</li> <li>2 = 5VIO</li> <li>3 = 5VUSB</li> <li>4 = AI2 = pin 18 at 26-pin connector</li> <li>5 = AI1 = pin 9 at 26-pin connector</li> <li>6 = NTC1 onboard thermistor</li> <li>7 = Not used</li> </ul> </li> <li> <p>Mini:</p> <ul> <li>0 = NTC1 onboard thermistor</li> <li>1 = Not used</li> <li>2 = Not used</li> <li>3 = Not used</li> <li>4 = AI2 = pin 13 on micro HDMI = pin 11 on HDMI Terminal</li> <li>5 = AI1 = pin 16 on micro HDMI = pin 17 on HDMI Terminal</li> <li>6 = Not used</li> <li>7 = Not used</li> </ul> </li> <li> <p>AS7010:</p> <ul> <li>0 = thermistor on optical bench (NIR 2.0 / NIR2.2 / NIR 2.5 / TEC)</li> <li>1 = Not used</li> <li>2 = Not used</li> <li>3 = Not used</li> <li>4 = AI2 = pin 18 at 26-pin connector</li> <li>5 = AI1 = pin 9 at 26-pin connector</li> <li>6 = digital temperature sensor, returns degrees Celsius, not Volts</li> <li>7 = Not used</li> </ul> </li> </ul> required <p>Returns:</p> Type Description <code>float</code> <p>The analog input value [Volts or degrees Celsius].</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_analog_in(self, analog_id: int) -&gt; float:\n    \"\"\"Get the status of the specified analog input.\n\n    Args:\n        analog_id: The identifier of the analog input to get.\n\n            * AS5216:\n\n                * 0 = thermistor on optical bench (NIR 2.0 / NIR2.2 / NIR 2.5 / TEC)\n                * 1 = 1V2\n                * 2 = 5VIO\n                * 3 = 5VUSB\n                * 4 = AI2 = pin 18 at 26-pin connector\n                * 5 = AI1 = pin 9 at 26-pin connector\n                * 6 = NTC1 onboard thermistor\n                * 7 = Not used\n\n            * Mini:\n\n                * 0 = NTC1 onboard thermistor\n                * 1 = Not used\n                * 2 = Not used\n                * 3 = Not used\n                * 4 = AI2 = pin 13 on micro HDMI = pin 11 on HDMI Terminal\n                * 5 = AI1 = pin 16 on micro HDMI = pin 17 on HDMI Terminal\n                * 6 = Not used\n                * 7 = Not used\n\n            * AS7010:\n\n                * 0 = thermistor on optical bench (NIR 2.0 / NIR2.2 / NIR 2.5 / TEC)\n                * 1 = Not used\n                * 2 = Not used\n                * 3 = Not used\n                * 4 = AI2 = pin 18 at 26-pin connector\n                * 5 = AI1 = pin 9 at 26-pin connector\n                * 6 = digital temperature sensor, returns degrees Celsius, not Volts\n                * 7 = Not used\n\n    Returns:\n        The analog input value [Volts or degrees Celsius].\n    \"\"\"\n    ain = c_float()\n    self.sdk.AVS_GetAnalogIn(self._handle, analog_id, ain)\n    return ain.value\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_com_port_name","title":"get_com_port_name","text":"<pre><code>get_com_port_name() -&gt; str\n</code></pre> <p>Get the IP address of the device.</p> <p>Returns:</p> Type Description <code>str</code> <p>The IP address of the device.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_com_port_name(self) -&gt; str:\n    \"\"\"Get the IP address of the device.\n\n    Returns:\n        The IP address of the device.\n    \"\"\"\n    device_id = AvsIdentityType()\n    device_id.SerialNumber = self.equipment.serial.encode()\n    name = create_string_buffer(255)\n    self.sdk.AVS_GetComPortName(device_id, name, len(name))\n    return name.value.decode()\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_com_type","title":"get_com_type","text":"<pre><code>get_com_type() -&gt; int\n</code></pre> <p>Get the communication protocol.</p> <p>Returns:</p> Type Description <code>int</code> <p>The communication type as defined below: * 0 = RS232 * 1 = USB5216 * 2 = USBMINI * 3 = USB7010 * 4 = ETH7010 * -1 = UNKNOWN</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_com_type(self) -&gt; int:\n    \"\"\"Get the communication protocol.\n\n    Returns:\n        The communication type as defined below:\n            * 0 = RS232\n            * 1 = USB5216\n            * 2 = USBMINI\n            * 3 = USB7010\n            * 4 = ETH7010\n            * -1 = UNKNOWN\n    \"\"\"\n    device_id = AvsIdentityType()\n    device_id.SerialNumber = self.equipment.serial.encode()\n    typ = c_int32(-1)\n    self.sdk.AVS_GetComType(device_id, typ)\n    return typ.value\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_dark_pixel_data","title":"get_dark_pixel_data","text":"<pre><code>get_dark_pixel_data() -&gt; NDArray[double]\n</code></pre> <p>Get the optically black pixel values of the last performed measurement.</p> <p>You must call get_data before you call this method.</p> <p>Returns:</p> Type Description <code>NDArray[double]</code> <p>The dark pixels.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_dark_pixel_data(self) -&gt; NDArray[np.double]:\n    \"\"\"Get the optically black pixel values of the last performed measurement.\n\n    You must call [get_data][msl.equipment_resources.avantes.avaspec.AvaSpec.get_data] before you call this method.\n\n    Returns:\n        The dark pixels.\n    \"\"\"\n    # from the docs the maximum size is size=18 for the AvaSpec-2048-USB2 and AvaSpec-2048L-USB2\n    values = np.zeros(32, dtype=np.double)  # make it bigger than 18\n    self.sdk.AVS_GetDarkPixelData(self._handle, values.ctypes.data_as(POINTER(c_double)))\n    return values[values &gt; 0]\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_data","title":"get_data","text":"<pre><code>get_data() -&gt; tuple[int, NDArray[double]]\n</code></pre> <p>Returns the timestamp and the spectral data of the last measurement.</p> <p>Returns:</p> Type Description <code>tuple[int, NDArray[double]]</code> <p>The timestamp and the spectral data.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_data(self) -&gt; tuple[int, NDArray[np.double]]:\n    \"\"\"Returns the timestamp and the spectral data of the last measurement.\n\n    Returns:\n        The timestamp and the spectral data.\n    \"\"\"\n    ticks = c_uint32()\n    values = np.ones(MAX_NR_PIXELS, dtype=np.double) * -1.0\n    self.sdk.AVS_GetScopeData(self._handle, ticks, values.ctypes.data_as(POINTER(c_double)))\n    return ticks.value, values[values &gt; -1.0]\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_digital_in","title":"get_digital_in","text":"<pre><code>get_digital_in(digital_id: int) -&gt; int\n</code></pre> <p>Get the status of the specified digital input.</p> <p>Parameters:</p> Name Type Description Default <code>digital_id</code> <code>int</code> <p>The identifier of the digital input to get.</p> <ul> <li> <p>AS5216:</p> <ul> <li><code>0</code>: DI1 = Pin 24 at 26-pin connector</li> <li><code>1</code>: DI2 = Pin 7 at 26-pin connector</li> <li><code>2</code>: DI3 = Pin 16 at 26-pin connector</li> </ul> </li> <li> <p>Mini:</p> <ul> <li><code>0</code>: DI1 = Pin 7 on Micro HDMI = Pin 5 on HDMI terminal</li> <li><code>1</code>: DI2 = Pin 5 on Micro HDMI = Pin 3 on HDMI Terminal</li> <li><code>2</code>: DI3 = Pin 3 on Micro HDMI = Pin 1 on HDMI Terminal</li> <li><code>3</code>: DI4 = Pin 1 on Micro HDMI = Pin 19 on HDMI Terminal</li> <li><code>4</code>: DI5 = Pin 4 on Micro HDMI = Pin 2 on HDMI Terminal</li> <li><code>5</code>: DI6 = Pin 2 on Micro HDMI = Pin 14 on HDMI Terminal</li> </ul> </li> <li> <p>AS7010:</p> <ul> <li><code>0</code>: DI1 = Pin 24 at 26-pin connector</li> <li><code>1</code>: DI2 = Pin 7 at 26-pin connector</li> <li><code>2</code>: DI3 = Pin 16 at 26-pin</li> </ul> </li> </ul> required <p>Returns:</p> Type Description <code>int</code> <p>The digital input value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_digital_in(self, digital_id: int) -&gt; int:\n    \"\"\"Get the status of the specified digital input.\n\n    Args:\n        digital_id: The identifier of the digital input to get.\n\n            * AS5216:\n\n                * `0`: DI1 = Pin 24 at 26-pin connector\n                * `1`: DI2 = Pin 7 at 26-pin connector\n                * `2`: DI3 = Pin 16 at 26-pin connector\n\n            * Mini:\n\n                * `0`: DI1 = Pin 7 on Micro HDMI = Pin 5 on HDMI terminal\n                * `1`: DI2 = Pin 5 on Micro HDMI = Pin 3 on HDMI Terminal\n                * `2`: DI3 = Pin 3 on Micro HDMI = Pin 1 on HDMI Terminal\n                * `3`: DI4 = Pin 1 on Micro HDMI = Pin 19 on HDMI Terminal\n                * `4`: DI5 = Pin 4 on Micro HDMI = Pin 2 on HDMI Terminal\n                * `5`: DI6 = Pin 2 on Micro HDMI = Pin 14 on HDMI Terminal\n\n            * AS7010:\n\n                * `0`: DI1 = Pin 24 at 26-pin connector\n                * `1`: DI2 = Pin 7 at 26-pin connector\n                * `2`: DI3 = Pin 16 at 26-pin\n\n    Returns:\n        The digital input value.\n    \"\"\"\n    din = c_ubyte()\n    self.sdk.AVS_GetDigIn(self._handle, digital_id, din)\n    return din.value\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_dll_version","title":"get_dll_version","text":"<pre><code>get_dll_version() -&gt; str\n</code></pre> <p>Get the DLL version number.</p> <p>Returns:</p> Type Description <code>str</code> <p>The DLL version number</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_dll_version(self) -&gt; str:\n    \"\"\"Get the DLL version number.\n\n    Returns:\n        The DLL version number\n    \"\"\"\n    version = create_string_buffer(255)\n    self.sdk.AVS_GetDLLVersion(version)\n    return version.value.decode()\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_handle_from_serial","title":"get_handle_from_serial","text":"<pre><code>get_handle_from_serial(serial: str | None = None) -&gt; int\n</code></pre> <p>Get the handle ID for the specified serial number.</p> <p>Parameters:</p> Name Type Description Default <code>serial</code> <code>str | None</code> <p>The serial number. Default is to get the handle for this class instance.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The handle.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_handle_from_serial(self, serial: str | None = None) -&gt; int:\n    \"\"\"Get the handle ID for the specified serial number.\n\n    Args:\n        serial: The serial number. Default is to get the handle for this class instance.\n\n    Returns:\n        The handle.\n    \"\"\"\n    serial = serial or self.equipment.serial\n    return int(self.sdk.AVS_GetHandleFromSerial(serial.encode()))\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_ip_config","title":"get_ip_config","text":"<pre><code>get_ip_config() -&gt; EthernetSettingsType\n</code></pre> <p>Retrieve IP settings from the spectrometer.</p> <p>Use this function to read the Ethernet settings of the spectrometer, without having to read the complete device configuration structure.</p> <p>Returns:</p> Type Description <code>EthernetSettingsType</code> <p>The Ethernet settings of the spectrometer.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_ip_config(self) -&gt; EthernetSettingsType:\n    \"\"\"Retrieve IP settings from the spectrometer.\n\n    Use this function to read the Ethernet settings of the spectrometer, without\n    having to read the complete device configuration structure.\n\n    Returns:\n        The Ethernet settings of the spectrometer.\n    \"\"\"\n    eth = EthernetSettingsType()\n    self.sdk.AVS_GetIpConfig(self._handle, eth)\n    return eth\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_lambda","title":"get_lambda","text":"<pre><code>get_lambda() -&gt; NDArray[double]\n</code></pre> <p>Returns the wavelength values corresponding to the pixels if available.</p> <p>Returns:</p> Type Description <code>NDArray[double]</code> <p>The wavelength value of each pixel.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_lambda(self) -&gt; NDArray[np.double]:\n    \"\"\"Returns the wavelength values corresponding to the pixels if available.\n\n    Returns:\n        The wavelength value of each pixel.\n    \"\"\"\n    values = np.zeros(MAX_NR_PIXELS, dtype=np.double)\n    self.sdk.AVS_GetLambda(self._handle, values.ctypes.data_as(POINTER(c_double)))\n    return values[values &gt; 0]\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_num_devices","title":"get_num_devices","text":"<pre><code>get_num_devices() -&gt; int\n</code></pre> <p>Scans for attached devices and returns the number of devices detected.</p> <p>Deprecated function, replaced by :meth:<code>.update_usb_devices</code>. The functionality is identical.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of devices found.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_num_devices(self) -&gt; int:\n    \"\"\"Scans for attached devices and returns the number of devices detected.\n\n    Deprecated function, replaced by :meth:`.update_usb_devices`. The\n    functionality is identical.\n\n    Returns:\n        The number of devices found.\n    \"\"\"\n    num: int = self.sdk.AVS_GetNrOfDevices()\n    return num\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_num_pixels","title":"get_num_pixels","text":"<pre><code>get_num_pixels() -&gt; int\n</code></pre> <p>Returns the number of pixels of a spectrometer.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_num_pixels(self) -&gt; int:\n    \"\"\"Returns the number of pixels of a spectrometer.\"\"\"\n    n = c_uint16()\n    self.sdk.AVS_GetNumPixels(self._handle, n)\n    return n.value\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_oem_parameter","title":"get_oem_parameter","text":"<pre><code>get_oem_parameter() -&gt; OemDataType\n</code></pre> <p>Returns the OEM data structure available on the spectrometer.</p> <p>Returns:</p> Type Description <code>OemDataType</code> <p>The OEM parameters.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_oem_parameter(self) -&gt; OemDataType:\n    \"\"\"Returns the OEM data structure available on the spectrometer.\n\n    Returns:\n        The OEM parameters.\n    \"\"\"\n    odt = OemDataType()\n    self.sdk.AVS_GetOemParameter(self._handle, odt)\n    return odt\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_parameter","title":"get_parameter","text":"<pre><code>get_parameter() -&gt; DeviceConfigType\n</code></pre> <p>Returns the device information of the spectrometer.</p> <p>Returns:</p> Type Description <code>DeviceConfigType</code> <p>The device parameters.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_parameter(self) -&gt; DeviceConfigType:\n    \"\"\"Returns the device information of the spectrometer.\n\n    Returns:\n        The device parameters.\n    \"\"\"\n    dct = DeviceConfigType()\n    required_size = c_uint32()\n    self.sdk.AVS_GetParameter(self._handle, sizeof(dct), required_size, dct)\n    return dct\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_saturated_pixels","title":"get_saturated_pixels","text":"<pre><code>get_saturated_pixels() -&gt; NDArray[uint8]\n</code></pre> <p>Returns, for each pixel, if a pixel was saturated (1) or not (0).</p> <p>Returns:</p> Type Description <code>NDArray[uint8]</code> <p>The saturation state of each pixel.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_saturated_pixels(self) -&gt; NDArray[np.uint8]:\n    \"\"\"Returns, for each pixel, if a pixel was saturated (1) or not (0).\n\n    Returns:\n        The saturation state of each pixel.\n    \"\"\"\n    n = 9\n    values = np.full(MAX_NR_PIXELS, n, dtype=np.uint8)\n    self.sdk.AVS_GetSaturatedPixels(self._handle, values.ctypes.data_as(POINTER(c_ubyte)))\n    return values[values &lt; n]\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_status_by_serial","title":"get_status_by_serial","text":"<pre><code>get_status_by_serial(serial: str | None = None) -&gt; int\n</code></pre> <p>Get the handle ID for the specified serial number.</p> <p>Parameters:</p> Name Type Description Default <code>serial</code> <code>str | None</code> <p>The serial number. Default is to get the status for this class instance.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_status_by_serial(self, serial: str | None = None) -&gt; int:\n    \"\"\"Get the handle ID for the specified serial number.\n\n    Args:\n        serial: The serial number. Default is to get the status for this class instance.\n\n    Returns:\n        The status.\n    \"\"\"\n    serial = serial or self.equipment.serial\n    status = c_int32()\n    self.sdk.AVS_GetStatusBySerial(serial.encode(), status)\n    return status.value\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_version_info","title":"get_version_info","text":"<pre><code>get_version_info() -&gt; tuple[str, str, str]\n</code></pre> <p>Returns software version information.</p> <p>Returns:</p> Type Description <code>tuple[str, str, str]</code> <p>FPGA software version, firmware version, DLL version.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_version_info(self) -&gt; tuple[str, str, str]:\n    \"\"\"Returns software version information.\n\n    Returns:\n        FPGA software version, firmware version, DLL version.\n    \"\"\"\n    fpga = create_string_buffer(16)\n    fm = create_string_buffer(16)\n    dll = create_string_buffer(16)\n    self.sdk.AVS_GetVersionInfo(self._handle, fpga, fm, dll)\n    return fpga.value.decode(), fm.value.decode(), dll.value.decode()\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.heartbeat","title":"heartbeat","text":"<pre><code>heartbeat(req_type: int) -&gt; HeartbeatRespType\n</code></pre> <p>Monitor the (heartbeat) functions of the spectrometer.</p> <p>This function applies only to the AS7010 platform. See the DLL manual for more details.</p> <p>Parameters:</p> Name Type Description Default <code>req_type</code> <code>int</code> <p>The heartbeat request values used to control heartbeat functions.</p> required <p>Returns:</p> Type Description <code>HeartbeatRespType</code> <p>The heartbeat response structure received from the spectrometer.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def heartbeat(self, req_type: int) -&gt; HeartbeatRespType:\n    \"\"\"Monitor the (heartbeat) functions of the spectrometer.\n\n    This function applies only to the AS7010 platform. See the DLL manual for more details.\n\n    Args:\n        req_type: The heartbeat request values used to control heartbeat functions.\n\n    Returns:\n        The heartbeat response structure received from the spectrometer.\n    \"\"\"\n    resp = HeartbeatRespType()\n    self.sdk.AVS_Heartbeat(self._handle, req_type, resp)\n    return resp\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.init","title":"init","text":"<pre><code>init(port_id: int) -&gt; int\n</code></pre> <p>Initializes the communication interface with the spectrometers and the internal data structures.</p> <p>For Ethernet devices this function will create a list of available Ethernet spectrometers within all the network interfaces of the host.</p> <p>Parameters:</p> Name Type Description Default <code>port_id</code> <code>int</code> <p>ID of port to be used. One of:</p> <ul> <li><code>-1</code>: Use both Ethernet (AS7010) and USB ports</li> <li><code>0</code>: Use USB port</li> <li><code>1..255</code>: Not supported in v9.7 of the SDK</li> <li><code>256</code>: Use Ethernet port (AS7010)</li> </ul> required <p>Returns:</p> Type Description <code>int</code> <p>On success, the number of connected or found devices.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def init(self, port_id: int) -&gt; int:\n    \"\"\"Initializes the communication interface with the spectrometers and the internal data structures.\n\n    For Ethernet devices this function will create a list of available Ethernet spectrometers\n    within all the network interfaces of the host.\n\n    Args:\n        port_id: ID of port to be used. One of:\n\n            * `-1`: Use both Ethernet (AS7010) and USB ports\n            * `0`: Use USB port\n            * `1..255`: Not supported in v9.7 of the SDK\n            * `256`: Use Ethernet port (AS7010)\n\n    Returns:\n        On success, the number of connected or found devices.\n    \"\"\"\n    ret = int(self.sdk.AVS_Init(port_id))\n    if ret == 0:\n        raise MSLConnectionError(self, \"No Avantes devices were found\")\n    return ret\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.measure","title":"measure","text":"<pre><code>measure(\n    num_measurements: int, window_handle: int | None = None\n) -&gt; None\n</code></pre> <p>Starts measurement on the spectrometer.</p> <p>Parameters:</p> Name Type Description Default <code>num_measurements</code> <code>int</code> <p>Number of measurements to acquire. Use -1 to measure continuously until stop_measure is called.</p> required <code>window_handle</code> <code>int | None</code> <p>Window handle to notify application measurement result data is available. The DLL sends a message to the window with command: <code>WM_MEAS_READY</code>, with <code>SUCCESS</code> (<code>0</code>), the number of scans that were saved in RAM (if <code>m_StoreToRAM</code> parameter &gt; 0, see ControlSettingsType), or <code>INVALID_MEAS_DATA</code> as <code>WPARM</code> value and <code>a_hDevice</code> as <code>LPARM</code> value. Set this value to <code>None</code> if a callback is not needed.</p> <code>None</code> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def measure(self, num_measurements: int, window_handle: int | None = None) -&gt; None:\n    \"\"\"Starts measurement on the spectrometer.\n\n    Args:\n        num_measurements: Number of measurements to acquire. Use -1 to measure continuously until\n            [stop_measure][msl.equipment_resources.avantes.avaspec.AvaSpec.stop_measure] is called.\n        window_handle: Window handle to notify application measurement result data is available.\n            The DLL sends a message to the window with command: `WM_MEAS_READY`, with `SUCCESS` (`0`),\n            the number of scans that were saved in RAM (if `m_StoreToRAM` parameter &gt; 0, see\n            [ControlSettingsType][msl.equipment_resources.avantes.avaspec.ControlSettingsType]),\n            or `INVALID_MEAS_DATA` as `WPARM` value and `a_hDevice` as `LPARM` value. Set this\n            value to `None` if a callback is not needed.\n    \"\"\"\n    self.sdk.AVS_Measure(self._handle, window_handle, num_measurements)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.measure_callback","title":"measure_callback","text":"<pre><code>measure_callback(\n    num_measurements: int,\n    callback: AvaSpecCallback | None = None,\n) -&gt; None\n</code></pre> <p>Register a measurement-available callback function for the spectrometer.</p> <p>Example</p> <p>See avaspec_callback.py for an example usage.</p> <p>Parameters:</p> Name Type Description Default <code>num_measurements</code> <code>int</code> <p>Number of measurements to acquire. Use -1 to measure continuously until stop_measure is called.</p> required <code>callback</code> <code>AvaSpecCallback | None</code> <p>A callback function to notify that application measurement result data is available. The DLL will call the given function to notify a measurement is ready and pass two parameters. The first parameter is a reference to the DLL handle. The second parameter is a reference to an integer value: <code>SUCCESS</code> (<code>0</code>) if a new scan is available, or the number of scans that were saved in RAM (if <code>m_StoreToRAM</code> parameter &gt; 0, see ControlSettingsType), or <code>INVALID_MEAS_DATA</code> (<code>-8</code>). Set this value to <code>None</code> if a callback is not needed.</p> <code>None</code> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def measure_callback(self, num_measurements: int, callback: AvaSpecCallback | None = None) -&gt; None:\n    \"\"\"Register a measurement-available callback function for the spectrometer.\n\n    !!! example\n        See [avaspec_callback.py](https://github.com/MSLNZ/msl-equipment/blob/main/packages/resources/examples/avantes/avaspec_callback.py)\n        for an example usage.\n\n    Args:\n        num_measurements: Number of measurements to acquire. Use -1 to measure continuously until\n            [stop_measure][msl.equipment_resources.avantes.avaspec.AvaSpec.stop_measure] is called.\n        callback: A callback function to notify that application measurement result data is available.\n            The DLL will call the given function to notify a measurement is ready and pass two parameters.\n            The first parameter is a reference to the DLL handle. The second parameter is a reference to\n            an integer value: `SUCCESS` (`0`) if a new scan is available, or the number of scans that were\n            saved in RAM (if `m_StoreToRAM` parameter &gt; 0, see\n            [ControlSettingsType][msl.equipment_resources.avantes.avaspec.ControlSettingsType]),\n            or `INVALID_MEAS_DATA` (`-8`). Set this value to `None` if a callback is not needed.\n    \"\"\"\n    self.sdk.AVS_MeasureCallback(self._handle, callback, num_measurements)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.poll_scan","title":"poll_scan","text":"<pre><code>poll_scan() -&gt; bool\n</code></pre> <p>Determines if new measurement results are available.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether there is a scan available.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def poll_scan(self) -&gt; bool:\n    \"\"\"Determines if new measurement results are available.\n\n    Returns:\n        Whether there is a scan available.\n    \"\"\"\n    return bool(self.sdk.AVS_PollScan(self._handle))\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.prepare_measure","title":"prepare_measure","text":"<pre><code>prepare_measure(config: MeasConfigType) -&gt; None\n</code></pre> <p>Prepares measurement on the spectrometer using the specified measurement configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>MeasConfigType</code> <p>The measurement configuration.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def prepare_measure(self, config: MeasConfigType) -&gt; None:\n    \"\"\"Prepares measurement on the spectrometer using the specified measurement configuration.\n\n    Args:\n        config: The measurement configuration.\n    \"\"\"\n    self.sdk.AVS_PrepareMeasure(self._handle, config)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.register","title":"register","text":"<pre><code>register(handle: int) -&gt; None\n</code></pre> <p>Installs an application windows handle to which device attachment/removal messages have to be sent.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int</code> <p>Application window handle.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def register(self, handle: int) -&gt; None:\n    \"\"\"Installs an application windows handle to which device attachment/removal messages have to be sent.\n\n    Args:\n        handle: Application window handle.\n    \"\"\"\n    self.sdk.AVS_Register(handle)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.reset_device","title":"reset_device","text":"<pre><code>reset_device() -&gt; None\n</code></pre> <p>Performs a hard reset on the given spectrometer.</p> <p>This function only works with the AS7010 platform.</p> <p>During reset of the spectrometer, all spectrometer HW modules (microprocessor and USB controller) will be reset at once. The spectrometer will start its reset procedure right after sending the command response back to the host.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def reset_device(self) -&gt; None:\n    \"\"\"Performs a hard reset on the given spectrometer.\n\n    This function only works with the AS7010 platform.\n\n    During reset of the spectrometer, all spectrometer HW modules (microprocessor and USB controller)\n    will be reset at once. The spectrometer will start its reset procedure right after sending the\n    command response back to the host.\n    \"\"\"\n    self.sdk.AVS_ResetDevice(self._handle)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.set_analog_out","title":"set_analog_out","text":"<pre><code>set_analog_out(port_id: int, value: float) -&gt; None\n</code></pre> <p>Sets the analog output value for the specified analog identifier.</p> <p>Parameters:</p> Name Type Description Default <code>port_id</code> <code>int</code> <p>Identifier for one of the two output signals:</p> <ul> <li> <p>AS5216:</p> <ul> <li><code>0</code>: AO1 = pin 17 at 26-pin connector</li> <li><code>1</code>: AO2 = pin 26 at 26-pin connector</li> </ul> </li> <li> <p>Mini:</p> <ul> <li><code>0</code>: AO1 = Pin 12 on Micro HDMI = Pin 10 on HDMI terminal</li> <li><code>1</code>: AO2 = Pin 14 on Micro HDMI = Pin 12 on HDMI terminal</li> </ul> </li> <li> <p>AS7010:</p> <ul> <li><code>0</code>: AO1 = pin 17 at 26-pin connector</li> <li><code>1</code>: AO2 = pin 26 at 26-pin connector</li> </ul> </li> </ul> required <code>value</code> <code>float</code> <p>DAC value to be set in Volts (internally an 8-bits DAC is used) with range 0 - 5V.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def set_analog_out(self, port_id: int, value: float) -&gt; None:\n    \"\"\"Sets the analog output value for the specified analog identifier.\n\n    Args:\n        port_id: Identifier for one of the two output signals:\n\n            * AS5216:\n\n                * `0`: AO1 = pin 17 at 26-pin connector\n                * `1`: AO2 = pin 26 at 26-pin connector\n\n            * Mini:\n\n                * `0`: AO1 = Pin 12 on Micro HDMI = Pin 10 on HDMI terminal\n                * `1`: AO2 = Pin 14 on Micro HDMI = Pin 12 on HDMI terminal\n\n            * AS7010:\n\n                * `0`: AO1 = pin 17 at 26-pin connector\n                * `1`: AO2 = pin 26 at 26-pin connector\n\n        value: DAC value to be set in Volts (internally an 8-bits DAC is used) with range 0 - 5V.\n    \"\"\"\n    self.sdk.AVS_SetAnalogOut(self._handle, port_id, value)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.set_digital_out","title":"set_digital_out","text":"<pre><code>set_digital_out(port_id: int, value: int) -&gt; None\n</code></pre> <p>Sets the digital output value for the specified digital identifier.</p> <p>Parameters:</p> Name Type Description Default <code>port_id</code> <code>int</code> <p>Identifier for one of the 10 output signals:</p> <ul> <li> <p>AS5216:</p> <ul> <li><code>0</code>: DO1 = pin 11 at 26-pin connector</li> <li><code>1</code>: DO2 = pin 2 at 26-pin connector</li> <li><code>2</code>: DO3 = pin 20 at 26-pin connector</li> <li><code>3</code>: DO4 = pin 12 at 26-pin connector</li> <li><code>4</code>: DO5 = pin 3 at 26-pin connector</li> <li><code>5</code>: DO6 = pin 21 at 26-pin connector</li> <li><code>6</code>: DO7 = pin 13 at 26-pin connector</li> <li><code>7</code>: DO8 = pin 4 at 26-pin connector</li> <li><code>8</code>: DO9 = pin 22 at 26-pin connector</li> <li><code>9</code>: DO10 = pin 25 at 26-pin connector</li> </ul> </li> <li> <p>Mini:</p> <ul> <li><code>0</code>: DO1 = Pin 7 on Micro HDMI = Pin 5 on HDMI terminal</li> <li><code>1</code>: DO2 = Pin 5 on Micro HDMI = Pin 3 on HDMI Terminal</li> <li><code>2</code>: DO3 = Pin 3 on Micro HDMI = Pin 1 on HDMI Terminal</li> <li><code>3</code>: DO4 = Pin 1 on Micro HDMI = Pin 19 on HDMI Terminal</li> <li><code>4</code>: DO5 = Pin 4 on Micro HDMI = Pin 2 on HDMI Terminal</li> <li><code>5</code>: DO6 = Pin 2 on Micro HDMI = Pin 14 on HDMI Terminal</li> <li><code>6</code>: Not used</li> <li><code>7</code>: Not used</li> <li><code>8</code>: Not used</li> <li><code>9</code>: Not used</li> </ul> </li> <li> <p>AS7010:</p> <ul> <li><code>0</code>: DO1 =pin 11 at 26-pin connector</li> <li><code>1</code>: DO2 = pin 2 at 26-pin connector</li> <li><code>2</code>: DO3 = pin 20 at 26-pin connector</li> <li><code>3</code>: DO4 = pin 12 at 26-pin connector</li> <li><code>4</code>: DO5 = pin 3 at 26-pin connector</li> <li><code>5</code>: DO6 = pin 21 at 26-pin connector</li> <li><code>6</code>: DO7 = pin 13 at 26-pin connector</li> <li><code>7</code>: DO8 = pin 4 at 26-pin connector</li> <li><code>8</code>: DO9 = pin 22 at 26-pin connector</li> <li><code>9</code>: DO10 = pin 25 at 26-pin connector</li> </ul> </li> </ul> required <code>value</code> <code>int</code> <p>The digital value to be set (0 or 1).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def set_digital_out(self, port_id: int, value: int) -&gt; None:\n    \"\"\"Sets the digital output value for the specified digital identifier.\n\n    Args:\n        port_id: Identifier for one of the 10 output signals:\n\n            * AS5216:\n\n                * `0`: DO1 = pin 11 at 26-pin connector\n                * `1`: DO2 = pin 2 at 26-pin connector\n                * `2`: DO3 = pin 20 at 26-pin connector\n                * `3`: DO4 = pin 12 at 26-pin connector\n                * `4`: DO5 = pin 3 at 26-pin connector\n                * `5`: DO6 = pin 21 at 26-pin connector\n                * `6`: DO7 = pin 13 at 26-pin connector\n                * `7`: DO8 = pin 4 at 26-pin connector\n                * `8`: DO9 = pin 22 at 26-pin connector\n                * `9`: DO10 = pin 25 at 26-pin connector\n\n            * Mini:\n\n                * `0`: DO1 = Pin 7 on Micro HDMI = Pin 5 on HDMI terminal\n                * `1`: DO2 = Pin 5 on Micro HDMI = Pin 3 on HDMI Terminal\n                * `2`: DO3 = Pin 3 on Micro HDMI = Pin 1 on HDMI Terminal\n                * `3`: DO4 = Pin 1 on Micro HDMI = Pin 19 on HDMI Terminal\n                * `4`: DO5 = Pin 4 on Micro HDMI = Pin 2 on HDMI Terminal\n                * `5`: DO6 = Pin 2 on Micro HDMI = Pin 14 on HDMI Terminal\n                * `6`: Not used\n                * `7`: Not used\n                * `8`: Not used\n                * `9`: Not used\n\n            * AS7010:\n\n                * `0`: DO1 =pin 11 at 26-pin connector\n                * `1`: DO2 = pin 2 at 26-pin connector\n                * `2`: DO3 = pin 20 at 26-pin connector\n                * `3`: DO4 = pin 12 at 26-pin connector\n                * `4`: DO5 = pin 3 at 26-pin connector\n                * `5`: DO6 = pin 21 at 26-pin connector\n                * `6`: DO7 = pin 13 at 26-pin connector\n                * `7`: DO8 = pin 4 at 26-pin connector\n                * `8`: DO9 = pin 22 at 26-pin connector\n                * `9`: DO10 = pin 25 at 26-pin connector\n\n        value: The digital value to be set (0 or 1).\n    \"\"\"\n    self.sdk.AVS_SetDigOut(self._handle, port_id, value)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.set_oem_parameter","title":"set_oem_parameter","text":"<pre><code>set_oem_parameter(parameter: OemDataType) -&gt; None\n</code></pre> <p>Sends the OEM data structure to the spectrometer.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>OemDataType</code> <p>The OEM data structure.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def set_oem_parameter(self, parameter: OemDataType) -&gt; None:\n    \"\"\"Sends the OEM data structure to the spectrometer.\n\n    Args:\n        parameter: The OEM data structure.\n    \"\"\"\n    self.sdk.AVS_SetOemParameter(self._handle, parameter)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.set_parameter","title":"set_parameter","text":"<pre><code>set_parameter(parameter: DeviceConfigType) -&gt; None\n</code></pre> <p>Overwrites the device configuration.</p> <p>Please note that OemDataType is part of the DeviceConfigType in EEPROM (see section 3.5 of DLL manual). Precautions must be taken to prevent OEM data overwrites when using this method together with set_oem_parameter.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>DeviceConfigType</code> <p>The device parameters.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def set_parameter(self, parameter: DeviceConfigType) -&gt; None:\n    \"\"\"Overwrites the device configuration.\n\n    Please note that [OemDataType][msl.equipment_resources.avantes.avaspec.OemDataType] is part\n    of the [DeviceConfigType][msl.equipment_resources.avantes.avaspec.DeviceConfigType] in EEPROM\n    (see section 3.5 of DLL manual). Precautions must be taken to prevent OEM data overwrites\n    when using this method together with\n    [set_oem_parameter][msl.equipment_resources.avantes.avaspec.AvaSpec.set_oem_parameter].\n\n    Args:\n        parameter: The device parameters.\n    \"\"\"\n    self.sdk.AVS_SetParameter(self._handle, parameter)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.set_prescan_mode","title":"set_prescan_mode","text":"<pre><code>set_prescan_mode(mode: bool) -&gt; None\n</code></pre> <p>If a prescan is set, the first measurement result will be skipped.</p> <p>This function is only useful for the AvaSpec-3648 because this detector can be operated in prescan mode, or clear-buffer mode (see DLL manual).</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>bool</code> <p>If <code>True</code>, the first measurement result will be skipped (prescan mode), else the detector will be cleared before each new scan (clear-buffer mode).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def set_prescan_mode(self, mode: bool) -&gt; None:  # noqa: FBT001\n    \"\"\"If a prescan is set, the first measurement result will be skipped.\n\n    This function is only useful for the AvaSpec-3648 because this detector\n    can be operated in prescan mode, or clear-buffer mode (see DLL manual).\n\n    Args:\n        mode: If `True`, the first measurement result will be skipped (prescan mode),\n            else the detector will be cleared before each new scan (clear-buffer mode).\n    \"\"\"\n    self.sdk.AVS_SetPrescanMode(self._handle, mode)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.set_pwm_out","title":"set_pwm_out","text":"<pre><code>set_pwm_out(\n    port_id: int, frequency: int, duty_cycle: int\n) -&gt; None\n</code></pre> <p>Selects the PWM functionality for the specified digital output.</p> <p>The PWM functionality is not supported on the Mini.</p> <p>Parameters:</p> Name Type Description Default <code>port_id</code> <code>int</code> <p>Identifier for one of the 6 PWM output signals:</p> <ul> <li><code>0</code>: DO1 = pin 11 at 26-pin connector</li> <li><code>1</code>: DO2 = pin 2 at 26-pin connector</li> <li><code>2</code>: DO3 = pin 20 at 26-pin connector</li> <li><code>4</code>: DO5 = pin 3 at 26-pin connector</li> <li><code>5</code>: DO6 = pin 21 at 26-pin connector</li> <li><code>6</code>: DO7 = pin 13 at 26-pin connector</li> </ul> required <code>frequency</code> <code>int</code> <p>Desired PWM frequency (500 - 300000) [Hz]. For the AS5216, the frequency of outputs 0, 1 and 2 is the same (the last specified frequency is used) and also the frequency of outputs 4, 5 and 6 is the same. For the AS7010, you can define six different frequencies.</p> required <code>duty_cycle</code> <code>int</code> <p>Percentage high time in one cycle (0 - 100). For the AS5216, channels 0, 1 and 2 have a synchronized rising edge, the same holds for channels 4, 5 and 6. For the AS7010, rising edges are unsynchronized.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def set_pwm_out(self, port_id: int, frequency: int, duty_cycle: int) -&gt; None:\n    \"\"\"Selects the PWM functionality for the specified digital output.\n\n    The PWM functionality is not supported on the Mini.\n\n    Args:\n        port_id: Identifier for one of the 6 PWM output signals:\n\n            * `0`: DO1 = pin 11 at 26-pin connector\n            * `1`: DO2 = pin 2 at 26-pin connector\n            * `2`: DO3 = pin 20 at 26-pin connector\n            * `4`: DO5 = pin 3 at 26-pin connector\n            * `5`: DO6 = pin 21 at 26-pin connector\n            * `6`: DO7 = pin 13 at 26-pin connector\n\n        frequency: Desired PWM frequency (500 - 300000) [Hz]. For the AS5216, the frequency of\n            outputs 0, 1 and 2 is the same (the last specified frequency is used) and\n            also the frequency of outputs 4, 5 and 6 is the same. For the AS7010, you\n            can define six different frequencies.\n        duty_cycle: Percentage high time in one cycle (0 - 100). For the AS5216, channels 0,\n            1 and 2 have a synchronized rising edge, the same holds for channels 4, 5\n            and 6. For the AS7010, rising edges are unsynchronized.\n    \"\"\"\n    self.sdk.AVS_SetPwmOut(self._handle, port_id, frequency, duty_cycle)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.set_sensitivity_mode","title":"set_sensitivity_mode","text":"<pre><code>set_sensitivity_mode(mode: int) -&gt; None\n</code></pre> <p>Set the sensitivity mode.</p> <p>This method is supported by the following detector types: HAMS9201, HAMG9208_512, SU256LSB and SU512LDB with the appropriate firmware version.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>int</code> <p>0 for low noise, &gt;0 for high sensitivity</p> required Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def set_sensitivity_mode(self, mode: int) -&gt; None:\n    \"\"\"Set the sensitivity mode.\n\n    This method is supported by the following detector types: HAMS9201,\n    HAMG9208_512, SU256LSB and SU512LDB with the appropriate firmware version.\n\n    Args:\n        mode: 0 for low noise, &gt;0 for high sensitivity\n    \"\"\"\n    self.sdk.AVS_SetSensitivityMode(self._handle, mode)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.set_sync_mode","title":"set_sync_mode","text":"<pre><code>set_sync_mode(enable: bool) -&gt; None\n</code></pre> <p>Disables/enables support for synchronous measurement.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p><code>False</code> to disable sync mode, <code>True</code> to enable sync mode.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def set_sync_mode(self, enable: bool) -&gt; None:  # noqa: FBT001\n    \"\"\"Disables/enables support for synchronous measurement.\n\n    Args:\n        enable: `False` to disable sync mode, `True` to enable sync mode.\n    \"\"\"\n    self.sdk.AVS_SetSyncMode(self._handle, int(bool(enable)))\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.stop_measure","title":"stop_measure","text":"<pre><code>stop_measure() -&gt; None\n</code></pre> <p>Stops the measurement.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def stop_measure(self) -&gt; None:\n    \"\"\"Stops the measurement.\"\"\"\n    self.sdk.AVS_StopMeasure(self._handle)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.suppress_stray_light","title":"suppress_stray_light","text":"<pre><code>suppress_stray_light(\n    factor: float,\n) -&gt; tuple[NDArray[double], NDArray[double]]\n</code></pre> <p>Returns the stray light corrected pixel values of a dark corrected measurement.</p> <p>Parameters:</p> Name Type Description Default <code>factor</code> <code>float</code> <p>Multiplication factor for the stray light algorithm.</p> required <p>Returns:</p> Type Description <code>tuple[NDArray[double], NDArray[double]]</code> <p>Scope minus dark array, stray light suppressed array.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def suppress_stray_light(self, factor: float) -&gt; tuple[NDArray[np.double], NDArray[np.double]]:\n    \"\"\"Returns the stray light corrected pixel values of a dark corrected measurement.\n\n    Args:\n        factor: Multiplication factor for the stray light algorithm.\n\n    Returns:\n        Scope minus dark array, stray light suppressed array.\n    \"\"\"\n    x = -9e99\n    src = np.full(MAX_NR_PIXELS, x, dtype=np.double)\n    dest = np.full(MAX_NR_PIXELS, x, dtype=np.double)\n    self.sdk.AVS_SuppressStrayLight(\n        self._handle, factor, src.ctypes.data_as(POINTER(c_double)), dest.ctypes.data_as(POINTER(c_double))\n    )\n    return src[src &gt; x], dest[dest &gt; x]\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.update_eth_devices","title":"update_eth_devices","text":"<pre><code>update_eth_devices(\n    nmax: int = 16,\n) -&gt; list[BroadcastAnswerType]\n</code></pre> <p>Return the number of Ethernet devices that are connected to the computer.</p> <p>Internally checks the list of connected Ethernet devices and returns the number of devices attached.</p> <p>Parameters:</p> Name Type Description Default <code>nmax</code> <code>int</code> <p>The maximum number of devices that can be found.</p> <code>16</code> <p>Returns:</p> Type Description <code>list[BroadcastAnswerType]</code> <p>The information about the devices.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def update_eth_devices(self, nmax: int = 16) -&gt; list[BroadcastAnswerType]:\n    \"\"\"Return the number of Ethernet devices that are connected to the computer.\n\n    Internally checks the list of connected Ethernet devices and returns the number of devices attached.\n\n    Args:\n        nmax: The maximum number of devices that can be found.\n\n    Returns:\n        The information about the devices.\n    \"\"\"\n    size = nmax * sizeof(BroadcastAnswerType)\n    required_size = c_uint32()\n    types = (BroadcastAnswerType * nmax)()\n    n = self.sdk.AVS_UpdateETHDevices(size, required_size, types)\n    return [types[i] for i in range(n)]\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.update_usb_devices","title":"update_usb_devices","text":"<pre><code>update_usb_devices() -&gt; int\n</code></pre> <p>Return the number of USB devices that are connected to the computer.</p> <p>Internally checks the list of connected USB devices and returns the number of devices attached.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of devices found.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def update_usb_devices(self) -&gt; int:\n    \"\"\"Return the number of USB devices that are connected to the computer.\n\n    Internally checks the list of connected USB devices and returns the number of devices attached.\n\n    Returns:\n        The number of devices found.\n    \"\"\"\n    return int(self.sdk.AVS_UpdateUSBDevices())\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.use_high_res_adc","title":"use_high_res_adc","text":"<pre><code>use_high_res_adc(enable: bool) -&gt; None\n</code></pre> <p>Enable the 16-bit AD converter.</p> <p>When using the 16 bit ADC in full High Resolution mode (0..65535), please note that the irradiance intensity calibration, as well as the nonlinearity calibration are based on the 14bit ADC range. Therefore, if using the nonlinearity correction or irradiance calibration in your own software using the High Resolution mode, you need to apply the additional correction with ADCFactor (= 4.0), as explained in detail in section 4.6.1 and 4.6.3 of the manual.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>If <code>True</code> use a 16-bit AD converter, otherwise use a 14-bit ADC.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def use_high_res_adc(self, enable: bool) -&gt; None:  # noqa: FBT001\n    \"\"\"Enable the 16-bit AD converter.\n\n    When using the 16 bit ADC in full High Resolution mode (0..65535), please note that the\n    irradiance intensity calibration, as well as the nonlinearity calibration are based on the 14bit\n    ADC range. Therefore, if using the nonlinearity correction or irradiance calibration in your\n    own software using the High Resolution mode, you need to apply the additional correction\n    with ADCFactor (= 4.0), as explained in detail in section 4.6.1 and 4.6.3 of the manual.\n\n    Args:\n        enable: If `True` use a 16-bit AD converter, otherwise use a 14-bit ADC.\n    \"\"\"\n    self.sdk.AVS_UseHighResAdc(self._handle, bool(enable))\n</code></pre>"},{"location":"resources/avantes/avaspec/#avaspec-enums-structs","title":"Enums and Structs","text":"<p>Wrapper around the <code>avaspec</code> SDK from Avantes.</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.MeasureCallback","title":"MeasureCallback  <code>module-attribute</code>","text":"<pre><code>MeasureCallback: type[_CFunctionType] = func_type(\n    None, POINTER(c_int32), POINTER(c_int32)\n)\n</code></pre> <p>CFUNCTYPE function prototype to use when a measurement scan is available.</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvsIdentityType","title":"AvsIdentityType","text":"<p>               Bases: <code>Structure</code></p> <p>IdentityType Structure.</p> <p>Attributes:</p> Name Type Description <code>SerialNumber</code> <code>c_char * 10</code> <p>Serial number of device.</p> <code>UserFriendlyName</code> <code>c_char * 64</code> <p>User-friendly name.</p> <code>Status</code> <code>c_ubyte</code> <p>Device status.</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.BroadcastAnswerType","title":"BroadcastAnswerType","text":"<p>               Bases: <code>Structure</code></p> <p>BroadcastAnswerType Structure.</p> <p>Attributes:</p> Name Type Description <code>InterfaceType</code> <code>c_ubyte</code> <p>InterfaceType</p> <code>serial</code> <code>c_ubyte * 10</code> <p>serial</p> <code>port</code> <code>c_uint16</code> <p>port</p> <code>status</code> <code>c_ubyte</code> <p>status</p> <code>RemoteHostIp</code> <code>c_uint32</code> <p>RemoteHostIp</p> <code>LocalIp</code> <code>c_uint32</code> <p>LocalIp</p> <code>reserved</code> <code>c_ubyte * 4</code> <p>reserved</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.ControlSettingsType","title":"ControlSettingsType","text":"<p>               Bases: <code>Structure</code></p> <p>ControlSettingsType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_StrobeControl</code> <code>c_uint16</code> <p>m_StrobeControl</p> <code>m_LaserDelay</code> <code>c_uint32</code> <p>m_LaserDelay</p> <code>m_LaserWidth</code> <code>c_uint32</code> <p>m_LaserWidth</p> <code>m_LaserWaveLength</code> <code>c_float</code> <p>m_LaserWaveLength</p> <code>m_StoreToRam</code> <code>c_uint16</code> <p>m_StoreToRam</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.DarkCorrectionType","title":"DarkCorrectionType","text":"<p>               Bases: <code>Structure</code></p> <p>DarkCorrectionType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_Enable</code> <code>c_ubyte</code> <p>m_Enable</p> <code>m_ForgetPercentage</code> <code>c_ubyte</code> <p>m_ForgetPercentage</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.DetectorType","title":"DetectorType","text":"<p>               Bases: <code>Structure</code></p> <p>DetectorType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_SensorType</code> <code>c_ubyte</code> <p>m_SensorType</p> <code>m_NrPixels</code> <code>c_uint16</code> <p>m_NrPixels</p> <code>m_aFit</code> <code>c_float * 5</code> <p>m_aFit</p> <code>m_NLEnable</code> <code>c_bool</code> <p>m_NLEnable</p> <code>m_aNLCorrect</code> <code>c_double * 8</code> <p>m_aNLCorrect</p> <code>m_aLowNLCounts</code> <code>c_double</code> <p>m_aLowNLCounts</p> <code>m_aHighNLCounts</code> <code>c_double</code> <p>m_aHighNLCounts</p> <code>m_Gain</code> <code>c_float * 2</code> <p>m_Gain</p> <code>m_Reserved</code> <code>c_float</code> <p>m_Reserved</p> <code>m_Offset</code> <code>c_float * 2</code> <p>m_Offset</p> <code>m_ExtOffset</code> <code>c_float</code> <p>m_ExtOffset</p> <code>m_DefectivePixels</code> <code>c_uint16 * 30</code> <p>m_DefectivePixels</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.DeviceConfigType","title":"DeviceConfigType","text":"<p>               Bases: <code>Structure</code></p> <p>DeviceConfigType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_Len</code> <code>c_uint16</code> <p>m_Len</p> <code>m_ConfigVersion</code> <code>c_uint16</code> <p>m_ConfigVersion</p> <code>m_aUserFriendlyId</code> <code>c_char * 64</code> <p>m_aUserFriendlyId</p> <code>m_Detector</code> <code>DetectorType</code> <p>m_Detector</p> <code>m_Irradiance</code> <code>IrradianceType</code> <p>m_Irradiance</p> <code>m_Reflectance</code> <code>SpectrumCalibrationType</code> <p>m_Reflectance</p> <code>m_SpectrumCorrect</code> <code>SpectrumCorrectionType</code> <p>m_SpectrumCorrect</p> <code>m_StandAlone</code> <code>StandAloneType</code> <p>m_StandAlone</p> <code>m_DynamicStorage</code> <code>DynamicStorageType</code> <p>m_DynamicStorage</p> <code>m_aTemperature</code> <code>TempSensorType * 3</code> <p>m_aTemperature</p> <code>m_TecControl</code> <code>TecControlType</code> <p>m_TecControl</p> <code>m_ProcessControl</code> <code>ProcessControlType</code> <p>m_ProcessControl</p> <code>m_EthernetSettings</code> <code>EthernetSettingsType</code> <p>m_EthernetSettings</p> <code>m_aReserved</code> <code>c_ubyte * 9720</code> <p>m_aReserved</p> <code>m_OemData</code> <code>OemDataType</code> <p>m_OemData</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.DeviceStatus","title":"DeviceStatus","text":"<p>               Bases: <code>IntEnum</code></p> <p>DeviceStatus enum.</p> <p>Attributes:</p> Name Type Description <code>UNKNOWN</code> <code>int</code> <p>0</p> <code>USB_AVAILABLE</code> <code>int</code> <p>1</p> <code>USB_IN_USE_BY_APPLICATION</code> <code>int</code> <p>2</p> <code>USB_IN_USE_BY_OTHER</code> <code>int</code> <p>3</p> <code>ETH_AVAILABLE</code> <code>int</code> <p>4</p> <code>ETH_IN_USE_BY_APPLICATION</code> <code>int</code> <p>5</p> <code>ETH_IN_USE_BY_OTHER</code> <code>int</code> <p>6</p> <code>ETH_ALREADY_IN_USE_USB</code> <code>int</code> <p>7</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.DynamicStorageType","title":"DynamicStorageType","text":"<p>               Bases: <code>Structure</code></p> <p>DynamicStorageType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_Nmsr</code> <code>c_int32</code> <p>m_Nmsr</p> <code>m_Reserved</code> <code>c_ubyte * 8</code> <p>m_Reserved</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.EthernetSettingsType","title":"EthernetSettingsType","text":"<p>               Bases: <code>Structure</code></p> <p>EthernetSettingsType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_IpAddr(c_uint32)</code> <p>m_IpAddr</p> <code>m_NetMask</code> <code>c_uint32</code> <p>m_NetMask</p> <code>m_Gateway</code> <code>c_uint32</code> <p>m_Gateway</p> <code>m_DhcpEnabled</code> <code>c_ubyte</code> <p>m_DhcpEnabled</p> <code>m_TcpPort</code> <code>c_uint16</code> <p>m_TcpPort</p> <code>m_LinkStatus</code> <code>c_ubyte</code> <p>m_LinkStatus</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.HeartbeatRespType","title":"HeartbeatRespType","text":"<p>               Bases: <code>Structure</code></p> <p>HeartbeatRespType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_BitMatrix</code> <code>c_uint32</code> <p>m_BitMatrix</p> <code>m_Reserved</code> <code>c_uint32</code> <p>m_Reserved</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.InterfaceType","title":"InterfaceType","text":"<p>               Bases: <code>IntEnum</code></p> <p>InterfaceType enum.</p> <p>Attributes:</p> Name Type Description <code>RS232</code> <code>int</code> <p>0</p> <code>USB5216</code> <code>int</code> <p>1</p> <code>USBMINI</code> <code>int</code> <p>2</p> <code>USB7010</code> <code>int</code> <p>3</p> <code>ETH7010</code> <code>int</code> <p>4</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.IrradianceType","title":"IrradianceType","text":"<p>               Bases: <code>Structure</code></p> <p>IrradianceType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_IntensityCalib</code> <code>SpectrumCalibrationType</code> <p>m_IntensityCalib</p> <code>m_CalibrationType</code> <code>c_ubyte</code> <p>m_CalibrationType</p> <code>m_FiberDiameter</code> <code>c_uint32</code> <p>m_FiberDiameter</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.MeasConfigType","title":"MeasConfigType","text":"<p>               Bases: <code>Structure</code></p> <p>MeasConfigType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_StartPixel</code> <code>c_uint16</code> <p>m_StartPixel</p> <code>m_StopPixel</code> <code>c_uint16</code> <p>m_StopPixel</p> <code>m_IntegrationTime</code> <code>c_float</code> <p>m_IntegrationTime</p> <code>m_IntegrationDelay</code> <code>c_uint32</code> <p>m_IntegrationDelay</p> <code>m_NrAverages</code> <code>c_uint32</code> <p>m_NrAverages</p> <code>m_CorDynDark</code> <code>DarkCorrectionType</code> <p>m_CorDynDark</p> <code>m_Smoothing</code> <code>SmoothingType</code> <p>m_Smoothing</p> <code>m_SaturationDetection</code> <code>c_ubyte</code> <p>m_SaturationDetection</p> <code>m_Trigger</code> <code>TriggerType</code> <p>m_Trigger</p> <code>m_Control</code> <code>ControlSettingsType</code> <p>m_Control</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.OemDataType","title":"OemDataType","text":"<p>               Bases: <code>Structure</code></p> <p>OemDataType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_data</code> <code>c_ubyte * 4096</code> <p>m_data</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.ProcessControlType","title":"ProcessControlType","text":"<p>               Bases: <code>Structure</code></p> <p>ProcessControlType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_AnalogLow</code> <code>c_float * 2</code> <p>m_AnalogLow</p> <code>m_AnalogHigh</code> <code>c_float * 2</code> <p>m_AnalogHigh</p> <code>m_DigitalLow</code> <code>c_float * 10</code> <p>m_DigitalLow</p> <code>m_DigitalHigh</code> <code>c_float * 10</code> <p>m_DigitalHigh</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.SensType","title":"SensType","text":"<p>               Bases: <code>IntEnum</code></p> <p>SensType enum.</p> <p>Attributes:</p> Name Type Description <code>SENS_HAMS8378_256</code> <code>int</code> <p>1</p> <code>SENS_HAMS8378_1024</code> <code>int</code> <p>2</p> <code>SENS_ILX554</code> <code>int</code> <p>3</p> <code>SENS_HAMS9201</code> <code>int</code> <p>4</p> <code>SENS_TCD1304</code> <code>int</code> <p>5</p> <code>SENS_TSL1301</code> <code>int</code> <p>6</p> <code>SENS_TSL1401</code> <code>int</code> <p>7</p> <code>SENS_HAMS8378_512</code> <code>int</code> <p>8</p> <code>SENS_HAMS9840</code> <code>int</code> <p>9</p> <code>SENS_ILX511</code> <code>int</code> <p>10</p> <code>SENS_HAMS10420_2048X64</code> <code>int</code> <p>11</p> <code>SENS_HAMS11071_2048X64</code> <code>int</code> <p>12</p> <code>SENS_HAMS7031_1024X122</code> <code>int</code> <p>13</p> <code>SENS_HAMS7031_1024X58</code> <code>int</code> <p>14</p> <code>SENS_HAMS11071_2048X16</code> <code>int</code> <p>15</p> <code>SENS_HAMS11155_2048</code> <code>int</code> <p>16</p> <code>SENS_SU256LSB</code> <code>int</code> <p>17</p> <code>SENS_SU512LDB</code> <code>int</code> <p>18</p> <code>SENS_HAMS11638</code> <code>int</code> <p>21</p> <code>SENS_HAMS11639</code> <code>int</code> <p>22</p> <code>SENS_HAMS12443</code> <code>int</code> <p>23</p> <code>SENS_HAMG9208_512</code> <code>int</code> <p>24</p> <code>SENS_HAMG13913</code> <code>int</code> <p>25</p> <code>SENS_HAMS13496</code> <code>int</code> <p>26</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.SmoothingType","title":"SmoothingType","text":"<p>               Bases: <code>Structure</code></p> <p>SmoothingType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_SmoothPix</code> <code>c_uint16</code> <p>m_SmoothPix</p> <code>m_SmoothModel</code> <code>c_ubyte</code> <p>m_SmoothModel</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.SpectrumCalibrationType","title":"SpectrumCalibrationType","text":"<p>               Bases: <code>Structure</code></p> <p>SpectrumCalibrationType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_Smoothing</code> <code>SmoothingType</code> <p>m_Smoothing</p> <code>m_CalInttime</code> <code>c_float</code> <p>m_CalInttime</p> <code>m_aCalibConvers</code> <code>c_float * 4096</code> <p>m_aCalibConvers</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.SpectrumCorrectionType","title":"SpectrumCorrectionType","text":"<p>               Bases: <code>Structure</code></p> <p>SpectrumCorrectionType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_aSpectrumCorrect</code> <code>c_float * 4096</code> <p>m_aSpectrumCorrect</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.StandAloneType","title":"StandAloneType","text":"<p>               Bases: <code>Structure</code></p> <p>StandAloneType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_Enable</code> <code>c_bool</code> <p>m_Enable</p> <code>m_Meas</code> <code>MeasConfigType</code> <p>m_Meas</p> <code>m_Nmsr</code> <code>c_int16</code> <p>m_Nmsr</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.TecControlType","title":"TecControlType","text":"<p>               Bases: <code>Structure</code></p> <p>TecControlType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_Enable</code> <code>c_bool</code> <p>m_Enable</p> <code>m_Setpoint</code> <code>c_float</code> <p>m_Setpoint</p> <code>m_aFit</code> <code>c_float * 2</code> <p>m_aFit</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.TempSensorType","title":"TempSensorType","text":"<p>               Bases: <code>Structure</code></p> <p>TempSensorType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_aFit</code> <code>c_float * 5</code> <p>m_aFit</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.TimeStampType","title":"TimeStampType","text":"<p>               Bases: <code>Structure</code></p> <p>TimeStampType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_Date</code> <code>c_uint16</code> <p>m_Date</p> <code>m_Time</code> <code>c_uint16</code> <p>m_Time</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.TriggerType","title":"TriggerType","text":"<p>               Bases: <code>Structure</code></p> <p>TriggerType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_Mode</code> <code>c_ubyte</code> <p>m_Mode</p> <code>m_Source</code> <code>c_ubyte</code> <p>m_Source</p> <code>m_SourceType</code> <code>c_ubyte</code> <p>m_SourceType</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.avaspec_callback","title":"avaspec_callback","text":"<pre><code>avaspec_callback(f: AvaSpecCallback) -&gt; _CFunctionType\n</code></pre> <p>Used as a decorator for a callback function when a measurement scan is available.</p> <p>See avaspec_callback.py for an example usage.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def avaspec_callback(f: AvaSpecCallback) -&gt; _CFunctionType:\n    \"\"\"Used as a decorator for a callback function when a measurement scan is available.\n\n    See [avaspec_callback.py](https://github.com/MSLNZ/msl-equipment/blob/main/packages/resources/examples/avantes/avaspec_callback.py)\n    for an example usage.\n    \"\"\"\n    return MeasureCallback(f)\n</code></pre>"},{"location":"resources/cmi/sia3/","title":"Switched Integrator Amplifier","text":"<p>A Switched Integrator Amplifier (SIA) designed by the Czech Metrology Institute.</p>"},{"location":"resources/cmi/sia3/#msl.equipment_resources.cmi.sia3.IntegrationTime","title":"IntegrationTime","text":"<p>               Bases: <code>IntEnum</code></p> <p>The amount of time to integrate the photodiode signal.</p> <p>Attributes:</p> Name Type Description <code>TIME_50us</code> <code>int</code> <p>5</p> <code>TIME_100us</code> <code>int</code> <p>6</p> <code>TIME_1ms</code> <code>int</code> <p>7</p> <code>TIME_10ms</code> <code>int</code> <p>8</p> <code>TIME_20ms</code> <code>int</code> <p>9</p> <code>TIME_100ms</code> <code>int</code> <p>10</p> <code>TIME_200ms</code> <code>int</code> <p>11</p> <code>TIME_500ms</code> <code>int</code> <p>12</p> <code>TIME_1s</code> <code>int</code> <p>13</p> <code>TIME_2s</code> <code>int</code> <p>14</p>"},{"location":"resources/cmi/sia3/#msl.equipment_resources.cmi.sia3.PreScale","title":"PreScale","text":"<p>               Bases: <code>IntEnum</code></p> <p>Pre-scale factor for the microprocessor frequency.</p> <p>Attributes:</p> Name Type Description <code>PS_0</code> <code>int</code> <p>0</p> <code>PS_1</code> <code>int</code> <p>1</p> <code>PS_2</code> <code>int</code> <p>2</p> <code>PS_3</code> <code>int</code> <p>3</p> <code>PS_4</code> <code>int</code> <p>4</p> <code>PS_5</code> <code>int</code> <p>5</p> <code>PS_6</code> <code>int</code> <p>6</p> <code>PS_7</code> <code>int</code> <p>7</p>"},{"location":"resources/cmi/sia3/#msl.equipment_resources.cmi.sia3.SIA3","title":"SIA3","text":"<pre><code>SIA3(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Serial</code></p> <p>A Switched Integrator Amplifier (SIA) designed by the Czech Metrology Institute.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/cmi/sia3.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"A Switched Integrator Amplifier (SIA) designed by the Czech Metrology Institute.\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"\n    assert equipment.connection is not None  # noqa: S101\n    if not equipment.connection.properties:\n        # then use the default connection properties\n        equipment.connection.properties = {\n            \"baud_rate\": 14400,\n            \"termination\": None,\n            \"timeout\": 10.0,\n        }\n    super().__init__(equipment)\n</code></pre>"},{"location":"resources/cmi/sia3/#msl.equipment_resources.cmi.sia3.SIA3.set_integration_time","title":"set_integration_time","text":"<pre><code>set_integration_time(\n    time: str | int | IntegrationTime,\n) -&gt; None\n</code></pre> <p>Set the integration time (i.e., the gain).</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>str | int | IntegrationTime</code> <p>The integration time. The following are equivalent to set the integration time to 10 milliseconds:</p> <ul> <li><code>set_integration_time(\"10ms\")</code></li> <li><code>set_integration_time(8)</code></li> <li><code>set_integration_time(cmi.IntegrationTime.TIME_10ms)</code></li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/cmi/sia3.py</code> <pre><code>def set_integration_time(self, time: str | int | IntegrationTime) -&gt; None:\n    \"\"\"Set the integration time (i.e., the gain).\n\n    Args:\n        time: The integration time. The following are equivalent to set the\n            integration time to 10 milliseconds:\n\n            * `set_integration_time(\"10ms\")`\n            * `set_integration_time(8)`\n            * `set_integration_time(cmi.IntegrationTime.TIME_10ms)`\n    \"\"\"\n    value = to_enum(time, IntegrationTime, prefix=\"TIME_\")\n    self._send_byte(7)\n    self._send_byte(value)\n</code></pre>"},{"location":"resources/cmi/sia3/#msl.equipment_resources.cmi.sia3.SIA3.set_ps","title":"set_ps","text":"<pre><code>set_ps(ps: int | PreScale) -&gt; None\n</code></pre> <p>Set the timer pre-scale value.</p> <p>The timer pre-scale value divides the microprocessor internal frequency by something similar to \\(2^{PS}\\). Therefore, to reach a 2-second integration time the <code>ps</code> value must be set to the maximum value of 7.</p> <p>Parameters:</p> Name Type Description Default <code>ps</code> <code>int | PreScale</code> <p>The timer pre-scale value. The following are equivalent to set the pre-scale value to 7</p> <ul> <li><code>set_ps(7)</code></li> <li><code>set_ps(cmi.PreScale.PS_7)</code></li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/cmi/sia3.py</code> <pre><code>def set_ps(self, ps: int | PreScale) -&gt; None:\n    \"\"\"Set the timer pre-scale value.\n\n    The timer pre-scale value divides the microprocessor internal frequency\n    by something similar to $2^{PS}$. Therefore, to reach a 2-second integration time\n    the `ps` value must be set to the maximum value of 7.\n\n    Args:\n        ps: The timer pre-scale value. The following are equivalent to set the\n            pre-scale value to 7\n\n            * `set_ps(7)`\n            * `set_ps(cmi.PreScale.PS_7)`\n    \"\"\"\n    value = to_enum(ps, PreScale, prefix=\"PS_\")\n    self._send_byte(1)\n    self._send_byte(4)\n    self._send_byte(value)\n    self._send_byte(value)\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/","title":"TC Temperature Controller","text":"<p>Establishes a connection to a TC Series Temperature Controller from Electron Dynamics Ltd.</p> <p>The main communication class is TCSeries.</p>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.Alarm","title":"Alarm  <code>dataclass</code>","text":"<pre><code>Alarm(\n    type: AlarmType,\n    alarm_min: float,\n    alarm_max: float,\n    ok_min: float,\n    ok_max: float,\n    limit_min: float,\n    limit_max: float,\n)\n</code></pre> <p>Alarm parameters.</p> <p>Parameters:</p> Name Type Description Default <code>alarm_min</code> <code>float</code> <p>The temperature below which the alarm is activated.</p> required <code>alarm_max</code> <code>float</code> <p>The temperature above which the alarm is activated.</p> required <code>ok_min</code> <code>float</code> <p>The minimum temperature difference from the setpoint for the temperature to be okay.</p> required <code>ok_max</code> <code>float</code> <p>The maximum temperature difference from the setpoint for the temperature to be okay.</p> required <code>limit_min</code> <code>float</code> <p>The minimum temperature below which the drive output is disabled.</p> required <code>limit_max</code> <code>float</code> <p>The maximum temperature above which the drive output is disabled.</p> required"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.AlarmType","title":"AlarmType","text":"<p>               Bases: <code>IntEnum</code></p> <p>Alarm type.</p> <p>Attributes:</p> Name Type Description <code>OFF</code> <code>int</code> <p>0</p> <code>MIN</code> <code>int</code> <p>1</p> <code>MAX</code> <code>int</code> <p>2</p> <code>BOTH</code> <code>int</code> <p>3</p>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.Control","title":"Control  <code>dataclass</code>","text":"<pre><code>Control(\n    type: ControlType,\n    p: float,\n    i: float,\n    d: float,\n    d_filter: float,\n    dead_band: float,\n    power_up_state: PowerUpState,\n)\n</code></pre> <p>The PID control parameters.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>ControlType</code> <p>The control type.</p> required <code>p</code> <code>float</code> <p>The proportional (gain) value. With a proportional control type, the controller output is proportional to the temperature error from the setpoint. The proportional terms sets the gain for this, i.e., <code>Output = setpoint-actual-temperature * proportional-term</code></p> required <code>i</code> <code>float</code> <p>The integral value. With integral action, the controller output is proportional to the amount of time the error is present. Integral action eliminates offset. The integral term is a time unit in seconds. NB for larger effects of integration reduce the integral time, also for operation without integral, integral time can be set to a large number, e.g. 1e6.</p> required <code>d</code> <code>float</code> <p>The derivative value. With derivative action, the controller output is proportional to the rate of change of the measurement or error. The controller output is calculated by the rate of change of the measurement with time, in seconds. To increase the derivative action increase the derivative value.</p> required <code>d_filter</code> <code>float</code> <p>The derivative filter is a low pass filter function on the derivative value. This allows the filtration of noise components which are a problem with a pure derivative function. The filter value should be set to be between 0 and 1.</p> required <code>dead_band</code> <code>float</code> <p>For use with On/Off control the dead band specifies the temperature range around the set point where the output is zero. For example:</p> <ul> <li>Temperature &gt; setpoint + dead_band (Fully Cooling)</li> <li>Temperature &lt; setpoint - dead_band (Fully Heating)</li> <li>Temperature &lt; setpoint + dead_band AND &gt; setpoint-dead_band (Output off)</li> </ul> required <code>power_up_state</code> <code>PowerUpState</code> <p>Temperature control state from power up.</p> required"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.ControlType","title":"ControlType","text":"<p>               Bases: <code>IntEnum</code></p> <p>Control type.</p> <p>Attributes:</p> Name Type Description <code>ON_OFF</code> <code>int</code> <p>Output drive is only fully on (heating or cooling) or off, <code>1</code>.</p> <code>P</code> <code>int</code> <p>Proportional, <code>2</code>.</p> <code>PI</code> <code>int</code> <p>Proportional and integral, <code>3</code>.</p> <code>PID</code> <code>int</code> <p>Proportional, integral and derivative, <code>4</code>.</p>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.Method","title":"Method","text":"<p>               Bases: <code>IntEnum</code></p> <p>Setpoint method type.</p> <p>The temperature setpoint can be set via software or by altering the potentiometer on the temperature controller hardware.</p> <p>Attributes:</p> Name Type Description <code>POTENTIOMETER</code> <code>int</code> <p>0</p> <code>SOFTWARE</code> <code>int</code> <p>1</p> <code>INPUT</code> <code>int</code> <p>2</p>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.Output","title":"Output  <code>dataclass</code>","text":"<pre><code>Output(\n    polarity: int | Polarity,\n    minimum: float,\n    maximum: float,\n    frequency: float,\n)\n</code></pre> <p>Output parameters.</p> <p>Parameters:</p> Name Type Description Default <code>polarity</code> <code>int | Polarity</code> <p>Output drive polarity.</p> required <code>minimum</code> <code>float</code> <p>The minimum value limit of the output. Range -100 to +100.</p> required <code>maximum</code> <code>float</code> <p>The maximum value limit of the output. Range -100 to +100.</p> required <code>frequency</code> <code>float</code> <p>Sets the pulse-width modulation repetition frequency of the output drive. Range 20 to 1000 Hz.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def __init__(self, polarity: int | Polarity, minimum: float, maximum: float, frequency: float) -&gt; None:\n    \"\"\"Output parameters.\n\n    Args:\n        polarity: Output drive polarity.\n        minimum: The minimum value limit of the output. Range -100 to +100.\n        maximum: The maximum value limit of the output. Range -100 to +100.\n        frequency: Sets the pulse-width modulation repetition frequency of the output drive.\n            Range 20 to 1000 Hz.\n    \"\"\"\n    if abs(minimum) &gt; 100:  # noqa: PLR2004\n        msg = f\"Invalid minimum={minimum}. Must be between -100 and +100\"\n        raise ValueError(msg)\n    if abs(maximum) &gt; 100:  # noqa: PLR2004\n        msg = f\"Invalid maximum={maximum}. Must be between -100 and +100\"\n        raise ValueError(msg)\n    if minimum &gt; maximum:\n        msg = f\"The minimum={minimum} value must be less than the maximum={maximum}\"\n        raise ValueError(msg)\n    if frequency &lt; 20 or frequency &gt; 1000:  # noqa: PLR2004\n        msg = f\"Invalid frequency={frequency}. Must be between 20 and 1000\"\n        raise ValueError(msg)\n\n    self.polarity: Polarity = to_enum(polarity, Polarity)\n    self.minimum: float = minimum\n    self.maximum: float = maximum\n    self.frequency: float = frequency\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.Polarity","title":"Polarity","text":"<p>               Bases: <code>IntEnum</code></p> <p>Output drive polarity.</p> <p>Attributes:</p> Name Type Description <code>NEGATIVE</code> <code>int</code> <p>0</p> <code>POSITIVE</code> <code>int</code> <p>1</p>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.PowerUpState","title":"PowerUpState","text":"<p>               Bases: <code>IntEnum</code></p> <p>Temperature control state from power up.</p> <p>Attributes:</p> Name Type Description <code>OFF</code> <code>int</code> <p>0</p> <code>ON</code> <code>int</code> <p>1</p> <code>LAST</code> <code>int</code> <p>2 (same as the last setting prior to power off)</p>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.Sensor","title":"Sensor  <code>dataclass</code>","text":"<pre><code>Sensor(\n    type: SensorType,\n    x2: float,\n    x: float,\n    c: float,\n    unit: Unit,\n    averaging: bool,\n    r: float = 22000.0,\n)\n</code></pre> <p>Sensor parameters.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>SensorType</code> <p>Sensor type.</p> required <code>x2</code> <code>float</code> <p>See <code>c</code> description.</p> required <code>x</code> <code>float</code> <p>See <code>c</code> description.</p> required <code>c</code> <code>float</code> <p>The <code>x2</code>, <code>x</code> and <code>c</code> parameters are the quadratic, linear and constant coefficients that are used to convert the sensor voltage into a temperature, i.e., <code>temperature = (v * v * x2) + (v * x) + c</code>, where <code>v</code> is the measured sensor voltage. For NTC thermistors, <code>x2</code> is the beta value as specified for the thermistor type, <code>x</code> is the resistance at \\(25~^\\circ\\text{C}\\), and <code>c</code> is still the offset.</p> required <code>unit</code> <code>Unit</code> <p>The temperature unit.</p> required <code>averaging</code> <code>bool</code> <p>Whether to enable or disable averaging.</p> required <code>r</code> <code>float</code> <p>Used for NTC or RES sensors and corresponds to the RL drive resistance.</p> <code>22000.0</code>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.SensorType","title":"SensorType","text":"<p>               Bases: <code>IntEnum</code></p> <p>Sensor type.</p> <p>Attributes:</p> Name Type Description <code>VOLTAGE</code> <code>int</code> <p>0</p> <code>PT100</code> <code>int</code> <p>1</p> <code>LM35</code> <code>int</code> <p>2</p> <code>LM50</code> <code>int</code> <p>3</p> <code>LM60</code> <code>int</code> <p>4</p> <code>LM61</code> <code>int</code> <p>5</p> <code>NTC_THERMISTOR</code> <code>int</code> <p>6</p> <code>RES</code> <code>int</code> <p>7</p> <code>PT1000</code> <code>int</code> <p>8</p> <code>RTD</code> <code>int</code> <p>9</p>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.Setpoint","title":"Setpoint  <code>dataclass</code>","text":"<pre><code>Setpoint(\n    method: Method,\n    value: float,\n    pot_range: float,\n    pot_offset: float,\n)\n</code></pre> <p>The setpoint parameters.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Method</code> <p>The setpoint method.</p> required <code>value</code> <code>float</code> <p>The setpoint value.</p> required <code>pot_range</code> <code>float</code> <p>The temperature range of the potentiometer.</p> required <code>pot_offset</code> <code>float</code> <p>The minimum temperature value of the potentiometer.</p> required"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.Status","title":"Status  <code>dataclass</code>","text":"<pre><code>Status(\n    setpoint: float,\n    temperature: float,\n    controlled: bool,\n    output: float,\n    alarm_type: AlarmType,\n    faults: int,\n    temp_ok: bool,\n    supply_v: float,\n    version: str,\n    test_cycles: float,\n    test_mode_completed: bool,\n)\n</code></pre> <p>Controller status.</p> <p>Parameters:</p> Name Type Description Default <code>setpoint</code> <code>float</code> <p>Setpoint value.</p> required <code>temperature</code> <code>float</code> <p>The measured temperature (for the specified Sensor Unit).</p> required <code>controlled</code> <code>bool</code> <p>Whether the temperature control drive is on or off.</p> required <code>output</code> <code>float</code> <p>The output value (between -100 and 100).</p> required <code>alarm_type</code> <code>AlarmType</code> <p>The type of alarm used.</p> required <code>faults</code> <code>int</code> <p>Fault flags.</p> <ul> <li>bit 0: ADC fault.</li> <li>bit 1: ADCR fault.</li> <li>bit 2: VDC limit.</li> <li>bit 3: Temperature limit.</li> <li>bit 4: Inhibited.</li> </ul> required <code>temp_ok</code> <code>bool</code> <p>Whether the temperature is ok (within range).</p> required <code>supply_v</code> <code>float</code> <p>The supply voltage.</p> required <code>version</code> <code>str</code> <p>The firmware version number of the controller.</p> required <code>test_cycles</code> <code>float</code> <p>The number of test cycles that have occurred.</p> required <code>test_mode_completed</code> <code>bool</code> <p>Whether the test has completed.</p> required"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries","title":"TCSeries","text":"<pre><code>TCSeries(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Serial</code></p> <p>Establishes a connection to a TC Series Temperature Controller from Electron Dynamics Ltd.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Establishes a connection to a TC Series Temperature Controller from Electron Dynamics Ltd.\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"\n    assert equipment.connection is not None  # noqa: S101\n    if not equipment.connection.properties:\n        # then use the default connection properties\n        equipment.connection.properties = {\n            \"baud_rate\": 19200,\n            \"write_termination\": None,\n            \"read_termination\": \"\\r\\n\",\n            \"timeout\": 10.0,\n        }\n    super().__init__(equipment)\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries.get_alarm","title":"get_alarm","text":"<pre><code>get_alarm() -&gt; Alarm\n</code></pre> <p>Get the alarm parameters.</p> <p>Returns:</p> Type Description <code>Alarm</code> <p>The alarm parameters.</p> Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def get_alarm(self) -&gt; Alarm:\n    \"\"\"Get the alarm parameters.\n\n    Returns:\n        The alarm parameters.\n    \"\"\"\n    a, b, c, d, e, f, g = map(float, self._reply(\"d\"))\n    return Alarm(\n        type=AlarmType(int(a)),\n        alarm_min=b,\n        alarm_max=c,\n        ok_min=d,\n        ok_max=e,\n        limit_min=f,\n        limit_max=g,\n    )\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries.get_control","title":"get_control","text":"<pre><code>get_control() -&gt; Control\n</code></pre> <p>Get the PID control parameters.</p> <p>Returns:</p> Type Description <code>Control</code> <p>The control parameters.</p> Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def get_control(self) -&gt; Control:\n    \"\"\"Get the PID control parameters.\n\n    Returns:\n        The control parameters.\n    \"\"\"\n    a, b, c, d, e, f, g = map(float, self._reply(\"b\"))\n    return Control(\n        type=ControlType(int(a)),\n        p=b,\n        i=c,\n        d=d,\n        d_filter=e,\n        dead_band=f,\n        power_up_state=PowerUpState(int(g)),\n    )\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries.get_output","title":"get_output","text":"<pre><code>get_output() -&gt; Output\n</code></pre> <p>Get the output parameters.</p> <p>Returns:</p> Type Description <code>Output</code> <p>The output parameters.</p> Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def get_output(self) -&gt; Output:\n    \"\"\"Get the output parameters.\n\n    Returns:\n        The output parameters.\n    \"\"\"\n    a, b, c, d = map(float, self._reply(\"h\"))\n    return Output(\n        polarity=Polarity(int(a)),\n        minimum=b,\n        maximum=c,\n        frequency=d,\n    )\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries.get_sensor","title":"get_sensor","text":"<pre><code>get_sensor() -&gt; Sensor\n</code></pre> <p>Get the sensor parameters.</p> <p>Returns:</p> Type Description <code>Sensor</code> <p>The sensor parameters.</p> Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def get_sensor(self) -&gt; Sensor:\n    \"\"\"Get the sensor parameters.\n\n    Returns:\n        The sensor parameters.\n    \"\"\"\n    data = list(map(float, self._reply(\"f\")))\n    return Sensor(\n        type=SensorType(int(data[0])),\n        x2=data[1],\n        x=data[2],\n        c=data[3],\n        unit=Unit(data[4]),\n        averaging=data[5] == 1,\n        r=0.0 if len(data) &lt; 7 else data[6],  # noqa: PLR2004\n    )\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries.get_setpoint","title":"get_setpoint","text":"<pre><code>get_setpoint() -&gt; Setpoint\n</code></pre> <p>Get the setpoint parameters.</p> <p>Returns:</p> Type Description <code>Setpoint</code> <p>The setpoint parameters.</p> Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def get_setpoint(self) -&gt; Setpoint:\n    \"\"\"Get the setpoint parameters.\n\n    Returns:\n        The setpoint parameters.\n    \"\"\"\n    a, b, c, d = map(float, self._reply(\"q\"))\n    return Setpoint(\n        method=Method(int(a)),\n        value=b,\n        pot_range=c,\n        pot_offset=d,\n    )\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries.get_status","title":"get_status","text":"<pre><code>get_status() -&gt; Status\n</code></pre> <p>Get the status.</p> <p>Returns:</p> Type Description <code>Status</code> <p>The status parameters.</p> Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def get_status(self) -&gt; Status:\n    \"\"\"Get the status.\n\n    Returns:\n        The status parameters.\n    \"\"\"\n    r = self._reply(\"j\")\n    return Status(\n        setpoint=float(r[0]),\n        temperature=float(r[1]),\n        controlled=r[2] == \"1\",\n        output=float(r[3]),\n        alarm_type=AlarmType(int(r[4])),\n        faults=int(r[5]),\n        temp_ok=r[6] == \"1\",\n        supply_v=float(r[7]),\n        version=r[8],\n        test_cycles=int(r[9]),\n        test_mode_completed=r[10] == \"1\",\n    )\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries.set_alarm","title":"set_alarm","text":"<pre><code>set_alarm(alarm: Alarm) -&gt; None\n</code></pre> <p>Set the alarm parameters.</p> <p>Parameters:</p> Name Type Description Default <code>alarm</code> <code>Alarm</code> <p>The alarm parameters.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def set_alarm(self, alarm: Alarm) -&gt; None:\n    \"\"\"Set the alarm parameters.\n\n    Args:\n        alarm: The alarm parameters.\n    \"\"\"\n    data = (\n        f\"{alarm.type};{alarm.alarm_min:.3f};{alarm.alarm_max:.3f};{alarm.ok_min:.3f};\"\n        f\"{alarm.ok_max:.3f};{alarm.limit_min:.3f};{alarm.limit_max:.3f};\"\n    )\n    self._send(\"c\", data)\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries.set_control","title":"set_control","text":"<pre><code>set_control(control: Control) -&gt; None\n</code></pre> <p>Set the PID control parameters.</p> <p>Parameters:</p> Name Type Description Default <code>control</code> <code>Control</code> <p>The control parameters.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def set_control(self, control: Control) -&gt; None:\n    \"\"\"Set the PID control parameters.\n\n    Args:\n        control: The control parameters.\n    \"\"\"\n    data = (\n        f\"{control.type};{control.p:.3f};{control.i:.3f};{control.d:.3f};\"\n        f\"{control.d_filter:.3f};{control.dead_band:.3f};{control.power_up_state};\"\n    )\n    self._send(\"a\", data)\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries.set_output","title":"set_output","text":"<pre><code>set_output(output: Output) -&gt; None\n</code></pre> <p>Set the output parameters.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>Output</code> <p>The output parameters.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def set_output(self, output: Output) -&gt; None:\n    \"\"\"Set the output parameters.\n\n    Args:\n        output: The output parameters.\n    \"\"\"\n    data = f\"{output.polarity};{output.minimum:.3f};{output.maximum:.3f};{output.frequency:.3f};\"\n    self._send(\"g\", data)\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries.set_output_drive","title":"set_output_drive","text":"<pre><code>set_output_drive(*, enable: bool, value: float) -&gt; None\n</code></pre> <p>Set the output drive state and value.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>Whether to enable or disable the output drive.</p> required <code>value</code> <code>float</code> <p>Percent drive output.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def set_output_drive(self, *, enable: bool, value: float) -&gt; None:\n    \"\"\"Set the output drive state and value.\n\n    Args:\n        enable: Whether to enable or disable the output drive.\n        value: Percent drive output.\n    \"\"\"\n    self._send(\"m\", f\"{int(enable)};{value:.3f};\")\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries.set_sensor","title":"set_sensor","text":"<pre><code>set_sensor(sensor: Sensor) -&gt; None\n</code></pre> <p>Set the sensor type and the sensor parameters.</p> <p>Parameters:</p> Name Type Description Default <code>sensor</code> <code>Sensor</code> <p>The sensor parameters.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def set_sensor(self, sensor: Sensor) -&gt; None:\n    \"\"\"Set the sensor type and the sensor parameters.\n\n    Args:\n        sensor: The sensor parameters.\n    \"\"\"\n    data = f\"{sensor.type};{sensor.x2:.3f};{sensor.x:.3f};{sensor.c:.3f};{sensor.unit};{int(sensor.averaging)};\"\n    if sensor.type in (SensorType.NTC_THERMISTOR, SensorType.RES):\n        data += f\"{sensor.r:.3f};\"\n    self._send(\"e\", data)\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries.set_setpoint","title":"set_setpoint","text":"<pre><code>set_setpoint(setpoint: Setpoint) -&gt; None\n</code></pre> <p>Set the setpoint parameters.</p> <p>Parameters:</p> Name Type Description Default <code>setpoint</code> <code>Setpoint</code> <p>The setpoint parameters.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def set_setpoint(self, setpoint: Setpoint) -&gt; None:\n    \"\"\"Set the setpoint parameters.\n\n    Args:\n        setpoint: The setpoint parameters.\n    \"\"\"\n    data = f\"{setpoint.method};{setpoint.value:.3f};{setpoint.pot_range:.3f};{setpoint.pot_offset:.3f};\"\n    self._send(\"i\", data)\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries.set_test","title":"set_test","text":"<pre><code>set_test(mode: int, *data: float) -&gt; None\n</code></pre> <p>Set the test parameters.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>int</code> <p>The test mode. One of:</p> <ul> <li><code>0</code>: Off</li> <li><code>1</code>: Normal</li> <li><code>2</code>: Temperature cycle</li> <li><code>3</code>: Temperature ramp</li> <li><code>4</code>: Auto tune</li> </ul> required <code>data</code> <code>float</code> <p>The test data.</p> <code>()</code> Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def set_test(self, mode: int, *data: float) -&gt; None:\n    \"\"\"Set the test parameters.\n\n    Args:\n        mode: The test mode. One of:\n\n            * `0`: Off\n            * `1`: Normal\n            * `2`: Temperature cycle\n            * `3`: Temperature ramp\n            * `4`: Auto tune\n\n        data: The test data.\n    \"\"\"\n    if mode &lt; 0 or mode &gt; 4:  # noqa: PLR2004\n        msg = f\"Invalid test mode={mode}. Must be 0, 1, 2, 3 or 4\"\n        raise ValueError(msg)\n\n    values = \";\".join(f\"{v:.3f}\" for v in data)\n    self._send(\"k\", f\"{mode};{values};\")\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.Unit","title":"Unit","text":"<p>               Bases: <code>Enum</code></p> <p>The temperature unit.</p> <p>Attributes:</p> Name Type Description <code>C</code> <code>str</code> <p>Celsius, <code>\"C\"</code>.</p> <code>F</code> <code>str</code> <p>Fahrenheit, <code>\"F\"</code>.</p> <code>K</code> <code>str</code> <p>Kelvin, <code>\"K\"</code>.</p> <code>V</code> <code>str</code> <p>Voltage, <code>\"V\"</code>.</p> <code>R</code> <code>str</code> <p>Resistance, <code>\"R\"</code>.</p>"},{"location":"resources/energetiq/eq99/","title":"EQ-99","text":"<p>Communicate with the EQ-99 Manager from Energetiq.</p>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99","title":"EQ99","text":"<pre><code>EQ99(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Serial</code></p> <p>Communicate with the EQ-99 Manager from Energetiq.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Communicate with the EQ-99 Manager from Energetiq.\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"\n    assert equipment.connection is not None  # noqa: S101\n    equipment.connection.properties.setdefault(\"baud_rate\", 38400)\n    super().__init__(equipment)\n    self.rstrip: bool = True\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.condition_register","title":"condition_register","text":"<pre><code>condition_register() -&gt; int\n</code></pre> <p>Query the LDLS condition register.</p> <p>The condition register reflects the state of the instrument at the time the condition register is read.</p> <p>The bit-mask sequence is as follows:</p> Bit Index Value Description 0 1 Interlock 1 2 Controller not detected 2 4 Controller fault 3 8 Lamp fault 4 16 Output on 5 32 Lamp on 6 64 Laser on 7 128 Laser stable 8 256 Shutter open <p>Returns:</p> Type Description <code>int</code> <p>The condition register value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def condition_register(self) -&gt; int:\n    \"\"\"Query the LDLS condition register.\n\n    The condition register reflects the state of the instrument\n    at the time the condition register is read.\n\n    The bit-mask sequence is as follows:\n\n    | Bit Index | Value | Description             |\n    | :-------: | :---: | :---------------------- |\n    |   0       |    1  | Interlock               |\n    |   1       |    2  | Controller not detected |\n    |   2       |    4  | Controller fault        |\n    |   3       |    8  | Lamp fault              |\n    |   4       |   16  | Output on               |\n    |   5       |   32  | Lamp on                 |\n    |   6       |   64  | Laser on                |\n    |   7       |  128  | Laser stable            |\n    |   8       |  256  | Shutter open            |\n\n    Returns:\n        The condition register value.\n    \"\"\"\n    return int(self.query(\"LDLS:COND?\"))\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.delay","title":"delay","text":"<pre><code>delay(milliseconds: int) -&gt; None\n</code></pre> <p>Specify a delay to use in command processing.</p> <p>Parameters:</p> Name Type Description Default <code>milliseconds</code> <code>int</code> <p>Causes command processing to be delayed for the specified number of milliseconds. Valid range is from 1 to 30000 milliseconds.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def delay(self, milliseconds: int) -&gt; None:\n    \"\"\"Specify a delay to use in command processing.\n\n    Args:\n        milliseconds: Causes command processing to be delayed for the specified number\n            of milliseconds. Valid range is from 1 to 30000 milliseconds.\n    \"\"\"\n    if not (1 &lt;= milliseconds &lt;= MAX_TIME):\n        msg = f\"Invalid delay of {milliseconds} milliseconds, must be in range [1, {MAX_TIME}]\"\n        raise ValueError(msg)\n    self._write_check(f\"DELAY {milliseconds}\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.event_register","title":"event_register","text":"<pre><code>event_register() -&gt; int\n</code></pre> <p>Query the LDLS event register.</p> <p>Returns the LDLS event register. The event register reflects the occurrence of any condition since the last time the event register was read. For example, if the output was turned on and then turned off, the Output on the bit in the condition register will be zero, but the same bit in the event register will be one.</p> <p>The bit-mask sequence is as follows:</p> Bit Index Value Description 0 1 Interlock 1 2 Controller not detected 2 4 Controller fault 3 8 Lamp fault 4 16 Output on 5 32 Lamp on 6 64 Laser on 7 128 Laser stable 8 256 Shutter open <p>Returns:</p> Type Description <code>int</code> <p>The event register value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def event_register(self) -&gt; int:\n    \"\"\"Query the LDLS event register.\n\n    Returns the LDLS event register. The event register reflects the\n    occurrence of any condition since the last time the event register\n    was read. For example, if the output was turned on and then turned off,\n    the Output on the bit in the condition register will be zero, but the\n    same bit in the event register will be one.\n\n    The bit-mask sequence is as follows:\n\n    | Bit Index | Value | Description             |\n    | :-------: | :---: | :---------------------- |\n    |   0       |    1  | Interlock               |\n    |   1       |    2  | Controller not detected |\n    |   2       |    4  | Controller fault        |\n    |   3       |    8  | Lamp fault              |\n    |   4       |   16  | Output on               |\n    |   5       |   32  | Lamp on                 |\n    |   6       |   64  | Laser on                |\n    |   7       |  128  | Laser stable            |\n    |   8       |  256  | Shutter open            |\n\n    Returns:\n        The event register value.\n    \"\"\"\n    return int(self.query(\"LDLS:EVENT?\"))\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.get_beep","title":"get_beep","text":"<pre><code>get_beep() -&gt; bool\n</code></pre> <p>Query whether beeps are enabled.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether beeps are enabled.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def get_beep(self) -&gt; bool:\n    \"\"\"Query whether beeps are enabled.\n\n    Returns:\n        Whether beeps are enabled.\n    \"\"\"\n    return bool(int(self.query(\"BEEP?\")))\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.get_brightness","title":"get_brightness","text":"<pre><code>get_brightness() -&gt; int\n</code></pre> <p>Query the display brightness.</p> <p>Returns:</p> Type Description <code>int</code> <p>Returns the value of the display brightness (between 0 and 100).</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def get_brightness(self) -&gt; int:\n    \"\"\"Query the display brightness.\n\n    Returns:\n        Returns the value of the display brightness (between 0 and 100).\n    \"\"\"\n    return int(self.query(\"BRIGHT?\"))\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.get_exposure_mode","title":"get_exposure_mode","text":"<pre><code>get_exposure_mode() -&gt; int\n</code></pre> <p>Query the exposure mode.</p> <p>Returns:</p> Type Description <code>int</code> <p>The exposure mode.</p> <ul> <li>0 \u2014 Manual mode</li> <li>1 \u2014 Exposure mode</li> </ul> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def get_exposure_mode(self) -&gt; int:\n    \"\"\"Query the exposure mode.\n\n    Returns:\n        The exposure mode.\n\n            * 0 &amp;mdash; Manual mode\n            * 1 &amp;mdash; Exposure mode\n    \"\"\"\n    return int(self.query(\"LDLS:EXPMODE?\"))\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.get_exposure_time","title":"get_exposure_time","text":"<pre><code>get_exposure_time() -&gt; int\n</code></pre> <p>Query the exposure time.</p> <p>Returns:</p> Type Description <code>int</code> <p>The exposure time, in milliseconds.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def get_exposure_time(self) -&gt; int:\n    \"\"\"Query the exposure time.\n\n    Returns:\n        The exposure time, in milliseconds.\n    \"\"\"\n    return int(self.query(\"LDLS:EXPOSURE?\"))\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.get_lamp_runtime","title":"get_lamp_runtime","text":"<pre><code>get_lamp_runtime() -&gt; float\n</code></pre> <p>Query the lamp runtime.</p> <p>Returns:</p> Type Description <code>float</code> <p>The number of hours accumulated while the lamp was on.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def get_lamp_runtime(self) -&gt; float:\n    \"\"\"Query the lamp runtime.\n\n    Returns:\n        The number of hours accumulated while the lamp was on.\n    \"\"\"\n    return float(self.query(\"LDLS:LAMPTIME?\"))\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.get_message_buffer","title":"get_message_buffer","text":"<pre><code>get_message_buffer() -&gt; str\n</code></pre> <p>Query the internal message buffer.</p> <p>Returns:</p> Type Description <code>str</code> <p>The value of the internal message buffer.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def get_message_buffer(self) -&gt; str:\n    \"\"\"Query the internal message buffer.\n\n    Returns:\n        The value of the internal message buffer.\n    \"\"\"\n    return self.query(\"MESSAGE?\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.get_output_state","title":"get_output_state","text":"<pre><code>get_output_state() -&gt; bool\n</code></pre> <p>Query the output state.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the output is enabled or disabled.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def get_output_state(self) -&gt; bool:\n    \"\"\"Query the output state.\n\n    Returns:\n        Whether the output is enabled or disabled.\n    \"\"\"\n    return bool(int(self.query(\"LDLS:OUTPUT?\")))\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.get_remote_mode_error","title":"get_remote_mode_error","text":"<pre><code>get_remote_mode_error() -&gt; bool\n</code></pre> <p>Query whether errors are displayed while in remote mode.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether errors are displayed while in remote mode.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def get_remote_mode_error(self) -&gt; bool:\n    \"\"\"Query whether errors are displayed while in remote mode.\n\n    Returns:\n        Whether errors are displayed while in remote mode.\n    \"\"\"\n    return bool(int(self.query(\"REMERR?\")))\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.get_shutter_power_up_state","title":"get_shutter_power_up_state","text":"<pre><code>get_shutter_power_up_state() -&gt; bool\n</code></pre> <p>Query the power-up shutter state.</p> <p>Returns:</p> Type Description <code>bool</code> <p>The power-up shutter state.</p> <ul> <li><code>False</code> \u2014 Shutter is closed on power-up</li> <li><code>True</code> \u2014 Shutter is open on power-up</li> </ul> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def get_shutter_power_up_state(self) -&gt; bool:\n    \"\"\"Query the power-up shutter state.\n\n    Returns:\n        The power-up shutter state.\n\n            * `False` &amp;mdash; Shutter is closed on power-up\n            * `True` &amp;mdash; Shutter is open on power-up\n    \"\"\"\n    return bool(int(self.query(\"LDLS:SHUTINIT?\")))\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.get_shutter_state","title":"get_shutter_state","text":"<pre><code>get_shutter_state() -&gt; bool\n</code></pre> <p>Query the shutter state.</p> <p>Returns:</p> Type Description <code>bool</code> <p>The state of the shutter.</p> <ul> <li><code>False</code> \u2014 Shutter is closed</li> <li><code>True</code> \u2014 Shutter is open</li> </ul> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def get_shutter_state(self) -&gt; bool:\n    \"\"\"Query the shutter state.\n\n    Returns:\n        The state of the shutter.\n\n            * `False` &amp;mdash; Shutter is closed\n            * `True` &amp;mdash; Shutter is open\n    \"\"\"\n    return bool(int(self.query(\"LDLS:SHUTTER?\")))\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.get_termination","title":"get_termination","text":"<pre><code>get_termination() -&gt; int\n</code></pre> <p>Query response terminator.</p> <p>Returns the current response terminator setting. See set_termination for possible return values.</p> <p>Returns:</p> Type Description <code>int</code> <p>The response terminator.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def get_termination(self) -&gt; int:\n    \"\"\"Query response terminator.\n\n    Returns the current response terminator setting. See\n    [set_termination][msl.equipment_resources.energetiq.eq99.EQ99.set_termination]\n    for possible return values.\n\n    Returns:\n        The response terminator.\n    \"\"\"\n    return int(self.query(\"TERM?\"))\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.get_trigger_mode","title":"get_trigger_mode","text":"<pre><code>get_trigger_mode() -&gt; int\n</code></pre> <p>Query the trigger mode.</p> <p>Returns:</p> Type Description <code>int</code> <p>The trigger mode. See set_trigger_mode for more details.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def get_trigger_mode(self) -&gt; int:\n    \"\"\"Query the trigger mode.\n\n    Returns:\n        The trigger mode. See [set_trigger_mode][msl.equipment_resources.energetiq.eq99.EQ99.set_trigger_mode]\n            for more details.\n    \"\"\"\n    return int(self.query(\"LDLS:TRIGMODE?\"))\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.identity","title":"identity","text":"<pre><code>identity() -&gt; str\n</code></pre> <p>Query the instrument identification.</p> <p>Returns:</p> Type Description <code>str</code> <p>Returns the identification string for the instrument in the following format: Energetiq Model SN Ver Build</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def identity(self) -&gt; str:\n    \"\"\"Query the instrument identification.\n\n    Returns:\n        Returns the identification string for the instrument in the following format:\n            *Energetiq Model SN Ver Build*\n    \"\"\"\n    return self.query(\"*IDN?\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Resets the instrument to factory defaults and the output is shut off.</p> <p>The unit remains in remote mode.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Resets the instrument to factory defaults and the output is shut off.\n\n    The unit remains in remote mode.\n    \"\"\"\n    _ = self._write_check(\"*RST\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.serial_number","title":"serial_number","text":"<pre><code>serial_number() -&gt; str\n</code></pre> <p>Query the serial number of the instrument.</p> <p>Returns:</p> Type Description <code>str</code> <p>The serial number of the instrument. This is the same information that is part of the <code>*IDN?</code> query.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def serial_number(self) -&gt; str:\n    \"\"\"Query the serial number of the instrument.\n\n    Returns:\n        The serial number of the instrument. This is the same information that is part of the `*IDN?` query.\n    \"\"\"\n    return self.query(\"SN?\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.set_beep","title":"set_beep","text":"<pre><code>set_beep(beep: bool | int = 2) -&gt; None\n</code></pre> <p>Set the beep value.</p> <p>Parameters:</p> Name Type Description Default <code>beep</code> <code>bool | int</code> <p>Causes the instrument to beep, or enables or disabled the beep sound for error messages and other events that generate and audible response.</p> <ul> <li>0 or <code>False</code> \u2014 Disable the beep sound</li> <li>1 or <code>True</code> \u2014 Enable the beep sound</li> <li>2 \u2014 Generate one beep</li> </ul> <code>2</code> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def set_beep(self, beep: bool | int = 2) -&gt; None:  # noqa: FBT001\n    \"\"\"Set the beep value.\n\n    Args:\n        beep: Causes the instrument to beep, or enables or disabled the beep\n            sound for error messages and other events that generate and\n            audible response.\n\n            * 0 or `False` &amp;mdash; Disable the beep sound\n            * 1 or `True` &amp;mdash; Enable the beep sound\n            * 2 &amp;mdash; Generate one beep\n    \"\"\"\n    if beep not in [0, 1, 2, True, False]:\n        msg = f\"Invalid beep value '{beep}'\"\n        raise MSLConnectionError(self, msg)\n    self._write_check(f\"BEEP {beep}\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.set_brightness","title":"set_brightness","text":"<pre><code>set_brightness(brightness: int) -&gt; None\n</code></pre> <p>Set the display brightness.</p> <p>Parameters:</p> Name Type Description Default <code>brightness</code> <code>int</code> <p>Sets the display brightness level from 0 to 100 percent. There are only 8 brightness levels (each separated by about 12.5 percent) and the brightness value is used to select an appropriate level.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def set_brightness(self, brightness: int) -&gt; None:\n    \"\"\"Set the display brightness.\n\n    Args:\n        brightness: Sets the display brightness level from 0 to 100 percent.\n            There are only 8 brightness levels (each separated by about\n            12.5 percent) and the brightness value is used to select an\n            appropriate level.\n    \"\"\"\n    self._write_check(f\"BRIGHT {int(brightness)}\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.set_exposure_mode","title":"set_exposure_mode","text":"<pre><code>set_exposure_mode(mode: int) -&gt; None\n</code></pre> <p>Set the exposure mode.</p> <p>Same as the Shutter setting in the menu.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>int</code> <p>The exposure mode.</p> <ul> <li>0 \u2014 Manual mode</li> <li>1 \u2014 Exposure mode</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def set_exposure_mode(self, mode: int) -&gt; None:\n    \"\"\"Set the exposure mode.\n\n    Same as the *Shutter* setting in the menu.\n\n    Args:\n        mode: The exposure mode.\n\n            * 0 &amp;mdash; Manual mode\n            * 1 &amp;mdash; Exposure mode\n    \"\"\"\n    self._write_check(f\"LDLS:EXPMODE {mode}\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.set_exposure_time","title":"set_exposure_time","text":"<pre><code>set_exposure_time(milliseconds: int) -&gt; None\n</code></pre> <p>Set the exposure time.</p> <p>Exposure time is used when the shutter exposure mode is set to <code>Exposure mode</code> (see set_exposure_mode). An exposure is triggered by a shutter button press or the shutter trigger input.</p> <p>Parameters:</p> Name Type Description Default <code>milliseconds</code> <code>int</code> <p>The exposure time, in milliseconds, from 100 to 30000 ms.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def set_exposure_time(self, milliseconds: int) -&gt; None:\n    \"\"\"Set the exposure time.\n\n    Exposure time is used when the shutter exposure mode is set to `Exposure mode`\n    (see [set_exposure_mode][msl.equipment_resources.energetiq.eq99.EQ99.set_exposure_mode]).\n    An exposure is triggered by a shutter button press or the shutter trigger input.\n\n    Args:\n        milliseconds: The exposure time, in milliseconds, from 100 to 30000 ms.\n    \"\"\"\n    if not (MIN_EXPOSURE_TIME &lt;= milliseconds &lt;= MAX_TIME):\n        msg = (\n            f\"Invalid exposure time of {milliseconds} milliseconds, \"\n            f\"must be in range [{MIN_EXPOSURE_TIME}, {MAX_TIME}]\"\n        )\n        raise ValueError(msg)\n    self._write_check(f\"LDLS:EXPOSURE {milliseconds}\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.set_lamp_runtime","title":"set_lamp_runtime","text":"<pre><code>set_lamp_runtime(hours: float) -&gt; None\n</code></pre> <p>Set the lamp runtime.</p> <p>Resets the runtime to the new value. Useful for resetting the runtime to zero when the lamp has been serviced or replaced, or when moving the manager to a new LDLS system.</p> <p>Parameters:</p> Name Type Description Default <code>hours</code> <code>float</code> <p>The lamp runtime, in hours, between 0 and 9999.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def set_lamp_runtime(self, hours: float) -&gt; None:\n    \"\"\"Set the lamp runtime.\n\n    Resets the runtime to the new value. Useful for resetting the runtime\n    to zero when the lamp has been serviced or replaced, or when moving\n    the manager to a new LDLS system.\n\n    Args:\n        hours: The lamp runtime, in hours, between 0 and 9999.\n    \"\"\"\n    if not (0 &lt;= hours &lt;= MAX_RUNTIME):\n        msg = f\"Invalid lamp runtime of {hours} hours, must be in range [0, {MAX_RUNTIME}]\"\n        raise ValueError(msg)\n    self._write_check(f\"LDLS:LAMPTIME {hours}\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.set_message_buffer","title":"set_message_buffer","text":"<pre><code>set_message_buffer(message: str) -&gt; None\n</code></pre> <p>Set the message buffer.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Sets the internal message buffer, up to a maximum of 16 characters. If more than 16 characters are specified then the additional characters are silently ignored.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def set_message_buffer(self, message: str) -&gt; None:\n    \"\"\"Set the message buffer.\n\n    Args:\n        message: Sets the internal message buffer, up to a maximum of 16 characters. If more than\n            16 characters are specified then the additional characters are silently ignored.\n    \"\"\"\n    self._write_check(f\"MESSAGE {message}\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.set_output_state","title":"set_output_state","text":"<pre><code>set_output_state(enable: bool) -&gt; None\n</code></pre> <p>Turn the output on or off.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>Whether to enable or disable the output.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def set_output_state(self, enable: bool) -&gt; None:  # noqa: FBT001\n    \"\"\"Turn the output on or off.\n\n    Args:\n        enable: Whether to enable or disable the output.\n    \"\"\"\n    self._write_check(f\"LDLS:OUTPUT {enable}\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.set_remote_mode_error","title":"set_remote_mode_error","text":"<pre><code>set_remote_mode_error(enable: bool | int) -&gt; None\n</code></pre> <p>Set whether to display errors while in remote mode.</p> <p>This command controls if the instrument will display errors while in remote mode. If set to <code>0</code>/<code>False</code>, then errors will not be displayed. If set to <code>1</code>/<code>True</code>, errors will be displayed. Errors will always accumulate in the error queue.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool | int</code> <p>Whether to display errors while in remote mode.</p> <ul> <li>0 or <code>False</code> \u2014 Do not display errors in remote mode</li> <li>1 or <code>True</code> \u2014 Display errors in remote mode</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def set_remote_mode_error(self, enable: bool | int) -&gt; None:  # noqa: FBT001\n    \"\"\"Set whether to display errors while in remote mode.\n\n    This command controls if the instrument will display errors while in\n    remote mode. If set to `0`/`False`, then errors will not be displayed. If\n    set to `1`/`True`, errors will be displayed. Errors will always accumulate\n    in the error queue.\n\n    Args:\n        enable: Whether to display errors while in remote mode.\n\n            * 0 or `False` &amp;mdash; Do not display errors in remote mode\n            * 1 or `True` &amp;mdash; Display errors in remote mode\n    \"\"\"\n    self._write_check(f\"REMERR {enable}\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.set_shutter_power_up_state","title":"set_shutter_power_up_state","text":"<pre><code>set_shutter_power_up_state(state: bool) -&gt; None\n</code></pre> <p>Set the power-up shutter state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>Sets the initial state of the shutter on power-up of the manager.</p> <ul> <li><code>False</code> \u2014 Shutter is closed on power-up</li> <li><code>True</code> \u2014 Shutter is open on power-up</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def set_shutter_power_up_state(self, state: bool) -&gt; None:  # noqa: FBT001\n    \"\"\"Set the power-up shutter state.\n\n    Args:\n        state: Sets the initial state of the shutter on power-up of the manager.\n\n            * `False` &amp;mdash; Shutter is closed on power-up\n            * `True` &amp;mdash; Shutter is open on power-up\n    \"\"\"\n    self._write_check(f\"LDLS:SHUTINIT {state}\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.set_shutter_state","title":"set_shutter_state","text":"<pre><code>set_shutter_state(state: bool) -&gt; None\n</code></pre> <p>Open, close, or trigger the shutter.</p> <p>A close command (state is <code>False</code>) will always close the shutter, regardless of exposure mode. An open command (state is <code>True</code>) will open the shutter if exposure mode is set to Manual, or trigger a shutter if exposure mode is set to Exposure.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>The state of the shutter.</p> <ul> <li><code>False</code> \u2014 Close the shutter</li> <li><code>True</code> \u2014 Open or trigger the shutter</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def set_shutter_state(self, state: bool) -&gt; None:  # noqa: FBT001\n    \"\"\"Open, close, or trigger the shutter.\n\n    A close command (state is `False`) will always close the shutter,\n    regardless of exposure mode. An open command (state is `True`)\n    will open the shutter if exposure mode is set to *Manual*, or\n    trigger a shutter if exposure mode is set to *Exposure*.\n\n    Args:\n        state: The state of the shutter.\n\n            * `False` &amp;mdash; Close the shutter\n            * `True` &amp;mdash; Open or trigger the shutter\n    \"\"\"\n    self._write_check(f\"LDLS:SHUTTER {state}\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.set_termination","title":"set_termination","text":"<pre><code>set_termination(value: int) -&gt; None\n</code></pre> <p>Set the response terminator character(s).</p> <p>This command controls the termination characters used for responses to queries.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The response terminator character(s).</p> <ul> <li>0 or 1 \u2014 <code>&lt;CR&gt;&lt;LF&gt;</code></li> <li>2 or 3 \u2014 <code>&lt;CR&gt;</code></li> <li>4 or 5 \u2014 <code>&lt;LF&gt;</code></li> <li>6 or 7 \u2014 no terminator</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def set_termination(self, value: int) -&gt; None:\n    \"\"\"Set the response terminator character(s).\n\n    This command controls the termination characters used for\n    responses to queries.\n\n    Args:\n        value: The response terminator character(s).\n\n            * 0 or 1 &amp;mdash; `&lt;CR&gt;&lt;LF&gt;`\n            * 2 or 3 &amp;mdash; `&lt;CR&gt;`\n            * 4 or 5 &amp;mdash; `&lt;LF&gt;`\n            * 6 or 7 &amp;mdash; no terminator\n    \"\"\"\n    self._write_check(f\"TERM {value}\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.set_trigger_mode","title":"set_trigger_mode","text":"<pre><code>set_trigger_mode(mode: int) -&gt; None\n</code></pre> <p>Set the trigger mode.</p> <p>The trigger mode controls how the shutter trigger input controls the operation of the shutter. For more information on trigger modes, see Shutter Operation in the Operating the Instrument section of the manual for more details.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>int</code> <p>The trigger mode.</p> <ul> <li>0 \u2014 Positive edge trigger</li> <li>1 \u2014 Negative edge trigger</li> <li>2 \u2014 Positive level trigger</li> <li>3 \u2014 Negative level trigger</li> <li>4 \u2014 Off (trigger disabled)</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def set_trigger_mode(self, mode: int) -&gt; None:\n    \"\"\"Set the trigger mode.\n\n    The trigger mode controls how the shutter trigger input controls the\n    operation of the shutter. For more information on trigger modes, see\n    *Shutter Operation* in the *Operating the Instrument* section of the\n    manual for more details.\n\n    Args:\n        mode: The trigger mode.\n\n            * 0 &amp;mdash; Positive edge trigger\n            * 1 &amp;mdash; Negative edge trigger\n            * 2 &amp;mdash; Positive level trigger\n            * 3 &amp;mdash; Negative level trigger\n            * 4 &amp;mdash; Off (trigger disabled)\n    \"\"\"\n    self._write_check(f\"LDLS:TRIGMODE {mode}\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.timer","title":"timer","text":"<pre><code>timer() -&gt; str\n</code></pre> <p>Query the elapsed time since the last time this method was called.</p> <p>Returns:</p> Type Description <code>str</code> <p>Returns the elapsed time since the last time this method was called, or, if this is the first time calling this method then the time since unit has been turned on. Format is in HH:MM:SS.ss, where HH is hours, MM is minutes, SS is seconds, and ss is hundredths of a second.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def timer(self) -&gt; str:\n    \"\"\"Query the elapsed time since the last time this method was called.\n\n    Returns:\n        Returns the elapsed time since the last time this method was\n            called, or, if this is the first time calling this method\n            then the time since unit has been turned on. Format is in\n            HH:MM:SS.ss, where HH is hours, MM is minutes, SS is seconds,\n            and ss is hundredths of a second.\n    \"\"\"\n    return self.query(\"TIMER?\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.unit_runtime","title":"unit_runtime","text":"<pre><code>unit_runtime() -&gt; str\n</code></pre> <p>Query unit run time.</p> <p>Returns:</p> Type Description <code>str</code> <p>Returns the elapsed time since the unit has been turned on. Format is in HH:MM:SS.ss, where HH is hours, MM is minutes, SS is seconds, and ss is hundredths of a second.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def unit_runtime(self) -&gt; str:\n    \"\"\"Query unit run time.\n\n    Returns:\n        Returns the elapsed time since the unit has been turned on.\n            Format is in HH:MM:SS.ss, where HH is hours, MM is minutes,\n            SS is seconds, and ss is hundredths of a second.\n    \"\"\"\n    return self.query(\"TIME?\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.version","title":"version","text":"<pre><code>version() -&gt; str\n</code></pre> <p>Query the firmware version.</p> <p>Returns:</p> Type Description <code>str</code> <p>Returns the firmware version. This is the same information that is part of the <code>*IDN?</code> query.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def version(self) -&gt; str:\n    \"\"\"Query the firmware version.\n\n    Returns:\n        Returns the firmware version. This is the same information that is part of the `*IDN?` query.\n    \"\"\"\n    return self.query(\"VER?\")\n</code></pre>"},{"location":"resources/greisinger/gmh3000/","title":"GMH 3000 Series thermometer","text":"<p>Communicate with a Greisinger GMH 3000 Series thermometer.</p>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000","title":"GMH3000","text":"<pre><code>GMH3000(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Serial</code></p> <p>Communicate with a Greisinger GMH 3000 Series thermometer.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for a GMH thermometer.</p> <p>Connection Properties:</p> Name Type Description <code>gmh_address</code> <code>int</code> <p>The GMH address of the device. Default: <code>1</code></p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Communicate with a Greisinger GMH 3000 Series thermometer.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for a GMH thermometer.\n\n    Attributes: Connection Properties:\n        gmh_address (int): The GMH address of the device. _Default: `1`_\n    \"\"\"\n    assert equipment.connection is not None  # noqa: S101\n    props = equipment.connection.properties\n    props.setdefault(\"baud_rate\", 4800)\n    super().__init__(equipment)\n\n    # termination characters are not used\n    self.read_termination: None = None\n    self.write_termination: None = None\n\n    self._address: int = self._invert(int(props.get(\"gmh_address\", 1)))\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.channel_count","title":"channel_count","text":"<pre><code>channel_count() -&gt; int\n</code></pre> <p>Get the number of channels.</p> <p>Returns:</p> Type Description <code>int</code> <p>The channel count.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def channel_count(self) -&gt; int:\n    \"\"\"Get the number of channels.\n\n    Returns:\n        The channel count.\n    \"\"\"\n    reply = self._get(code=208)\n    return self._to_uint16(*reply[3:5])\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.clear_max_value","title":"clear_max_value","text":"<pre><code>clear_max_value() -&gt; float\n</code></pre> <p>Clear the maximum value stored in the device memory.</p> <p>Returns:</p> Type Description <code>float</code> <p>The current value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def clear_max_value(self) -&gt; float:\n    \"\"\"Clear the maximum value stored in the device memory.\n\n    Returns:\n        The current value.\n    \"\"\"\n    # used Wireshark with the USBPcap plugin to eavesdrop on the\n    # GMH_Transmit(1, 175, 0, 0.0, 1) call of the DLL to get the\n    # hex values and message lengths\n    code, value = self._invert(175), 1\n    _ = self.write(\n        bytes(\n            [\n                self._address,\n                0xF6,\n                self._crc(self._address, 0xF6),\n                code,\n                value,\n                self._crc(code, value),\n                0x00,\n                0xFF,\n                0x0C,\n                0x00,\n                0xFF,\n                0x0C,\n            ]\n        )\n    )\n    reply = self.read(size=12, decode=False)\n    self._check_crc(reply)\n    return self._decode32(*reply[6:8], *reply[9:11])\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.clear_min_value","title":"clear_min_value","text":"<pre><code>clear_min_value() -&gt; float\n</code></pre> <p>Clear the minimum value stored in the device memory.</p> <p>Returns:</p> Type Description <code>float</code> <p>The current value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def clear_min_value(self) -&gt; float:\n    \"\"\"Clear the minimum value stored in the device memory.\n\n    Returns:\n        The current value.\n    \"\"\"\n    # used Wireshark with the USBPcap plugin to eavesdrop on the\n    # GMH_Transmit(1, 174, 0, 0.0, 1) call of the DLL to get the\n    # hex values and message lengths\n    code, value = self._invert(174), 1\n    _ = self.write(\n        bytes(\n            [\n                self._address,\n                0xF6,\n                self._crc(self._address, 0xF6),\n                code,\n                value,\n                self._crc(code, value),\n                0x00,\n                0xFF,\n                0x0C,\n                0x00,\n                0xFF,\n                0x0C,\n            ]\n        )\n    )\n    reply = self.read(size=12, decode=False)\n    self._check_crc(reply)\n    return self._decode32(*reply[6:8], *reply[9:11])\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.display_range","title":"display_range","text":"<pre><code>display_range() -&gt; tuple[float, float]\n</code></pre> <p>Get the range of the display.</p> <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>The <code>(minimum, maximum)</code> value that the device can display.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def display_range(self) -&gt; tuple[float, float]:\n    \"\"\"Get the range of the display.\n\n    Returns:\n        The `(minimum, maximum)` value that the device can display.\n    \"\"\"\n    reply = self._get(code=200)\n    minimum = self._decode32(*reply[3:5], *reply[6:8])\n    reply = self._get(code=201)\n    maximum = self._decode32(*reply[3:5], *reply[6:8])\n    return minimum, maximum\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.firmware_version","title":"firmware_version","text":"<pre><code>firmware_version() -&gt; tuple[int, int]\n</code></pre> <p>Get the version information of the firmware.</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>The version number, version identifier.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def firmware_version(self) -&gt; tuple[int, int]:\n    \"\"\"Get the version information of the firmware.\n\n    Returns:\n        The version number, version identifier.\n    \"\"\"\n    reply = self._get(code=254)\n    return reply[4], self._invert(reply[3])\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.id_number","title":"id_number","text":"<pre><code>id_number() -&gt; str\n</code></pre> <p>Get the device ID (serial) number.</p> <p>Returns:</p> Type Description <code>str</code> <p>The ID (serial) number of the device.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def id_number(self) -&gt; str:\n    \"\"\"Get the device ID (serial) number.\n\n    Returns:\n        The ID (serial) number of the device.\n    \"\"\"\n    reply = self._get(code=12)\n    a = self._to_uint16(*reply[:2])\n    b = self._to_uint16(*reply[3:5])\n    return f\"{self._to_uint32(a, b):x}\"\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.max_value","title":"max_value","text":"<pre><code>max_value() -&gt; float\n</code></pre> <p>Get the maximum value that has been read.</p> <p>Returns:</p> Type Description <code>float</code> <p>The maximum value that has been read since the device was turned on or since clear_max_value was called.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def max_value(self) -&gt; float:\n    \"\"\"Get the maximum value that has been read.\n\n    Returns:\n        The maximum value that has been read since the device was turned on or since\n            [clear_max_value][msl.equipment_resources.greisinger.gmh3000.GMH3000.clear_max_value]\n            was called.\n    \"\"\"\n    return self._decode(self._get(code=7))\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.measurement_range","title":"measurement_range","text":"<pre><code>measurement_range() -&gt; tuple[float, float]\n</code></pre> <p>Get the measurement range.</p> <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>The <code>(minimum, maximum)</code> value that the device can measure.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def measurement_range(self) -&gt; tuple[float, float]:\n    \"\"\"Get the measurement range.\n\n    Returns:\n        The `(minimum, maximum)` value that the device can measure.\n    \"\"\"\n    reply = self._get(code=176)\n    minimum = self._decode16(*reply[3:5])\n    reply = self._get(code=177)\n    maximum = self._decode16(*reply[3:5])\n    return minimum, maximum\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.min_value","title":"min_value","text":"<pre><code>min_value() -&gt; float\n</code></pre> <p>Get the minimum value that has been read.</p> <p>Returns:</p> Type Description <code>float</code> <p>The minimum value that has been read since the device was turned on or since clear_min_value was called.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def min_value(self) -&gt; float:\n    \"\"\"Get the minimum value that has been read.\n\n    Returns:\n        The minimum value that has been read since the device was turned on or since\n            [clear_min_value][msl.equipment_resources.greisinger.gmh3000.GMH3000.clear_min_value]\n            was called.\n    \"\"\"\n    return self._decode(self._get(code=6))\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.offset_correction","title":"offset_correction","text":"<pre><code>offset_correction() -&gt; float\n</code></pre> <p>Get the offset-correction value.</p> <p>The zero point (intercept in a linear calibration equation) of the measurement will be displaced by this value to compensate for deviations in the temperature probe or in the measuring device.</p> <p>Returns:</p> Type Description <code>float</code> <p>The offset-correction value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def offset_correction(self) -&gt; float:\n    \"\"\"Get the offset-correction value.\n\n    The zero point (intercept in a linear calibration equation) of the\n    measurement will be displaced by this value to compensate for\n    deviations in the temperature probe or in the measuring device.\n\n    Returns:\n        The offset-correction value.\n    \"\"\"\n    reply = self._get(code=216)\n    return self._decode16(*reply[3:5])\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.power_off_time","title":"power_off_time","text":"<pre><code>power_off_time() -&gt; int\n</code></pre> <p>Get the power-off time.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of minutes that the device will automatically power off as soon as this time has elapsed if no key is pressed or if no interface communication takes place. A value of 0 means that power off is disabled.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def power_off_time(self) -&gt; int:\n    \"\"\"Get the power-off time.\n\n    Returns:\n        The number of minutes that the device will automatically power off as soon as\n            this time has elapsed if no key is pressed or if no interface communication\n            takes place. A value of 0 means that power off is disabled.\n    \"\"\"\n    reply = self._get(code=222)\n    return self._to_uint16(*reply[3:5])\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.resolution","title":"resolution","text":"<pre><code>resolution() -&gt; int\n</code></pre> <p>Get the measurement resolution.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of digits after the decimal point that is acquired for the measured value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def resolution(self) -&gt; int:\n    \"\"\"Get the measurement resolution.\n\n    Returns:\n        The number of digits after the decimal point that is acquired for the measured value.\n    \"\"\"\n    # The manual says to use code=204, however, using Wireshark to eavesdrop\n    # on the GMH_Transmit(address, 204, ...) DLL call the actual code sent\n    # is 0, which is the code to read the nominal value\n    reply = self._get(code=0)\n    return (self._invert(reply[0]) &gt;&gt; 3) - 15\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.scale_correction","title":"scale_correction","text":"<pre><code>scale_correction() -&gt; float\n</code></pre> <p>Get the scale-correction factor.</p> <p>The scale (slope in a linear calibration equation) of the measurement will be changed by this factor to compensate for deviations in the temperature probe or in the measuring device.</p> <p>Returns:</p> Type Description <code>float</code> <p>The scale-correction factor.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def scale_correction(self) -&gt; float:\n    \"\"\"Get the scale-correction factor.\n\n    The scale (slope in a linear calibration equation) of the measurement\n    will be changed by this factor to compensate for deviations in the\n    temperature probe or in the measuring device.\n\n    Returns:\n        The scale-correction factor.\n    \"\"\"\n    reply = self._get(code=214)\n    return self._decode16(*reply[3:5])\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.set_power_off_time","title":"set_power_off_time","text":"<pre><code>set_power_off_time(minutes: int) -&gt; int\n</code></pre> <p>Set the power-off time.</p> <p>Parameters:</p> Name Type Description Default <code>minutes</code> <code>int</code> <p>The number of minutes that the device will automatically power off as soon as this time has elapsed if no key is pressed or if no interface communication takes place. A value of 0 means that power off is disabled.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The actual power-off time that the device was set to. If you set the power-off time to a value greater than the maximum time allowed, the device automatically coerces the value to be the maximum time.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def set_power_off_time(self, minutes: int) -&gt; int:\n    \"\"\"Set the power-off time.\n\n    Args:\n        minutes: The number of minutes that the device will automatically power off\n            as soon as this time has elapsed if no key is pressed or if no interface\n            communication takes place. A value of 0 means that power off is disabled.\n\n    Returns:\n        The actual power-off time that the device was set to. If you set\n            the power-off time to a value greater than the maximum time allowed,\n            the device automatically coerces the value to be the maximum time.\n    \"\"\"\n    # used Wireshark with the USBPcap plugin to eavesdrop on the\n    # GMH_Transmit(1, 223, 0, 0.0, minutes) call of the DLL to get the\n    # hex values and message lengths\n    code = self._invert(223)\n    _ = self.write(\n        bytes(\n            [\n                self._address,\n                0xF4,\n                self._crc(self._address, 0xF4),\n                code,\n                0x00,\n                self._crc(code, 0x00),\n                0xFF,\n                minutes,\n                self._crc(0xFF, minutes),\n            ]\n        )\n    )\n    reply = self.read(size=9, decode=False)\n    self._check_crc(reply)\n    # do not check if reply[7]==minutes and raise an exception if not equal\n    # because if, for example, minutes=121 the device will automatically\n    # set the power-off time to the maximum value that it supports (120) and\n    # raising an exception would be very confusing to the end user because\n    # the power-off value has changed, but not to the expected value. It's\n    # better to mention in the docstring that the returned value is what\n    # actually happened so the end user can do their own checks.\n    return reply[7]\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.status","title":"status","text":"<pre><code>status() -&gt; int\n</code></pre> <p>Get the system status.</p> <p>The status value represents a bit mask:</p> Bit Index Value Description 0 1 Max. alarm 1 2 Min. alarm 2 4 Display over range 3 8 Display under range 4 16 Reserved 5 32 Reserved 6 64 Reserved 7 128 Reserved 8 256 Measuring over range 9 512 Measuring under range 10 1024 Sensor error 11 2048 Reserved 12 4096 System fault 13 8192 Calculation not possible 14 16384 Reserved 15 32768 Low battery <p>Returns:</p> Type Description <code>int</code> <p>The system status.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def status(self) -&gt; int:\n    \"\"\"Get the system status.\n\n    The status value represents a bit mask:\n\n    | Bit Index | Value | Description              |\n    | :-------: | :---: | :----------------------- |\n    |   0       |     1 | Max. alarm               |\n    |   1       |     2 | Min. alarm               |\n    |   2       |     4 | Display over range       |\n    |   3       |     8 | Display under range      |\n    |   4       |    16 | Reserved                 |\n    |   5       |    32 | Reserved                 |\n    |   6       |    64 | Reserved                 |\n    |   7       |   128 | Reserved                 |\n    |   8       |   256 | Measuring over range     |\n    |   9       |   512 | Measuring under range    |\n    |   10      |  1024 | Sensor error             |\n    |   11      |  2048 | Reserved                 |\n    |   12      |  4096 | System fault             |\n    |   13      |  8192 | Calculation not possible |\n    |   14      | 16384 | Reserved                 |\n    |   15      | 32768 | Low battery              |\n\n    Returns:\n        The system status.\n    \"\"\"\n    reply = self._get(code=3)\n    return self._to_uint16(*reply[:2])\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.unit","title":"unit","text":"<pre><code>unit() -&gt; str\n</code></pre> <p>Get the measurement unit.</p> <p>Returns:</p> Type Description <code>str</code> <p>The measurement unit.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def unit(self) -&gt; str:\n    \"\"\"Get the measurement unit.\n\n    Returns:\n        The measurement unit.\n    \"\"\"\n    reply = self._get(code=202)\n    unit = self._to_uint16(*reply[3:5])\n    if unit == 1:\n        return \"\\u00b0C\"\n    if unit == 2:  # noqa: PLR2004\n        return \"\\u00b0F\"\n\n    raise MSLConnectionError(self, f\"Unimplemented unit ID {unit}\")\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.value","title":"value","text":"<pre><code>value() -&gt; float\n</code></pre> <p>Get the current measurement value.</p> <p>Returns:</p> Type Description <code>float</code> <p>The current value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def value(self) -&gt; float:\n    \"\"\"Get the current measurement value.\n\n    Returns:\n        The current value.\n    \"\"\"\n    return self._decode(self._get(code=0))\n</code></pre>"},{"location":"resources/isotech/millik/","title":"milliK","text":"<p>IsoTech milliK Precision Thermometer.</p> <p>There can also be multiple millisKanner Channel Expanders connected to the milliK.</p>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.Current","title":"Current","text":"<p>Measure the current on channel 3.</p>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.MilliK","title":"MilliK","text":"<pre><code>MilliK(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MultiMessageBased</code></p> <p>IsoTech milliK Precision Thermometer.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/isotech/millik.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"[IsoTech](https://isotech.co.uk/) milliK Precision Thermometer.\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"\n    super().__init__(equipment)\n    self.rstrip: bool = True\n    self.read_termination: bytes = b\"\\r\"\n    self.write_termination: bytes = b\"\\r\"\n\n    # REMOTE mode speeds up communication and is required for voltage measurements\n    _ = self.write(\"MILLIK:REMOTE\")\n\n    devices, channels = _find_channel_numbers(self)\n\n    # These are the strings that would be returned from each device by the *IDN? command\n    # e.g. ['Isothermal Technology,millisKanner,21-P2593,2.01', 'Isothermal Technology,milliK,21-P2460,4.0.0']\n    self._devices: list[MilliKDevice] = [MilliKDevice(*d.split(\",\")) for d in devices]\n\n    self._channels: list[int] = channels\n\n    self.channel_configuration: dict[int, Current | Resistance | Voltage] = {}\n    \"\"\"The channels that have been configured.\"\"\"\n</code></pre>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.MilliK.channel_configuration","title":"channel_configuration  <code>instance-attribute</code>","text":"<pre><code>channel_configuration: dict[\n    int, Current | Resistance | Voltage\n] = {}\n</code></pre> <p>The channels that have been configured.</p>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.MilliK.channel_numbers","title":"channel_numbers  <code>property</code>","text":"<pre><code>channel_numbers: list[int]\n</code></pre> <p>A list of available channel numbers.</p> <p>For example, [1, 2] for a single milliK or [1, 10, 11, 12, 13, 14, 15, 16, 17] for a milliK connected to a single millisKanner.</p>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.MilliK.connected_devices","title":"connected_devices  <code>property</code>","text":"<pre><code>connected_devices: list[MilliKDevice]\n</code></pre> <p>A list of information about the connected devices.</p>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.MilliK.num_devices","title":"num_devices  <code>property</code>","text":"<pre><code>num_devices: int\n</code></pre> <p>The number of connected devices.</p>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.MilliK.configure_current_measurement","title":"configure_current_measurement","text":"<pre><code>configure_current_measurement() -&gt; None\n</code></pre> <p>Configure the milliK to measure current on channel 3.</p> <p>The current is from a 4-20 mA transmitter on the rear of the milliK.</p> Source code in <code>packages/resources/src/msl/equipment_resources/isotech/millik.py</code> <pre><code>def configure_current_measurement(self) -&gt; None:\n    \"\"\"Configure the milliK to measure current on channel 3.\n\n    The current is from a 4-20 mA transmitter on the rear of the milliK.\n    \"\"\"\n    self.channel_configuration[3] = Current()\n</code></pre>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.MilliK.configure_resistance_measurement","title":"configure_resistance_measurement","text":"<pre><code>configure_resistance_measurement(\n    channel: int,\n    resistance: float,\n    *,\n    root2: bool = False,\n    wire3: bool = False\n) -&gt; None\n</code></pre> <p>Configure the milliK to measure resistance for the specified channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The channel to configure for resistance measurements.</p> required <code>resistance</code> <code>float</code> <p>The largest resistance value, in \u03a9, that is expected to be measured. The milliK selects the most sensitive range that can accommodate the specified value (up to 115 \u03a9, 460 \u03a9 or 500 k\u03a9 for the three supported ranges).</p> required <code>root2</code> <code>bool</code> <p>Use \\(\\sqrt{2}\\) mA sense current instead of the normal 1 mA sense current. Thermistors (resistance measurements in the 500 k\u03a9 range) always use 2 \u03bcA.</p> <code>False</code> <code>wire3</code> <code>bool</code> <p>Whether the wiring arrangement is for 3 wires instead of the typical 4 wires.</p> <code>False</code> Source code in <code>packages/resources/src/msl/equipment_resources/isotech/millik.py</code> <pre><code>def configure_resistance_measurement(\n    self, channel: int, resistance: float, *, root2: bool = False, wire3: bool = False\n) -&gt; None:\n    r\"\"\"Configure the milliK to measure resistance for the specified channel.\n\n    Args:\n        channel: The channel to configure for resistance measurements.\n        resistance: The largest resistance value, in &amp;Omega;, that is expected to be measured.\n            The milliK selects the most sensitive range that can accommodate the specified value\n            (up to 115 &amp;Omega;, 460 &amp;Omega; or 500 k&amp;Omega; for the three supported ranges).\n        root2: Use $\\sqrt{2}$ mA sense current instead of the normal 1 mA sense current.\n            Thermistors (resistance measurements in the 500 k&amp;Omega; range) always use 2 \u03bcA.\n        wire3: Whether the wiring arrangement is for 3 wires instead of the typical 4 wires.\n    \"\"\"\n    if channel not in self._channels:\n        msg = f\"Channel {channel} is not available in the connected milliK devices\"\n        raise ValueError(msg)\n\n    self.channel_configuration[channel] = Resistance(\n        range=round(resistance), current=\"ROOT2\" if root2 else \"NORMAL\", wires=3 if wire3 else 4\n    )\n</code></pre>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.MilliK.configure_voltage_measurement","title":"configure_voltage_measurement","text":"<pre><code>configure_voltage_measurement(\n    channel: int,\n    *,\n    rjc: bool = False,\n    thermocouple: str | Type | None = None\n) -&gt; None\n</code></pre> <p>Configure the milliK to measure voltage for the specified channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The channel to configure for voltage measurements.</p> required <code>rjc</code> <code>bool</code> <p>Whether to use reference junction compensation for the measurements.</p> <code>False</code> <code>thermocouple</code> <code>str | Type | None</code> <p>The type of thermocouple that is used. If the <code>thermocouple</code> value is of type str, it must be a member name of the Type enumeration, e.g., <code>K</code>, <code>J</code>, <code>AU_PT</code>.</p> <code>None</code> Source code in <code>packages/resources/src/msl/equipment_resources/isotech/millik.py</code> <pre><code>def configure_voltage_measurement(\n    self, channel: int, *, rjc: bool = False, thermocouple: str | Type | None = None\n) -&gt; None:\n    \"\"\"Configure the milliK to measure voltage for the specified channel.\n\n    Args:\n        channel: The channel to configure for voltage measurements.\n        rjc: Whether to use reference junction compensation for the measurements.\n        thermocouple: The type of thermocouple that is used. If the `thermocouple` value is\n            of type [str][], it must be a member name of the [Type][msl.equipment_resources.isotech.millik.Type]\n            enumeration, e.g., `K`, `J`, `AU_PT`.\n    \"\"\"\n    if channel not in self._channels:\n        msg = f\"Channel {channel} is not available in the connected milliK devices\"\n        raise ValueError(msg)\n\n    self.channel_configuration[channel] = Voltage(\n        rjc=\"INTERNAL\" if rjc else \"NONE\",\n        thermocouple=\"NONE\" if thermocouple is None else to_enum(thermocouple, Type, to_upper=True),\n    )\n</code></pre>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.MilliK.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Return the milliK device to LOCAL mode then disconnect from the device.</p> Source code in <code>packages/resources/src/msl/equipment_resources/isotech/millik.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Return the milliK device to LOCAL mode then disconnect from the device.\"\"\"\n    if not self._connected:\n        return\n\n    _ = self.write(\"MILLIK:LOCAL\")\n    super().disconnect()\n</code></pre>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.MilliK.read_all_channels","title":"read_all_channels","text":"<pre><code>read_all_channels(\n    n: int = 1,\n) -&gt; Iterator[tuple[int, float]]\n</code></pre> <p>Read from all configured channels.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of readings to average for each channel.</p> <code>1</code> <p>Yields:</p> Type Description <code>tuple[int, float]</code> <p>The channel number and the average measurement value for that channel.</p> Source code in <code>packages/resources/src/msl/equipment_resources/isotech/millik.py</code> <pre><code>def read_all_channels(self, n: int = 1) -&gt; Iterator[tuple[int, float]]:\n    \"\"\"Read from all configured channels.\n\n    Args:\n        n: The number of readings to average for each channel.\n\n    Yields:\n        The channel number and the average measurement value for that channel.\n    \"\"\"\n    for c in sorted(self.channel_configuration):\n        if n == 1:  # already a single float value\n            yield c, self.read_channel(c)\n        else:  # average multiple readings\n            readings = self.read_channel(c, n=n)\n            yield c, sum(readings) / len(readings)\n</code></pre>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.MilliK.read_channel","title":"read_channel","text":"<pre><code>read_channel(channel: int, n: Literal[1] = 1) -&gt; float\n</code></pre><pre><code>read_channel(channel: int, n: int) -&gt; list[float]\n</code></pre> <pre><code>read_channel(\n    channel: int, n: int = 1\n) -&gt; float | list[float]\n</code></pre> <p>Read a configured channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The channel to read.</p> required <code>n</code> <code>int</code> <p>The number of readings to acquire.</p> <code>1</code> <p>Returns:</p> Type Description <code>float | list[float]</code> <p>A list of <code>n</code> readings or a single value if only one reading is requested.</p> Source code in <code>packages/resources/src/msl/equipment_resources/isotech/millik.py</code> <pre><code>def read_channel(self, channel: int, n: int = 1) -&gt; float | list[float]:\n    \"\"\"Read a configured channel.\n\n    Args:\n        channel: The channel to read.\n        n: The number of readings to acquire.\n\n    Returns:\n        A list of `n` readings or a single value if only one reading is requested.\n    \"\"\"\n    cfg = self.channel_configuration.get(channel)\n    if cfg is None:\n        msg = f\"Please first configure channel {channel} before attempting to read values\"\n        raise ValueError(msg)\n\n    if isinstance(cfg, Resistance):\n        commands = [\n            f\"SENSE:CHANNEL {channel}\",\n            \"SENSE:FUNCTION RESISTANCE\",\n            f\"SENSE:RESISTANCE:RANGE {cfg.range}\",\n            f\"SENSE:RESISTANCE:WIRES {cfg.wires}\",\n            f\"SENSE:CURRENT {cfg.current}\",\n        ]\n    elif isinstance(cfg, Voltage):\n        commands = [\n            f\"SENSE:CHANNEL {channel}\",\n            \"SENSE:FUNCTION VOLTAGE\",\n            f\"SENSE:PROBE {cfg.thermocouple}\",\n            f\"SENSE:RJC {cfg.rjc}\",\n        ]\n    else:\n        commands = [\"SENSE:CHANNEL 3\", \"SENSE:FUNCTION CURRENT\"]\n\n    commands.append(f\"READ? {n}\" if n &gt; 1 else \"READ?\")\n    reply = self.query(\";\".join(commands))\n\n    try:\n        readings = list(map(float, reply.split(\",\")))\n    except ValueError:\n        raise MSLConnectionError(self, f\"Cannot map reply to float, {reply!r}\") from None\n\n    if len(readings) == 1:\n        return readings[0]\n    return readings\n</code></pre>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.MilliKDevice","title":"MilliKDevice  <code>dataclass</code>","text":"<pre><code>MilliKDevice(\n    manufacturer: str,\n    model: str,\n    serial: str,\n    firmware: str,\n)\n</code></pre> <p>Information about a connected milliK device.</p> <p>Parameters:</p> Name Type Description Default <code>manufacturer</code> <code>str</code> <p>Manufacturer's name.</p> required <code>model</code> <code>str</code> <p>Model number.</p> required <code>serial</code> <code>str</code> <p>Serial number.</p> required <code>firmware</code> <code>str</code> <p>Firmware revision number.</p> required"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.Resistance","title":"Resistance  <code>dataclass</code>","text":"<pre><code>Resistance(\n    range: int,\n    current: Literal[\"NORMAL\", \"ROOT2\"],\n    wires: Literal[3, 4],\n)\n</code></pre> <p>A channel configured to measure resistance.</p> <p>Parameters:</p> Name Type Description Default <code>range</code> <code>int</code> <p>The largest resistance that is expected to be measured.</p> required <code>current</code> <code>Literal['NORMAL', 'ROOT2']</code> <p>The type of sense current to use.</p> required <code>wires</code> <code>Literal[3, 4]</code> <p>The number of wires that are used for the resistance measurement.</p> required"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.Type","title":"Type","text":"<p>               Bases: <code>Enum</code></p> <p>Standard thermocouple types.</p> <p>Attributes:</p> Name Type Description <code>B</code> <code>str</code> <p><code>\"TYPE B\"</code></p> <code>E</code> <code>str</code> <p><code>\"TYPE E\"</code></p> <code>J</code> <code>str</code> <p><code>\"TYPE J\"</code></p> <code>K</code> <code>str</code> <p><code>\"TYPE K\"</code></p> <code>L</code> <code>str</code> <p><code>\"TYPE L\"</code></p> <code>N</code> <code>str</code> <p><code>\"TYPE N\"</code></p> <code>R</code> <code>str</code> <p><code>\"TYPE R\"</code></p> <code>S</code> <code>str</code> <p><code>\"TYPE S\"</code></p> <code>T</code> <code>str</code> <p><code>\"TYPE T\"</code></p> <code>AU_PT</code> <code>str</code> <p><code>\"TYPE AU-PT\"</code></p> <code>PT_PD</code> <code>str</code> <p><code>\"TYPE PT-PD\"</code></p>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.Voltage","title":"Voltage  <code>dataclass</code>","text":"<pre><code>Voltage(\n    rjc: Literal[\"NONE\", \"INTERNAL\"],\n    thermocouple: Type | Literal[\"NONE\"],\n)\n</code></pre> <p>A channel configured to measure voltage.</p> <p>Parameters:</p> Name Type Description Default <code>rjc</code> <code>Literal['NONE', 'INTERNAL']</code> <p>The reference junction compensation type.</p> required <code>thermocouple</code> <code>Type | Literal['NONE']</code> <p>The thermocouple type.</p> required"},{"location":"resources/mks/pr4000b/","title":"PR4000B","text":"<p>Flow and Pressure controller, PR4000B, from MKS Instruments.</p>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.UNIT","title":"UNIT  <code>module-attribute</code>","text":"<pre><code>UNIT = {\n    0: \"ubar\",\n    1: \"mbar\",\n    2: \"bar\",\n    3: \"mTorr\",\n    4: \"Torr\",\n    5: \"kTorr\",\n    6: \"Pa\",\n    7: \"kPa\",\n    8: \"mH2O\",\n    9: \"cH2O\",\n    10: \"PSI\",\n    11: \"N/qm\",\n    12: \"SCCM\",\n    13: \"SLM\",\n    14: \"SCM\",\n    15: \"SCFH\",\n    16: \"SCFM\",\n    17: \"mA\",\n    18: \"V\",\n    19: \"%\",\n    20: \"C\",\n}\n</code></pre> <p>Mapping from an index value to a unit name.</p>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.LimitMode","title":"LimitMode","text":"<p>               Bases: <code>IntEnum</code></p> <p>Limit mode type.</p> <p>Attributes:</p> Name Type Description <code>SLEEP</code> <code>int</code> <p>0</p> <code>LIMIT</code> <code>int</code> <p>1</p> <code>BAND</code> <code>int</code> <p>2</p> <code>MLIMIT</code> <code>int</code> <p>3</p> <code>MBAND</code> <code>int</code> <p>4</p>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B","title":"PR4000B","text":"<pre><code>PR4000B(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Serial</code></p> <p>Flow and Pressure controller, PR4000B, from MKS Instruments.</p> <p>The default settings for the RS232 connection are:</p> <ul> <li>Baud rate: 9600</li> <li>Parity: ODD</li> <li>Data bits: 7</li> <li>Stop bits: 1</li> <li>Flow control: None</li> </ul> <p>The baud rate and parity can be changed on the controller. The data bits, stop bits, and flow control cannot be changed. A null modem (cross over) cable is required when using a USB to RS232 converter. RS485 support is not implemented.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance..</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Flow and Pressure controller, PR4000B, from [MKS](https://www.mks.com/) Instruments.\n\n    The default settings for the RS232 connection are:\n\n    * Baud rate: 9600\n    * Parity: ODD\n    * Data bits: 7\n    * Stop bits: 1\n    * Flow control: None\n\n    The baud rate and parity can be changed on the controller. The data bits,\n    stop bits, and flow control cannot be changed. A null modem (cross over)\n    cable is required when using a USB to RS232 converter. RS485 support is\n    not implemented.\n\n    Args:\n        equipment: An [Equipment][] instance..\n    \"\"\"\n    assert equipment.connection is not None  # noqa: S101\n    equipment.connection.properties.setdefault(\"data_bits\", DataBits.SEVEN)\n    super().__init__(equipment)\n    self.read_termination: bytes = b\"\\r\"\n    self.write_termination: bytes = b\"\\r\"\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.auto_zero","title":"auto_zero","text":"<pre><code>auto_zero(channel: Literal[1, 2]) -&gt; int\n</code></pre> <p>Auto zero a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The offset.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def auto_zero(self, channel: Literal[1, 2]) -&gt; int:\n    \"\"\"Auto zero a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The offset.\n    \"\"\"\n    self._check_channel(channel)\n    return int(self.query(f\"AZ{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.default","title":"default","text":"<pre><code>default(\n    mode: Literal[\"pressure\", \"p\", \"flow\", \"f\"],\n) -&gt; None\n</code></pre> <p>Reset to the default configuration.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>Literal['pressure', 'p', 'flow', 'f']</code> <p>The mode to reset.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def default(self, mode: Literal[\"pressure\", \"p\", \"flow\", \"f\"]) -&gt; None:\n    \"\"\"Reset to the default configuration.\n\n    Args:\n        mode: The mode to reset.\n    \"\"\"\n    upper = mode.upper()\n    if upper not in {\"P\", \"F\", \"PRESSURE\", \"FLOW\"}:\n        msg = f\"Invalid default mode {mode!r}, must one of: pressure, flow, p or f\"\n        raise ValueError(msg)\n\n    _ = self._check(f\"DF,{upper[0]}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.display_4","title":"display_4","text":"<pre><code>display_4(*, enable: bool) -&gt; None\n</code></pre> <p>Whether to enable or disable display 4.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>Whether to enable or disable display 4.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def display_4(self, *, enable: bool) -&gt; None:\n    \"\"\"Whether to enable or disable display 4.\n\n    Args:\n        enable: Whether to enable or disable display 4.\n    \"\"\"\n    state = \"ON\" if enable else \"OFF\"\n    _ = self._check(f\"DP4,{state}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.display_enable","title":"display_enable","text":"<pre><code>display_enable(\n    display: Literal[1, 2, 3, 4], *, enable: bool\n) -&gt; None\n</code></pre> <p>Turn a display on or off.</p> <p>Parameters:</p> Name Type Description Default <code>display</code> <code>Literal[1, 2, 3, 4]</code> <p>The display number.</p> required <code>enable</code> <code>bool</code> <p>Whether to turn the display on (<code>True</code>) or off (<code>False</code>).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def display_enable(self, display: Literal[1, 2, 3, 4], *, enable: bool) -&gt; None:\n    \"\"\"Turn a display on or off.\n\n    Args:\n        display: The display number.\n        enable: Whether to turn the display on (`True`) or off (`False`).\n    \"\"\"\n    if display not in {1, 2, 3, 4}:\n        msg = f\"Invalid display number {display}, must be 1, 2, 3 or 4\"\n        raise ValueError(msg)\n\n    state = \"ON\" if enable else \"OFF\"\n    _ = self._check(f\"DP{display},{state}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.display_setup","title":"display_setup","text":"<pre><code>display_setup(\n    display: Literal[1, 2, 3, 4],\n    line: Literal[1, 2],\n    channel: Literal[1, 2],\n    tag: int | str | Tag,\n) -&gt; None\n</code></pre> <p>Configure a display.</p> <p>Parameters:</p> Name Type Description Default <code>display</code> <code>Literal[1, 2, 3, 4]</code> <p>The display number.</p> required <code>line</code> <code>Literal[1, 2]</code> <p>The line number.</p> required <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>tag</code> <code>int | str | Tag</code> <p>The tag to use. Can be a Tag member name or value. For example, <code>Tag.PR</code>, <code>4</code>, or <code>\"PR\"</code> are equivalent.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def display_setup(\n    self, display: Literal[1, 2, 3, 4], line: Literal[1, 2], channel: Literal[1, 2], tag: int | str | Tag\n) -&gt; None:\n    \"\"\"Configure a display.\n\n    Args:\n        display: The display number.\n        line: The line number.\n        channel: The channel number.\n        tag: The tag to use. Can be a [Tag][msl.equipment_resources.mks.pr4000b.Tag] member name or value.\n            For example, `Tag.PR`, `4`, or `\"PR\"` are equivalent.\n    \"\"\"\n    if display not in {1, 2, 3, 4}:\n        msg = f\"Invalid display number {display}, must be 1, 2, 3 or 4\"\n        raise ValueError(msg)\n\n    if line not in {1, 2}:\n        msg = f\"Invalid line number {line}, must be 1 or 2\"\n        raise ValueError(msg)\n\n    self._check_channel(channel)\n    tag = to_enum(tag, Tag, to_upper=True)\n    _ = self._check(f\"DP{display},{line},{tag},{channel}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.external_input","title":"external_input","text":"<pre><code>external_input(channel: Literal[1, 2]) -&gt; float\n</code></pre> <p>Return the external input of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The external input.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def external_input(self, channel: Literal[1, 2]) -&gt; float:\n    \"\"\"Return the external input of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The external input.\n    \"\"\"\n    self._check_channel(channel)\n    return float(self.query(f\"EX{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_access_channel","title":"get_access_channel","text":"<pre><code>get_access_channel(\n    channel: Literal[1, 2],\n) -&gt; tuple[float, bool]\n</code></pre> <p>Get the setpoint and the state of the valve of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>tuple[float, bool]</code> <p>The setpoint value and whether the valve is on (<code>True</code>) or off (<code>False</code>).</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_access_channel(self, channel: Literal[1, 2]) -&gt; tuple[float, bool]:\n    \"\"\"Get the setpoint and the state of the valve of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The setpoint value and whether the valve is on (`True`) or off (`False`).\n    \"\"\"\n    self._check_channel(channel)\n    a, b = self.query(f\"?AC{channel}\").rstrip().split(\",\")\n    return float(a), b == \"ON\"\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_actual_value","title":"get_actual_value","text":"<pre><code>get_actual_value(channel: Literal[1, 2]) -&gt; float\n</code></pre> <p>Get the actual value of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_actual_value(self, channel: Literal[1, 2]) -&gt; float:\n    \"\"\"Get the actual value of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The value.\n    \"\"\"\n    self._check_channel(channel)\n    return float(self.query(f\"AV{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_address","title":"get_address","text":"<pre><code>get_address() -&gt; int\n</code></pre> <p>Get the address.</p> <p>Returns:</p> Type Description <code>int</code> <p>The address.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_address(self) -&gt; int:\n    \"\"\"Get the address.\n\n    Returns:\n        The address.\n    \"\"\"\n    return int(self.query(\"?AD\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_dead_band","title":"get_dead_band","text":"<pre><code>get_dead_band(channel: Literal[1, 2]) -&gt; float\n</code></pre> <p>Get the dead band of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The dead band.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_dead_band(self, channel: Literal[1, 2]) -&gt; float:\n    \"\"\"Get the dead band of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The dead band.\n    \"\"\"\n    self._check_channel(channel)\n    return float(self.query(f\"?DB{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_dialog","title":"get_dialog","text":"<pre><code>get_dialog() -&gt; int\n</code></pre> <p>Get the current dialog index that is displayed.</p> <p>Returns:</p> Type Description <code>int</code> <p>The dialog index.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_dialog(self) -&gt; int:\n    \"\"\"Get the current dialog index that is displayed.\n\n    Returns:\n        The dialog index.\n    \"\"\"\n    return int(self.query(\"?DG\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_display_text","title":"get_display_text","text":"<pre><code>get_display_text() -&gt; str\n</code></pre> <p>Get the display text.</p> <p>Returns:</p> Type Description <code>str</code> <p>The display text.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_display_text(self) -&gt; str:\n    \"\"\"Get the display text.\n\n    Returns:\n        The display text.\n    \"\"\"\n    return self.query(\"?DT\").rstrip()\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_external_input_range","title":"get_external_input_range","text":"<pre><code>get_external_input_range(channel: Literal[1, 2]) -&gt; int\n</code></pre> <p>Get the external input range of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The external input range.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_external_input_range(self, channel: Literal[1, 2]) -&gt; int:\n    \"\"\"Get the external input range of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The external input range.\n    \"\"\"\n    self._check_channel(channel)\n    return int(self.query(f\"?EI{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_external_output_range","title":"get_external_output_range","text":"<pre><code>get_external_output_range(channel: Literal[1, 2]) -&gt; int\n</code></pre> <p>Get the external output range of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The external output range.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_external_output_range(self, channel: Literal[1, 2]) -&gt; int:\n    \"\"\"Get the external output range of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The external output range.\n    \"\"\"\n    self._check_channel(channel)\n    return int(self.query(f\"?EO{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_formula_relay","title":"get_formula_relay","text":"<pre><code>get_formula_relay(channel: Literal[1, 2]) -&gt; str\n</code></pre> <p>Get the relay formula of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The formula.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_formula_relay(self, channel: Literal[1, 2]) -&gt; str:\n    \"\"\"Get the relay formula of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The formula.\n    \"\"\"\n    self._check_channel(channel)\n    return self.query(f\"?FR{channel}\").strip()\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_formula_temporary","title":"get_formula_temporary","text":"<pre><code>get_formula_temporary(channel: Literal[1, 2]) -&gt; str\n</code></pre> <p>Get the temporary formula of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The formula.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_formula_temporary(self, channel: Literal[1, 2]) -&gt; str:\n    \"\"\"Get the temporary formula of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The formula.\n    \"\"\"\n    self._check_channel(channel)\n    return self.query(f\"?FT{channel}\").strip()\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_gain","title":"get_gain","text":"<pre><code>get_gain(channel: Literal[1, 2]) -&gt; float\n</code></pre> <p>Get the gain of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The gain.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_gain(self, channel: Literal[1, 2]) -&gt; float:\n    \"\"\"Get the gain of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The gain.\n    \"\"\"\n    self._check_channel(channel)\n    return float(self.query(f\"?GN{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_input_range","title":"get_input_range","text":"<pre><code>get_input_range(channel: Literal[1, 2]) -&gt; int\n</code></pre> <p>Get the input range of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The input range.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_input_range(self, channel: Literal[1, 2]) -&gt; int:\n    \"\"\"Get the input range of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The input range.\n    \"\"\"\n    self._check_channel(channel)\n    return int(self.query(f\"?IN{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_interface_mode","title":"get_interface_mode","text":"<pre><code>get_interface_mode() -&gt; int\n</code></pre> <p>Get the interface mode.</p> <p>Returns:</p> Type Description <code>int</code> <p>The interface mode.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_interface_mode(self) -&gt; int:\n    \"\"\"Get the interface mode.\n\n    Returns:\n        The interface mode.\n    \"\"\"\n    return int(self.query(\"?IM\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_limit_mode","title":"get_limit_mode","text":"<pre><code>get_limit_mode(channel: Literal[1, 2]) -&gt; LimitMode\n</code></pre> <p>Get the limit mode of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>LimitMode</code> <p>The limit mode.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_limit_mode(self, channel: Literal[1, 2]) -&gt; LimitMode:\n    \"\"\"Get the limit mode of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The limit mode.\n    \"\"\"\n    self._check_channel(channel)\n    mode = int(self.query(f\"?LM{channel}\"))\n    return LimitMode(mode)\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_linearization_point","title":"get_linearization_point","text":"<pre><code>get_linearization_point(\n    channel: Literal[1, 2], point: int\n) -&gt; tuple[float, float]\n</code></pre> <p>Get the point in the linearization table of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>point</code> <code>int</code> <p>The point in the table [0, 10].</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>The <code>(x, y)</code> point.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_linearization_point(self, channel: Literal[1, 2], point: int) -&gt; tuple[float, float]:\n    \"\"\"Get the point in the linearization table of a channel.\n\n    Args:\n        channel: The channel number.\n        point: The point in the table [0, 10].\n\n    Returns:\n        The `(x, y)` point.\n    \"\"\"\n    self._check_channel(channel)\n    if point &lt; 0 or point &gt; MAX_POINT:\n        msg = f\"Invalid point {point}, must be between [0, 10]\"\n        raise ValueError(msg)\n    a, b = self.query(f\"?LN{channel},{point}\").split(\",\")\n    return float(a), float(b)\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_linearization_size","title":"get_linearization_size","text":"<pre><code>get_linearization_size(channel: Literal[1, 2]) -&gt; int\n</code></pre> <p>Get the size of the linearization table of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The size of the table.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_linearization_size(self, channel: Literal[1, 2]) -&gt; int:\n    \"\"\"Get the size of the linearization table of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The size of the table.\n    \"\"\"\n    self._check_channel(channel)\n    return int(self.query(f\"?LS{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_lower_limit","title":"get_lower_limit","text":"<pre><code>get_lower_limit(channel: Literal[1, 2]) -&gt; float\n</code></pre> <p>Get the lower limit of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The lower limit.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_lower_limit(self, channel: Literal[1, 2]) -&gt; float:\n    \"\"\"Get the lower limit of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The lower limit.\n    \"\"\"\n    self._check_channel(channel)\n    return float(self.query(f\"?LL{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_offset","title":"get_offset","text":"<pre><code>get_offset(channel: Literal[1, 2]) -&gt; int\n</code></pre> <p>Get the offset of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The offset.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_offset(self, channel: Literal[1, 2]) -&gt; int:\n    \"\"\"Get the offset of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The offset.\n    \"\"\"\n    self._check_channel(channel)\n    return int(self.query(f\"?OF{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_output_range","title":"get_output_range","text":"<pre><code>get_output_range(channel: Literal[1, 2]) -&gt; int\n</code></pre> <p>Get the output range of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The output range.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_output_range(self, channel: Literal[1, 2]) -&gt; int:\n    \"\"\"Get the output range of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The output range.\n    \"\"\"\n    self._check_channel(channel)\n    return int(self.query(f\"?OT{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_range","title":"get_range","text":"<pre><code>get_range(channel: Literal[1, 2]) -&gt; tuple[float, int, str]\n</code></pre> <p>Get the range and unit of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>tuple[float, int, str]</code> <p>The range, unit index and unit name.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_range(self, channel: Literal[1, 2]) -&gt; tuple[float, int, str]:\n    \"\"\"Get the range and unit of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The range, unit index and unit name.\n    \"\"\"\n    self._check_channel(channel)\n    a, b = self.query(f\"?RG{channel}\").split(\",\")\n    unit = int(b)\n    return float(a), unit, UNIT[unit]\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_relays","title":"get_relays","text":"<pre><code>get_relays(channel: Literal[1, 2]) -&gt; bool\n</code></pre> <p>Get the relay state of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the relay is enabled or disabled.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_relays(self, channel: Literal[1, 2]) -&gt; bool:\n    \"\"\"Get the relay state of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        Whether the relay is enabled or disabled.\n    \"\"\"\n    self._check_channel(channel)\n    return self.query(f\"?RL{channel}\").rstrip() == \"ON\"\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_remote_mode","title":"get_remote_mode","text":"<pre><code>get_remote_mode() -&gt; bool\n</code></pre> <p>Get the remote operation mode.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the remote operation mode is enabled (<code>True</code>) or disabled (<code>False</code>).</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_remote_mode(self) -&gt; bool:\n    \"\"\"Get the remote operation mode.\n\n    Returns:\n        Whether the remote operation mode is enabled (`True`) or disabled (`False`).\n    \"\"\"\n    return self.query(\"?RT\").rstrip() == \"ON\"\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_resolution","title":"get_resolution","text":"<pre><code>get_resolution() -&gt; bool\n</code></pre> <p>Get whether 16-bit resolution is enabled.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether 16-bit resolution is enabled (<code>True</code>) or disabled (<code>False</code>).</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_resolution(self) -&gt; bool:\n    \"\"\"Get whether 16-bit resolution is enabled.\n\n    Returns:\n        Whether 16-bit resolution is enabled (`True`) or disabled (`False`).\n    \"\"\"\n    return self.query(\"?RS\").rstrip() == \"ON\"\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_rtd_offset","title":"get_rtd_offset","text":"<pre><code>get_rtd_offset(channel: Literal[1, 2]) -&gt; int\n</code></pre> <p>Get the RTD offset of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The offset.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_rtd_offset(self, channel: Literal[1, 2]) -&gt; int:\n    \"\"\"Get the RTD offset of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The offset.\n    \"\"\"\n    self._check_channel(channel)\n    return int(self.query(f\"?RO{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_scale","title":"get_scale","text":"<pre><code>get_scale(channel: Literal[1, 2]) -&gt; float\n</code></pre> <p>Get the scale of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The scale.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_scale(self, channel: Literal[1, 2]) -&gt; float:\n    \"\"\"Get the scale of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The scale.\n    \"\"\"\n    return float(self.query(f\"?SC{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_setpoint","title":"get_setpoint","text":"<pre><code>get_setpoint(channel: Literal[1, 2]) -&gt; float\n</code></pre> <p>Get the setpoint of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The setpoint.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_setpoint(self, channel: Literal[1, 2]) -&gt; float:\n    \"\"\"Get the setpoint of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The setpoint.\n    \"\"\"\n    self._check_channel(channel)\n    return float(self.query(f\"?SP{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_signal_mode","title":"get_signal_mode","text":"<pre><code>get_signal_mode(channel: Literal[1, 2]) -&gt; SignalMode\n</code></pre> <p>Get the signal mode of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>SignalMode</code> <p>The signal mode.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_signal_mode(self, channel: Literal[1, 2]) -&gt; SignalMode:\n    \"\"\"Get the signal mode of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The signal mode.\n    \"\"\"\n    self._check_channel(channel)\n    mode = int(self.query(f\"?SM{channel}\"))\n    return SignalMode(mode)\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_upper_limit","title":"get_upper_limit","text":"<pre><code>get_upper_limit(channel: Literal[1, 2]) -&gt; float\n</code></pre> <p>Get the upper limit of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The upper limit.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_upper_limit(self, channel: Literal[1, 2]) -&gt; float:\n    \"\"\"Get the upper limit of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The upper limit.\n    \"\"\"\n    self._check_channel(channel)\n    return float(self.query(f\"?UL{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_valve","title":"get_valve","text":"<pre><code>get_valve(channel: Literal[1, 2]) -&gt; bool\n</code></pre> <p>Get the state of the valve of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the valve is enabled (<code>True</code>) or disabled (<code>False</code>).</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_valve(self, channel: Literal[1, 2]) -&gt; bool:\n    \"\"\"Get the state of the valve of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        Whether the valve is enabled (`True`) or disabled (`False`).\n    \"\"\"\n    self._check_channel(channel)\n    return self.query(f\"?VL{channel}\").rstrip() == \"ON\"\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.identity","title":"identity","text":"<pre><code>identity() -&gt; str\n</code></pre> <p>Returns the identity.</p> <p>Returns:</p> Type Description <code>str</code> <p>The identity. For example, <code>PR42vvrrsssss</code>, where <code>vv</code> is the version, <code>rr</code> is the release and <code>sssss</code> is the serial number.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def identity(self) -&gt; str:\n    \"\"\"Returns the identity.\n\n    Returns:\n        The identity. For example, `PR42vvrrsssss`, where `vv` is the version,\n            `rr` is the release and `sssss` is the serial number.\n    \"\"\"\n    return self.query(\"?ID\").rstrip()\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.lock","title":"lock","text":"<pre><code>lock() -&gt; None\n</code></pre> <p>Lock setup.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def lock(self) -&gt; None:\n    \"\"\"Lock setup.\"\"\"\n    _ = self._check(\"#1\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.request_key","title":"request_key","text":"<pre><code>request_key() -&gt; tuple[int, int]\n</code></pre> <p>Requests most recent key that was pressed.</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>The key that was most recently pressed and the number of key presses that occurred since the last time this method was called.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def request_key(self) -&gt; tuple[int, int]:\n    \"\"\"Requests most recent key that was pressed.\n\n    Returns:\n        The key that was most recently pressed and the number of key presses\n            that occurred since the last time this method was called.\n    \"\"\"\n    a, b = self.query(\"?KY\").split(\",\")\n    return int(a), int(b)\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.reset_status","title":"reset_status","text":"<pre><code>reset_status() -&gt; None\n</code></pre> <p>Send the reset/status command.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def reset_status(self) -&gt; None:\n    \"\"\"Send the reset/status command.\"\"\"\n    _ = self._check(\"RE\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_access_channel","title":"set_access_channel","text":"<pre><code>set_access_channel(\n    channel: Literal[1, 2], setpoint: float, *, enable: bool\n) -&gt; float\n</code></pre> <p>Set the setpoint and the state of the valve for a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>setpoint</code> <code>float</code> <p>The setpoint value.</p> required <code>enable</code> <code>bool</code> <p>Whether to enable (<code>True</code>) or disable (<code>False</code>) the valve.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The actual setpoint value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_access_channel(self, channel: Literal[1, 2], setpoint: float, *, enable: bool) -&gt; float:\n    \"\"\"Set the setpoint and the state of the valve for a channel.\n\n    Args:\n        channel: The channel number.\n        setpoint: The setpoint value.\n        enable: Whether to enable (`True`) or disable (`False`) the valve.\n\n    Returns:\n        The actual setpoint value.\n    \"\"\"\n    self._check_channel(channel)\n    state = \"ON\" if enable else \"OFF\"\n    return float(self._check(f\"AC{channel},{setpoint},{state}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_actual_value","title":"set_actual_value","text":"<pre><code>set_actual_value(\n    channel: Literal[1, 2], setpoint: float\n) -&gt; float\n</code></pre> <p>Set the actual value of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>setpoint</code> <code>float</code> <p>The setpoint.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The actual value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_actual_value(self, channel: Literal[1, 2], setpoint: float) -&gt; float:\n    \"\"\"Set the actual value of a channel.\n\n    Args:\n        channel: The channel number.\n        setpoint: The setpoint.\n\n    Returns:\n        The actual value.\n    \"\"\"\n    self._check_channel(channel)\n    return float(self.query(f\"AV{channel},{setpoint}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_address","title":"set_address","text":"<pre><code>set_address(address: int) -&gt; None\n</code></pre> <p>Set the address.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address [0, 31].</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_address(self, address: int) -&gt; None:\n    \"\"\"Set the address.\n\n    Args:\n        address: The address [0, 31].\n    \"\"\"\n    if address &lt; 0 or address &gt; 31:  # noqa: PLR2004\n        msg = f\"Invalid address {address}, must be between [0, 31]\"\n        raise ValueError(msg)\n\n    _ = self._check(f\"AD,{address}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_dead_band","title":"set_dead_band","text":"<pre><code>set_dead_band(channel: Literal[1, 2], band: float) -&gt; None\n</code></pre> <p>Set the dead band of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>band</code> <code>float</code> <p>The dead band (0.0% to 9.9% of full scale).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_dead_band(self, channel: Literal[1, 2], band: float) -&gt; None:\n    \"\"\"Set the dead band of a channel.\n\n    Args:\n        channel: The channel number.\n        band: The dead band (0.0% to 9.9% of full scale).\n    \"\"\"\n    self._check_channel(channel)\n    _ = self._check(f\"DB{channel},{band}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_dialog","title":"set_dialog","text":"<pre><code>set_dialog(index: int) -&gt; None\n</code></pre> <p>Set the display dialog.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The dialog index [0, 29]. See Appendix D of the manual for more information.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_dialog(self, index: int) -&gt; None:\n    \"\"\"Set the display dialog.\n\n    Args:\n        index: The dialog index [0, 29]. See Appendix D of the manual for more information.\n    \"\"\"\n    if index &lt; 0 or index &gt; 29:  # noqa: PLR2004\n        msg = f\"Invalid dialog index {index}, must be in the range [0, 29]\"\n        raise ValueError(msg)\n    _ = self._check(f\"DG,{index}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_display_text","title":"set_display_text","text":"<pre><code>set_display_text(text: str, *, clear: bool = True) -&gt; None\n</code></pre> <p>Set the display text.</p> <p>To view the text on the display you must call set_dialog with the index equal to 3.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to display. Maximum 32 characters.</p> required <code>clear</code> <code>bool</code> <p>Whether to clear the current display text before setting the new text.</p> <code>True</code> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_display_text(self, text: str, *, clear: bool = True) -&gt; None:\n    \"\"\"Set the display text.\n\n    To view the text on the display you must call\n    [set_dialog][msl.equipment_resources.mks.pr4000b.PR4000B.set_dialog]\n    with the index equal to 3.\n\n    Args:\n        text: The text to display. Maximum 32 characters.\n        clear: Whether to clear the current display text before setting the new text.\n    \"\"\"\n    if len(text) &gt; 32:  # noqa: PLR2004\n        msg = f\"The display text must be &lt;= 32 characters, got {text!r}\"\n        raise ValueError(msg)\n    if clear:\n        _ = self._check(\"!DT\")\n    _ = self._check(f\"DT,{text}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_external_input_range","title":"set_external_input_range","text":"<pre><code>set_external_input_range(\n    channel: Literal[1, 2], range: int\n) -&gt; None\n</code></pre> <p>Set the external input range of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>range</code> <code>int</code> <p>The external input range [1, 10] in Volts.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_external_input_range(self, channel: Literal[1, 2], range: int) -&gt; None:  # noqa: A002\n    \"\"\"Set the external input range of a channel.\n\n    Args:\n        channel: The channel number.\n        range: The external input range [1, 10] in Volts.\n    \"\"\"\n    self._check_channel(channel)\n    if range &lt; 1 or range &gt; MAX_RANGE:\n        msg = f\"Invalid external input range {range}\"\n        raise ValueError(msg)\n    _ = self._check(f\"EI{channel},{range}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_external_output_range","title":"set_external_output_range","text":"<pre><code>set_external_output_range(\n    channel: Literal[1, 2], range: int\n) -&gt; None\n</code></pre> <p>Set the external output range of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>range</code> <code>int</code> <p>The external output range [1, 10] in Volts.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_external_output_range(self, channel: Literal[1, 2], range: int) -&gt; None:  # noqa: A002\n    \"\"\"Set the external output range of a channel.\n\n    Args:\n        channel: The channel number.\n        range: The external output range [1, 10] in Volts.\n    \"\"\"\n    self._check_channel(channel)\n    if range &lt; 1 or range &gt; MAX_RANGE:\n        msg = f\"Invalid external output range {range}\"\n        raise ValueError(msg)\n    _ = self._check(f\"EO{channel},{range}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_formula_relay","title":"set_formula_relay","text":"<pre><code>set_formula_relay(\n    channel: Literal[1, 2], formula: str\n) -&gt; None\n</code></pre> <p>Set the relay formula of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>formula</code> <code>str</code> <p>The relay formula.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_formula_relay(self, channel: Literal[1, 2], formula: str) -&gt; None:\n    \"\"\"Set the relay formula of a channel.\n\n    Args:\n        channel: The channel number.\n        formula: The relay formula.\n    \"\"\"\n    self._check_channel(channel)\n    _ = self._check(f\"FR{channel},{formula}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_formula_temporary","title":"set_formula_temporary","text":"<pre><code>set_formula_temporary(\n    channel: Literal[1, 2], formula: str\n) -&gt; None\n</code></pre> <p>Set the temporary formula of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>formula</code> <code>str</code> <p>The temporary formula.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_formula_temporary(self, channel: Literal[1, 2], formula: str) -&gt; None:\n    \"\"\"Set the temporary formula of a channel.\n\n    Args:\n        channel: The channel number.\n        formula: The temporary formula.\n    \"\"\"\n    self._check_channel(channel)\n    _ = self._check(f\"FT{channel},{formula}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_gain","title":"set_gain","text":"<pre><code>set_gain(channel: Literal[1, 2], gain: float) -&gt; None\n</code></pre> <p>Set the gain of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>gain</code> <code>float</code> <p>The gain [0.001, 2.000].</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_gain(self, channel: Literal[1, 2], gain: float) -&gt; None:\n    \"\"\"Set the gain of a channel.\n\n    Args:\n        channel: The channel number.\n        gain: The gain [0.001, 2.000].\n    \"\"\"\n    self._check_channel(channel)\n    _ = self._check(f\"GN{channel},{gain}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_input_range","title":"set_input_range","text":"<pre><code>set_input_range(channel: Literal[1, 2], range: int) -&gt; None\n</code></pre> <p>Set the input range of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>range</code> <code>int</code> <p>The input range [1, 10] in Volts.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_input_range(self, channel: Literal[1, 2], range: int) -&gt; None:  # noqa: A002\n    \"\"\"Set the input range of a channel.\n\n    Args:\n        channel: The channel number.\n        range: The input range [1, 10] in Volts.\n    \"\"\"\n    self._check_channel(channel)\n    if range &lt; 1 or range &gt; MAX_RANGE:\n        msg = f\"Invalid input range {range}\"\n        raise ValueError(msg)\n    _ = self._check(f\"IN{channel},{range}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_interface_mode","title":"set_interface_mode","text":"<pre><code>set_interface_mode(mode: int) -&gt; None\n</code></pre> <p>Set the interface mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>int</code> <p>The interface mode.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_interface_mode(self, mode: int) -&gt; None:\n    \"\"\"Set the interface mode.\n\n    Args:\n        mode: The interface mode.\n    \"\"\"\n    _ = self._check(f\"IM,{mode}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_limit_mode","title":"set_limit_mode","text":"<pre><code>set_limit_mode(\n    channel: Literal[1, 2], mode: int | str | LimitMode\n) -&gt; None\n</code></pre> <p>Set the limit mode of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>mode</code> <code>int | str | LimitMode</code> <p>The limit mode. Can be a LimitMode member name or value. For example, <code>LimitMode.BAND</code>, <code>2</code>, or <code>\"BAND\"</code> are equivalent.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_limit_mode(self, channel: Literal[1, 2], mode: int | str | LimitMode) -&gt; None:\n    \"\"\"Set the limit mode of a channel.\n\n    Args:\n        channel: The channel number.\n        mode: The limit mode. Can be a [LimitMode][msl.equipment_resources.mks.pr4000b.LimitMode]\n            member name or value. For example, `LimitMode.BAND`, `2`, or `\"BAND\"` are equivalent.\n    \"\"\"\n    self._check_channel(channel)\n    lm = to_enum(mode, LimitMode, to_upper=True)\n    _ = self._check(f\"LM{channel},{lm}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_linearization_point","title":"set_linearization_point","text":"<pre><code>set_linearization_point(\n    channel: Literal[1, 2], point: int, x: float, y: float\n) -&gt; None\n</code></pre> <p>Set a point in the linearization table of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>point</code> <code>int</code> <p>The point in the table [0, 10].</p> required <code>x</code> <code>float</code> <p>The x value [-5% to 100% of full scale].</p> required <code>y</code> <code>float</code> <p>The y value [-5% to 100% of full scale].</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_linearization_point(self, channel: Literal[1, 2], point: int, x: float, y: float) -&gt; None:\n    \"\"\"Set a point in the linearization table of a channel.\n\n    Args:\n        channel: The channel number.\n        point: The point in the table [0, 10].\n        x: The x value [-5% to 100% of full scale].\n        y: The y value [-5% to 100% of full scale].\n    \"\"\"\n    self._check_channel(channel)\n    if point &lt; 0 or point &gt; MAX_POINT:\n        msg = f\"Invalid point {point}\"\n        raise ValueError(msg)\n    _ = self._check(f\"LN{channel},{point},{x},{y}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_linearization_size","title":"set_linearization_size","text":"<pre><code>set_linearization_size(\n    channel: Literal[1, 2], size: int\n) -&gt; None\n</code></pre> <p>Set the size of the linearization table of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>size</code> <code>int</code> <p>The size of the table.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_linearization_size(self, channel: Literal[1, 2], size: int) -&gt; None:\n    \"\"\"Set the size of the linearization table of a channel.\n\n    Args:\n        channel: The channel number.\n        size: The size of the table.\n    \"\"\"\n    self._check_channel(channel)\n    if size &lt; 0 or size &gt; MAX_SIZE:\n        msg = f\"Invalid size {size}\"\n        raise ValueError(msg)\n    _ = self._check(f\"LS{channel},{size}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_lower_limit","title":"set_lower_limit","text":"<pre><code>set_lower_limit(\n    channel: Literal[1, 2], limit: float\n) -&gt; None\n</code></pre> <p>Set the lower limit of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>limit</code> <code>float</code> <p>The lower limit [-5% to 110% of full scale].</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_lower_limit(self, channel: Literal[1, 2], limit: float) -&gt; None:\n    \"\"\"Set the lower limit of a channel.\n\n    Args:\n        channel: The channel number.\n        limit: The lower limit [-5% to 110% of full scale].\n    \"\"\"\n    self._check_channel(channel)\n    _ = self._check(f\"LL{channel},{limit}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_offset","title":"set_offset","text":"<pre><code>set_offset(channel: Literal[1, 2], offset: int) -&gt; None\n</code></pre> <p>Set the offset of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>offset</code> <code>int</code> <p>The offset [-250, 250].</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_offset(self, channel: Literal[1, 2], offset: int) -&gt; None:\n    \"\"\"Set the offset of a channel.\n\n    Args:\n        channel: The channel number.\n        offset: The offset [-250, 250].\n    \"\"\"\n    self._check_channel(channel)\n    if offset &lt; -MAX_OFFSET or offset &gt; MAX_OFFSET:\n        msg = f\"Invalid offset {offset}, must be between [-{MAX_OFFSET}, {MAX_OFFSET}]\"\n        raise ValueError(msg)\n    _ = self._check(f\"OF{channel},{offset}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_output_range","title":"set_output_range","text":"<pre><code>set_output_range(\n    channel: Literal[1, 2], range: int\n) -&gt; None\n</code></pre> <p>Set the output range of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>range</code> <code>int</code> <p>The output range [1, 10] in Volts.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_output_range(self, channel: Literal[1, 2], range: int) -&gt; None:  # noqa: A002\n    \"\"\"Set the output range of a channel.\n\n    Args:\n        channel: The channel number.\n        range: The output range [1, 10] in Volts.\n    \"\"\"\n    self._check_channel(channel)\n    if range &lt; 1 or range &gt; MAX_RANGE:\n        msg = f\"Invalid output range {range}\"\n        raise ValueError(msg)\n    _ = self._check(f\"OT{channel},{range}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_range","title":"set_range","text":"<pre><code>set_range(\n    channel: Literal[1, 2], range: float, unit: int | str\n) -&gt; None\n</code></pre> <p>Set the range and unit of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>range</code> <code>float</code> <p>The range value.</p> required <code>unit</code> <code>int | str</code> <p>The unit as either an index number [0, 20] or a name (e.g., <code>7</code> or <code>\"kPa\"</code>). See UNIT for the supported unit values.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_range(self, channel: Literal[1, 2], range: float, unit: int | str) -&gt; None:  # noqa: A002\n    \"\"\"Set the range and unit of a channel.\n\n    Args:\n        channel: The channel number.\n        range: The range value.\n        unit: The unit as either an index number [0, 20] or a name (e.g., `7` or `\"kPa\"`).\n            See [UNIT][msl.equipment_resources.mks.pr4000b.UNIT] for the supported unit values.\n    \"\"\"\n    self._check_channel(channel)\n    index = -1\n    if isinstance(unit, str):\n        lower = unit.lower()\n        for i, v in enumerate(UNIT.values()):\n            if v.lower() == lower:\n                index = i\n                break\n    elif unit in UNIT:\n        index = unit\n\n    if index == -1:\n        msg = f\"Invalid unit {unit!r}\"\n        raise ValueError(msg)\n\n    _ = self._check(f\"RG{channel},{range},{index}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_relays","title":"set_relays","text":"<pre><code>set_relays(channel: Literal[1, 2], *, enable: bool) -&gt; None\n</code></pre> <p>Set the relay state of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>enable</code> <code>bool</code> <p>Whether to enable or disable the relay.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_relays(self, channel: Literal[1, 2], *, enable: bool) -&gt; None:\n    \"\"\"Set the relay state of a channel.\n\n    Args:\n        channel: The channel number.\n        enable: Whether to enable or disable the relay.\n    \"\"\"\n    self._check_channel(channel)\n    state = \"ON\" if enable else \"OFF\"\n    _ = self._check(f\"RL{channel},{state}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_remote_mode","title":"set_remote_mode","text":"<pre><code>set_remote_mode(*, enable: bool) -&gt; None\n</code></pre> <p>Set the remote operation mode to be enable or disabled.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>Whether to enable or disable remote operation.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_remote_mode(self, *, enable: bool) -&gt; None:\n    \"\"\"Set the remote operation mode to be enable or disabled.\n\n    Args:\n        enable: Whether to enable or disable remote operation.\n    \"\"\"\n    mode = \"ON\" if enable else \"OFF\"\n    _ = self._check(f\"RT,{mode}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_resolution","title":"set_resolution","text":"<pre><code>set_resolution(*, enable: bool) -&gt; None\n</code></pre> <p>Set the 16-bit resolution to be enabled or disabled.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>Whether to enable or disable 16-bit resolution.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_resolution(self, *, enable: bool) -&gt; None:\n    \"\"\"Set the 16-bit resolution to be enabled or disabled.\n\n    Args:\n        enable: Whether to enable or disable 16-bit resolution.\n    \"\"\"\n    state = \"ON\" if enable else \"OFF\"\n    _ = self._check(f\"RS,{state}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_rtd_offset","title":"set_rtd_offset","text":"<pre><code>set_rtd_offset(channel: Literal[1, 2], offset: int) -&gt; None\n</code></pre> <p>Set the RTD offset of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>offset</code> <code>int</code> <p>The RTD offset [-250, 250].</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_rtd_offset(self, channel: Literal[1, 2], offset: int) -&gt; None:\n    \"\"\"Set the RTD offset of a channel.\n\n    Args:\n        channel: The channel number.\n        offset: The RTD offset [-250, 250].\n    \"\"\"\n    self._check_channel(channel)\n    if offset &lt; -MAX_OFFSET or offset &gt; MAX_OFFSET:\n        msg = f\"Invalid RTD offset {offset}, must be between [-{MAX_OFFSET}, {MAX_OFFSET}]\"\n        raise ValueError(msg)\n    _ = self._check(f\"RO{channel},{offset}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_scale","title":"set_scale","text":"<pre><code>set_scale(channel: Literal[1, 2], scale: float) -&gt; None\n</code></pre> <p>Set the scale of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>scale</code> <code>float</code> <p>The scale.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_scale(self, channel: Literal[1, 2], scale: float) -&gt; None:\n    \"\"\"Set the scale of a channel.\n\n    Args:\n        channel: The channel number.\n        scale: The scale.\n    \"\"\"\n    self._check_channel(channel)\n    _ = self._check(f\"SC{channel},{scale}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_setpoint","title":"set_setpoint","text":"<pre><code>set_setpoint(\n    channel: Literal[1, 2], setpoint: float\n) -&gt; None\n</code></pre> <p>Set the setpoint of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>setpoint</code> <code>float</code> <p>The setpoint.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_setpoint(self, channel: Literal[1, 2], setpoint: float) -&gt; None:\n    \"\"\"Set the setpoint of a channel.\n\n    Args:\n        channel: The channel number.\n        setpoint: The setpoint.\n    \"\"\"\n    self._check_channel(channel)\n    _ = self._check(f\"SP{channel},{setpoint}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_signal_mode","title":"set_signal_mode","text":"<pre><code>set_signal_mode(\n    channel: Literal[1, 2], mode: SignalMode\n) -&gt; None\n</code></pre> <p>Set the range and unit of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>mode</code> <code>SignalMode</code> <p>The signal mode. Can be a SignalMode member name or value. For example, <code>SignalMode.OFF</code>, <code>1</code>, or <code>\"OFF\"</code> are equivalent.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_signal_mode(self, channel: Literal[1, 2], mode: SignalMode) -&gt; None:\n    \"\"\"Set the range and unit of a channel.\n\n    Args:\n        channel: The channel number.\n        mode: The signal mode. Can be a [SignalMode][msl.equipment_resources.mks.pr4000b.SignalMode]\n            member name or value. For example, `SignalMode.OFF`, `1`, or `\"OFF\"` are equivalent.\n    \"\"\"\n    self._check_channel(channel)\n    sm = to_enum(mode, SignalMode, to_upper=True)\n    _ = self._check(f\"SM{channel},{sm}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_tweak_control","title":"set_tweak_control","text":"<pre><code>set_tweak_control(*, enable: bool) -&gt; None\n</code></pre> <p>Set tweak control.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>Whether to switch tweak control on or off.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_tweak_control(self, *, enable: bool) -&gt; None:\n    \"\"\"Set tweak control.\n\n    Args:\n        enable: Whether to switch tweak control on or off.\n    \"\"\"\n    _ = self._check(\"$1\" if enable else \"$0\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_upper_limit","title":"set_upper_limit","text":"<pre><code>set_upper_limit(\n    channel: Literal[1, 2], limit: float\n) -&gt; None\n</code></pre> <p>Set the upper limit of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>limit</code> <code>float</code> <p>The upper limit [-5% to 110% of full scale].</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_upper_limit(self, channel: Literal[1, 2], limit: float) -&gt; None:\n    \"\"\"Set the upper limit of a channel.\n\n    Args:\n        channel: The channel number.\n        limit: The upper limit [-5% to 110% of full scale].\n    \"\"\"\n    self._check_channel(channel)\n    _ = self._check(f\"UL{channel},{limit}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_valve","title":"set_valve","text":"<pre><code>set_valve(channel: Literal[1, 2], *, enable: bool) -&gt; None\n</code></pre> <p>Set the state of the valve of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>enable</code> <code>bool</code> <p>Whether to enable or disable the valve state.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_valve(self, channel: Literal[1, 2], *, enable: bool) -&gt; None:\n    \"\"\"Set the state of the valve of a channel.\n\n    Args:\n        channel: The channel number.\n        enable: Whether to enable or disable the valve state.\n    \"\"\"\n    if channel == 0:  # pyright: ignore[reportUnnecessaryComparison]\n        msg = (  # pyright: ignore[reportUnreachable]\n            \"The manual indicates that you can specify channel=0 \"\n            \"to set both valves simultaneously, but that does not work\"\n        )\n        raise ValueError(msg)\n\n    self._check_channel(channel)\n    state = \"ON\" if enable else \"OFF\"\n    _ = self._check(f\"VL{channel},{state}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.status","title":"status","text":"<pre><code>status() -&gt; int\n</code></pre> <p>Request status bits.</p> <p>Returns:</p> Type Description <code>int</code> <p>The status value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def status(self) -&gt; int:\n    \"\"\"Request status bits.\n\n    Returns:\n        The status value.\n    \"\"\"\n    return int(self.query(\"ST\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.unlock","title":"unlock","text":"<pre><code>unlock() -&gt; None\n</code></pre> <p>Unlock setup.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def unlock(self) -&gt; None:\n    \"\"\"Unlock setup.\"\"\"\n    _ = self._check(\"#0\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.SignalMode","title":"SignalMode","text":"<p>               Bases: <code>IntEnum</code></p> <p>Signal mode type.</p> <p>Determines the source of the setpoint which shall be applied to the respective channel.</p> <p>Attributes:</p> Name Type Description <code>METER</code> <code>int</code> <p>0</p> <code>OFF</code> <code>int</code> <p>1</p> <code>INDEPENDENT</code> <code>int</code> <p>2</p> <code>EXTERNAL</code> <code>int</code> <p>3</p> <code>SLAVE</code> <code>int</code> <p>4</p> <code>RTD</code> <code>int</code> <p>5</p>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.Tag","title":"Tag","text":"<p>               Bases: <code>IntEnum</code></p> <p>Display tag types.</p> <p>Attributes:</p> Name Type Description <code>SP</code> <code>int</code> <p>0</p> <code>VA</code> <code>int</code> <p>1</p> <code>CH</code> <code>int</code> <p>2</p> <code>FL</code> <code>int</code> <p>3</p> <code>PR</code> <code>int</code> <p>4</p> <code>EX</code> <code>int</code> <p>5</p>"},{"location":"resources/nkt/nktpdll/","title":"NKTPDLL","text":"<p>Wrapper around the <code>NKTPDLL.dll</code> SDK from NKT Photonics.</p> <p>The wrapper was written using v2.1.2.766 of the SDK.</p>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.DeviceStatusCallback","title":"DeviceStatusCallback  <code>module-attribute</code>","text":"<pre><code>DeviceStatusCallback = CFUNCTYPE(\n    None, c_char_p, c_ubyte, c_ubyte, c_ubyte, c_void_p\n)\n</code></pre> <p>A callback function when the status of a device changes.</p>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.PortStatusCallback","title":"PortStatusCallback  <code>module-attribute</code>","text":"<pre><code>PortStatusCallback = CFUNCTYPE(\n    None, c_char_p, c_ubyte, c_ubyte, c_ubyte, c_ubyte\n)\n</code></pre> <p>A callback function when the status of a port changes.</p>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.RegisterStatusCallback","title":"RegisterStatusCallback  <code>module-attribute</code>","text":"<pre><code>RegisterStatusCallback = CFUNCTYPE(\n    None,\n    c_char_p,\n    c_ubyte,\n    c_ubyte,\n    c_ubyte,\n    c_ubyte,\n    c_ubyte,\n    c_void_p,\n)\n</code></pre> <p>A callback function when the status of a register changes.</p>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.DateTime","title":"DateTime","text":"<p>               Bases: <code>Structure</code></p> <p>The DateTimeType struct (24 hour format).</p> <p>Attributes:</p> Name Type Description <code>Sec</code> <code>c_uint8</code> <p>Second.</p> <code>Min</code> <code>c_uint8</code> <p>Minute.</p> <code>Hour</code> <code>c_uint8</code> <p>Hour.</p> <code>Day</code> <code>c_uint8</code> <p>Day.</p> <code>Month</code> <code>c_uint8</code> <p>Month.</p> <code>Year</code> <code>c_uint8</code> <p>Year.</p>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.DeviceMode","title":"DeviceMode","text":"<p>               Bases: <code>IntEnum</code></p> <p>The DeviceModeTypes enum.</p> <p>Attributes:</p> Name Type Description <code>Disabled</code> <code>int</code> <p>The device is disabled. Not being polled and serviced, <code>0</code>.</p> <code>AnalyseInit</code> <code>int</code> <p>The analyse cycle has been started for the device, <code>1</code>.</p> <code>Analyse</code> <code>int</code> <p>The analyse cycle is in progress. All default registers being read to determine its state, <code>2</code>.</p> <code>Normal</code> <code>int</code> <p>The analyse cycle has completed and the device is ready, <code>3</code>.</p> <code>LogDownload</code> <code>int</code> <p>A log is being downloaded from the device, <code>4</code>.</p> <code>Error</code> <code>int</code> <p>The device is in an error state, <code>5</code>.</p> <code>Timeout</code> <code>int</code> <p>The connection to the device has been lost, <code>6</code>.</p> <code>Upload</code> <code>int</code> <p>The device is in upload mode and can not be used normally, <code>7</code>.</p>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.DeviceStatus","title":"DeviceStatus","text":"<p>               Bases: <code>IntEnum</code></p> <p>The DeviceStatusTypes enum.</p> <p>Attributes:</p> Name Type Description <code>ModeChanged</code> <code>int</code> <p>Data contains 1 unsigned byte DeviceMode, <code>0</code>.</p> <code>LiveChanged</code> <code>int</code> <p>Data contains 1 unsigned byte, 0=live off, 1=live on, <code>1</code>.</p> <code>TypeChanged</code> <code>int</code> <p>Data contains 1 unsigned byte with DeviceType, <code>2</code>.</p> <code>PartNumberChanged</code> <code>int</code> <p>Data contains a zero terminated string with part number, <code>3</code>.</p> <code>PCBVersionChanged</code> <code>int</code> <p>Data contains 1 unsigned byte with PCB version number, <code>4</code>.</p> <code>StatusBitsChanged</code> <code>int</code> <p>Data contains 1 unsigned long with status bits, <code>5</code>.</p> <code>ErrorCodeChanged</code> <code>int</code> <p>Data contains 1 unsigned short with error code, <code>6</code>.</p> <code>BlVerChanged</code> <code>int</code> <p>Data contains a zero terminated string with Bootloader version, <code>7</code>.</p> <code>FwVerChanged</code> <code>int</code> <p>Data contains a zero terminated string with Firmware version, <code>8</code>.</p> <code>ModuleSerialChanged</code> <code>int</code> <p>Data contains a zero terminated string with Module serial number, <code>9</code>.</p> <code>PCBSerialChanged</code> <code>int</code> <p>Data contains a zero terminated string with PCB serial number, <code>10</code>.</p> <code>SysTypeChanged</code> <code>int</code> <p>Data contains 1 unsigned byte with SystemType, <code>11</code>.</p>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT","title":"NKT","text":"<pre><code>NKT(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Wrapper around the <code>NKTPDLL.dll</code> SDK from NKT Photonics.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for the NKT wrapper.</p> <p>Connection Properties:</p> Name Type Description <code>sdk_path</code> <code>str</code> <p>The path to the SDK library. Default: <code>\"NKTPDLL.dll\"</code></p> <code>open_port</code> <code>bool</code> <p>Whether to automatically open the port. Default: <code>True</code></p> <code>auto</code> <code>bool</code> <p>Whether to open the port with bus scanning. Default: <code>True</code></p> <code>live</code> <code>bool</code> <p>Whether to open the port in live mode. Default: <code>True</code></p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Wrapper around the `NKTPDLL.dll` SDK from [NKT Photonics](https://www.nktphotonics.com/).\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for the NKT wrapper.\n\n    Attributes: Connection Properties:\n        sdk_path (str): The path to the SDK library. _Default: `\"NKTPDLL.dll\"`_\n        open_port (bool): Whether to automatically open the port. _Default: `True`_\n        auto (bool): Whether to open the port with bus scanning. _Default: `True`_\n        live (bool): Whether to open the port in live mode. _Default: `True`_\n    \"\"\"\n    super().__init__(equipment)\n\n    assert equipment.connection is not None  # noqa: S101\n    address = equipment.connection.address\n    self._portname: bytes = address.encode()\n\n    p = equipment.connection.properties\n    _load_sdk(p.get(\"sdk_path\", _path), self)\n    assert NKT._SDK is not None  # noqa: S101\n\n    self._sdk: CDLL = NKT._SDK\n    if p.get(\"open_port\", True):\n        NKT.open_ports(address, auto=p.get(\"auto\", True), live=p.get(\"live\", True))\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.close_ports","title":"close_ports  <code>staticmethod</code>","text":"<pre><code>close_ports(*ports: str) -&gt; None\n</code></pre> <p>Close the specified port(s).</p> <p>Parameters:</p> Name Type Description Default <code>ports</code> <code>str</code> <p>The name(s) of the port(s) to close. If not specified, close all opened ports. Port names are case sensitive.</p> <code>()</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>@staticmethod\ndef close_ports(*ports: str) -&gt; None:\n    \"\"\"Close the specified port(s).\n\n    Args:\n        ports: The name(s) of the port(s) to close. If not specified, close all opened ports.\n            Port names are case sensitive.\n    \"\"\"\n    if NKT._SDK is None:\n        return\n\n    _names = b\",\".join(port.encode() for port in ports)\n    NKT._SDK.closePorts(ports)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_create","title":"device_create","text":"<pre><code>device_create(device_id: int, *, wait_ready: bool) -&gt; None\n</code></pre> <p>Creates a device in the internal device list.</p> <p>If the open_ports function has been called with <code>live=True</code> then the kernel immediately starts to monitor the device.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>wait_ready</code> <code>bool</code> <p><code>False</code> means don't wait for the device to be ready. <code>True</code> means to wait up to 2 seconds for the device to complete its analyse cycle. (All standard registers being successfully read)</p> required Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_create(self, device_id: int, *, wait_ready: bool) -&gt; None:\n    \"\"\"Creates a device in the internal device list.\n\n    If the [open_ports][msl.equipment_resources.nkt.nktpdll.NKT.open_ports] function has\n    been called with `live=True` then the kernel immediately starts to monitor the device.\n\n    Args:\n        device_id: The device id (module address).\n        wait_ready: `False` means don't wait for the device to be ready. `True` means to\n            wait up to 2 seconds for the device to complete its analyse cycle.\n            (All standard registers being successfully read)\n    \"\"\"\n    self._sdk.deviceCreate(self._portname, device_id, int(bool(wait_ready)))\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_exists","title":"device_exists","text":"<pre><code>device_exists(device_id: int) -&gt; bool\n</code></pre> <p>Checks if a specific device already exists in the internal device list.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the device exists.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_exists(self, device_id: int) -&gt; bool:\n    \"\"\"Checks if a specific device already exists in the internal device list.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        Whether the device exists.\n    \"\"\"\n    exists = c_ubyte(0)\n    self._sdk.deviceExists(self._portname, device_id, exists)\n    return bool(exists.value)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_all_types","title":"device_get_all_types  <code>staticmethod</code>","text":"<pre><code>device_get_all_types(\n    *ports: str, size: int = 255\n) -&gt; dict[str, dict[str, int]]\n</code></pre> <p>Returns all device types (module types) from the internal device list.</p> <p>Parameters:</p> Name Type Description Default <code>ports</code> <code>str</code> <p>A port or multiple ports. If not specified then the get_open_ports method is called.</p> <code>()</code> <code>size</code> <code>int</code> <p>The maximum number of bytes that the device list can be.</p> <code>255</code> <p>Returns:</p> Type Description <code>dict[str, dict[str, int]]</code> <p>The port names are the keys and each value is dict with the module type as the keys and its corresponding device ID as the value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>@staticmethod\ndef device_get_all_types(*ports: str, size: int = 255) -&gt; dict[str, dict[str, int]]:\n    \"\"\"Returns all device types (module types) from the internal device list.\n\n    Args:\n        ports: A port or multiple ports. If not specified then the\n            [get_open_ports][msl.equipment_resources.nkt.nktpdll.NKT.get_open_ports]\n            method is called.\n        size: The maximum number of bytes that the device list can be.\n\n    Returns:\n        The port names are the keys and each value is [dict][] with the\n            module type as the keys and its corresponding device ID as the value.\n    \"\"\"\n    if NKT._SDK is None:\n        msg = \"You must first call NKT.load_sdk()\"\n        raise RuntimeError(msg)\n\n    if not ports:\n        opened_ports = [port.encode() for port in NKT.get_open_ports()]\n    else:\n        opened_ports = [port.encode() for port in ports]\n\n    out: dict[str, dict[str, int]] = {}\n    length = c_ubyte(size)\n    types = create_string_buffer(size)\n    for port in opened_ports:\n        NKT._SDK.deviceGetAllTypes(port, types, length)\n        key = port.decode()\n        out[key] = {}\n        for dev_id, typ in enumerate(types.raw):\n            if typ != 0:\n                out[key][f\"0x{typ:02X}\"] = dev_id\n    return out\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_boot_loader_version","title":"device_get_boot_loader_version","text":"<pre><code>device_get_boot_loader_version(device_id: int) -&gt; int\n</code></pre> <p>Returns the boot-loader version (int) for a given device id.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The boot-loader version.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_get_boot_loader_version(self, device_id: int) -&gt; int:\n    \"\"\"Returns the boot-loader version (int) for a given device id.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        The boot-loader version.\n    \"\"\"\n    version = c_ushort(0)\n    self._sdk.deviceGetBootloaderVersion(self._portname, device_id, version)\n    return version.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_boot_loader_version_str","title":"device_get_boot_loader_version_str","text":"<pre><code>device_get_boot_loader_version_str(device_id: int) -&gt; str\n</code></pre> <p>Returns the boot-loader version (string) for a given device id.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>str</code> <p>The boot-loader version.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_get_boot_loader_version_str(self, device_id: int) -&gt; str:\n    \"\"\"Returns the boot-loader version (string) for a given device id.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        The boot-loader version.\n    \"\"\"\n    size = c_ubyte(255)\n    version = create_string_buffer(size.value)\n    self._sdk.deviceGetBootloaderVersionStr(self._portname, device_id, version, size)\n    return bytes(version.value).decode()\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_error_code","title":"device_get_error_code","text":"<pre><code>device_get_error_code(device_id: int) -&gt; int\n</code></pre> <p>Returns the error code for a given device id.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The error code.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_get_error_code(self, device_id: int) -&gt; int:\n    \"\"\"Returns the error code for a given device id.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        The error code.\n    \"\"\"\n    error_code = c_ushort(0)\n    self._sdk.deviceGetErrorCode(self._portname, device_id, error_code)\n    return error_code.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_firmware_version","title":"device_get_firmware_version","text":"<pre><code>device_get_firmware_version(device_id: int) -&gt; int\n</code></pre> <p>Returns the firmware version (int) for a given device id.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The firmware version.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_get_firmware_version(self, device_id: int) -&gt; int:\n    \"\"\"Returns the firmware version (int) for a given device id.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        The firmware version.\n    \"\"\"\n    version = c_ushort(0)\n    self._sdk.deviceGetFirmwareVersion(self._portname, device_id, version)\n    return version.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_firmware_version_str","title":"device_get_firmware_version_str","text":"<pre><code>device_get_firmware_version_str(device_id: int) -&gt; str\n</code></pre> <p>Returns the firmware version (string) for a given device id.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>str</code> <p>The firmware version.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_get_firmware_version_str(self, device_id: int) -&gt; str:\n    \"\"\"Returns the firmware version (string) for a given device id.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        The firmware version.\n    \"\"\"\n    size = c_ubyte(255)\n    version = create_string_buffer(size.value)\n    self._sdk.deviceGetFirmwareVersionStr(self._portname, device_id, version, size)\n    return bytes(version.value).decode()\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_live","title":"device_get_live","text":"<pre><code>device_get_live(device_id: int) -&gt; bool\n</code></pre> <p>Returns the internal device live status for a specific device id.</p> <p>Requires the port being already opened with the open_ports function and the device being already created, either automatically or with the device_create function.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether live mode is enabled.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_get_live(self, device_id: int) -&gt; bool:\n    \"\"\"Returns the internal device live status for a specific device id.\n\n    Requires the port being already opened with the [open_ports][msl.equipment_resources.nkt.nktpdll.NKT.open_ports]\n    function and the device being already created, either automatically or with the\n    [device_create][msl.equipment_resources.nkt.nktpdll.NKT.device_create] function.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        Whether live mode is enabled.\n    \"\"\"\n    live_mode = c_ubyte(0)\n    self._sdk.deviceGetLive(self._portname, device_id, live_mode)\n    return bool(live_mode.value)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_mode","title":"device_get_mode","text":"<pre><code>device_get_mode(device_id: int) -&gt; DeviceMode\n</code></pre> <p>Returns the internal device mode for a specific device id.</p> <p>Requires the port being already opened with the open_ports function and the device being already created, either automatically or with the device_create function.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>DeviceMode</code> <p>The device mode type.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_get_mode(self, device_id: int) -&gt; DeviceMode:\n    \"\"\"Returns the internal device mode for a specific device id.\n\n    Requires the port being already opened with the [open_ports][msl.equipment_resources.nkt.nktpdll.NKT.open_ports]\n    function and the device being already created, either automatically or with the\n    [device_create][msl.equipment_resources.nkt.nktpdll.NKT.device_create] function.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        The device mode type.\n    \"\"\"\n    dev_mode = c_ubyte(0)\n    self._sdk.deviceGetMode(self._portname, device_id, dev_mode)\n    return DeviceMode(dev_mode.value)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_module_serial_number_str","title":"device_get_module_serial_number_str","text":"<pre><code>device_get_module_serial_number_str(device_id: int) -&gt; str\n</code></pre> <p>Returns the module serial number (string) for a given device id.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>str</code> <p>The serial number.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_get_module_serial_number_str(self, device_id: int) -&gt; str:\n    \"\"\"Returns the module serial number (string) for a given device id.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        The serial number.\n    \"\"\"\n    size = c_ubyte(255)\n    serial = create_string_buffer(size.value)\n    self._sdk.deviceGetModuleSerialNumberStr(self._portname, device_id, serial, size)\n    return bytes(serial.value).decode()\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_part_number_str","title":"device_get_part_number_str","text":"<pre><code>device_get_part_number_str(device_id: int) -&gt; str\n</code></pre> <p>Returns the part number for a given device id.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>str</code> <p>The part number.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_get_part_number_str(self, device_id: int) -&gt; str:\n    \"\"\"Returns the part number for a given device id.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        The part number.\n    \"\"\"\n    size = c_ubyte(255)\n    part = create_string_buffer(size.value)\n    self._sdk.deviceGetPartNumberStr(self._portname, device_id, part, size)\n    return bytes(part.value).decode()\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_pcb_serial_number_str","title":"device_get_pcb_serial_number_str","text":"<pre><code>device_get_pcb_serial_number_str(device_id: int) -&gt; str\n</code></pre> <p>Returns the PCB serial number (string) for a given device id.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>str</code> <p>The part number.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_get_pcb_serial_number_str(self, device_id: int) -&gt; str:\n    \"\"\"Returns the PCB serial number (string) for a given device id.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        The part number.\n    \"\"\"\n    size = c_ubyte(255)\n    serial = create_string_buffer(size.value)\n    self._sdk.deviceGetPCBSerialNumberStr(self._portname, device_id, serial, size)\n    return bytes(serial.value).decode()\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_pcb_version","title":"device_get_pcb_version","text":"<pre><code>device_get_pcb_version(device_id: int) -&gt; int\n</code></pre> <p>Returns the PCB version for a given device id.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The PCB version number.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_get_pcb_version(self, device_id: int) -&gt; int:\n    \"\"\"Returns the PCB version for a given device id.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        The PCB version number.\n    \"\"\"\n    version = c_ubyte(0)\n    self._sdk.deviceGetPCBVersion(self._portname, device_id, version)\n    return version.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_status_bits","title":"device_get_status_bits","text":"<pre><code>device_get_status_bits(device_id: int) -&gt; int\n</code></pre> <p>Returns the status bits for a given device id.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The status bits.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_get_status_bits(self, device_id: int) -&gt; int:\n    \"\"\"Returns the status bits for a given device id.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        The status bits.\n    \"\"\"\n    status = c_ushort(0)\n    self._sdk.deviceGetStatusBits(self._portname, device_id, status)\n    return status.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_type","title":"device_get_type","text":"<pre><code>device_get_type(device_id: int) -&gt; int\n</code></pre> <p>Returns the module type for a specific device id.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The module type.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_get_type(self, device_id: int) -&gt; int:\n    \"\"\"Returns the module type for a specific device id.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        The module type.\n    \"\"\"\n    dev_type = c_ubyte(0)\n    self._sdk.deviceGetType(self._portname, device_id, dev_type)\n    return dev_type.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_remove","title":"device_remove","text":"<pre><code>device_remove(device_id: int) -&gt; None\n</code></pre> <p>Remove a specific device from the internal device list.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_remove(self, device_id: int) -&gt; None:\n    \"\"\"Remove a specific device from the internal device list.\n\n    Args:\n        device_id: The device id (module address).\n    \"\"\"\n    self._sdk.deviceRemove(self._portname, device_id)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_remove_all","title":"device_remove_all","text":"<pre><code>device_remove_all() -&gt; None\n</code></pre> <p>Remove all devices from the internal device list.</p> <p>No confirmation is given, the list is simply cleared.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_remove_all(self) -&gt; None:\n    \"\"\"Remove all devices from the internal device list.\n\n    No confirmation is given, the list is simply cleared.\n    \"\"\"\n    self._sdk.deviceRemoveAll(self._portname)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_set_live","title":"device_set_live","text":"<pre><code>device_set_live(device_id: int, *, enabled: bool) -&gt; None\n</code></pre> <p>Sets the internal device live status for a specific device id (module address).</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>enabled</code> <code>bool</code> <p>Whether to enable (<code>True</code>) or disable (<code>False</code>) live status.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_set_live(self, device_id: int, *, enabled: bool) -&gt; None:\n    \"\"\"Sets the internal device live status for a specific device id (module address).\n\n    Args:\n        device_id: The device id (module address).\n        enabled: Whether to enable (`True`) or disable (`False`) live status.\n    \"\"\"\n    self._sdk.deviceSetLive(self._portname, device_id, int(enabled))\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the port.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Disconnect from the port.\"\"\"\n    if hasattr(self, \"_address\") and self._portname:\n        self.close_ports(self._portname.decode())\n        self._portname = b\"\"\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.get_all_ports","title":"get_all_ports  <code>staticmethod</code>","text":"<pre><code>get_all_ports(size: int = 255) -&gt; list[str]\n</code></pre> <p>Returns a list of all ports.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>The maximum size of the string buffer to fetch the results.</p> <code>255</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of port names.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>@staticmethod\ndef get_all_ports(size: int = 255) -&gt; list[str]:\n    \"\"\"Returns a list of all ports.\n\n    Args:\n        size: The maximum size of the string buffer to fetch the results.\n\n    Returns:\n        A list of port names.\n    \"\"\"\n    if NKT._SDK is None:\n        msg = \"You must first call NKT.load_sdk()\"\n        raise RuntimeError(msg)\n\n    length = c_ushort(size)\n    names = create_string_buffer(size)\n    NKT._SDK.getAllPorts(names, length)\n    return [name for name in bytes(names.value).decode().split(\",\") if name]\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.get_legacy_bus_scanning","title":"get_legacy_bus_scanning  <code>staticmethod</code>","text":"<pre><code>get_legacy_bus_scanning() -&gt; bool\n</code></pre> <p>Get the bus-scanning mode.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if in legacy mode, <code>False</code> if in normal mode.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>@staticmethod\ndef get_legacy_bus_scanning() -&gt; bool:\n    \"\"\"Get the bus-scanning mode.\n\n    Returns:\n        `True` if in legacy mode, `False` if in normal mode.\n    \"\"\"\n    if NKT._SDK is None:\n        msg = \"You must first call NKT.load_sdk()\"\n        raise RuntimeError(msg)\n\n    return bool(NKT._SDK.getLegacyBusScanning())\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.get_modules","title":"get_modules","text":"<pre><code>get_modules(size: int = 255) -&gt; dict[str, int]\n</code></pre> <p>Returns all device types (module types) from the device.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>The maximum number of bytes that the device list can be.</p> <code>255</code> <p>Returns:</p> Type Description <code>dict[str, int]</code> <p>The module type as the keys and its corresponding device ID as the value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def get_modules(self, size: int = 255) -&gt; dict[str, int]:\n    \"\"\"Returns all device types (module types) from the device.\n\n    Args:\n        size: The maximum number of bytes that the device list can be.\n\n    Returns:\n        The module type as the keys and its corresponding device ID as the value.\n    \"\"\"\n    a = self._portname.decode()\n    return NKT.device_get_all_types(a, size=size)[a]\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.get_open_ports","title":"get_open_ports  <code>staticmethod</code>","text":"<pre><code>get_open_ports(size: int = 255) -&gt; list[str]\n</code></pre> <p>Returns a list of already-opened ports.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>The maximum size of the string buffer to fetch the results.</p> <code>255</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of port names that are already open.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>@staticmethod\ndef get_open_ports(size: int = 255) -&gt; list[str]:\n    \"\"\"Returns a list of already-opened ports.\n\n    Args:\n        size: The maximum size of the string buffer to fetch the results.\n\n    Returns:\n        A list of port names that are already open.\n    \"\"\"\n    if NKT._SDK is None:\n        msg = \"You must first call NKT.load_sdk()\"\n        raise RuntimeError(msg)\n\n    length = c_ushort(size)\n    names = create_string_buffer(size)\n    NKT._SDK.getOpenPorts(names, length)\n    return [name for name in bytes(names.value).decode().split(\",\") if name]\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.get_port_error_msg","title":"get_port_error_msg","text":"<pre><code>get_port_error_msg() -&gt; str\n</code></pre> <p>Retrieve error message for the port.</p> <p>Returns:</p> Type Description <code>str</code> <p>The error message. An empty string indicates no error.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def get_port_error_msg(self) -&gt; str:\n    \"\"\"Retrieve error message for the port.\n\n    Returns:\n        The error message. An empty string indicates no error.\n    \"\"\"\n    length = c_ushort(255)\n    msg = create_string_buffer(length.value)\n    self._sdk.getPortErrorMsg(self._portname, msg, length)\n    return bytes(msg.value).decode()\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.get_port_status","title":"get_port_status","text":"<pre><code>get_port_status() -&gt; PortStatus\n</code></pre> <p>Get the status of the port.</p> <p>Returns:</p> Type Description <code>PortStatus</code> <p>The port status.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def get_port_status(self) -&gt; PortStatus:\n    \"\"\"Get the status of the port.\n\n    Returns:\n        The port status.\n    \"\"\"\n    status = c_ubyte(0)\n    self._sdk.getPortStatus(self._portname, status)\n    return PortStatus(status.value)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.load_sdk","title":"load_sdk  <code>staticmethod</code>","text":"<pre><code>load_sdk(path: PathLike | None = None) -&gt; None\n</code></pre> <p>Load the SDK.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>PathLike | None</code> <p>The path to <code>NKTPDLL.dll</code>. Reads from the <code>NKTP_SDK_PATH</code> environment variable if not specified.</p> <code>None</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>@staticmethod\ndef load_sdk(path: PathLike | None = None) -&gt; None:\n    \"\"\"Load the SDK.\n\n    Args:\n        path: The path to `NKTPDLL.dll`. Reads from the `NKTP_SDK_PATH` environment\n            variable if not specified.\n    \"\"\"\n    _load_sdk(_path if not path else os.fsdecode(path))\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.open_ports","title":"open_ports  <code>staticmethod</code>","text":"<pre><code>open_ports(\n    *names: str, auto: bool = True, live: bool = True\n) -&gt; None\n</code></pre> <p>Open the specified port(s).</p> <p>Repeated calls to this function is allowed to reopen and/or rescan for devices.</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>str</code> <p>If not specified then open all available ports are opened. Port names are case sensitive. Example port names are <code>\"AcoustikPort1\"</code>, <code>\"COM6\"</code>.</p> <code>()</code> <code>auto</code> <code>bool</code> <p>If <code>True</code> then automatically start bus scanning and add the found devices in the internal device list. If <code>False</code> then bus scanning and device creation is not automatically handled. The port is automatically closed if no devices are found.</p> <code>True</code> <code>live</code> <code>bool</code> <p>If <code>True</code> then keep all the found or created devices in live mode, which means the inter-bus kernel keeps monitoring all the found devices and their registers. Please note that this will keep the modules watchdog alive as long as the port is open. If <code>False</code> then disable continuous monitoring of the registers. No callback is possible on register changes, so you must call the register_read, register_write and register_write_read methods.</p> <code>True</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>@staticmethod\ndef open_ports(*names: str, auto: bool = True, live: bool = True) -&gt; None:\n    \"\"\"Open the specified port(s).\n\n    Repeated calls to this function is allowed to reopen and/or rescan for devices.\n\n    Args:\n        names: If not specified then open all available ports are opened. Port\n            names are case sensitive. Example port names are `\"AcoustikPort1\"`, `\"COM6\"`.\n        auto: If `True` then automatically start bus scanning and add the\n            found devices in the internal device list. If `False` then\n            bus scanning and device creation is not automatically handled. The\n            port is automatically closed if no devices are found.\n        live: If `True` then keep all the found or created devices in live\n            mode, which means the inter-bus kernel keeps monitoring all the found\n            devices and their registers. Please note that this will keep the modules\n            watchdog alive as long as the port is open. If `False` then disable\n            continuous monitoring of the registers. No callback is possible on register\n            changes, so you must call the [register_read][msl.equipment_resources.nkt.nktpdll.NKT.register_read],\n            [register_write][msl.equipment_resources.nkt.nktpdll.NKT.register_write] and\n            [register_write_read][msl.equipment_resources.nkt.nktpdll.NKT.register_write_read]\n            methods.\n    \"\"\"\n    if NKT._SDK is None:\n        msg = \"You must first call NKT.load_sdk()\"\n        raise RuntimeError(msg)\n\n    _names = b\",\".join(name.encode() for name in names)\n    NKT._SDK.openPorts(names, int(bool(auto)), int(bool(live)))\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.point_to_point_port_add","title":"point_to_point_port_add","text":"<pre><code>point_to_point_port_add(port: PointToPoint) -&gt; None\n</code></pre> <p>Creates or modifies a point-to-point port.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>PointToPoint</code> <p>A point-to-point port.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def point_to_point_port_add(self, port: PointToPoint) -&gt; None:\n    \"\"\"Creates or modifies a point-to-point port.\n\n    Args:\n        port: A point-to-point port.\n    \"\"\"\n    self._sdk.pointToPointPortAdd(\n        self._portname,\n        port.host_address.encode(),\n        port.host_port,\n        port.client_address.encode(),\n        port.client_port,\n        port.protocol,\n        port.ms_timeout,\n    )\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.point_to_point_port_del","title":"point_to_point_port_del","text":"<pre><code>point_to_point_port_del() -&gt; None\n</code></pre> <p>Delete the point-to-point port.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def point_to_point_port_del(self) -&gt; None:\n    \"\"\"Delete the point-to-point port.\"\"\"\n    self._sdk.pointToPointPortDel(self._portname)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.point_to_point_port_get","title":"point_to_point_port_get","text":"<pre><code>point_to_point_port_get() -&gt; PointToPoint\n</code></pre> <p>Retrieve the information about the point-to-point port setting.</p> <p>Returns:</p> Type Description <code>PointToPoint</code> <p>The information about the point-to-point port setting.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def point_to_point_port_get(self) -&gt; PointToPoint:\n    \"\"\"Retrieve the information about the point-to-point port setting.\n\n    Returns:\n        The information about the point-to-point port setting.\n    \"\"\"\n    host_length = c_ubyte(255)\n    host_address = create_string_buffer(host_length.value)\n    host_port = c_ushort(0)\n    client_length = c_ubyte(255)\n    client_address = create_string_buffer(client_length.value)\n    client_port = c_ushort(0)\n    protocol = c_ubyte(0)\n    ms_timeout = c_ubyte(0)\n    self._sdk.pointToPointPortGet(\n        self._portname,\n        host_address,\n        host_length,\n        host_port,\n        client_address,\n        client_length,\n        client_port,\n        protocol,\n        ms_timeout,\n    )\n    return PointToPoint(\n        host_address=host_address.value.decode(),\n        host_port=host_port.value,\n        client_address=client_address.value.decode(),\n        client_port=client_port.value,\n        protocol=protocol.value,\n        ms_timeout=ms_timeout.value,\n    )\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_create","title":"register_create","text":"<pre><code>register_create(\n    device_id: int,\n    reg_id: int,\n    priority: int | RegisterPriority,\n    data: int | RegisterData,\n) -&gt; None\n</code></pre> <p>Creates a register in the internal register list.</p> <p>If the open_ports function has been called with <code>live=True</code> then the kernel immediately starts to monitor the register.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>priority</code> <code>int | RegisterPriority</code> <p>The monitoring priority.</p> required <code>data</code> <code>int | RegisterData</code> <p>The register data type. Not used internally but could be used in a common callback function to determine the data type.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_create(\n    self, device_id: int, reg_id: int, priority: int | RegisterPriority, data: int | RegisterData\n) -&gt; None:\n    \"\"\"Creates a register in the internal register list.\n\n    If the [open_ports][msl.equipment_resources.nkt.nktpdll.NKT.open_ports] function has\n    been called with `live=True` then the kernel immediately starts to monitor the register.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        priority: The monitoring priority.\n        data: The register data type. Not used internally but could be used in a\n            common callback function to determine the data type.\n    \"\"\"\n    self._sdk.registerCreate(self._portname, device_id, reg_id, RegisterPriority(priority), RegisterData(data))\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_exists","title":"register_exists","text":"<pre><code>register_exists(device_id: int, reg_id: int) -&gt; bool\n</code></pre> <p>Checks if a specific register already exists in the internal register list.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the register exists.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_exists(self, device_id: int, reg_id: int) -&gt; bool:\n    \"\"\"Checks if a specific register already exists in the internal register list.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n\n    Returns:\n        Whether the register exists.\n    \"\"\"\n    exists = c_ubyte(0)\n    self._sdk.registerExists(self._portname, device_id, reg_id, exists)\n    return bool(exists.value)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_get_all","title":"register_get_all","text":"<pre><code>register_get_all(device_id: int) -&gt; list[int]\n</code></pre> <p>Returns the register ids (register addresses) from the internal register list.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>The register ids.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_get_all(self, device_id: int) -&gt; list[int]:\n    \"\"\"Returns the register ids (register addresses) from the internal register list.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        The register ids.\n    \"\"\"\n    size = c_ubyte(255)\n    regs = create_string_buffer(size.value)\n    self._sdk.registerGetAll(self._portname, device_id, regs, size)\n    ids: list[int] = list(regs.value)\n    return ids\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_read","title":"register_read","text":"<pre><code>register_read(\n    device_id: int, reg_id: int, index: int = -1\n) -&gt; bytes\n</code></pre> <p>Reads a register value and returns the result.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to extract data from a specific position in the register. Index is byte counted.</p> <code>-1</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The register value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_read(self, device_id: int, reg_id: int, index: int = -1) -&gt; bytes:\n    \"\"\"Reads a register value and returns the result.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        index: Value index. Typically -1, but could be used to extract data from\n            a specific position in the register. Index is byte counted.\n\n    Returns:\n        The register value.\n    \"\"\"\n    size = c_ubyte(255)\n    data = create_string_buffer(size.value)\n    self._sdk.registerRead(self._portname, device_id, reg_id, data, size, index)\n    return data.raw[: size.value]\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_read_ascii","title":"register_read_ascii","text":"<pre><code>register_read_ascii(\n    device_id: int, reg_id: int, index: int = -1\n) -&gt; str\n</code></pre> <p>Reads an ascii string from the register.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to extract data from a specific position in the register. Index is byte counted.</p> <code>-1</code> <p>Returns:</p> Type Description <code>str</code> <p>The ascii value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_read_ascii(self, device_id: int, reg_id: int, index: int = -1) -&gt; str:\n    \"\"\"Reads an ascii string from the register.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        index: Value index. Typically -1, but could be used to extract data from\n            a specific position in the register. Index is byte counted.\n\n    Returns:\n        The ascii value.\n    \"\"\"\n    size = c_ubyte(255)\n    data = create_string_buffer(size.value)\n    self._sdk.registerReadAscii(self._portname, device_id, reg_id, data, size, index)\n    return bytes(data.value).decode()\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_read_f32","title":"register_read_f32","text":"<pre><code>register_read_f32(\n    device_id: int, reg_id: int, index: int = -1\n) -&gt; float\n</code></pre> <p>Reads 32-bit float value from the register.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to extract data from a specific position in the register. Index is byte counted.</p> <code>-1</code> <p>Returns:</p> Type Description <code>float</code> <p>The 32-bit float value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_read_f32(self, device_id: int, reg_id: int, index: int = -1) -&gt; float:\n    \"\"\"Reads 32-bit float value from the register.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        index: Value index. Typically -1, but could be used to extract data from\n            a specific position in the register. Index is byte counted.\n\n    Returns:\n        The 32-bit float value.\n    \"\"\"\n    data = c_float(0)\n    self._sdk.registerReadF32(self._portname, device_id, reg_id, data, index)\n    return data.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_read_f64","title":"register_read_f64","text":"<pre><code>register_read_f64(\n    device_id: int, reg_id: int, index: int = -1\n) -&gt; float\n</code></pre> <p>Reads 64-bit double value from the register.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to extract data from a specific position in the register. Index is byte counted.</p> <code>-1</code> <p>Returns:</p> Type Description <code>float</code> <p>The 64-bit double value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_read_f64(self, device_id: int, reg_id: int, index: int = -1) -&gt; float:\n    \"\"\"Reads 64-bit double value from the register.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        index: Value index. Typically -1, but could be used to extract data from\n            a specific position in the register. Index is byte counted.\n\n    Returns:\n        The 64-bit double value.\n    \"\"\"\n    data = c_double(0)\n    self._sdk.registerReadF64(self._portname, device_id, reg_id, data, index)\n    return data.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_read_s16","title":"register_read_s16","text":"<pre><code>register_read_s16(\n    device_id: int, reg_id: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Reads 16-bit signed short value from the register.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to extract data from a specific position in the register. Index is byte counted.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 16-bit signed short value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_read_s16(self, device_id: int, reg_id: int, index: int = -1) -&gt; int:\n    \"\"\"Reads 16-bit signed short value from the register.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        index: Value index. Typically -1, but could be used to extract data from\n            a specific position in the register. Index is byte counted.\n\n    Returns:\n        The 16-bit signed short value.\n    \"\"\"\n    data = c_short(0)\n    self._sdk.registerReadS16(self._portname, device_id, reg_id, data, index)\n    return data.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_read_s32","title":"register_read_s32","text":"<pre><code>register_read_s32(\n    device_id: int, reg_id: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Reads 32-bit signed long value from the register.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to extract data from a specific position in the register. Index is byte counted.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 32-bit signed long value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_read_s32(self, device_id: int, reg_id: int, index: int = -1) -&gt; int:\n    \"\"\"Reads 32-bit signed long value from the register.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        index: Value index. Typically -1, but could be used to extract data from\n            a specific position in the register. Index is byte counted.\n\n    Returns:\n        The 32-bit signed long value.\n    \"\"\"\n    data = c_long(0)\n    self._sdk.registerReadS32(self._portname, device_id, reg_id, data, index)\n    return data.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_read_s64","title":"register_read_s64","text":"<pre><code>register_read_s64(\n    device_id: int, reg_id: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Reads 64-bit signed long long value from the register.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to extract data from a specific position in the register. Index is byte counted.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 64-bit signed long long value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_read_s64(self, device_id: int, reg_id: int, index: int = -1) -&gt; int:\n    \"\"\"Reads 64-bit signed long long value from the register.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        index: Value index. Typically -1, but could be used to extract data from\n            a specific position in the register. Index is byte counted.\n\n    Returns:\n        The 64-bit signed long long value.\n    \"\"\"\n    data = c_longlong(0)\n    self._sdk.registerReadS64(self._portname, device_id, reg_id, data, index)\n    return data.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_read_s8","title":"register_read_s8","text":"<pre><code>register_read_s8(\n    device_id: int, reg_id: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Reads 8-bit signed char value from the register.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to extract data from a specific position in the register. Index is byte counted.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 8-bit signed char value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_read_s8(self, device_id: int, reg_id: int, index: int = -1) -&gt; int:\n    \"\"\"Reads 8-bit signed char value from the register.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        index: Value index. Typically -1, but could be used to extract data from\n            a specific position in the register. Index is byte counted.\n\n    Returns:\n        The 8-bit signed char value.\n    \"\"\"\n    data = c_byte(0)\n    self._sdk.registerReadS8(self._portname, device_id, reg_id, data, index)\n    return data.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_read_u16","title":"register_read_u16","text":"<pre><code>register_read_u16(\n    device_id: int, reg_id: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Reads 16-bit unsigned short value from the register.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to extract data from a specific position in the register. Index is byte counted.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 16-bit unsigned short value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_read_u16(self, device_id: int, reg_id: int, index: int = -1) -&gt; int:\n    \"\"\"Reads 16-bit unsigned short value from the register.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        index: Value index. Typically -1, but could be used to extract data from\n            a specific position in the register. Index is byte counted.\n\n    Returns:\n        The 16-bit unsigned short value.\n    \"\"\"\n    data = c_ushort(0)\n    self._sdk.registerReadU16(self._portname, device_id, reg_id, data, index)\n    return data.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_read_u32","title":"register_read_u32","text":"<pre><code>register_read_u32(\n    device_id: int, reg_id: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Reads 32-bit unsigned long value from the register.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to extract data from a specific position in the register. Index is byte counted.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 32-bit unsigned long value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_read_u32(self, device_id: int, reg_id: int, index: int = -1) -&gt; int:\n    \"\"\"Reads 32-bit unsigned long value from the register.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        index: Value index. Typically -1, but could be used to extract data from\n            a specific position in the register. Index is byte counted.\n\n    Returns:\n        The 32-bit unsigned long value.\n    \"\"\"\n    data = c_ulong(0)\n    self._sdk.registerReadU32(self._portname, device_id, reg_id, data, index)\n    return data.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_read_u64","title":"register_read_u64","text":"<pre><code>register_read_u64(\n    device_id: int, reg_id: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Reads 64-bit unsigned long long value from the register.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to extract data from a specific position in the register. Index is byte counted.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 64-bit unsigned long long value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_read_u64(self, device_id: int, reg_id: int, index: int = -1) -&gt; int:\n    \"\"\"Reads 64-bit unsigned long long value from the register.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        index: Value index. Typically -1, but could be used to extract data from\n            a specific position in the register. Index is byte counted.\n\n    Returns:\n        The 64-bit unsigned long long value.\n    \"\"\"\n    data = c_ulonglong(0)\n    self._sdk.registerReadU64(self._portname, device_id, reg_id, data, index)\n    return data.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_read_u8","title":"register_read_u8","text":"<pre><code>register_read_u8(\n    device_id: int, reg_id: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Reads 8-bit unsigned char value from the register.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to extract data from a specific position in the register. Index is byte counted.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 8-bit unsigned char value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_read_u8(self, device_id: int, reg_id: int, index: int = -1) -&gt; int:\n    \"\"\"Reads 8-bit unsigned char value from the register.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        index: Value index. Typically -1, but could be used to extract data from\n            a specific position in the register. Index is byte counted.\n\n    Returns:\n        The 8-bit unsigned char value.\n    \"\"\"\n    data = c_ubyte(0)\n    self._sdk.registerReadU8(self._portname, device_id, reg_id, data, index)\n    return data.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_remove","title":"register_remove","text":"<pre><code>register_remove(device_id: int, reg_id: int) -&gt; None\n</code></pre> <p>Remove a specific register from the internal register list.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_remove(self, device_id: int, reg_id: int) -&gt; None:\n    \"\"\"Remove a specific register from the internal register list.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n    \"\"\"\n    self._sdk.registerRemove(self._portname, device_id, reg_id)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_remove_all","title":"register_remove_all","text":"<pre><code>register_remove_all(device_id: int) -&gt; None\n</code></pre> <p>Remove all registers from the internal register list.</p> <p>No confirmation given, the list is simply cleared.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_remove_all(self, device_id: int) -&gt; None:\n    \"\"\"Remove all registers from the internal register list.\n\n    No confirmation given, the list is simply cleared.\n\n    Args:\n        device_id: The device id (module address).\n    \"\"\"\n    self._sdk.registerRemoveAll(self._portname, device_id)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write","title":"register_write","text":"<pre><code>register_write(\n    device_id: int,\n    reg_id: int,\n    data: bytes,\n    index: int = -1,\n) -&gt; None\n</code></pre> <p>Writes a register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>data</code> <code>bytes</code> <p>The data to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write(self, device_id: int, reg_id: int, data: bytes, index: int = -1) -&gt; None:\n    \"\"\"Writes a register value.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated write.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        data: The data to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n    \"\"\"\n    self._sdk.registerWrite(self._portname, device_id, reg_id, data, len(data), index)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_ascii","title":"register_write_ascii","text":"<pre><code>register_write_ascii(\n    device_id: int,\n    reg_id: int,\n    string: str,\n    *,\n    write_eol: bool = False,\n    index: int = -1\n) -&gt; None\n</code></pre> <p>Writes a string to the register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>string</code> <code>str</code> <p>The string to write to the register.</p> required <code>write_eol</code> <code>bool</code> <p>Whether to append the End Of Line character (a null character) to the string.</p> <code>False</code> <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a mixed-type register.</p> <code>-1</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_ascii(\n    self, device_id: int, reg_id: int, string: str, *, write_eol: bool = False, index: int = -1\n) -&gt; None:\n    \"\"\"Writes a string to the register value.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated write.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        string: The string to write to the register.\n        write_eol: Whether to append the End Of Line character (a null character) to the string.\n        index: Value index. Typically -1, but could be used to write a value in a mixed-type register.\n    \"\"\"\n    buffer = create_string_buffer(string.encode(\"ascii\"))\n    self._sdk.registerWriteAscii(self._portname, device_id, reg_id, buffer, int(write_eol), index)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_f32","title":"register_write_f32","text":"<pre><code>register_write_f32(\n    device_id: int,\n    reg_id: int,\n    value: float,\n    index: int = -1,\n) -&gt; None\n</code></pre> <p>Writes a 32-bit float register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>float</code> <p>The 32-bit float to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_f32(self, device_id: int, reg_id: int, value: float, index: int = -1) -&gt; None:\n    \"\"\"Writes a 32-bit float register value.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated write.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 32-bit float to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n    \"\"\"\n    self._sdk.registerWriteF32(self._portname, device_id, reg_id, value, index)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_f64","title":"register_write_f64","text":"<pre><code>register_write_f64(\n    device_id: int,\n    reg_id: int,\n    value: float,\n    index: int = -1,\n) -&gt; None\n</code></pre> <p>Writes a 64-bit double register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>float</code> <p>The 64-bit double to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_f64(self, device_id: int, reg_id: int, value: float, index: int = -1) -&gt; None:\n    \"\"\"Writes a 64-bit double register value.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated write.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 64-bit double to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n    \"\"\"\n    self._sdk.registerWriteF64(self._portname, device_id, reg_id, value, index)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_read","title":"register_write_read","text":"<pre><code>register_write_read(\n    device_id: int,\n    reg_id: int,\n    data: bytes,\n    index: int = -1,\n) -&gt; bytes\n</code></pre> <p>Writes then reads a register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write followed by a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>data</code> <code>bytes</code> <p>The data to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The data that was written to the register.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_read(self, device_id: int, reg_id: int, data: bytes, index: int = -1) -&gt; bytes:\n    \"\"\"Writes then reads a register value.\n\n    It is not necessary to open the port, create the device or register before using\n    this function, since it will do a dedicated write followed by a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        data: The data to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n\n    Returns:\n        The data that was written to the register.\n    \"\"\"\n    size = c_ubyte(255)\n    read = create_string_buffer(size.value)\n    self._sdk.registerWriteRead(self._portname, device_id, reg_id, data, len(data), index, read, size, index)\n    return read.raw[: size.value]\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_read_ascii","title":"register_write_read_ascii","text":"<pre><code>register_write_read_ascii(\n    device_id: int,\n    reg_id: int,\n    string: str,\n    *,\n    write_eol: bool = False,\n    index: int = -1\n) -&gt; str\n</code></pre> <p>Writes then reads a string register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write followed by a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>string</code> <code>str</code> <p>The string to write to the register.</p> required <code>write_eol</code> <code>bool</code> <p>Whether to append the End Of Line character (a null character) to the string.</p> <code>False</code> <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> <p>Returns:</p> Type Description <code>str</code> <p>The string that was written to the register.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_read_ascii(\n    self, device_id: int, reg_id: int, string: str, *, write_eol: bool = False, index: int = -1\n) -&gt; str:\n    \"\"\"Writes then reads a string register value.\n\n    It is not necessary to open the port, create the device or register before using\n    this function, since it will do a dedicated write followed by a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        string: The string to write to the register.\n        write_eol: Whether to append the End Of Line character (a null character) to the string.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n\n    Returns:\n        The string that was written to the register.\n    \"\"\"\n    ascii_value = create_string_buffer(string.encode(\"ascii\"))\n    size = c_ubyte(255)\n    read = create_string_buffer(size.value)\n    self._sdk.registerWriteReadAscii(\n        self._portname, device_id, reg_id, ascii_value, int(write_eol), read, size, index\n    )\n    return bytes(read.value).decode(\"ascii\")\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_read_f32","title":"register_write_read_f32","text":"<pre><code>register_write_read_f32(\n    device_id: int,\n    reg_id: int,\n    value: float,\n    index: int = -1,\n) -&gt; float\n</code></pre> <p>Writes then reads a 32-bit float register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write followed by a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>float</code> <p>The 32-bit float value to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> <p>Returns:</p> Type Description <code>float</code> <p>The 32-bit float value that was written to the register.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_read_f32(self, device_id: int, reg_id: int, value: float, index: int = -1) -&gt; float:\n    \"\"\"Writes then reads a 32-bit float register value.\n\n    It is not necessary to open the port, create the device or register before using\n    this function, since it will do a dedicated write followed by a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 32-bit float value to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n\n    Returns:\n        The 32-bit float value that was written to the register.\n    \"\"\"\n    read = c_float(0)\n    self._sdk.registerWriteReadF32(self._portname, device_id, reg_id, value, read, index)\n    return read.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_read_f64","title":"register_write_read_f64","text":"<pre><code>register_write_read_f64(\n    device_id: int,\n    reg_id: int,\n    value: float,\n    index: int = -1,\n) -&gt; float\n</code></pre> <p>Writes then reads a 64-bit double register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write followed by a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>float</code> <p>The 64-bit double value to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> <p>Returns:</p> Type Description <code>float</code> <p>The 64-bit double value that was written to the register.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_read_f64(self, device_id: int, reg_id: int, value: float, index: int = -1) -&gt; float:\n    \"\"\"Writes then reads a 64-bit double register value.\n\n    It is not necessary to open the port, create the device or register before using\n    this function, since it will do a dedicated write followed by a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 64-bit double value to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n\n    Returns:\n        The 64-bit double value that was written to the register.\n    \"\"\"\n    read = c_double(0)\n    self._sdk.registerWriteReadF64(self._portname, device_id, reg_id, value, read, index)\n    return read.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_read_s16","title":"register_write_read_s16","text":"<pre><code>register_write_read_s16(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Writes then reads a 16-bit signed short register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write followed by a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 16-bit signed short value to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 16-bit signed short value that was written to the register.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_read_s16(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; int:\n    \"\"\"Writes then reads a 16-bit signed short register value.\n\n    It is not necessary to open the port, create the device or register before using\n    this function, since it will do a dedicated write followed by a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 16-bit signed short value to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n\n    Returns:\n        The 16-bit signed short value that was written to the register.\n    \"\"\"\n    read = c_short(0)\n    self._sdk.registerWriteReadS16(self._portname, device_id, reg_id, value, read, index)\n    return read.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_read_s32","title":"register_write_read_s32","text":"<pre><code>register_write_read_s32(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Writes then reads a 32-bit signed long register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write followed by a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 32-bit signed long value to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 32-bit signed long value that was written to the register.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_read_s32(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; int:\n    \"\"\"Writes then reads a 32-bit signed long register value.\n\n    It is not necessary to open the port, create the device or register before using\n    this function, since it will do a dedicated write followed by a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 32-bit signed long value to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n\n    Returns:\n        The 32-bit signed long value that was written to the register.\n    \"\"\"\n    read = c_long(0)\n    self._sdk.registerWriteReadS32(self._portname, device_id, reg_id, value, read, index)\n    return read.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_read_s64","title":"register_write_read_s64","text":"<pre><code>register_write_read_s64(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Writes then reads a 64-bit signed long long register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write followed by a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 64-bit signed long long value to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 64-bit signed long long value that was written to the register.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_read_s64(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; int:\n    \"\"\"Writes then reads a 64-bit signed long long register value.\n\n    It is not necessary to open the port, create the device or register before using\n    this function, since it will do a dedicated write followed by a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 64-bit signed long long value to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n\n    Returns:\n        The 64-bit signed long long value that was written to the register.\n    \"\"\"\n    read = c_longlong(0)\n    self._sdk.registerWriteReadS64(self._portname, device_id, reg_id, value, read, index)\n    return read.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_read_s8","title":"register_write_read_s8","text":"<pre><code>register_write_read_s8(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Writes then reads a 8-bit signed char register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write followed by a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 8-bit signed char value to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 8-bit signed char value that was written to the register.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_read_s8(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; int:\n    \"\"\"Writes then reads a 8-bit signed char register value.\n\n    It is not necessary to open the port, create the device or register before using\n    this function, since it will do a dedicated write followed by a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 8-bit signed char value to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n\n    Returns:\n        The 8-bit signed char value that was written to the register.\n    \"\"\"\n    read = c_byte(0)\n    self._sdk.registerWriteReadS8(self._portname, device_id, reg_id, value, read, index)\n    return read.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_read_u16","title":"register_write_read_u16","text":"<pre><code>register_write_read_u16(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Writes then reads a 16-bit unsigned short register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write followed by a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 16-bit unsigned short value to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 16-bit unsigned short value that was written to the register.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_read_u16(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; int:\n    \"\"\"Writes then reads a 16-bit unsigned short register value.\n\n    It is not necessary to open the port, create the device or register before using\n    this function, since it will do a dedicated write followed by a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 16-bit unsigned short value to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n\n    Returns:\n        The 16-bit unsigned short value that was written to the register.\n    \"\"\"\n    read = c_ushort(0)\n    self._sdk.registerWriteReadU16(self._portname, device_id, reg_id, value, read, index)\n    return read.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_read_u32","title":"register_write_read_u32","text":"<pre><code>register_write_read_u32(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Writes then reads a 32-bit unsigned long register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write followed by a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 32-bit unsigned long value to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 32-bit unsigned long value that was written to the register.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_read_u32(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; int:\n    \"\"\"Writes then reads a 32-bit unsigned long register value.\n\n    It is not necessary to open the port, create the device or register before using\n    this function, since it will do a dedicated write followed by a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 32-bit unsigned long value to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n\n    Returns:\n        The 32-bit unsigned long value that was written to the register.\n    \"\"\"\n    read = c_ulong(0)\n    self._sdk.registerWriteReadU32(self._portname, device_id, reg_id, value, read, index)\n    return read.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_read_u64","title":"register_write_read_u64","text":"<pre><code>register_write_read_u64(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Writes then reads a 64-bit unsigned long long register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write followed by a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 64-bit unsigned long long value to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 64-bit unsigned long long value that was written to the register.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_read_u64(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; int:\n    \"\"\"Writes then reads a 64-bit unsigned long long register value.\n\n    It is not necessary to open the port, create the device or register before using\n    this function, since it will do a dedicated write followed by a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 64-bit unsigned long long value to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n\n    Returns:\n        The 64-bit unsigned long long value that was written to the register.\n    \"\"\"\n    read = c_ulonglong(0)\n    self._sdk.registerWriteReadU64(self._portname, device_id, reg_id, value, read, index)\n    return read.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_read_u8","title":"register_write_read_u8","text":"<pre><code>register_write_read_u8(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Writes then reads a 8-bit unsigned char register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write followed by a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 8-bit unsigned char value to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 8-bit unsigned char value that was written to the register.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_read_u8(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; int:\n    \"\"\"Writes then reads a 8-bit unsigned char register value.\n\n    It is not necessary to open the port, create the device or register before using\n    this function, since it will do a dedicated write followed by a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 8-bit unsigned char value to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n\n    Returns:\n        The 8-bit unsigned char value that was written to the register.\n    \"\"\"\n    read = c_ubyte(0)\n    self._sdk.registerWriteReadU8(self._portname, device_id, reg_id, value, read, index)\n    return read.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_s16","title":"register_write_s16","text":"<pre><code>register_write_s16(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; None\n</code></pre> <p>Writes a 16-bit signed short register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 16-bit signed short to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_s16(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; None:\n    \"\"\"Writes a 16-bit signed short register value.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated write.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 16-bit signed short to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n    \"\"\"\n    self._sdk.registerWriteS16(self._portname, device_id, reg_id, value, index)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_s32","title":"register_write_s32","text":"<pre><code>register_write_s32(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; None\n</code></pre> <p>Writes a 32-bit signed long register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 32-bit signed long to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_s32(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; None:\n    \"\"\"Writes a 32-bit signed long register value.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated write.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 32-bit signed long to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n    \"\"\"\n    self._sdk.registerWriteS32(self._portname, device_id, reg_id, value, index)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_s64","title":"register_write_s64","text":"<pre><code>register_write_s64(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; None\n</code></pre> <p>Writes a 64-bit signed long long register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 64-bit signed long long to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_s64(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; None:\n    \"\"\"Writes a 64-bit signed long long register value.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated write.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 64-bit signed long long to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n    \"\"\"\n    self._sdk.registerWriteS64(self._portname, device_id, reg_id, value, index)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_s8","title":"register_write_s8","text":"<pre><code>register_write_s8(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; None\n</code></pre> <p>Writes a 8-bit signed char register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 8-bit signed char to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_s8(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; None:\n    \"\"\"Writes a 8-bit signed char register value.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated write.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 8-bit signed char to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n    \"\"\"\n    self._sdk.registerWriteS8(self._portname, device_id, reg_id, value, index)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_u16","title":"register_write_u16","text":"<pre><code>register_write_u16(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; None\n</code></pre> <p>Writes a 16-bit unsigned short register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 16-bit unsigned short to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_u16(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; None:\n    \"\"\"Writes a 16-bit unsigned short register value.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated write.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 16-bit unsigned short to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n    \"\"\"\n    self._sdk.registerWriteU16(self._portname, device_id, reg_id, value, index)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_u32","title":"register_write_u32","text":"<pre><code>register_write_u32(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; None\n</code></pre> <p>Writes a 32-bit unsigned long register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 32-bit unsigned long to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_u32(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; None:\n    \"\"\"Writes a 32-bit unsigned long register value.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated write.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 32-bit unsigned long to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n    \"\"\"\n    self._sdk.registerWriteU32(self._portname, device_id, reg_id, value, index)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_u64","title":"register_write_u64","text":"<pre><code>register_write_u64(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; None\n</code></pre> <p>Writes a 64-bit unsigned long long register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 64-bit unsigned long long to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_u64(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; None:\n    \"\"\"Writes a 64-bit unsigned long long register value.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated write.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 64-bit unsigned long long to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n    \"\"\"\n    self._sdk.registerWriteU64(self._portname, device_id, reg_id, value, index)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_u8","title":"register_write_u8","text":"<pre><code>register_write_u8(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; None\n</code></pre> <p>Writes a 8-bit unsigned char register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 8-bit unsigned char to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_u8(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; None:\n    \"\"\"Writes a 8-bit unsigned char register value.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated write.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 8-bit unsigned char to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n    \"\"\"\n    self._sdk.registerWriteU8(self._portname, device_id, reg_id, value, index)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.set_callback_device_status","title":"set_callback_device_status  <code>staticmethod</code>","text":"<pre><code>set_callback_device_status(\n    callback: NKTDeviceStatusCallback | None,\n) -&gt; None\n</code></pre> <p>Enables/Disables a callback for device status changes.</p> <p>See superk_callback.py for an example usage.</p> <p>Note</p> <p>Due to a risk of circular runaway leading to stack overflow, it is not allowed to call functions in the DLL from within the callback function. If a call is made to a function in the DLL the function will raise an exception.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>NKTDeviceStatusCallback | None</code> <p>A callback function. Pass in <code>None</code> to disable the device-status callback.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>@staticmethod\ndef set_callback_device_status(callback: NKTDeviceStatusCallback | None) -&gt; None:\n    \"\"\"Enables/Disables a callback for device status changes.\n\n    See [superk_callback.py](https://github.com/MSLNZ/msl-equipment/blob/main/packages/resources/examples/nkt/superk_callback.py)\n    for an example usage.\n\n    !!! note\n        Due to a risk of circular runaway leading to stack overflow, it is not allowed\n        to call functions in the DLL from within the callback function. If a call is\n        made to a function in the DLL the function will raise an exception.\n\n    Args:\n        callback: A callback function. Pass in `None` to disable the device-status callback.\n    \"\"\"\n    if NKT._SDK is None:\n        msg = \"You must first call NKT.load_sdk()\"\n        raise RuntimeError(msg)\n\n    if callback is not None and not isinstance(callback, DeviceStatusCallback):\n        msg = \"Must pass in a DeviceStatusCallback object\"\n        raise TypeError(msg)\n\n    NKT._SDK.setCallbackPtrDeviceInfo(callback)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.set_callback_port_status","title":"set_callback_port_status  <code>staticmethod</code>","text":"<pre><code>set_callback_port_status(\n    callback: NKTPortStatusCallback | None,\n) -&gt; None\n</code></pre> <p>Enables/Disables a callback for port status changes.</p> <p>Used by the open_ports and close_ports functions.</p> <p>See superk_callback.py for an example usage.</p> <p>Note</p> <p>Due to a risk of circular runaway leading to stack overflow, it is not allowed to call functions in the DLL from within the callback function. If a call is made to a function in the DLL the function will raise an exception.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>NKTPortStatusCallback | None</code> <p>A callback function. Pass in <code>None</code> to disable the port-status callback.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>@staticmethod\ndef set_callback_port_status(callback: NKTPortStatusCallback | None) -&gt; None:\n    \"\"\"Enables/Disables a callback for port status changes.\n\n    Used by the [open_ports][msl.equipment_resources.nkt.nktpdll.NKT.open_ports] and\n    [close_ports][msl.equipment_resources.nkt.nktpdll.NKT.close_ports] functions.\n\n    See [superk_callback.py](https://github.com/MSLNZ/msl-equipment/blob/main/packages/resources/examples/nkt/superk_callback.py)\n    for an example usage.\n\n    !!! note\n        Due to a risk of circular runaway leading to stack overflow, it is not allowed\n        to call functions in the DLL from within the callback function. If a call is\n        made to a function in the DLL the function will raise an exception.\n\n    Args:\n        callback: A callback function. Pass in `None` to disable the port-status callback.\n    \"\"\"\n    if NKT._SDK is None:\n        msg = \"You must first call NKT.load_sdk()\"\n        raise RuntimeError(msg)\n\n    if callback is not None and not isinstance(callback, PortStatusCallback):\n        msg = \"Must pass in a PortStatusCallback object\"\n        raise TypeError(msg)\n\n    NKT._SDK.setCallbackPtrPortInfo(callback)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.set_callback_register_status","title":"set_callback_register_status  <code>staticmethod</code>","text":"<pre><code>set_callback_register_status(\n    callback: NKTRegisterStatusCallback | None,\n) -&gt; None\n</code></pre> <p>Enables/Disables a callback for register status changes.</p> <p>See superk_callback.py for an example usage.</p> <p>Note</p> <p>Due to a risk of circular runaway leading to stack overflow, it is not allowed to call functions in the DLL from within the callback function. If a call is made to a function in the DLL the function will raise an exception.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>NKTRegisterStatusCallback | None</code> <p>A callback function. Pass in <code>None</code> to disable the register-status callback.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>@staticmethod\ndef set_callback_register_status(callback: NKTRegisterStatusCallback | None) -&gt; None:\n    \"\"\"Enables/Disables a callback for register status changes.\n\n    See [superk_callback.py](https://github.com/MSLNZ/msl-equipment/blob/main/packages/resources/examples/nkt/superk_callback.py)\n    for an example usage.\n\n    !!! note\n        Due to a risk of circular runaway leading to stack overflow, it is not allowed\n        to call functions in the DLL from within the callback function. If a call is\n        made to a function in the DLL the function will raise an exception.\n\n    Args:\n        callback: A callback function. Pass in `None` to disable the register-status callback.\n    \"\"\"\n    if NKT._SDK is None:\n        msg = \"You must first call NKT.load_sdk()\"\n        raise RuntimeError(msg)\n\n    if callback is not None and not isinstance(callback, RegisterStatusCallback):\n        msg = \"Must pass in a RegisterStatusCallback object\"\n        raise TypeError(msg)\n\n    NKT._SDK.setCallbackPtrRegisterInfo(callback)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.set_legacy_bus_scanning","title":"set_legacy_bus_scanning  <code>staticmethod</code>","text":"<pre><code>set_legacy_bus_scanning(*, mode: bool) -&gt; None\n</code></pre> <p>Set the bus-scanning mode to normal or legacy.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>bool</code> <p>If <code>False</code>, bus scanning is set to normal mode and allows for a rolling masterId. In this mode the masterId is changed for each message to allow for out-of-sync detection. If <code>True</code>, bus scanning is set to legacy mode and fixes the masterId at address 66 (0x42). Some older modules do not accept masterIds other than 66 (0x42).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>@staticmethod\ndef set_legacy_bus_scanning(*, mode: bool) -&gt; None:\n    \"\"\"Set the bus-scanning mode to normal or legacy.\n\n    Args:\n        mode: If `False`, bus scanning is set to normal mode and allows for a\n            rolling _masterId_. In this mode the _masterId_ is changed for each\n            message to allow for out-of-sync detection. If `True`, bus scanning\n            is set to legacy mode and fixes the _masterId_ at address 66 (0x42).\n            Some older modules do not accept _masterIds_ other than 66 (0x42).\n    \"\"\"\n    if NKT._SDK is None:\n        msg = \"You must first call NKT.load_sdk()\"\n        raise RuntimeError(msg)\n\n    NKT._SDK.setLegacyBusScanning(int(bool(mode)))\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.ParameterSet","title":"ParameterSet","text":"<p>               Bases: <code>Structure</code></p> <p>The ParameterSet struct.</p> <p>This is how a calculation on parameter sets is done internally by modules:</p> <p>DAC_value = (value * (X/Y)) + Offset</p> <p>where, value is either <code>ParameterSet.StartVal</code> or <code>ParameterSet.FactoryVal</code></p> <p>value = (ADC_value * (X/Y)) + Offset</p> <p>where, value often is available via another measurement register.</p> <p>Attributes:</p> Name Type Description <code>Unit</code> <code>c_uint8</code> <p>Unit type as defined in tParamSetUnitTypes.</p> <code>ErrorHandler</code> <code>c_uint8</code> <p>Warning/Error handler not used.</p> <code>StartVal</code> <code>c_ushort</code> <p>Setpoint for Settings parameter set, unused in Measurement parameter sets.</p> <code>FactoryVal</code> <code>c_ushort</code> <p>Factory Setpoint for Settings parameter set, unused in Measurement parameter sets.</p> <code>ULimit</code> <code>c_ushort</code> <p>Upper limit.</p> <code>LLimit</code> <code>c_ushort</code> <p>Lower limit.</p> <code>Numerator</code> <code>c_short</code> <p>Numerator(X) for calculation.</p> <code>Denominator</code> <code>c_short</code> <p>Denominator(Y) for calculation.</p> <code>Offset</code> <code>c_short</code> <p>Offset for calculation.</p>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.PointToPoint","title":"PointToPoint  <code>dataclass</code>","text":"<pre><code>PointToPoint(\n    host_address: str,\n    host_port: int,\n    client_address: str,\n    client_port: int,\n    protocol: int,\n    ms_timeout: int,\n)\n</code></pre> <p>A point-to-point port.</p> <p>Parameters:</p> Name Type Description Default <code>host_address</code> <code>str</code> <p>The local ip address, e.g., <code>\"192.168.1.67\"</code>.</p> required <code>host_port</code> <code>int</code> <p>The local port number.</p> required <code>client_address</code> <code>str</code> <p>The remote ip address, e.g., <code>\"192.168.1.100\"</code>.</p> required <code>client_port</code> <code>int</code> <p>The remote port number.</p> required <code>protocol</code> <code>int</code> <p>Either <code>0</code> (TCP) or <code>1</code> (UDP).</p> required <code>ms_timeout</code> <code>int</code> <p>Telegram timeout value in milliseconds.</p> required"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.PortStatus","title":"PortStatus","text":"<p>               Bases: <code>IntEnum</code></p> <p>The PortStatusTypes enum.</p> <p>Attributes:</p> Name Type Description <code>Unknown</code> <code>int</code> <p>Unknown status, <code>0</code>.</p> <code>Opening</code> <code>int</code> <p>The port is opening, <code>1</code>.</p> <code>Opened</code> <code>int</code> <p>The port is now open, <code>2</code>.</p> <code>OpenFail</code> <code>int</code> <p>The port open failed, <code>3</code>.</p> <code>ScanStarted</code> <code>int</code> <p>The port scanning is started, <code>4</code>.</p> <code>ScanProgress</code> <code>int</code> <p>The port scanning progress, <code>5</code>.</p> <code>ScanDeviceFound</code> <code>int</code> <p>The port scan found a device, <code>6</code>.</p> <code>ScanEnded</code> <code>int</code> <p>The port scanning ended, <code>7</code>.</p> <code>Closing</code> <code>int</code> <p>The port is closing, <code>8</code>.</p> <code>Closed</code> <code>int</code> <p>The port is now closed, <code>9</code>.</p> <code>Ready</code> <code>int</code> <p>The port is open and ready, <code>10</code>.</p>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.RegisterData","title":"RegisterData","text":"<p>               Bases: <code>IntEnum</code></p> <p>The RegisterDataTypes enum.</p> <p>Attributes:</p> Name Type Description <code>UNKNOWN</code> <code>int</code> <p>Unknown/Undefined data type, <code>0</code>.</p> <code>MIXED</code> <code>int</code> <p>Mixed content data type, <code>1</code>.</p> <code>U8</code> <code>int</code> <p>8-bit unsigned data type (unsigned char), <code>2</code>.</p> <code>S8</code> <code>int</code> <p>8-bit signed data type (char), <code>3</code>.</p> <code>U16</code> <code>int</code> <p>16-bit unsigned data type (unsigned short), <code>4</code>.</p> <code>S16</code> <code>int</code> <p>16-bit signed data type (short), <code>5</code>.</p> <code>U32</code> <code>int</code> <p>32-bit unsigned data type (unsigned long), <code>6</code>.</p> <code>S32</code> <code>int</code> <p>32-bit signed data type (long), <code>7</code>.</p> <code>F32</code> <code>int</code> <p>32-bit floating point data type (float), <code>8</code>.</p> <code>U64</code> <code>int</code> <p>64-bit unsigned data type (unsigned long long), <code>9</code>.</p> <code>S64</code> <code>int</code> <p>64-bit signed data type (long long), <code>10</code>.</p> <code>F64</code> <code>int</code> <p>64-bit floating point data type (double), <code>11</code>.</p> <code>ASCII</code> <code>int</code> <p>Zero terminated ascii string data type, <code>12</code>.</p> <code>ParamSet</code> <code>int</code> <p>ParameterSet data type, <code>13</code>.</p> <code>B8</code> <code>int</code> <p>8-bit binary data type (unsigned char), <code>14</code>.</p> <code>H8</code> <code>int</code> <p>8-bit hexadecimal data type (unsigned char), <code>15</code>.</p> <code>B16</code> <code>int</code> <p>16-bit binary data type (unsigned short), <code>16</code>.</p> <code>H16</code> <code>int</code> <p>16-bit hexadecimal data type (unsigned short), <code>17</code>.</p> <code>B32</code> <code>int</code> <p>32-bit binary data type (unsigned long), <code>18</code>.</p> <code>H32</code> <code>int</code> <p>32-bit hexadecimal data type (unsigned long), <code>19</code>.</p> <code>B64</code> <code>int</code> <p>64-bit binary data type (unsigned long long), <code>20</code>.</p> <code>H64</code> <code>int</code> <p>64-bit hexadecimal data type (unsigned long long), <code>21</code>.</p> <code>DATETIME</code> <code>int</code> <p>DateTime data type, <code>22</code>.</p>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.RegisterPriority","title":"RegisterPriority","text":"<p>               Bases: <code>IntEnum</code></p> <p>The RegisterPriorityTypes enum.</p> <p>Attributes:</p> Name Type Description <code>Low</code> <code>int</code> <p>The register is polled with low priority, <code>0</code>.</p> <code>High</code> <code>int</code> <p>The register is polled with high priority, <code>1</code>.</p>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.RegisterStatus","title":"RegisterStatus","text":"<p>               Bases: <code>IntEnum</code></p> <p>The RegisterStatusTypes enum.</p> <p>Attributes:</p> Name Type Description <code>Success</code> <code>int</code> <p>Register operation was successful <code>0</code>.</p> <code>Busy</code> <code>int</code> <p>Register operation resulted in a busy, <code>1</code>.</p> <code>Knackered</code> <code>int</code> <p>Register operation resulted in a knackered register (a non-existing register), <code>2</code>.</p> <code>CRCErr</code> <code>int</code> <p>Register operation resulted in a CRC error, <code>3</code>.</p> <code>Timeout</code> <code>int</code> <p>Register operation resulted in a timeout, <code>4</code>.</p> <code>ComError</code> <code>int</code> <p>Register operation resulted in a COM error. Out of sync. or garbage error, <code>5</code>.</p>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.Unit","title":"Unit","text":"<p>               Bases: <code>IntEnum</code></p> <p>The ParamSetUnitTypes enum.</p> <p>Attributes:</p> Name Type Description <code>NONE</code> <code>int</code> <p>None/Unknown, <code>0</code>.</p> <code>mV</code> <code>int</code> <p>mV, <code>1</code>.</p> <code>V</code> <code>int</code> <p>V, <code>2</code>.</p> <code>uA</code> <code>int</code> <p>uA, <code>3</code>.</p> <code>mA</code> <code>int</code> <p>mA, <code>4</code>.</p> <code>A</code> <code>int</code> <p>A, <code>5</code>.</p> <code>uW</code> <code>int</code> <p>uW, <code>6</code>.</p> <code>cmW</code> <code>int</code> <p>mW/100, <code>7</code>.</p> <code>dmW</code> <code>int</code> <p>mW/10, <code>8</code>.</p> <code>mW</code> <code>int</code> <p>mW, <code>9</code>.</p> <code>W</code> <code>int</code> <p>W, <code>10</code>.</p> <code>mC</code> <code>int</code> <p>degC/1000, <code>11</code>.</p> <code>cC</code> <code>int</code> <p>degC/100, <code>12</code>.</p> <code>dC</code> <code>int</code> <p>degC/10, <code>13</code>.</p> <code>pm</code> <code>int</code> <p>pm, <code>14</code>.</p> <code>dnm</code> <code>int</code> <p>nm/10, <code>15</code>.</p> <code>nm</code> <code>int</code> <p>nm, <code>16</code>.</p> <code>percent</code> <code>int</code> <p>%, <code>17</code>.</p> <code>perMile</code> <code>int</code> <p>per mile, <code>18</code>.</p> <code>cmA</code> <code>int</code> <p>mA/100, <code>19</code>.</p> <code>dmA</code> <code>int</code> <p>mA/10, <code>20</code>.</p> <code>RPM</code> <code>int</code> <p>RPM, <code>21</code>.</p> <code>dBm</code> <code>int</code> <p>dBm, <code>22</code>.</p> <code>cBm</code> <code>int</code> <p>dBm/10, <code>23</code>.</p> <code>mBm</code> <code>int</code> <p>dBm/100, <code>24</code>.</p> <code>dB</code> <code>int</code> <p>dB, <code>25</code>.</p> <code>cB</code> <code>int</code> <p>dB/10, <code>26</code>.</p> <code>mB</code> <code>int</code> <p>dB/100, <code>27</code>.</p> <code>dpm</code> <code>int</code> <p>pm/10, <code>28</code>.</p> <code>cV</code> <code>int</code> <p>V/100, <code>29</code>.</p> <code>dV</code> <code>int</code> <p>V/10, <code>30</code>.</p> <code>lm</code> <code>int</code> <p>lm (lumen), <code>31</code>.</p> <code>dlm</code> <code>int</code> <p>lm/10, <code>32</code>.</p> <code>clm</code> <code>int</code> <p>lm/100, <code>33</code>.</p> <code>mlm</code> <code>int</code> <p>lm/1000, <code>34</code>.</p>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.device_status_callback","title":"device_status_callback","text":"<pre><code>device_status_callback(\n    f: NKTDeviceStatusCallback,\n) -&gt; _CFunctionType\n</code></pre> <p>Used as a decorator for a callback function when the status of a device changes.</p> <p>See superk_callback.py for an example usage.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_status_callback(f: NKTDeviceStatusCallback) -&gt; _CFunctionType:\n    \"\"\"Used as a decorator for a callback function when the status of a device changes.\n\n    See [superk_callback.py](https://github.com/MSLNZ/msl-equipment/blob/main/packages/resources/examples/nkt/superk_callback.py)\n    for an example usage.\n    \"\"\"\n    return DeviceStatusCallback(f)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.port_status_callback","title":"port_status_callback","text":"<pre><code>port_status_callback(\n    f: NKTPortStatusCallback,\n) -&gt; _CFunctionType\n</code></pre> <p>Used as a decorator for a callback function when the status of a port changes.</p> <p>See superk_callback.py for an example usage.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def port_status_callback(f: NKTPortStatusCallback) -&gt; _CFunctionType:\n    \"\"\"Used as a decorator for a callback function when the status of a port changes.\n\n    See [superk_callback.py](https://github.com/MSLNZ/msl-equipment/blob/main/packages/resources/examples/nkt/superk_callback.py)\n    for an example usage.\n    \"\"\"\n    return PortStatusCallback(f)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.register_status_callback","title":"register_status_callback","text":"<pre><code>register_status_callback(\n    f: NKTRegisterStatusCallback,\n) -&gt; _CFunctionType\n</code></pre> <p>Used as a decorator for a callback function when the status of a register changes.</p> <p>See superk_callback.py for an example usage.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_status_callback(f: NKTRegisterStatusCallback) -&gt; _CFunctionType:\n    \"\"\"Used as a decorator for a callback function when the status of a register changes.\n\n    See [superk_callback.py](https://github.com/MSLNZ/msl-equipment/blob/main/packages/resources/examples/nkt/superk_callback.py)\n    for an example usage.\n    \"\"\"\n    return RegisterStatusCallback(f)\n</code></pre>"},{"location":"schema/","title":"Schema Classes","text":"<p>Class representations of the XML Schema Definition for an equipment register.</p> <p>The primary class is Register which contains a sequence of Equipment classes that are each composed of the following classes:</p> <ul> <li>AcceptanceCriteria</li> <li>Accessories</li> <li>Adjustment</li> <li>Alteration</li> <li>CapitalExpenditure</li> <li>Competency</li> <li>CompletedTask</li> <li>Component</li> <li>Conditions</li> <li>CVDEquation (Callendar-Van Dusen equation, uses the cvdCoefficients)</li> <li>Deserialised (opposite of serialised)</li> <li>DigitalReport</li> <li>Equation</li> <li>File</li> <li>Financial</li> <li>Firmware</li> <li>Maintenance</li> <li>Measurand</li> <li>PerformanceCheck</li> <li>PlannedTask</li> <li>QualityManual</li> <li>ReferenceMaterials</li> <li>Report</li> <li>Specifications</li> <li>SpecifiedRequirements</li> <li>Status</li> <li>Table</li> </ul> <p>The Any class is used as a base class for elements that are currently represented by the any type in the XML Schema Definition.</p>"},{"location":"schema/acceptance_criteria/","title":"AcceptanceCriteria","text":""},{"location":"schema/acceptance_criteria/#msl.equipment.schema.AcceptanceCriteria","title":"AcceptanceCriteria","text":"<pre><code>AcceptanceCriteria(**attributes: str)\n</code></pre> <p>               Bases: <code>Any</code></p> <p>Represents the acceptance criteria in a calibration report.</p> <p>Since this class is currently represented by the any type in the XML Schema Definition, it is simply a subclass of Element. It may be updated to be a more specific class at a later date.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any] type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/acceptance_criteria/#msl.equipment.schema.AcceptanceCriteria.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str = 'acceptanceCriteria'\n</code></pre> <p>The element's name.</p>"},{"location":"schema/acceptance_criteria/#msl.equipment.schema.AcceptanceCriteria.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/accessories/","title":"Accessories","text":""},{"location":"schema/accessories/#msl.equipment.schema.Accessories","title":"Accessories","text":"<pre><code>Accessories(**attributes: str)\n</code></pre> <p>               Bases: <code>Any</code></p> <p>Additional accessories that may be required to use the equipment.</p> <p>Since this class is currently represented by the any type in the XML Schema Definition, it is simply a subclass of Element. It may be updated to be a more specific class at a later date.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any] type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/accessories/#msl.equipment.schema.Accessories.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str = 'accessories'\n</code></pre> <p>The element's name.</p>"},{"location":"schema/accessories/#msl.equipment.schema.Accessories.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/adjustment/","title":"Adjustment","text":""},{"location":"schema/adjustment/#msl.equipment.schema.Adjustment","title":"Adjustment  <code>dataclass</code>","text":"<pre><code>Adjustment(details: str, date: date)\n</code></pre> <p>An adjustment of the equipment.</p> <p>An example of an adjustment is cleaning the equipment (e.g., a spectral filter) and then performing another calibration measurement.</p> <p>This XML element is found in component.</p> <p>Parameters:</p> Name Type Description Default <code>details</code> <code>str</code> <p>The details of the adjustment that was performed.</p> required <code>date</code> <code>date</code> <p>The date that the adjustment was performed.</p> required"},{"location":"schema/adjustment/#msl.equipment.schema.Adjustment.date","title":"date  <code>instance-attribute</code>","text":"<pre><code>date: date\n</code></pre> <p>The date that the adjustment was performed.</p>"},{"location":"schema/adjustment/#msl.equipment.schema.Adjustment.details","title":"details  <code>instance-attribute</code>","text":"<pre><code>details: str\n</code></pre> <p>The details of the adjustment that was performed.</p>"},{"location":"schema/adjustment/#msl.equipment.schema.Adjustment.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Adjustment\n</code></pre> <p>Convert an XML element into a Adjustment instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An <code>&lt;adjustment&gt;</code> XML element from an equipment register (see component).</p> required <p>Returns:</p> Type Description <code>Adjustment</code> <p>The Adjustment instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Adjustment:\n    \"\"\"Convert an XML element into a [Adjustment][msl.equipment.schema.Adjustment] instance.\n\n    Args:\n        element: An `&lt;adjustment&gt;` XML element from an equipment register\n            (see [component][type_component]).\n\n    Returns:\n        The [Adjustment][msl.equipment.schema.Adjustment] instance.\n    \"\"\"\n    return cls(details=element.text or \"\", date=_date.fromisoformat(element.attrib[\"date\"]))\n</code></pre>"},{"location":"schema/adjustment/#msl.equipment.schema.Adjustment.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Adjustment class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Adjustment as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Adjustment][msl.equipment.schema.Adjustment] class into an XML element.\n\n    Returns:\n        The [Adjustment][msl.equipment.schema.Adjustment] as an XML element.\n    \"\"\"\n    e = Element(\"adjustment\", attrib={\"date\": self.date.isoformat()})\n    e.text = self.details\n    return e\n</code></pre>"},{"location":"schema/alteration/","title":"Alteration","text":""},{"location":"schema/alteration/#msl.equipment.schema.Alteration","title":"Alteration  <code>dataclass</code>","text":"<pre><code>Alteration(date: date, details: str, performed_by: str)\n</code></pre> <p>Represents the alteration element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>date</code> <p>The date that the alteration was performed.</p> required <code>details</code> <code>str</code> <p>The details of the alteration.</p> required <code>performed_by</code> <code>str</code> <p>The person or company that performed the alteration.</p> required"},{"location":"schema/alteration/#msl.equipment.schema.Alteration.date","title":"date  <code>instance-attribute</code>","text":"<pre><code>date: date\n</code></pre> <p>The date that the alteration was performed.</p>"},{"location":"schema/alteration/#msl.equipment.schema.Alteration.details","title":"details  <code>instance-attribute</code>","text":"<pre><code>details: str\n</code></pre> <p>The details of the alteration.</p>"},{"location":"schema/alteration/#msl.equipment.schema.Alteration.performed_by","title":"performed_by  <code>instance-attribute</code>","text":"<pre><code>performed_by: str\n</code></pre> <p>The person or company that performed the alteration.</p>"},{"location":"schema/alteration/#msl.equipment.schema.Alteration.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Alteration\n</code></pre> <p>Convert an XML element into an Alteration instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An alteration XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Alteration</code> <p>The Alteration instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Alteration:\n    \"\"\"Convert an XML element into an [Alteration][msl.equipment.schema.Alteration] instance.\n\n    Args:\n        element: An [alteration][type_alteration] XML element from an equipment register.\n\n    Returns:\n        The [Alteration][msl.equipment.schema.Alteration] instance.\n    \"\"\"\n    return cls(\n        date=_date.fromisoformat(element.attrib[\"date\"]),\n        details=element.text or \"\",\n        performed_by=element.attrib[\"performedBy\"],\n    )\n</code></pre>"},{"location":"schema/alteration/#msl.equipment.schema.Alteration.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Alteration class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Alteration as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Alteration][msl.equipment.schema.Alteration] class into an XML element.\n\n    Returns:\n        The [Alteration][msl.equipment.schema.Alteration] as an XML element.\n    \"\"\"\n    e = Element(\"alteration\", attrib={\"date\": self.date.isoformat(), \"performedBy\": self.performed_by})\n    e.text = self.details\n    return e\n</code></pre>"},{"location":"schema/any/","title":"Any","text":""},{"location":"schema/any/#msl.equipment.schema.Any","title":"Any","text":"<pre><code>Any(**attributes: str)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Base class that represents the any type in the XML Schema Definition.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any] type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/any/#msl.equipment.schema.Any.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/capital_expenditure/","title":"CapitalExpenditure","text":""},{"location":"schema/capital_expenditure/#msl.equipment.schema.CapitalExpenditure","title":"CapitalExpenditure  <code>dataclass</code>","text":"<pre><code>CapitalExpenditure(\n    asset_number: str,\n    depreciation_end_year: int,\n    price: float,\n    currency: str,\n)\n</code></pre> <p>Represents the capitalExpenditure element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>asset_number</code> <code>str</code> <p>The asset number in the financial system.</p> required <code>depreciation_end_year</code> <code>int</code> <p>The year (inclusive) that depreciation ends for the asset.</p> required <code>price</code> <code>float</code> <p>The purchase price of the asset.</p> required <code>currency</code> <code>str</code> <p>The currency associated with the <code>price</code>.</p> required"},{"location":"schema/capital_expenditure/#msl.equipment.schema.CapitalExpenditure.asset_number","title":"asset_number  <code>instance-attribute</code>","text":"<pre><code>asset_number: str\n</code></pre> <p>The asset number in the financial system.</p>"},{"location":"schema/capital_expenditure/#msl.equipment.schema.CapitalExpenditure.currency","title":"currency  <code>instance-attribute</code>","text":"<pre><code>currency: str\n</code></pre> <p>The currency associated with the <code>price</code>.</p>"},{"location":"schema/capital_expenditure/#msl.equipment.schema.CapitalExpenditure.depreciation_end_year","title":"depreciation_end_year  <code>instance-attribute</code>","text":"<pre><code>depreciation_end_year: int\n</code></pre> <p>The year (inclusive) that depreciation ends for the asset.</p>"},{"location":"schema/capital_expenditure/#msl.equipment.schema.CapitalExpenditure.price","title":"price  <code>instance-attribute</code>","text":"<pre><code>price: float\n</code></pre> <p>The price of the asset.</p>"},{"location":"schema/capital_expenditure/#msl.equipment.schema.CapitalExpenditure.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; CapitalExpenditure\n</code></pre> <p>Convert an XML element into a CapitalExpenditure instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A capitalExpenditure XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>CapitalExpenditure</code> <p>The CapitalExpenditure instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; CapitalExpenditure:\n    \"\"\"Convert an XML element into a [CapitalExpenditure][msl.equipment.schema.CapitalExpenditure] instance.\n\n    Args:\n        element: A [capitalExpenditure][type_capitalExpenditure] XML element\n            from an equipment register.\n\n    Returns:\n        The [CapitalExpenditure][msl.equipment.schema.CapitalExpenditure] instance.\n    \"\"\"\n    # Schema forces order\n    return cls(\n        asset_number=element[0].text or \"\",\n        depreciation_end_year=int(element[1].text or 0),\n        price=float(element[2].text or 0),\n        currency=element[2].attrib[\"currency\"],\n    )\n</code></pre>"},{"location":"schema/capital_expenditure/#msl.equipment.schema.CapitalExpenditure.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the CapitalExpenditure class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The CapitalExpenditure as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [CapitalExpenditure][msl.equipment.schema.CapitalExpenditure] class into an XML element.\n\n    Returns:\n        The [CapitalExpenditure][msl.equipment.schema.CapitalExpenditure] as an XML element.\n    \"\"\"\n    e = Element(\"capitalExpenditure\")\n\n    an = SubElement(e, \"assetNumber\")\n    an.text = self.asset_number\n\n    dey = SubElement(e, \"depreciationEndYear\")\n    dey.text = str(self.depreciation_end_year)\n\n    p = SubElement(e, \"price\", attrib={\"currency\": self.currency})\n    p.text = f\"{self.price:.14g}\"\n\n    return e\n</code></pre>"},{"location":"schema/competency/","title":"Competency","text":""},{"location":"schema/competency/#msl.equipment.schema.Competency","title":"Competency  <code>dataclass</code>","text":"<pre><code>Competency(\n    worker: str, checker: str, technical_procedure: str\n)\n</code></pre> <p>Represents the competency element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>worker</code> <code>str</code> <p>The competent person who executed the technical procedure to accomplish the performance check.</p> required <code>checker</code> <code>str</code> <p>The competent person who reviewed the work done by the <code>worker</code>.</p> required <code>technical_procedure</code> <code>str</code> <p>The technical procedure that was executed to accomplish the performance check.</p> required"},{"location":"schema/competency/#msl.equipment.schema.Competency.checker","title":"checker  <code>instance-attribute</code>","text":"<pre><code>checker: str\n</code></pre> <p>The competent person who reviewed the work done by the <code>worker</code>.</p>"},{"location":"schema/competency/#msl.equipment.schema.Competency.technical_procedure","title":"technical_procedure  <code>instance-attribute</code>","text":"<pre><code>technical_procedure: str\n</code></pre> <p>The technical procedure that was executed to accomplish the performance check.</p>"},{"location":"schema/competency/#msl.equipment.schema.Competency.worker","title":"worker  <code>instance-attribute</code>","text":"<pre><code>worker: str\n</code></pre> <p>The competent person who executed the technical procedure to accomplish the performance check.</p>"},{"location":"schema/competency/#msl.equipment.schema.Competency.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Competency\n</code></pre> <p>Convert an XML element into a Competency instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A competency XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Competency</code> <p>The Competency instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Competency:\n    \"\"\"Convert an XML element into a [Competency][msl.equipment.schema.Competency] instance.\n\n    Args:\n        element: A [competency][type_competency] XML element from an equipment register.\n\n    Returns:\n        The [Competency][msl.equipment.schema.Competency] instance.\n    \"\"\"\n    # Schema forces order\n    return cls(\n        worker=element[0].text or \"\",\n        checker=element[1].text or \"\",\n        technical_procedure=element[2].text or \"\",\n    )\n</code></pre>"},{"location":"schema/competency/#msl.equipment.schema.Competency.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Competency class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Competency as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Competency][msl.equipment.schema.Competency] class into an XML element.\n\n    Returns:\n        The [Competency][msl.equipment.schema.Competency] as an XML element.\n    \"\"\"\n    e = Element(\"competency\")\n    worker = SubElement(e, \"worker\")\n    worker.text = self.worker\n    checker = SubElement(e, \"checker\")\n    checker.text = self.checker\n    tp = SubElement(e, \"technicalProcedure\")\n    tp.text = self.technical_procedure\n    return e\n</code></pre>"},{"location":"schema/completed_task/","title":"CompletedTask","text":""},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask","title":"CompletedTask  <code>dataclass</code>","text":"<pre><code>CompletedTask(\n    task: str,\n    due_date: date,\n    performed_by: str,\n    completed_date: date,\n)\n</code></pre> <p>Represents the completedTask element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>str</code> <p>A description of the task that was completed.</p> required <code>due_date</code> <code>date</code> <p>The date that the maintenance task was due to be completed.</p> required <code>performed_by</code> <code>str</code> <p>The person or company that performed the maintenance task.</p> required <code>completed_date</code> <code>date</code> <p>The date that the maintenance task was completed.</p> required"},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask.completed_date","title":"completed_date  <code>instance-attribute</code>","text":"<pre><code>completed_date: date\n</code></pre> <p>The date that the maintenance task was completed.</p>"},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask.due_date","title":"due_date  <code>instance-attribute</code>","text":"<pre><code>due_date: date\n</code></pre> <p>The date that the maintenance task was due to be completed.</p>"},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask.performed_by","title":"performed_by  <code>instance-attribute</code>","text":"<pre><code>performed_by: str\n</code></pre> <p>The person or company that performed the maintenance task.</p>"},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask.task","title":"task  <code>instance-attribute</code>","text":"<pre><code>task: str\n</code></pre> <p>A description of the task that was completed.</p>"},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; CompletedTask\n</code></pre> <p>Convert an XML element into a CompletedTask instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A completedTask XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>CompletedTask</code> <p>The CompletedTask instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; CompletedTask:\n    \"\"\"Convert an XML element into a [CompletedTask][msl.equipment.schema.CompletedTask] instance.\n\n    Args:\n        element: A [completedTask][type_completedTask] XML element from an equipment register.\n\n    Returns:\n        The [CompletedTask][msl.equipment.schema.CompletedTask] instance.\n    \"\"\"\n    return cls(\n        task=element.text or \"\",\n        due_date=_date.fromisoformat(element.attrib[\"dueDate\"]),\n        performed_by=element.attrib[\"performedBy\"],\n        completed_date=_date.fromisoformat(element.attrib[\"completedDate\"]),\n    )\n</code></pre>"},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the CompletedTask class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The CompletedTask as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [CompletedTask][msl.equipment.schema.CompletedTask] class into an XML element.\n\n    Returns:\n        The [CompletedTask][msl.equipment.schema.CompletedTask] as an XML element.\n    \"\"\"\n    attrib = {\n        \"dueDate\": self.due_date.isoformat(),\n        \"completedDate\": self.completed_date.isoformat(),\n        \"performedBy\": self.performed_by,\n    }\n\n    e = Element(\"task\", attrib=attrib)\n    e.text = self.task\n    return e\n</code></pre>"},{"location":"schema/component/","title":"Component","text":""},{"location":"schema/component/#msl.equipment.schema.Component","title":"Component  <code>dataclass</code>","text":"<pre><code>Component(\n    name: str = \"\",\n    adjustments: tuple[Adjustment, ...] = (),\n    digital_reports: tuple[DigitalReport, ...] = (),\n    performance_checks: tuple[PerformanceCheck, ...] = (),\n    reports: tuple[Report, ...] = (),\n)\n</code></pre> <p>Represents the component element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name to associate with this component. The value must be unique amongst the other component elements within the same measurand element. An empty string is permitted.</p> <code>''</code> <code>adjustments</code> <code>tuple[Adjustment, ...]</code> <p>The history of adjustments.</p> <code>()</code> <code>digital_reports</code> <code>tuple[DigitalReport, ...]</code> <p>The history of digital calibration reports.</p> <code>()</code> <code>performance_checks</code> <code>tuple[PerformanceCheck, ...]</code> <p>The history of performance checks.</p> <code>()</code> <code>reports</code> <code>tuple[Report, ...]</code> <p>The history of calibration reports.</p> <code>()</code>"},{"location":"schema/component/#msl.equipment.schema.Component.adjustments","title":"adjustments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>adjustments: tuple[Adjustment, ...] = ()\n</code></pre> <p>The history of adjustments.</p>"},{"location":"schema/component/#msl.equipment.schema.Component.digital_reports","title":"digital_reports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>digital_reports: tuple[DigitalReport, ...] = ()\n</code></pre> <p>The history of digital calibration reports.</p>"},{"location":"schema/component/#msl.equipment.schema.Component.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = ''\n</code></pre> <p>The name associated with this component.</p>"},{"location":"schema/component/#msl.equipment.schema.Component.performance_checks","title":"performance_checks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performance_checks: tuple[PerformanceCheck, ...] = ()\n</code></pre> <p>The history of performance checks.</p>"},{"location":"schema/component/#msl.equipment.schema.Component.reports","title":"reports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reports: tuple[Report, ...] = ()\n</code></pre> <p>The history of calibration reports.</p>"},{"location":"schema/component/#msl.equipment.schema.Component.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Component\n</code></pre> <p>Convert an XML element into a Component instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A component XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Component</code> <p>The Component instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Component:\n    \"\"\"Convert an XML element into a [Component][msl.equipment.schema.Component] instance.\n\n    Args:\n        element: A [component][type_component] XML element from an equipment register.\n\n    Returns:\n        The [Component][msl.equipment.schema.Component] instance.\n    \"\"\"\n    # Schema defines &lt;component&gt; using xsd:choice, which allows sub-elements to appear (or not appear) in any order\n    # Using str.endswith() allows for ignoring XML namespaces that may be associated with each tag\n    a: list[Adjustment] = []\n    dr: list[DigitalReport] = []\n    pc: list[PerformanceCheck] = []\n    r: list[Report] = []\n    for child in element:\n        tag = child.tag\n        if tag.endswith(\"report\"):\n            r.append(Report.from_xml(child))\n        elif tag.endswith(\"performanceCheck\"):\n            pc.append(PerformanceCheck.from_xml(child))\n        elif tag.endswith(\"adjustment\"):\n            a.append(Adjustment.from_xml(child))\n        else:\n            dr.append(DigitalReport.from_xml(child))\n\n    return cls(\n        name=element.attrib[\"name\"],\n        adjustments=tuple(a),\n        digital_reports=tuple(dr),\n        performance_checks=tuple(pc),\n        reports=tuple(r),\n    )\n</code></pre>"},{"location":"schema/component/#msl.equipment.schema.Component.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Component class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Component as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Component][msl.equipment.schema.Component] class into an XML element.\n\n    Returns:\n        The [Component][msl.equipment.schema.Component] as an XML element.\n    \"\"\"\n    e = Element(\"component\", attrib={\"name\": self.name})\n\n    # the order is not important since xsd:choice is used\n    e.extend(r.to_xml() for r in self.reports)\n    e.extend(p.to_xml() for p in self.performance_checks)\n    e.extend(a.to_xml() for a in self.adjustments)\n    e.extend(d.to_xml() for d in self.digital_reports)\n    return e\n</code></pre>"},{"location":"schema/conditions/","title":"Conditions","text":""},{"location":"schema/conditions/#msl.equipment.schema.Conditions","title":"Conditions","text":"<pre><code>Conditions(**attributes: str)\n</code></pre> <p>               Bases: <code>Any</code></p> <p>Conditions under which a performance check or calibration report is valid.</p> <p>Since this class is currently represented by the any type in the XML Schema Definition, it is simply a subclass of Element. It may be updated to be a more specific class at a later date.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any] type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/conditions/#msl.equipment.schema.Conditions.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str = 'conditions'\n</code></pre> <p>The element's name.</p>"},{"location":"schema/conditions/#msl.equipment.schema.Conditions.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/cvd_equation/","title":"CVDEquation","text":"<p>The Callendar-Van Dusen (CVD) equation describes the relationship between resistance, \\(R\\), and temperature, \\(t\\), of platinum resistance thermometers (PRT). It is defined in two temperature ranges</p> \\[ \\frac{R(t)}{R_0} = \\begin{cases}     1 + A \\cdot t + B \\cdot t^2 + D \\cdot t^3 &amp; R(t) \\geq R_0 \\\\     1 + A \\cdot t + B \\cdot t^2 + C \\cdot t^3 \\cdot (t-100) &amp; R(t) \\lt R_0 \\\\ \\end{cases} \\] <p>where, \\(R_0 = R(0~^{\\circ}\\text{C})\\) is the resistance at \\(t=0~^{\\circ}\\text{C}\\) and \\(A\\), \\(B\\), \\(C\\) and \\(D\\) are the CVD coefficients. The \\(D\\) coefficient is typically zero but may be non-zero if \\(t \\gtrsim 200~^{\\circ}\\text{C}\\).</p> <p>Suppose you have a variable named <code>cvd</code> (which is an instance of CVDEquation) that represents the following information in an equipment register for a PRT</p> <pre><code>&lt;cvdCoefficients&gt;\n  &lt;R0&gt;100.0189&lt;/R0&gt;\n  &lt;A&gt;3.913e-3&lt;/A&gt;\n  &lt;B&gt;-6.056e-7&lt;/B&gt;\n  &lt;C&gt;1.372e-12&lt;/C&gt;\n  &lt;D&gt;0&lt;/D&gt;\n  &lt;uncertainty variables=\"\"&gt;0.0056/2&lt;/uncertainty&gt;\n  &lt;range&gt;\n    &lt;minimum&gt;-10&lt;/minimum&gt;\n    &lt;maximum&gt;70&lt;/maximum&gt;\n  &lt;/range&gt;\n&lt;/cvdCoefficients&gt;\n</code></pre> <p>You can access the CVD coefficients, degrees of freedom and comment as attributes of <code>cvd</code>,</p> <pre><code>&gt;&gt;&gt; cvd.R0\n100.0189\n&gt;&gt;&gt; cvd.A\n0.003913\n&gt;&gt;&gt; cvd.B\n-6.056e-07\n&gt;&gt;&gt; cvd.C\n1.372e-12\n&gt;&gt;&gt; cvd.D\n0.0\n&gt;&gt;&gt; cvd.degree_freedom\ninf\n&gt;&gt;&gt; cvd.comment\n''\n</code></pre> <p>evaluate the uncertainty,</p> <pre><code>&gt;&gt;&gt; print(cvd.uncertainty())\n0.0026\n</code></pre> <p>calculate resistance from temperature,</p> <pre><code>&gt;&gt;&gt; print(cvd.resistance(12.4))\n104.86262358516764\n&gt;&gt;&gt; cvd.resistance([-5, 0, 5, 10, 15, 20, 25])\narray([ 98.06051774, 100.0189    , 101.97425549, 103.92658241,\n       105.87588076, 107.82215054, 109.76539174])\n</code></pre> <p>and calculate temperature from resistance</p> <pre><code>&gt;&gt;&gt; print(cvd.temperature(109.1))\n23.287055698724505\n&gt;&gt;&gt; cvd.temperature([98.7, 99.2, 100.4, 101.7, 103.8])\narray([-3.36816839, -2.09169544,  0.9738958 ,  4.29823964,  9.67558125])\n</code></pre> <p>A number or any sequence of numbers, i.e., a list, tuple or ndarray may be used to calculate the temperature or resistance (tip: using ndarray will improve performance since a copy of the values is not required).</p> <p>When calculating resistance or temperature, the values of the inputs are checked to ensure that the values are within the range that the CVD coefficients are valid for. The XML data above shows that the temperature must be in the range \\(-10~^\\circ\\text{C}\\) to \\(70~^\\circ\\text{C}\\), which has a corresponding resistance range of \\(96.099~\\Omega\\) to \\(127.118~\\Omega\\) from the equation above. If you calculate resistance from \\(t=-10.2~^\\circ\\text{C}\\) or temperature from \\(R=96.0~\\Omega\\) a ValueError is raised, since the value is outside the range.</p> <pre><code>&gt;&gt;&gt; cvd.ranges\n{'t': Range(minimum=-10, maximum=70), 'r': Range(minimum=96.099, maximum=127.118)}\n\n&gt;&gt;&gt; cvd.resistance(-10.2)\nTraceback (most recent call last):\n...\nValueError: The value -10.2 is not within the range [-10, 70]\n\n&gt;&gt;&gt; cvd.temperature(96)\nTraceback (most recent call last):\n...\nValueError: The value 96.0 is not within the range [96.099, 127.118]\n</code></pre> <p>You can bypass range checking by including a <code>check_range=False</code> keyword argument</p> <pre><code>&gt;&gt;&gt; print(cvd.resistance(-10.2, check_range=False))\n96.02059984653798\n&gt;&gt;&gt; print(cvd.temperature(96, check_range=False))\n-10.252469261526016\n</code></pre>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation","title":"CVDEquation  <code>dataclass</code>","text":"<pre><code>CVDEquation(\n    R0: float,\n    A: float,\n    B: float,\n    C: float,\n    D: float,\n    uncertainty: Evaluable,\n    ranges: dict[str, Range] = dict(),\n    degree_freedom: float = float(\"inf\"),\n    comment: str = \"\",\n)\n</code></pre> <p>The Callendar-Van Dusen (CVD) equation based on the cvdCoefficients element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>R0</code> <code>float</code> <p>The value, in \\(\\Omega\\), of the resistance at \\(0~^\\circ\\text{C}\\), \\(R_0\\).</p> required <code>A</code> <code>float</code> <p>The value, in \\((^\\circ\\text{C})^{-1}\\), of the A coefficient, \\(A \\cdot t\\).</p> required <code>B</code> <code>float</code> <p>The value, in \\((^\\circ\\text{C})^{-2}\\), of the B coefficient, \\(B \\cdot t^2\\).</p> required <code>C</code> <code>float</code> <p>The value, in \\((^\\circ\\text{C})^{-4}\\), of the C coefficient, \\(C \\cdot t^3 \\cdot (t-100)\\).</p> required <code>D</code> <code>float</code> <p>The value, in \\((^\\circ\\text{C})^{-3}\\), of the D coefficient, \\(D \\cdot t^3\\). The \\(D\\) coefficient is typically zero but may be non-zero if \\(t \\gtrsim 200~^{\\circ}\\text{C}\\). If a calibration report does not specify the \\(D\\) coefficient, set the value to be 0.</p> required <code>uncertainty</code> <code>Evaluable</code> <p>The equation to evaluate to calculate the standard uncertainty.</p> required <code>ranges</code> <code>dict[str, Range]</code> <p>The temperature range, in \\((^\\circ)\\text{C}\\), and the resistance range, in \\(\\Omega\\), that the CVD coefficients are valid. The temperature key must be <code>\"t\"</code> and the resistance key <code>\"r\"</code>.</p> <code>dict()</code> <code>degree_freedom</code> <code>float</code> <p>The degrees of freedom.</p> <code>float('inf')</code> <code>comment</code> <code>str</code> <p>A comment to associate with the CVD equation.</p> <code>''</code>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.A","title":"A  <code>instance-attribute</code>","text":"<pre><code>A: float\n</code></pre> <p>The value, in \\((^\\circ\\text{C})^{-1}\\), of the A coefficient, \\(A \\cdot t\\).</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.B","title":"B  <code>instance-attribute</code>","text":"<pre><code>B: float\n</code></pre> <p>The value, in \\((^\\circ\\text{C})^{-2}\\), of the B coefficient, \\(B \\cdot t^2\\).</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.C","title":"C  <code>instance-attribute</code>","text":"<pre><code>C: float\n</code></pre> <p>The value, in \\((^\\circ\\text{C})^{-4}\\), of the C coefficient, \\(C \\cdot t^3 \\cdot (t-100)\\).</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.D","title":"D  <code>instance-attribute</code>","text":"<pre><code>D: float\n</code></pre> <p>The value, in \\((^\\circ\\text{C})^{-3}\\), of the D coefficient, \\(D \\cdot t^3\\).</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.R0","title":"R0  <code>instance-attribute</code>","text":"<pre><code>R0: float\n</code></pre> <p>The value, in \\(\\Omega\\), of the resistance at \\(0~^\\circ\\text{C}\\), \\(R_0\\).</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.comment","title":"comment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comment: str = ''\n</code></pre> <p>A comment associated with the Callendar-Van Dusen equation.</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.degree_freedom","title":"degree_freedom  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>degree_freedom: float = float('inf')\n</code></pre> <p>The degrees of freedom.</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.ranges","title":"ranges  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ranges: dict[str, Range] = field(default_factory=dict)\n</code></pre> <p>The temperature range, in \\(^\\circ\\text{C}\\), and the resistance range, in \\(\\Omega\\), that the Callendar-Van Dusen coefficients are valid.</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.uncertainty","title":"uncertainty  <code>instance-attribute</code>","text":"<pre><code>uncertainty: Evaluable\n</code></pre> <p>The equation to evaluate to calculate the standard uncertainty.</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; CVDEquation\n</code></pre> <p>Convert an XML element into a CVDEquation instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A cvdCoefficients XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>CVDEquation</code> <p>The CVDEquation instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; CVDEquation:\n    \"\"\"Convert an XML element into a [CVDEquation][msl.equipment.schema.CVDEquation] instance.\n\n    Args:\n        element: A [cvdCoefficients][type_cvdCoefficients] XML element\n            from an equipment register.\n\n    Returns:\n        The [CVDEquation][msl.equipment.schema.CVDEquation] instance.\n    \"\"\"\n    # Schema forces order\n    r0 = float(element[0].text or 0)\n    a = float(element[1].text or 0)\n    b = float(element[2].text or 0)\n    c = float(element[3].text or 0)\n    d = float(element[4].text or 0)\n\n    r = element[6]\n    _range = Range(float(r[0].text or -200), float(r[1].text or 661))\n    ranges = {\n        \"t\": _range,\n        \"r\": Range(\n            minimum=round(float(_cvd_resistance(_range.minimum, r0, a, b, c, d)), 3),\n            maximum=round(float(_cvd_resistance(_range.maximum, r0, a, b, c, d)), 3),\n        ),\n    }\n\n    u = element[5]\n    uncertainty = Evaluable(\n        equation=u.text or \"\",\n        variables=tuple(u.attrib[\"variables\"].split()),\n        ranges=ranges,\n    )\n\n    return cls(\n        R0=r0,\n        A=a,\n        B=b,\n        C=c,\n        D=d,\n        uncertainty=uncertainty,\n        ranges=ranges,\n        degree_freedom=float(element[7].text or np.inf) if len(element) &gt; 7 else np.inf,  # noqa: PLR2004\n        comment=element.attrib.get(\"comment\", \"\"),\n    )\n</code></pre>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.resistance","title":"resistance","text":"<pre><code>resistance(\n    temperature: ArrayLike, *, check_range: bool = True\n) -&gt; NDArray[float64]\n</code></pre> <p>Calculate resistance from temperature.</p> <p>Parameters:</p> Name Type Description Default <code>temperature</code> <code>ArrayLike</code> <p>The temperature values, in \\(^\\circ\\text{C}\\).</p> required <code>check_range</code> <code>bool</code> <p>Whether to check that the temperature values are within the allowed range.</p> <code>True</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The resistance values.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def resistance(self, temperature: ArrayLike, *, check_range: bool = True) -&gt; NDArray[np.float64]:\n    r\"\"\"Calculate resistance from temperature.\n\n    Args:\n        temperature: The temperature values, in $^\\circ\\text{C}$.\n        check_range: Whether to check that the temperature values are within the allowed range.\n\n    Returns:\n        The resistance values.\n    \"\"\"\n    array = np.asarray(temperature, dtype=float)\n    if check_range and self.ranges[\"t\"].check_within_range(array):\n        pass  # check_within_range() will raise an error, if one occurred\n\n    return _cvd_resistance(array, self.R0, self.A, self.B, self.C, self.D)\n</code></pre>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.temperature","title":"temperature","text":"<pre><code>temperature(\n    resistance: ArrayLike, *, check_range: bool = True\n) -&gt; NDArray[float64]\n</code></pre> <p>Calculate temperature from resistance.</p> <p>Parameters:</p> Name Type Description Default <code>resistance</code> <code>ArrayLike</code> <p>The resistance values, in \\(\\Omega\\).</p> required <code>check_range</code> <code>bool</code> <p>Whether to check that the resistance values are within the allowed range.</p> <code>True</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The temperature values.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def temperature(self, resistance: ArrayLike, *, check_range: bool = True) -&gt; NDArray[np.float64]:\n    r\"\"\"Calculate temperature from resistance.\n\n    Args:\n        resistance: The resistance values, in $\\Omega$.\n        check_range: Whether to check that the resistance values are within the allowed range.\n\n    Returns:\n        The temperature values.\n    \"\"\"\n    array: NDArray[np.float64] = np.asarray(resistance, dtype=float)\n    if check_range and self.ranges[\"r\"].check_within_range(array):\n        pass  # check_within_range raised an error, if one occurred\n\n    def positive_quadratic(r: NDArray[np.float64]) -&gt; NDArray[np.float64]:\n        # rearrange CVD equation to be: a*x^2 + b*x + c = 0\n        #   a -&gt; B, b -&gt; A, c -&gt; 1 - R/R0\n        # then use the quadratic formula\n        return (-self.A + np.sqrt(self.A**2 - 4.0 * self.B * (1.0 - r / self.R0))) / (2.0 * self.B)\n\n    def positive_cubic(r: NDArray[np.float64]) -&gt; NDArray[np.float64]:\n        # rearrange CVD equation to be: a*x^3 + b*x^2 + c*x + d = 0\n        a = self.D\n        b = self.B\n        c = self.A\n        d = 1.0 - (r / self.R0)\n\n        # then use Cardano's Formula\n        # https://proofwiki.org/wiki/Cardano's_Formula#Real_Coefficients\n        Q: float = (3.0 * a * c - b**2) / (9.0 * a**2)  # noqa: N806\n        R: NDArray[np.float64] = (9.0 * a * b * c - 27.0 * a**2 * d - 2.0 * b**3) / (54.0 * a**3)  # noqa: N806\n        sqrt: NDArray[np.float64] = np.sqrt(Q**3 + R**2)\n        S: NDArray[np.float64] = np.cbrt(R + sqrt)  # noqa: N806\n        T: NDArray[np.float64] = np.cbrt(R - sqrt)  # noqa: N806\n        return S + T - (b / (3.0 * a))  # x1 equation\n\n    def negative(r: NDArray[np.float64]) -&gt; NDArray[np.float64]:\n        # rearrange CVD equation to be: a*x^4 + b*x^3 + c*x^2 + d*x + e = 0\n        a = self.C\n        b = -100.0 * self.C\n        c = self.B\n        d = self.A\n        e = 1.0 - (r / self.R0)\n\n        # https://en.wikipedia.org/wiki/Quartic_function#Solving_a_quartic_equation]\n        # See Section \"General formula for roots\" for the definitions of these variables\n        p = (8 * a * c - 3 * b**2) / (8 * a**2)\n        q = (b**3 - 4 * a * b * c + 8 * a**2 * d) / (8 * a**3)\n        delta_0 = c**2 - 3 * b * d + 12 * a * e\n        delta_1 = 2 * c**3 - 9 * b * c * d + 27 * b**2 * e + 27 * a * d**2 - 72 * a * c * e\n        Q = np.cbrt((delta_1 + np.sqrt(delta_1**2 - 4 * delta_0**3)) / 2)  # noqa: N806\n        S = 0.5 * np.sqrt(-2 * p / 3 + 1 / (3 * a) * (Q + delta_0 / Q))  # noqa: N806\n\n        # decide which root of the quartic to use by looking at the value under the\n        # square root in the x1,2 and x3,4 equations\n        t1 = -4 * S**2 - 2 * p\n        t2 = q / S\n        t3 = t1 - t2\n        return np.piecewise(\n            t3,\n            [t3 &gt;= 0, t3 &lt; 0],\n            [\n                lambda x: -b / (4.0 * a) + S - 0.5 * np.sqrt(x),  # x4 equation\n                lambda x: -b / (4.0 * a) - S + 0.5 * np.sqrt(x + 2.0 * t2),  # x1 equation\n            ],\n        )\n\n    positive = positive_quadratic if self.D == 0 else positive_cubic\n    return np.piecewise(array, [array &lt; self.R0, array &gt;= self.R0], [negative, positive])\n</code></pre>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the CVDEquation class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The CVDEquation as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [CVDEquation][msl.equipment.schema.CVDEquation] class into an XML element.\n\n    Returns:\n        The [CVDEquation][msl.equipment.schema.CVDEquation] as an XML element.\n    \"\"\"\n    attrib = {\"comment\": self.comment} if self.comment else {}\n    e = Element(\"cvdCoefficients\", attrib=attrib)\n\n    r0 = SubElement(e, \"R0\")\n    r0.text = str(self.R0)\n\n    a = SubElement(e, \"A\")\n    a.text = str(self.A)\n\n    b = SubElement(e, \"B\")\n    b.text = str(self.B)\n\n    c = SubElement(e, \"C\")\n    c.text = str(self.C)\n\n    d = SubElement(e, \"D\")\n    d.text = str(self.D)\n\n    u = SubElement(e, \"uncertainty\", attrib={\"variables\": \" \".join(self.uncertainty.variables)})\n    u.text = str(self.uncertainty.equation)\n\n    rng = SubElement(e, \"range\")\n    mn = SubElement(rng, \"minimum\")\n    mn.text = str(self.ranges[\"t\"].minimum)\n    mx = SubElement(rng, \"maximum\")\n    mx.text = str(self.ranges[\"t\"].maximum)\n\n    if not isinf(self.degree_freedom):\n        dof = SubElement(e, \"degreeFreedom\")\n        dof.text = str(self.degree_freedom)\n\n    return e\n</code></pre>"},{"location":"schema/deserialised/","title":"Deserialised","text":""},{"location":"schema/deserialised/#msl.equipment.schema.Deserialised","title":"Deserialised  <code>dataclass</code>","text":"<pre><code>Deserialised(value: Any, comment: str = '')\n</code></pre> <p>Represents the opposite of the serialised element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value of the deserialised object.</p> required <code>comment</code> <code>str</code> <p>A comment to associate with the (de)serialised object.</p> <code>''</code>"},{"location":"schema/deserialised/#msl.equipment.schema.Deserialised.comment","title":"comment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comment: str = ''\n</code></pre> <p>A comment associated with the (de)serialised object.</p>"},{"location":"schema/deserialised/#msl.equipment.schema.Deserialised.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: Any\n</code></pre> <p>The value of the deserialised object. For example, an Archive object from GTC.</p>"},{"location":"schema/deserialised/#msl.equipment.schema.Deserialised.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Deserialised\n</code></pre> <p>Convert a serialised XML element into a Deserialised instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A serialised XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Deserialised</code> <p>The Deserialised instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Deserialised:\n    \"\"\"Convert a [serialised][type_serialised] XML element into a [Deserialised][msl.equipment.schema.Deserialised] instance.\n\n    Args:\n        element: A [serialised][type_serialised] XML element from an equipment register.\n\n    Returns:\n        The [Deserialised][msl.equipment.schema.Deserialised] instance.\n    \"\"\"  # noqa: E501\n    e = element[0]\n    comment = element.attrib.get(\"comment\", \"\")\n\n    # GTC is not required for msl-equipment, so we import it here\n    if e.tag.endswith(\"gtcArchive\"):\n        from GTC.xml_format import (  # type: ignore[import-untyped]  # pyright: ignore[reportMissingTypeStubs]  # noqa: PLC0415\n            xml_to_archive,  # pyright: ignore[reportUnknownVariableType]\n        )\n\n        return cls(value=xml_to_archive(e), comment=comment)\n\n    if e.tag.endswith(\"gtcArchiveJSON\"):\n        from GTC import (  # type: ignore[import-untyped]  # pyright: ignore[reportMissingTypeStubs]  # noqa: PLC0415\n            pr,  # pyright: ignore[reportUnknownVariableType]\n        )\n\n        return cls(value=pr.loads_json(e.text), comment=comment)  # pyright: ignore[reportUnknownMemberType]\n\n    # Use the Element object rather than raising an exception that the deserializer has not been implemented yet\n    return cls(value=e, comment=comment)\n</code></pre>"},{"location":"schema/deserialised/#msl.equipment.schema.Deserialised.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Deserialised class into a serialised XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The serialised XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Deserialised][msl.equipment.schema.Deserialised] class into a [serialised][type_serialised] XML element.\n\n    Returns:\n        The [serialised][type_serialised] XML element.\n    \"\"\"  # noqa: E501\n    attrib = {\"comment\": self.comment} if self.comment else {}\n    e = Element(\"serialised\", attrib=attrib)\n\n    if isinstance(self.value, Element):\n        e.append(self.value)  # pyright: ignore[reportUnknownMemberType, reportUnknownArgumentType]\n        return e\n\n    # Currently, only a GTC Archive is supported so we don't need to check how to serialise it\n    # GTC is not required for msl-equipment, so we import it here\n    from GTC.persistence import (  # type: ignore[import-untyped]  # pyright: ignore[reportMissingTypeStubs]  # noqa: PLC0415\n        Archive,  # pyright: ignore[reportUnknownVariableType]\n    )\n    from GTC.xml_format import (  # pyright: ignore[reportMissingTypeStubs]  # noqa: PLC0415\n        archive_to_xml,  # pyright: ignore[reportUnknownVariableType]\n    )\n\n    e.append(archive_to_xml(Archive.copy(self.value)))  # pyright: ignore[reportUnknownArgumentType, reportUnknownMemberType]\n    return e\n</code></pre>"},{"location":"schema/digital_report/","title":"DigitalReport","text":""},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport","title":"DigitalReport  <code>dataclass</code>","text":"<pre><code>DigitalReport(\n    url: str,\n    format: DigitalFormat,\n    id: str,\n    sha256: str,\n    attributes: dict[str, str] = dict(),\n    comment: str = \"\",\n)\n</code></pre> <p>Represents the digitalReport element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The location of the digital report. The syntax follows RFC 1738 <code>scheme:scheme-specific-part</code>. If <code>scheme:</code> is not specified, it is assumed to be <code>file:</code>.</p> required <code>format</code> <code>DigitalFormat</code> <p>The format of the digital calibration report.</p> required <code>id</code> <code>str</code> <p>The report identification number.</p> required <code>sha256</code> <code>str</code> <p>The SHA-256 checksum of the digital report.</p> required <code>attributes</code> <code>dict[str, str]</code> <p>XML attributes associated with the <code>&lt;url&gt;</code> element.</p> <code>dict()</code> <code>comment</code> <code>str</code> <p>A comment to associate with the digital report.</p> <code>''</code>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.attributes","title":"attributes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attributes: dict[str, str] = field(default_factory=dict)\n</code></pre> <p>XML attributes associated with the <code>&lt;url&gt;</code> element.</p>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.comment","title":"comment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comment: str = ''\n</code></pre> <p>A comment associated with the digital report.</p>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.format","title":"format  <code>instance-attribute</code>","text":"<pre><code>format: DigitalFormat\n</code></pre> <p>The format of the digital calibration report.</p>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>The report identification number.</p>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.sha256","title":"sha256  <code>instance-attribute</code>","text":"<pre><code>sha256: str\n</code></pre> <p>The SHA-256 checksum of the digital report.</p>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: str\n</code></pre> <p>The location of the digital report. The syntax follows RFC 1738 <code>scheme:scheme-specific-part</code>. If <code>scheme:</code> is not specified, it is assumed to be <code>file:</code>.</p>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; DigitalReport\n</code></pre> <p>Convert an XML element into a DigitalReport instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A digitalReport XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>DigitalReport</code> <p>The DigitalReport instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; DigitalReport:\n    \"\"\"Convert an XML element into a [DigitalReport][msl.equipment.schema.DigitalReport] instance.\n\n    Args:\n        element: A [digitalReport][type_digitalReport] XML element from an equipment register.\n\n    Returns:\n        The [DigitalReport][msl.equipment.schema.DigitalReport] instance.\n    \"\"\"\n    # Schema forces order\n    return cls(\n        url=element[0].text or \"\",\n        format=DigitalFormat(element.attrib[\"format\"]),\n        id=element.attrib[\"id\"],\n        sha256=element[1].text or \"\",\n        attributes=element[0].attrib,\n        comment=element.attrib.get(\"comment\", \"\"),\n    )\n</code></pre>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the DigitalReport class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The DigitalReport as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [DigitalReport][msl.equipment.schema.DigitalReport] class into an XML element.\n\n    Returns:\n        The [DigitalReport][msl.equipment.schema.DigitalReport] as an XML element.\n    \"\"\"\n    attrib = {\"format\": self.format.value, \"id\": self.id}\n    if self.comment:\n        attrib[\"comment\"] = self.comment\n    e = Element(\"digitalReport\", attrib=attrib)\n    url = SubElement(e, \"url\", attrib=self.attributes)\n    url.text = self.url\n    sha256 = SubElement(e, \"sha256\")\n    sha256.text = self.sha256\n    return e\n</code></pre>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalFormat","title":"DigitalFormat","text":"<p>               Bases: <code>Enum</code></p> <p>Represents the digitalFormatEnumerationString enumeration in an equipment register.</p> <p>Attributes:</p> Name Type Description <code>MSL_PDF</code> <code>str</code> <p><code>\"MSL PDF/A-3\"</code> (MSL's PDF/A-3 format).</p> <code>PTB_DCC</code> <code>str</code> <p><code>\"PTB DCC\"</code> (PTB's Digital Calibration Certificate).</p>"},{"location":"schema/equation/","title":"Equation","text":"<p>Suppose you have a variable named <code>equation</code> (which is an instance of Equation) that represents the following information in an equipment register for equipment that measures relative humidity. The corrected value depends on two variables (<code>r</code> and <code>t</code>) and the standard uncertainty is a constant.</p> <pre><code>&lt;equation&gt;\n  &lt;value variables=\"r t\"&gt;r-0.71-0.04*r+3.4e-4*pow(r,2)+2.4e-3*t+1.3e-3*r*t&lt;/value&gt;\n  &lt;uncertainty variables=\"\"&gt;0.355&lt;/uncertainty&gt;\n  &lt;unit&gt;%rh&lt;/unit&gt;\n  &lt;ranges&gt;\n    &lt;range variable=\"r\"&gt;\n      &lt;minimum&gt;30&lt;/minimum&gt;\n      &lt;maximum&gt;80&lt;/maximum&gt;\n    &lt;/range&gt;\n    &lt;range variable=\"t\"&gt;\n      &lt;minimum&gt;15&lt;/minimum&gt;\n      &lt;maximum&gt;25&lt;/maximum&gt;\n    &lt;/range&gt;\n  &lt;/ranges&gt;\n&lt;/equation&gt;\n</code></pre> <p>You can access the unit, degrees of freedom and comment as attributes of <code>equation</code></p> <pre><code>&gt;&gt;&gt; equation.unit\n'%rh'\n&gt;&gt;&gt; equation.degree_freedom\ninf\n&gt;&gt;&gt; equation.comment\n''\n</code></pre> <p>To evaluate an equation, call the appropriate attribute with the variable(s) that are required to evaluate the equation with</p> <pre><code>&gt;&gt;&gt; equation.value.variables\n('r', 't')\n&gt;&gt;&gt; equation.uncertainty.variables\n()\n&gt;&gt;&gt; assert equation.value(r=50.3, t=20.4) == 49.8211466\n&gt;&gt;&gt; assert equation.uncertainty() == 0.355\n</code></pre> <p>A variable can have multiple values. Any sequence of numbers, i.e., a list, tuple, ndarray, etc., may be used (tip: using ndarray will improve performance since a copy of the values is not required),</p> <pre><code>&gt;&gt;&gt; equation.value(r=[50.3, 52.1, 48.7], t=[20.4, 19.7, 20.0])\narray([49.8211466, 51.6104604, 48.1625746])\n</code></pre> <p>the values of the variables do not need to be 1-dimensional arrays,</p> <pre><code>&gt;&gt;&gt; equation.value(r=[(50.3, 52.1), (48.7, 47.9)], t=[(20.4, 19.7), (20.0, 19.6)])\narray([[49.8211466, 51.6104604],\n       [48.1625746, 47.3216314]])\n</code></pre> <p>and the array broadcasting rules of numpy also apply, i.e., multiple <code>r</code> values and a single <code>t</code> value</p> <pre><code>&gt;&gt;&gt; equation.value(r=(50.3, 52.1, 48.7), t=20.4)\narray([49.8211466, 51.6595514, 48.1888586])\n</code></pre> <p>If you forget to specify a variable (in the following case, <code>t</code>) a NameError will be raised,</p> <pre><code>&gt;&gt;&gt; equation.value(r=50.3)\nTraceback (most recent call last):\n...\nNameError: name 't' is not defined\n</code></pre> <p>however, if you specify more variables than are required to evaluate the equation, the additional variables are ignored <pre><code>&gt;&gt;&gt; equation.uncertainty(r=50.3, t=20.4)\narray(0.355)\n</code></pre></p> <p>Notice in the last returned value that the result was printed as <code>array(0.355)</code> even though a single <code>r</code> and <code>t</code> value was specified (although these variables were ignored in this particular example, since the standard uncertainty is a constant, the principle remains the same if they were not ignored). All evaluated returned types are an instance of a numpy ndarray even if a single value is specified. These particular returned array instances are referred to as 0-dimensional array scalars in numpy terminology.</p> <p>When evaluating an equation, the value(s) of the input variables are checked to ensure that the value(s) are within the ranges that the equation is valid for. The XML data above shows that the temperature, <code>t</code>, value must be in the range <code>15</code> to <code>25</code>. If you evaluate the corrected value at <code>t=30</code> a ValueError is raised</p> <pre><code>&gt;&gt;&gt; equation.value.ranges\n{'r': Range(minimum=30, maximum=80), 't': Range(minimum=15, maximum=25)}\n&gt;&gt;&gt; equation.value(r=50.3, t=30)\nTraceback (most recent call last):\n...\nValueError: The value 30.0 is not within the range [15, 25]\n</code></pre> <p>You can bypass range checking by including a <code>check_range=False</code> keyword argument</p> <pre><code>&gt;&gt;&gt; equation.value(r=50.3, t=30, check_range=False)\narray(50.4719306)\n</code></pre>"},{"location":"schema/equation/#msl.equipment.schema.Equation","title":"Equation  <code>dataclass</code>","text":"<pre><code>Equation(\n    value: Evaluable,\n    uncertainty: Evaluable,\n    unit: str,\n    degree_freedom: float = float(\"inf\"),\n    comment: str = \"\",\n)\n</code></pre> <p>Represents the equation element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Evaluable</code> <p>The equation to evaluate to calculate the corrected value.</p> required <code>uncertainty</code> <code>Evaluable</code> <p>The equation to evaluate to calculate the standard uncertainty.</p> required <code>unit</code> <code>str</code> <p>The unit of the measured quantity.</p> required <code>degree_freedom</code> <code>float</code> <p>The degrees of freedom.</p> <code>float('inf')</code> <code>comment</code> <code>str</code> <p>A comment to associate with the equation.</p> <code>''</code>"},{"location":"schema/equation/#msl.equipment.schema.Equation.comment","title":"comment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comment: str = ''\n</code></pre> <p>A comment associated with the equation.</p>"},{"location":"schema/equation/#msl.equipment.schema.Equation.degree_freedom","title":"degree_freedom  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>degree_freedom: float = float('inf')\n</code></pre> <p>The degrees of freedom.</p>"},{"location":"schema/equation/#msl.equipment.schema.Equation.uncertainty","title":"uncertainty  <code>instance-attribute</code>","text":"<pre><code>uncertainty: Evaluable\n</code></pre> <p>The equation to evaluate to calculate the standard uncertainty.</p>"},{"location":"schema/equation/#msl.equipment.schema.Equation.unit","title":"unit  <code>instance-attribute</code>","text":"<pre><code>unit: str\n</code></pre> <p>The unit of the measured quantity.</p>"},{"location":"schema/equation/#msl.equipment.schema.Equation.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: Evaluable\n</code></pre> <p>The equation to evaluate to calculate the corrected value.</p>"},{"location":"schema/equation/#msl.equipment.schema.Equation.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Equation\n</code></pre> <p>Convert an XML element into an Equation instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An equation XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Equation</code> <p>The Equation instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Equation:\n    \"\"\"Convert an XML element into an [Equation][msl.equipment.schema.Equation] instance.\n\n    Args:\n        element: An [equation][type_equation] XML element from an equipment register.\n\n    Returns:\n        The [Equation][msl.equipment.schema.Equation] instance.\n    \"\"\"\n    # Schema forces order\n    value = element[0]\n    uncertainty = element[1]\n    ranges = {\n        r.attrib[\"variable\"]: Range(minimum=float(r[0].text or -np.inf), maximum=float(r[1].text or np.inf))\n        for r in element[3]\n    }\n\n    return cls(\n        value=Evaluable(\n            equation=value.text or \"\", variables=tuple(value.attrib[\"variables\"].split()), ranges=ranges\n        ),\n        uncertainty=Evaluable(\n            equation=uncertainty.text or \"\", variables=tuple(uncertainty.attrib[\"variables\"].split()), ranges=ranges\n        ),\n        unit=element[2].text or \"\",\n        degree_freedom=float(element[4].text or np.inf) if len(element) &gt; 4 else np.inf,  # noqa: PLR2004\n        comment=element.attrib.get(\"comment\", \"\"),\n    )\n</code></pre>"},{"location":"schema/equation/#msl.equipment.schema.Equation.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Equation class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Equation as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Equation][msl.equipment.schema.Equation] class into an XML element.\n\n    Returns:\n        The [Equation][msl.equipment.schema.Equation] as an XML element.\n    \"\"\"\n    attrib = {\"comment\": self.comment} if self.comment else {}\n    e = Element(\"equation\", attrib=attrib)\n    value = SubElement(e, \"value\", attrib={\"variables\": \" \".join(self.value.variables)})\n    value.text = self.value.equation\n    uncertainty = SubElement(e, \"uncertainty\", attrib={\"variables\": \" \".join(self.uncertainty.variables)})\n    uncertainty.text = self.uncertainty.equation\n    unit = SubElement(e, \"unit\")\n    unit.text = self.unit\n\n    ranges = SubElement(e, \"ranges\")\n    for name, _range in self.value.ranges.items():  # self.value.ranges and self.uncertainty.ranges are the same\n        rng = SubElement(ranges, \"range\", attrib={\"variable\": name})\n        mn = SubElement(rng, \"minimum\")\n        mn.text = str(_range.minimum)\n        mx = SubElement(rng, \"maximum\")\n        mx.text = str(_range.maximum)\n\n    if not isinf(self.degree_freedom):\n        dof = SubElement(e, \"degreeFreedom\")\n        dof.text = str(self.degree_freedom)\n\n    return e\n</code></pre>"},{"location":"schema/equation/#msl.equipment.schema.Evaluable","title":"Evaluable  <code>dataclass</code>","text":"<pre><code>Evaluable(\n    equation: str,\n    variables: tuple[str, ...] = (),\n    ranges: dict[str, Range] = dict(),\n)\n</code></pre> <p>Represents the <code>&lt;value&gt;</code> and <code>&lt;uncertainty&gt;</code> XML elements in an equation.</p> <p>Parameters:</p> Name Type Description Default <code>equation</code> <code>str</code> <p>The string representation of the equation to evaluate.</p> required <code>variables</code> <code>tuple[str, ...]</code> <p>The names of the variables in the equation.</p> <code>()</code> <code>ranges</code> <code>dict[str, Range]</code> <p>The numeric range for a variable that the <code>equation</code> is valid for. The keys are the variable names. A range does not need to be defined for every variable. If a range is not defined then a range of \\([-\\infty, +\\infty]\\) is assumed.</p> <code>dict()</code>"},{"location":"schema/equation/#msl.equipment.schema.Evaluable.equation","title":"equation  <code>instance-attribute</code>","text":"<pre><code>equation: str\n</code></pre> <p>The string representation of the equation to evaluate.</p>"},{"location":"schema/equation/#msl.equipment.schema.Evaluable.ranges","title":"ranges  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ranges: dict[str, Range] = field(default_factory=dict)\n</code></pre> <p>The numeric range for each variable that the <code>equation</code> is valid for. The keys are the variable names.</p>"},{"location":"schema/equation/#msl.equipment.schema.Evaluable.variables","title":"variables  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variables: tuple[str, ...] = ()\n</code></pre> <p>The names of the variables in the equation.</p>"},{"location":"schema/equation/#msl.equipment.schema.Range","title":"Range","text":"<p>               Bases: <code>NamedTuple</code></p> <p>The numeric range of a variable that an equation is valid for.</p> <p>Parameters:</p> Name Type Description <code>minimum</code> <code>float</code> <p>Minimum value in range.</p> <code>maximum</code> <code>float</code> <p>Maximum value in range.</p>"},{"location":"schema/equation/#msl.equipment.schema.Range.maximum","title":"maximum  <code>instance-attribute</code>","text":"<pre><code>maximum: float\n</code></pre> <p>Maximum value in range.</p>"},{"location":"schema/equation/#msl.equipment.schema.Range.minimum","title":"minimum  <code>instance-attribute</code>","text":"<pre><code>minimum: float\n</code></pre> <p>Minimum value in range.</p>"},{"location":"schema/equation/#msl.equipment.schema.Range.check_within_range","title":"check_within_range","text":"<pre><code>check_within_range(\n    value: float | ArrayLike,\n) -&gt; Literal[True]\n</code></pre> <p>Check that the values are within the range.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float | ArrayLike</code> <p>The values to check, raises</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>Always returns <code>True</code>. Raises ValueError if <code>value</code> is not within the range.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def check_within_range(self, value: float | ArrayLike) -&gt; Literal[True]:\n    \"\"\"Check that the values are within the range.\n\n    Args:\n        value: The values to check, raises\n\n    Returns:\n        Always returns `True`. Raises [ValueError][] if\n            `value` is not within the range.\n    \"\"\"\n    if isinstance(value, (int, float)) or (isinstance(value, np.ndarray) and value.ndim == 0):\n        if value &lt; self.minimum or value &gt; self.maximum:\n            msg = f\"The value {value} is not within the range [{self.minimum}, {self.maximum}]\"\n            raise ValueError(msg)\n    elif np.any(np.less(value, self.minimum)) or np.any(np.greater(value, self.maximum)):  # pyright: ignore[reportUnknownArgumentType]\n        msg = f\"A value in the sequence is not within the range [{self.minimum}, {self.maximum}]\"\n        raise ValueError(msg)\n    return True\n</code></pre>"},{"location":"schema/equipment/","title":"Equipment","text":""},{"location":"schema/equipment/#msl.equipment.schema.Equipment","title":"Equipment  <code>dataclass</code>","text":"<pre><code>Equipment(\n    entered_by: str = \"\",\n    checked_by: str = \"\",\n    checked_date: date | None = None,\n    alias: str = \"\",\n    keywords: tuple[str, ...] = (),\n    id: str = \"\",\n    manufacturer: str = \"\",\n    model: str = \"\",\n    serial: str = \"\",\n    description: str = \"\",\n    specifications: Specifications = Specifications(),\n    location: str = \"\",\n    status: Status = Active,\n    loggable: bool = False,\n    traceable: bool = False,\n    calibrations: tuple[Measurand, ...] = (),\n    maintenance: Maintenance = Maintenance(),\n    alterations: tuple[Alteration, ...] = (),\n    firmware: tuple[Firmware, ...] = (),\n    specified_requirements: SpecifiedRequirements = SpecifiedRequirements(),\n    reference_materials: ReferenceMaterials = ReferenceMaterials(),\n    quality_manual: QualityManual = QualityManual(),\n    connection: Connection | None = None,\n)\n</code></pre> <p>Represents the equipment element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>entered_by</code> <code>str</code> <p>The name of the person who initially entered the <code>&lt;equipment&gt;</code> element in the register.</p> <code>''</code> <code>checked_by</code> <code>str</code> <p>The name of the person who checked the information in the <code>&lt;equipment&gt;</code> element.</p> <code>''</code> <code>checked_date</code> <code>date | None</code> <p>The date that the information in the <code>&lt;equipment&gt;</code> element was last checked.</p> <code>None</code> <code>alias</code> <code>str</code> <p>An alternative name to associate with the equipment.</p> <code>''</code> <code>keywords</code> <code>tuple[str, ...]</code> <p>Keywords that describe the equipment.</p> <code>()</code> <code>id</code> <code>str</code> <p>Identity in an equipment register.</p> <code>''</code> <code>manufacturer</code> <code>str</code> <p>Name of manufacturer.</p> <code>''</code> <code>model</code> <code>str</code> <p>Manufacturer's model number (or type identification).</p> <code>''</code> <code>serial</code> <code>str</code> <p>Manufacturer's serial number (or other unique identification).</p> <code>''</code> <code>description</code> <code>str</code> <p>A short description about the equipment.</p> <code>''</code> <code>specifications</code> <code>Specifications</code> <p>Specifications provided by the manufacturer of the equipment.</p> <code>Specifications()</code> <code>location</code> <code>str</code> <p>The usual location (laboratory) that the equipment is found in.</p> <code>''</code> <code>status</code> <code>Status</code> <p>The status of the equipment is an indication of whether the equipment is active (in use) or inactive (not in use).</p> <code>Active</code> <code>loggable</code> <code>bool</code> <p>Whether measurements from the equipment should be logged. Equipment that monitor (for example) pressure, temperature or humidity of a laboratory environment are considered as loggable.</p> <code>False</code> <code>traceable</code> <code>bool</code> <p>Whether the equipment is used for a traceable measurement.</p> <code>False</code> <code>calibrations</code> <code>tuple[Measurand, ...]</code> <p>The calibration history.</p> <code>()</code> <code>maintenance</code> <code>Maintenance</code> <p>The maintenance history and maintenance plan.</p> <code>Maintenance()</code> <code>alterations</code> <code>tuple[Alteration, ...]</code> <p>The alteration history.</p> <code>()</code> <code>firmware</code> <code>tuple[Firmware, ...]</code> <p>The firmware version history.</p> <code>()</code> <code>specified_requirements</code> <code>SpecifiedRequirements</code> <p>Verification that equipment conforms with specified requirements before being placed or returned into service.</p> <code>SpecifiedRequirements()</code> <code>reference_materials</code> <code>ReferenceMaterials</code> <p>Documentation of reference materials, results, acceptance criteria, relevant dates and the period of validity.</p> <code>ReferenceMaterials()</code> <code>quality_manual</code> <code>QualityManual</code> <p>Information that is specified in Section 4.3.6 of the MSL Quality Manual.</p> <code>QualityManual()</code> <code>connection</code> <code>Connection | None</code> <p>The connection to the equipment for computer control.</p> <code>None</code>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.alias","title":"alias  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alias: str = ''\n</code></pre> <p>An alternative name to associate with the equipment.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.alterations","title":"alterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alterations: tuple[Alteration, ...] = ()\n</code></pre> <p>The alteration history.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.calibrations","title":"calibrations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>calibrations: tuple[Measurand, ...] = ()\n</code></pre> <p>The calibration history.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.checked_by","title":"checked_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_by: str = ''\n</code></pre> <p>The name of the person who checked the information in the <code>&lt;equipment&gt;</code> element.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.checked_date","title":"checked_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_date: date | None = None\n</code></pre> <p>The date that the information in the <code>&lt;equipment&gt;</code> element was last checked.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.connection","title":"connection  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>connection: Connection | None = None\n</code></pre> <p>The connection to use for computer control.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = ''\n</code></pre> <p>A short description about the equipment.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.entered_by","title":"entered_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entered_by: str = ''\n</code></pre> <p>The name of the person who initially entered the <code>&lt;equipment&gt;</code> element in the register.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.firmware","title":"firmware  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>firmware: tuple[Firmware, ...] = ()\n</code></pre> <p>The firmware version history.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = ''\n</code></pre> <p>Identity in an equipment register.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.keywords","title":"keywords  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keywords: tuple[str, ...] = ()\n</code></pre> <p>Keywords that describe the equipment.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.location","title":"location  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>location: str = ''\n</code></pre> <p>The usual location (laboratory) that the equipment is found in.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.loggable","title":"loggable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>loggable: bool = False\n</code></pre> <p>Whether measurements from the equipment should be logged.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.maintenance","title":"maintenance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>maintenance: Maintenance = field(\n    default_factory=Maintenance\n)\n</code></pre> <p>The maintenance history and maintenance plan.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.manufacturer","title":"manufacturer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>manufacturer: str = ''\n</code></pre> <p>Name of manufacturer.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.model","title":"model  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model: str = ''\n</code></pre> <p>Manufacturer's model number (or type identification).</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.quality_manual","title":"quality_manual  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quality_manual: QualityManual = field(\n    default_factory=QualityManual\n)\n</code></pre> <p>Information that is specified in Section 4.3.6 of the MSL Quality Manual.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.reference_materials","title":"reference_materials  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reference_materials: ReferenceMaterials = field(\n    default_factory=ReferenceMaterials\n)\n</code></pre> <p>Documentation of reference materials, results, acceptance criteria, relevant dates and the period of validity.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.serial","title":"serial  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>serial: str = ''\n</code></pre> <p>Manufacturer's serial number (or other unique identification).</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.specifications","title":"specifications  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>specifications: Specifications = field(\n    default_factory=Specifications\n)\n</code></pre> <p>Specifications provided by the manufacturer of the equipment.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.specified_requirements","title":"specified_requirements  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>specified_requirements: SpecifiedRequirements = field(\n    default_factory=SpecifiedRequirements\n)\n</code></pre> <p>Verification that equipment conforms with specified requirements before being placed or returned into service.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.status","title":"status  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>status: Status = Active\n</code></pre> <p>The status of the equipment is an indication of whether the equipment is active (in use) or inactive (not in use).</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.traceable","title":"traceable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traceable: bool = False\n</code></pre> <p>Whether the equipment is used for a traceable measurement.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.connect","title":"connect","text":"<pre><code>connect() -&gt; Any\n</code></pre> <p>Connect to the equipment for computer control.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def connect(self) -&gt; _Any:  # noqa: ANN401\n    \"\"\"Connect to the equipment for computer control.\"\"\"\n    if self.connection is None:\n        # Cannot simply call super(). Must specify (type, object) since the dataclass uses slots=True\n        super(Equipment, self).__setattr__(\"connection\", connections[self.id])  # noqa: UP008\n        assert self.connection is not None  # noqa: S101\n\n    for backend in backends:\n        if backend.handles(self.connection):\n            return backend.cls(self)\n\n    for resource in resources:\n        if resource.handles(self):\n            return resource.cls(self)\n\n    address = self.connection.address\n    for interface in interfaces:\n        if interface.handles(address):\n            return interface.cls(self)\n\n    msg = f\"Cannot determine the interface from the address {address!r}\"\n    raise ValueError(msg)\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Equipment\n</code></pre> <p>Convert an XML element into an Equipment instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An equipment XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Equipment</code> <p>The Equipment instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Equipment:\n    \"\"\"Convert an XML element into an [Equipment][msl.equipment.schema.Equipment] instance.\n\n    Args:\n        element: An [equipment][type_equipment] XML element from an equipment register.\n\n    Returns:\n        The [Equipment][msl.equipment.schema.Equipment] instance.\n    \"\"\"\n    # Schema forces order\n    a = element.attrib\n    return cls(\n        entered_by=a[\"enteredBy\"],\n        checked_by=a.get(\"checkedBy\", \"\"),\n        checked_date=None if not a.get(\"checkedDate\") else _date.fromisoformat(a[\"checkedDate\"]),\n        alias=a.get(\"alias\", \"\"),\n        keywords=tuple(a.get(\"keywords\", \"\").split()),\n        id=element[0].text or \"\",\n        manufacturer=element[1].text or \"\",\n        model=element[2].text or \"\",\n        serial=element[3].text or \"\",\n        description=element[4].text or \"\",\n        specifications=Specifications.from_xml(element[5]),\n        location=element[6].text or \"\",\n        status=Status(element[7].text),\n        loggable=element[8].text in {\"1\", \"true\"},\n        traceable=element[9].text in {\"1\", \"true\"},\n        calibrations=tuple(Measurand.from_xml(e) for e in element[10]),\n        maintenance=Maintenance.from_xml(element[11]),\n        alterations=tuple(Alteration.from_xml(e) for e in element[12]),\n        firmware=tuple(Firmware.from_xml(e) for e in element[13]),\n        specified_requirements=SpecifiedRequirements.from_xml(element[14]),\n        reference_materials=ReferenceMaterials.from_xml(element[15]),\n        quality_manual=QualityManual.from_xml(element[16]),\n    )\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.latest_performance_check","title":"latest_performance_check","text":"<pre><code>latest_performance_check(\n    *, quantity: str = \"\", name: str = \"\"\n) -&gt; LatestPerformanceCheck | None\n</code></pre> <p>Returns the latest performance check.</p> <p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>str</code> <p>The measurand quantity.</p> <code>''</code> <code>name</code> <code>str</code> <p>The component name.</p> <code>''</code> <p>Returns:</p> Type Description <code>LatestPerformanceCheck | None</code> <p>The LatestPerformanceCheck for the specified <code>quantity</code> and <code>name</code>. If the equipment has only one measurand and only one component then you do not need to specify a value for the <code>quantity</code> and <code>name</code>. Returns <code>None</code> if there are no performance checks that match the <code>quantity</code> and <code>name</code> criteria or if the equipment does not have performance checks entered in the register.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def latest_performance_check(self, *, quantity: str = \"\", name: str = \"\") -&gt; LatestPerformanceCheck | None:\n    \"\"\"Returns the latest performance check.\n\n    Args:\n        quantity: The measurand [quantity][msl.equipment.schema.Measurand.quantity].\n        name: The component [name][msl.equipment.schema.Component.name].\n\n    Returns:\n        The [LatestPerformanceCheck][msl.equipment.schema.LatestPerformanceCheck] for the specified\n            `quantity` and `name`. If the equipment has only one _measurand_ and only one _component_\n            then you do not need to specify a value for the `quantity` and `name`. Returns `None` if\n            there are no performance checks that match the `quantity` and `name` criteria or if\n            the equipment does not have performance checks entered in the register.\n    \"\"\"\n    return _latest(items=list(self.latest_performance_checks()), quantity=quantity, name=name)\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.latest_performance_checks","title":"latest_performance_checks","text":"<pre><code>latest_performance_checks() -&gt; (\n    Iterator[LatestPerformanceCheck]\n)\n</code></pre> <p>Yields the latest performance check for every measurand and component.</p> <p>Yields:</p> Type Description <code>LatestPerformanceCheck</code> <p>The latest performance check.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def latest_performance_checks(self) -&gt; Iterator[LatestPerformanceCheck]:\n    \"\"\"Yields the latest performance check for every _measurand_ and _component_.\n\n    Yields:\n        The latest performance check.\n    \"\"\"\n    default = _date(1875, 5, 20)\n    for m in self.calibrations:\n        for c in m.components:\n            latest = default\n            check: PerformanceCheck | None = None\n            for pc in c.performance_checks:\n                if pc.completed_date &gt; latest:\n                    check = pc\n                    latest = pc.completed_date\n\n            if check is not None:\n                yield LatestPerformanceCheck(\n                    calibration_interval=m.calibration_interval,\n                    name=c.name,\n                    next_calibration_date=_future_date(latest, m.calibration_interval),\n                    quantity=m.quantity,\n                    completed_date=check.completed_date,\n                    competency=check.competency,\n                    entered_by=check.entered_by,\n                    checked_by=check.checked_by,\n                    checked_date=check.checked_date,\n                    conditions=check.conditions,\n                    cvd_equations=check.cvd_equations,\n                    deserialisers=check.deserialisers,\n                    equations=check.equations,\n                    files=check.files,\n                    tables=check.tables,\n                )\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.latest_report","title":"latest_report","text":"<pre><code>latest_report(\n    *,\n    quantity: str = \"\",\n    name: str = \"\",\n    date: Literal[\"issue\", \"start\", \"stop\"] = \"stop\"\n) -&gt; LatestReport | None\n</code></pre> <p>Returns the latest calibration report.</p> <p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>str</code> <p>The measurand quantity.</p> <code>''</code> <code>name</code> <code>str</code> <p>The component name.</p> <code>''</code> <code>date</code> <code>Literal['issue', 'start', 'stop']</code> <p>Which date in a report to use to determine what latest refers to:</p> <ul> <li><code>issue</code>: Report issue date</li> <li><code>start</code>: Measurement start date</li> <li><code>stop</code>: Measurement stop date</li> </ul> <code>'stop'</code> <p>Returns:</p> Type Description <code>LatestReport | None</code> <p>The LatestReport for the specified <code>quantity</code> and <code>name</code>. If the equipment has only one measurand and only one component then you do not need to specify a value for the <code>quantity</code> and <code>name</code>. Returns <code>None</code> if there are no calibration reports that match the <code>quantity</code> and <code>name</code> criteria or if the equipment does not have calibration reports entered in the register.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def latest_report(\n    self, *, quantity: str = \"\", name: str = \"\", date: Literal[\"issue\", \"start\", \"stop\"] = \"stop\"\n) -&gt; LatestReport | None:\n    \"\"\"Returns the latest calibration report.\n\n    Args:\n        quantity: The measurand [quantity][msl.equipment.schema.Measurand.quantity].\n        name: The component [name][msl.equipment.schema.Component.name].\n        date: Which date in a report to use to determine what _latest_ refers to:\n\n            * `issue`: Report issue date\n            * `start`: Measurement start date\n            * `stop`: Measurement stop date\n\n    Returns:\n        The [LatestReport][msl.equipment.schema.LatestReport] for the specified `quantity` and `name`.\n            If the equipment has only one _measurand_ and only one _component_ then you do not need\n            to specify a value for the `quantity` and `name`. Returns `None` if there are no calibration\n            reports that match the `quantity` and `name` criteria or if the equipment does not have\n            calibration reports entered in the register.\n    \"\"\"\n    return _latest(items=list(self.latest_reports(date=date)), quantity=quantity, name=name)\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.latest_reports","title":"latest_reports","text":"<pre><code>latest_reports(\n    date: Literal[\"issue\", \"start\", \"stop\"] = \"stop\",\n) -&gt; Iterator[LatestReport]\n</code></pre> <p>Yields the latest calibration report for every measurand and component.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>Literal['issue', 'start', 'stop']</code> <p>Which date in a report to use to determine what latest refers to:</p> <ul> <li><code>issue</code>: Report issue date</li> <li><code>start</code>: Measurement start date</li> <li><code>stop</code>: Measurement stop date</li> </ul> <code>'stop'</code> <p>Yields:</p> Type Description <code>LatestReport</code> <p>The latest calibration report.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def latest_reports(self, date: Literal[\"issue\", \"start\", \"stop\"] = \"stop\") -&gt; Iterator[LatestReport]:\n    \"\"\"Yields the latest calibration report for every _measurand_ and _component_.\n\n    Args:\n        date: Which date in a report to use to determine what _latest_ refers to:\n\n            * `issue`: Report issue date\n            * `start`: Measurement start date\n            * `stop`: Measurement stop date\n\n    Yields:\n        The latest calibration report.\n    \"\"\"\n    default = _date(1875, 5, 20)\n    for m in self.calibrations:\n        for c in m.components:\n            latest = default\n            report: Report | None = None\n            for r in c.reports:\n                if date == \"stop\":\n                    if r.measurement_stop_date &gt; latest:\n                        report = r\n                        latest = r.measurement_stop_date\n                elif date == \"start\":\n                    if r.measurement_start_date &gt; latest:\n                        report = r\n                        latest = r.measurement_start_date\n                elif r.report_issue_date &gt; latest:\n                    report = r\n                    latest = r.report_issue_date\n\n            if report is not None:\n                yield LatestReport(\n                    calibration_interval=m.calibration_interval,\n                    name=c.name,\n                    next_calibration_date=_future_date(latest, m.calibration_interval),\n                    quantity=m.quantity,\n                    id=report.id,\n                    report_issue_date=report.report_issue_date,\n                    measurement_start_date=report.measurement_start_date,\n                    measurement_stop_date=report.measurement_stop_date,\n                    issuing_laboratory=report.issuing_laboratory,\n                    technical_procedure=report.technical_procedure,\n                    entered_by=report.entered_by,\n                    checked_by=report.checked_by,\n                    checked_date=report.checked_date,\n                    conditions=report.conditions,\n                    acceptance_criteria=report.acceptance_criteria,\n                    cvd_equations=report.cvd_equations,\n                    deserialisers=report.deserialisers,\n                    equations=report.equations,\n                    files=report.files,\n                    tables=report.tables,\n                )\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Equipment class into an XML element.</p> <p>The connection attribute is not included as an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Equipment as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Equipment][msl.equipment.schema.Equipment] class into an XML element.\n\n    The [connection][msl.equipment.schema.Equipment.connection] attribute is not included\n    as an XML element.\n\n    Returns:\n        The [Equipment][msl.equipment.schema.Equipment] as an XML element.\n    \"\"\"\n    a = {\"enteredBy\": self.entered_by}\n    if self.checked_by:\n        a[\"checkedBy\"] = self.checked_by\n    if self.checked_date is not None:\n        a[\"checkedDate\"] = self.checked_date.isoformat()\n    if self.alias:\n        a[\"alias\"] = self.alias\n    if self.keywords:\n        a[\"keywords\"] = \" \".join(self.keywords)\n\n    e = Element(\"equipment\", attrib=a)\n\n    _id = SubElement(e, \"id\")\n    _id.text = self.id\n\n    manufacturer = SubElement(e, \"manufacturer\")\n    manufacturer.text = self.manufacturer\n\n    model = SubElement(e, \"model\")\n    model.text = self.model\n\n    serial = SubElement(e, \"serial\")\n    serial.text = self.serial\n\n    description = SubElement(e, \"description\")\n    description.text = self.description\n\n    e.append(self.specifications)\n\n    location = SubElement(e, \"location\")\n    location.text = self.location\n\n    status = SubElement(e, \"status\")\n    status.text = self.status.value\n\n    loggable = SubElement(e, \"loggable\")\n    loggable.text = \"true\" if self.loggable else \"false\"\n\n    traceable = SubElement(e, \"traceable\")\n    traceable.text = \"true\" if self.traceable else \"false\"\n\n    calibrations = SubElement(e, \"calibrations\")\n    calibrations.extend(c.to_xml() for c in self.calibrations)\n\n    e.append(self.maintenance.to_xml())\n\n    alterations = SubElement(e, \"alterations\")\n    alterations.extend(a.to_xml() for a in self.alterations)\n\n    firmware = SubElement(e, \"firmware\")\n    firmware.extend(f.to_xml() for f in self.firmware)\n\n    e.append(self.specified_requirements)\n    e.append(self.reference_materials)\n    e.append(self.quality_manual.to_xml())\n    return e\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Latest","title":"Latest  <code>dataclass</code>","text":"<pre><code>Latest(\n    calibration_interval: float = 0.0,\n    name: str = \"\",\n    next_calibration_date: date = date(1875, 5, 20),\n    quantity: str = \"\",\n)\n</code></pre> <p>Base class for LatestReport and LatestPerformanceCheck.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Latest.calibration_interval","title":"calibration_interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>calibration_interval: float = 0.0\n</code></pre> <p>The number of years that may pass between a calibration or a performance check.</p> <p>For equipment that do not have a required and periodic interval, but are calibrated on demand, the value is <code>0</code>.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Latest.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = ''\n</code></pre> <p>The Component name.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Latest.next_calibration_date","title":"next_calibration_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_calibration_date: date = date(1875, 5, 20)\n</code></pre> <p>The date that the equipment is due for a re-calibration.</p> <p>If the calibration_interval is <code>0</code>, i.e., the equipment is calibrated on demand, this date is equal to the date that the equipment was last calibrated.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Latest.quantity","title":"quantity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quantity: str = ''\n</code></pre> <p>The Measurand quantity.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Latest.is_calibration_due","title":"is_calibration_due","text":"<pre><code>is_calibration_due(months: int = 0) -&gt; bool\n</code></pre> <p>Determine if the equipment needs to be re-calibrated.</p> <p>Parameters:</p> Name Type Description Default <code>months</code> <code>int</code> <p>The number of months to add to today's date to determine if the equipment needs to be re-calibrated.</p> <code>0</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether a calibration is due within the specified number of <code>months</code>.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def is_calibration_due(self, months: int = 0) -&gt; bool:\n    \"\"\"Determine if the equipment needs to be re-calibrated.\n\n    Args:\n        months: The number of months to add to today's date to determine if\n            the equipment needs to be re-calibrated.\n\n    Returns:\n        Whether a calibration is due within the specified number of `months`.\n    \"\"\"\n    if self.calibration_interval &lt;= 0:\n        return False  # calibrate on-demand\n\n    ask_date = _future_date(_date.today(), max(0.0, months / 12.0))  # noqa: DTZ011\n    return ask_date &gt;= self.next_calibration_date\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck","title":"LatestPerformanceCheck  <code>dataclass</code>","text":"<pre><code>LatestPerformanceCheck(\n    completed_date: date,\n    competency: Competency,\n    entered_by: str = \"\",\n    checked_by: str = \"\",\n    checked_date: date | None = None,\n    conditions: Conditions = Conditions(),\n    cvd_equations: tuple[CVDEquation, ...] = (),\n    deserialisers: tuple[Deserialised, ...] = (),\n    equations: tuple[Equation, ...] = (),\n    files: tuple[File, ...] = (),\n    tables: tuple[Table, ...] = (),\n    calibration_interval: float = 0.0,\n    name: str = \"\",\n    next_calibration_date: date = date(1875, 5, 20),\n    quantity: str = \"\",\n)\n</code></pre> <p>               Bases: <code>Latest</code>, <code>PerformanceCheck</code></p> <p>Latest performance check.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.calibration_interval","title":"calibration_interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>calibration_interval: float = 0.0\n</code></pre> <p>The number of years that may pass between a calibration or a performance check.</p> <p>For equipment that do not have a required and periodic interval, but are calibrated on demand, the value is <code>0</code>.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.checked_by","title":"checked_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_by: str = ''\n</code></pre> <p>The name of the person who checked the information in the <code>&lt;performanceCheck&gt;</code> element.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.checked_date","title":"checked_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_date: date | None = None\n</code></pre> <p>The date that the information in the <code>&lt;performanceCheck&gt;</code> element was last checked.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.competency","title":"competency  <code>instance-attribute</code>","text":"<pre><code>competency: Competency\n</code></pre> <p>The competent people who accomplished the performance check and the technical procedure that was executed.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.completed_date","title":"completed_date  <code>instance-attribute</code>","text":"<pre><code>completed_date: date\n</code></pre> <p>The date that the performance check was completed.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.conditions","title":"conditions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>conditions: Conditions = field(default_factory=Conditions)\n</code></pre> <p>The conditions under which the performance check is valid.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.cvd_equation","title":"cvd_equation  <code>property</code>","text":"<pre><code>cvd_equation: CVDEquation\n</code></pre> <p>Returns the first item in the cvd_equations tuple.</p> <p>Raises IndexError if the performance check does not contain Callendar-Van Dusen equations.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.cvd_equations","title":"cvd_equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cvd_equations: tuple[CVDEquation, ...] = ()\n</code></pre> <p>Performance-check data is expressed as Callendar-Van Dusen equations.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.deserialised","title":"deserialised  <code>property</code>","text":"<pre><code>deserialised: Deserialised\n</code></pre> <p>Returns the first item in the deserialisers tuple.</p> <p>Raises IndexError if the performance check does not contain serialised data.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.deserialisers","title":"deserialisers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>deserialisers: tuple[Deserialised, ...] = ()\n</code></pre> <p>Performance-check data is stored in serialised formats and deserialised.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.entered_by","title":"entered_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entered_by: str = ''\n</code></pre> <p>The name of the person who initially entered the <code>&lt;performanceCheck&gt;</code> element in the register.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.equation","title":"equation  <code>property</code>","text":"<pre><code>equation: Equation\n</code></pre> <p>Returns the first item in the equations tuple.</p> <p>Raises IndexError if the performance check does not contain equations.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.equations","title":"equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>equations: tuple[Equation, ...] = ()\n</code></pre> <p>Performance-check data is expressed as equations.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.file","title":"file  <code>property</code>","text":"<pre><code>file: File\n</code></pre> <p>Returns the first item in the files tuple.</p> <p>Raises IndexError if the performance check does not contain files.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.files","title":"files  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>files: tuple[File, ...] = ()\n</code></pre> <p>Performance-check data is stored in other files (not in the equipment register).</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = ''\n</code></pre> <p>The Component name.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.next_calibration_date","title":"next_calibration_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_calibration_date: date = date(1875, 5, 20)\n</code></pre> <p>The date that the equipment is due for a re-calibration.</p> <p>If the calibration_interval is <code>0</code>, i.e., the equipment is calibrated on demand, this date is equal to the date that the equipment was last calibrated.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.quantity","title":"quantity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quantity: str = ''\n</code></pre> <p>The Measurand quantity.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.table","title":"table  <code>property</code>","text":"<pre><code>table: Table\n</code></pre> <p>Returns the first item in the tables tuple.</p> <p>Raises IndexError if the performance check does not contain tables.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.tables","title":"tables  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tables: tuple[Table, ...] = ()\n</code></pre> <p>Performance-check data is stored as Comma Separated Values (CSV) tables.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; PerformanceCheck\n</code></pre> <p>Convert an XML element into a PerformanceCheck instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A performanceCheck XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>PerformanceCheck</code> <p>The PerformanceCheck instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; PerformanceCheck:\n    \"\"\"Convert an XML element into a [PerformanceCheck][msl.equipment.schema.PerformanceCheck] instance.\n\n    Args:\n        element: A [performanceCheck][type_performanceCheck] XML element from an\n            equipment register.\n\n    Returns:\n        The [PerformanceCheck][msl.equipment.schema.PerformanceCheck] instance.\n    \"\"\"\n    # Schema forces order for `competency` and `conditions` but uses xsd:choice,\n    # which allows sub-elements to appear (or not appear) in any order, for the data elements.\n    # Using str.endswith() allows for ignoring XML namespaces that may be associated with each tag\n    cvd_equations: list[CVDEquation] = []\n    equations: list[Equation] = []\n    files: list[File] = []\n    deserialisers: list[Deserialised] = []\n    tables: list[Table] = []\n    for child in element[2:]:\n        tag = child.tag\n        if tag.endswith(\"equation\"):\n            equations.append(Equation.from_xml(child))\n        elif tag.endswith(\"table\"):\n            tables.append(Table.from_xml(child))\n        elif tag.endswith(\"cvdCoefficients\"):\n            cvd_equations.append(CVDEquation.from_xml(child))\n        elif tag.endswith(\"file\"):\n            files.append(File.from_xml(child))\n        else:\n            deserialisers.append(Deserialised.from_xml(child))\n\n    a = element.attrib\n    return cls(\n        completed_date=_date.fromisoformat(a[\"completedDate\"] or \"\"),\n        entered_by=a[\"enteredBy\"] or \"\",\n        checked_by=a.get(\"checkedBy\", \"\"),\n        checked_date=None if not a.get(\"checkedDate\") else _date.fromisoformat(a[\"checkedDate\"]),\n        competency=Competency.from_xml(element[0]),\n        conditions=Conditions.from_xml(element[1]),\n        cvd_equations=tuple(cvd_equations),\n        deserialisers=tuple(deserialisers),\n        equations=tuple(equations),\n        files=tuple(files),\n        tables=tuple(tables),\n    )\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.is_calibration_due","title":"is_calibration_due","text":"<pre><code>is_calibration_due(months: int = 0) -&gt; bool\n</code></pre> <p>Determine if the equipment needs to be re-calibrated.</p> <p>Parameters:</p> Name Type Description Default <code>months</code> <code>int</code> <p>The number of months to add to today's date to determine if the equipment needs to be re-calibrated.</p> <code>0</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether a calibration is due within the specified number of <code>months</code>.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def is_calibration_due(self, months: int = 0) -&gt; bool:\n    \"\"\"Determine if the equipment needs to be re-calibrated.\n\n    Args:\n        months: The number of months to add to today's date to determine if\n            the equipment needs to be re-calibrated.\n\n    Returns:\n        Whether a calibration is due within the specified number of `months`.\n    \"\"\"\n    if self.calibration_interval &lt;= 0:\n        return False  # calibrate on-demand\n\n    ask_date = _future_date(_date.today(), max(0.0, months / 12.0))  # noqa: DTZ011\n    return ask_date &gt;= self.next_calibration_date\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the PerformanceCheck class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The PerformanceCheck as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [PerformanceCheck][msl.equipment.schema.PerformanceCheck] class into an XML element.\n\n    Returns:\n        The [PerformanceCheck][msl.equipment.schema.PerformanceCheck] as an XML element.\n    \"\"\"\n    a = {\"completedDate\": self.completed_date.isoformat(), \"enteredBy\": self.entered_by}\n    if self.checked_by:\n        a[\"checkedBy\"] = self.checked_by\n    if self.checked_date is not None:\n        a[\"checkedDate\"] = self.checked_date.isoformat()\n\n    e = Element(\"performanceCheck\", attrib=a)\n    e.append(self.competency.to_xml())\n    e.append(self.conditions)\n    e.extend(equation.to_xml() for equation in self.equations)\n    e.extend(table.to_xml() for table in self.tables)\n    e.extend(cvd.to_xml() for cvd in self.cvd_equations)\n    e.extend(file.to_xml() for file in self.files)\n    e.extend(deserialised.to_xml() for deserialised in self.deserialisers)\n    return e\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport","title":"LatestReport  <code>dataclass</code>","text":"<pre><code>LatestReport(\n    id: str,\n    report_issue_date: date,\n    measurement_start_date: date,\n    measurement_stop_date: date,\n    issuing_laboratory: IssuingLaboratory = IssuingLaboratory(),\n    technical_procedure: str = \"\",\n    entered_by: str = \"\",\n    checked_by: str = \"\",\n    checked_date: date | None = None,\n    conditions: Conditions = Conditions(),\n    acceptance_criteria: AcceptanceCriteria = AcceptanceCriteria(),\n    cvd_equations: tuple[CVDEquation, ...] = (),\n    deserialisers: tuple[Deserialised, ...] = (),\n    equations: tuple[Equation, ...] = (),\n    files: tuple[File, ...] = (),\n    tables: tuple[Table, ...] = (),\n    calibration_interval: float = 0.0,\n    name: str = \"\",\n    next_calibration_date: date = date(1875, 5, 20),\n    quantity: str = \"\",\n)\n</code></pre> <p>               Bases: <code>Latest</code>, <code>Report</code></p> <p>Latest calibration report.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.acceptance_criteria","title":"acceptance_criteria  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acceptance_criteria: AcceptanceCriteria = field(\n    default_factory=AcceptanceCriteria\n)\n</code></pre> <p>Acceptance criteria for the calibration report.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.calibration_interval","title":"calibration_interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>calibration_interval: float = 0.0\n</code></pre> <p>The number of years that may pass between a calibration or a performance check.</p> <p>For equipment that do not have a required and periodic interval, but are calibrated on demand, the value is <code>0</code>.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.checked_by","title":"checked_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_by: str = ''\n</code></pre> <p>The name of the person who checked the information in the <code>&lt;report&gt;</code> element.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.checked_date","title":"checked_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_date: date | None = None\n</code></pre> <p>The date that the information in the <code>&lt;report&gt;</code> element was last checked.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.conditions","title":"conditions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>conditions: Conditions = field(default_factory=Conditions)\n</code></pre> <p>The conditions under which the report is valid.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.cvd_equation","title":"cvd_equation  <code>property</code>","text":"<pre><code>cvd_equation: CVDEquation\n</code></pre> <p>Returns the first item in the cvd_equations tuple.</p> <p>Raises IndexError if the report does not contain Callendar-Van Dusen equations.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.cvd_equations","title":"cvd_equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cvd_equations: tuple[CVDEquation, ...] = ()\n</code></pre> <p>Calibration data is expressed as Callendar-Van Dusen equations.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.deserialised","title":"deserialised  <code>property</code>","text":"<pre><code>deserialised: Deserialised\n</code></pre> <p>Returns the first item in the deserialisers tuple.</p> <p>Raises IndexError if the report does not contain serialised data.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.deserialisers","title":"deserialisers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>deserialisers: tuple[Deserialised, ...] = ()\n</code></pre> <p>Calibration data is stored in serialised formats and deserialised.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.entered_by","title":"entered_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entered_by: str = ''\n</code></pre> <p>The name of the person who initially entered the <code>&lt;report&gt;</code> element in the register.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.equation","title":"equation  <code>property</code>","text":"<pre><code>equation: Equation\n</code></pre> <p>Returns the first item in the equations tuple.</p> <p>Raises IndexError if the report does not contain equations.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.equations","title":"equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>equations: tuple[Equation, ...] = ()\n</code></pre> <p>Calibration data is expressed as equations.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.file","title":"file  <code>property</code>","text":"<pre><code>file: File\n</code></pre> <p>Returns the first item in the files tuple.</p> <p>Raises IndexError if the report does not contain files.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.files","title":"files  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>files: tuple[File, ...] = ()\n</code></pre> <p>Calibration data is stored in other files (not in the equipment register).</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>The report identification number.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.issuing_laboratory","title":"issuing_laboratory  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>issuing_laboratory: IssuingLaboratory = field(\n    default_factory=IssuingLaboratory\n)\n</code></pre> <p>Information about the laboratory that issued the calibration report.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.measurement_start_date","title":"measurement_start_date  <code>instance-attribute</code>","text":"<pre><code>measurement_start_date: date\n</code></pre> <p>The date that the calibration measurement started.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.measurement_stop_date","title":"measurement_stop_date  <code>instance-attribute</code>","text":"<pre><code>measurement_stop_date: date\n</code></pre> <p>The date that the calibration measurement stopped.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = ''\n</code></pre> <p>The Component name.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.next_calibration_date","title":"next_calibration_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_calibration_date: date = date(1875, 5, 20)\n</code></pre> <p>The date that the equipment is due for a re-calibration.</p> <p>If the calibration_interval is <code>0</code>, i.e., the equipment is calibrated on demand, this date is equal to the date that the equipment was last calibrated.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.quantity","title":"quantity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quantity: str = ''\n</code></pre> <p>The Measurand quantity.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.report_issue_date","title":"report_issue_date  <code>instance-attribute</code>","text":"<pre><code>report_issue_date: date\n</code></pre> <p>The date that the report was issued.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.table","title":"table  <code>property</code>","text":"<pre><code>table: Table\n</code></pre> <p>Returns the first item in the tables tuple.</p> <p>Raises IndexError if the report does not contain tables.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.tables","title":"tables  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tables: tuple[Table, ...] = ()\n</code></pre> <p>Calibration data is stored as Comma Separated Values (CSV) tables.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.technical_procedure","title":"technical_procedure  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>technical_procedure: str = ''\n</code></pre> <p>The technical procedure(s) that was(were) followed to perform the calibration.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Report\n</code></pre> <p>Convert an XML element into a Report instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A report XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Report</code> <p>The Report instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Report:\n    \"\"\"Convert an XML element into a [Report][msl.equipment.schema.Report] instance.\n\n    Args:\n        element: A [report][type_report] XML element from an equipment register.\n\n    Returns:\n        The [Report][msl.equipment.schema.Report] instance.\n    \"\"\"\n    # Schema forces order until `acceptanceCriteria` and then uses xsd:choice, which\n    # allows sub-elements to appear (or not appear) in any order, for the data elements.\n    # Using str.endswith() allows for ignoring XML namespaces that may be associated with each tag\n    cvd_equations: list[CVDEquation] = []\n    deserialisers: list[Deserialised] = []\n    equations: list[Equation] = []\n    files: list[File] = []\n    tables: list[Table] = []\n    for child in element[7:]:\n        tag = child.tag\n        if tag.endswith(\"equation\"):\n            equations.append(Equation.from_xml(child))\n        elif tag.endswith(\"table\"):\n            tables.append(Table.from_xml(child))\n        elif tag.endswith(\"cvdCoefficients\"):\n            cvd_equations.append(CVDEquation.from_xml(child))\n        elif tag.endswith(\"file\"):\n            files.append(File.from_xml(child))\n        else:\n            deserialisers.append(Deserialised.from_xml(child))\n\n    a = element.attrib\n    return cls(\n        id=a[\"id\"] or \"\",\n        entered_by=a[\"enteredBy\"] or \"\",\n        checked_by=a.get(\"checkedBy\", \"\"),\n        checked_date=None if not a.get(\"checkedDate\") else _date.fromisoformat(a[\"checkedDate\"]),\n        report_issue_date=_date.fromisoformat(element[0].text or \"\"),\n        measurement_start_date=_date.fromisoformat(element[1].text or \"\"),\n        measurement_stop_date=_date.fromisoformat(element[2].text or \"\"),\n        issuing_laboratory=IssuingLaboratory.from_xml(element[3]),\n        technical_procedure=element[4].text or \"\",\n        conditions=Conditions.from_xml(element[5]),\n        acceptance_criteria=AcceptanceCriteria.from_xml(element[6]),\n        cvd_equations=tuple(cvd_equations),\n        deserialisers=tuple(deserialisers),\n        equations=tuple(equations),\n        files=tuple(files),\n        tables=tuple(tables),\n    )\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.is_calibration_due","title":"is_calibration_due","text":"<pre><code>is_calibration_due(months: int = 0) -&gt; bool\n</code></pre> <p>Determine if the equipment needs to be re-calibrated.</p> <p>Parameters:</p> Name Type Description Default <code>months</code> <code>int</code> <p>The number of months to add to today's date to determine if the equipment needs to be re-calibrated.</p> <code>0</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether a calibration is due within the specified number of <code>months</code>.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def is_calibration_due(self, months: int = 0) -&gt; bool:\n    \"\"\"Determine if the equipment needs to be re-calibrated.\n\n    Args:\n        months: The number of months to add to today's date to determine if\n            the equipment needs to be re-calibrated.\n\n    Returns:\n        Whether a calibration is due within the specified number of `months`.\n    \"\"\"\n    if self.calibration_interval &lt;= 0:\n        return False  # calibrate on-demand\n\n    ask_date = _future_date(_date.today(), max(0.0, months / 12.0))  # noqa: DTZ011\n    return ask_date &gt;= self.next_calibration_date\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Report class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Report as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Report][msl.equipment.schema.Report] class into an XML element.\n\n    Returns:\n        The [Report][msl.equipment.schema.Report] as an XML element.\n    \"\"\"\n    a = {\"id\": self.id, \"enteredBy\": self.entered_by}\n    if self.checked_by:\n        a[\"checkedBy\"] = self.checked_by\n    if self.checked_date is not None:\n        a[\"checkedDate\"] = self.checked_date.isoformat()\n\n    e = Element(\"report\", attrib=a)\n\n    rid = SubElement(e, \"reportIssueDate\")\n    rid.text = self.report_issue_date.isoformat()\n\n    start = SubElement(e, \"measurementStartDate\")\n    start.text = self.measurement_start_date.isoformat()\n\n    stop = SubElement(e, \"measurementStopDate\")\n    stop.text = self.measurement_stop_date.isoformat()\n\n    e.append(self.issuing_laboratory.to_xml())\n\n    tp = SubElement(e, \"technicalProcedure\")\n    tp.text = self.technical_procedure\n\n    e.append(self.conditions)\n    e.append(self.acceptance_criteria)\n    e.extend(equation.to_xml() for equation in self.equations)\n    e.extend(table.to_xml() for table in self.tables)\n    e.extend(cvd.to_xml() for cvd in self.cvd_equations)\n    e.extend(file.to_xml() for file in self.files)\n    e.extend(deserialised.to_xml() for deserialised in self.deserialisers)\n    return e\n</code></pre>"},{"location":"schema/file/","title":"File","text":"<p>Suppose you have a variable named <code>file</code> (which is an instance of File) that represents the following information in an equipment register for data that is stored in a Spreadsheet</p> <pre><code>&lt;file comment=\"FEL T647\"&gt;\n  &lt;url sheet=\"2024-May\" cells=\"A1:C11\"&gt;tests\\resources\\irradiance.xlsx&lt;/url&gt;\n  &lt;sha256&gt;7a91267cfb529388a99762b891ee4b7a12463e83b5d55809f76a0c8e76c71886&lt;/sha256&gt;\n&lt;/file&gt;\n</code></pre> <p>You can access sha256 and comment as attributes of <code>file</code></p> <pre><code>&gt;&gt;&gt; file.sha256\n'7a91267cfb529388a99762b891ee4b7a12463e83b5d55809f76a0c8e76c71886'\n&gt;&gt;&gt; file.comment\n'FEL T647'\n</code></pre> <p>The url and attributes attributes of <code>file</code> can be used with the read_table function of msl-io to read the Spreadsheet data</p> <pre><code>&gt;&gt;&gt; from msl.io import read_table\n&gt;&gt;&gt; table = read_table(file.url, **file.attributes)\n&gt;&gt;&gt; print(table.metadata.header)\n['Wavelength' 'Irradiance' 'u(Irradiance)']\n&gt;&gt;&gt; table\n&lt;Dataset 'irradiance.xlsx' shape=(10, 3) dtype='&lt;f8' (1 metadata)&gt;\n&gt;&gt;&gt; print(table)\narray([[2.500000e+02, 1.818000e-02, 2.033000e-02],\n       [3.000000e+02, 1.847800e-01, 1.755000e-02],\n       [3.500000e+02, 8.084500e-01, 1.606000e-02],\n       [4.000000e+02, 2.213550e+00, 1.405000e-02],\n       [4.500000e+02, 4.490040e+00, 1.250000e-02],\n       [5.000000e+02, 7.451350e+00, 1.200000e-02],\n       [5.500000e+02, 1.075753e+01, 1.152000e-02],\n       [6.000000e+02, 1.403809e+01, 1.102000e-02],\n       [6.500000e+02, 1.699469e+01, 1.103000e-02],\n       [7.000000e+02, 1.944093e+01, 1.077000e-02]])\n</code></pre> <p>Note</p> <p>Passing <code>**file.attributes</code> to read_table works as expected provided that the XML attributes of the <code>&lt;url&gt;</code> element are valid keyword arguments to read_table. See Read a table for more examples from msl-io, in particular, specifying <code>dtype=\"header\"</code> will return a structured dataset which would behave similar to the Table example in <code>msl-equipment</code> (i.e., accessing columns by header name).</p>"},{"location":"schema/file/#msl.equipment.schema.File","title":"File  <code>dataclass</code>","text":"<pre><code>File(\n    url: str,\n    sha256: str,\n    attributes: dict[str, str] = dict(),\n    comment: str = \"\",\n)\n</code></pre> <p>Represents the file element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The location of the file. The syntax follows RFC 1738 <code>scheme:scheme-specific-part</code>. If <code>scheme:</code> is not specified, it is assumed to be <code>file:</code>.</p> required <code>sha256</code> <code>str</code> <p>The SHA-256 checksum of the file.</p> required <code>attributes</code> <code>dict[str, str]</code> <p>XML attributes associated with the <code>&lt;url&gt;</code> element.</p> <code>dict()</code> <code>comment</code> <code>str</code> <p>A comment to associate with the file.</p> <code>''</code>"},{"location":"schema/file/#msl.equipment.schema.File.attributes","title":"attributes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attributes: dict[str, str] = field(default_factory=dict)\n</code></pre> <p>XML attributes associated with the <code>&lt;url&gt;</code> element.</p>"},{"location":"schema/file/#msl.equipment.schema.File.comment","title":"comment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comment: str = ''\n</code></pre> <p>A comment associated with the file.</p>"},{"location":"schema/file/#msl.equipment.schema.File.scheme","title":"scheme  <code>property</code>","text":"<pre><code>scheme: str\n</code></pre> <p>Returns the scheme component that is specified in the url (see RFC 1738 for more details).</p> <p>If a <code>&lt;scheme&gt;</code> is not specified, an empty string is returned (which shall be treated as the <code>file</code> scheme). Drive letters on Windows are not considered as a scheme.</p>"},{"location":"schema/file/#msl.equipment.schema.File.sha256","title":"sha256  <code>instance-attribute</code>","text":"<pre><code>sha256: str\n</code></pre> <p>The SHA-256 checksum of the file.</p>"},{"location":"schema/file/#msl.equipment.schema.File.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: str\n</code></pre> <p>The location of the file.</p> <p>The syntax follows RFC 1738 <code>&lt;scheme&gt;:&lt;scheme-specific-part&gt;</code>. If <code>&lt;scheme&gt;</code> is not specified, it shall be treated as the <code>file</code> scheme (see also scheme).</p>"},{"location":"schema/file/#msl.equipment.schema.File.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; File\n</code></pre> <p>Convert an XML element into a File instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A file XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>File</code> <p>The File instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; File:\n    \"\"\"Convert an XML element into a [File][msl.equipment.schema.File] instance.\n\n    Args:\n        element: A [file][type_file] XML element from an equipment register.\n\n    Returns:\n        The [File][msl.equipment.schema.File] instance.\n    \"\"\"\n    # Schema forces order\n    return cls(\n        url=element[0].text or \"\",\n        sha256=element[1].text or \"\",\n        attributes=element[0].attrib,\n        comment=element.attrib.get(\"comment\", \"\"),\n    )\n</code></pre>"},{"location":"schema/file/#msl.equipment.schema.File.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the File class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The File as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [File][msl.equipment.schema.File] class into an XML element.\n\n    Returns:\n        The [File][msl.equipment.schema.File] as an XML element.\n    \"\"\"\n    attrib = {\"comment\": self.comment} if self.comment else {}\n    e = Element(\"file\", attrib=attrib)\n    url = SubElement(e, \"url\", attrib=self.attributes)\n    url.text = self.url\n    sha256 = SubElement(e, \"sha256\")\n    sha256.text = self.sha256\n    return e\n</code></pre>"},{"location":"schema/financial/","title":"Financial","text":""},{"location":"schema/financial/#msl.equipment.schema.Financial","title":"Financial  <code>dataclass</code>","text":"<pre><code>Financial(\n    capital_expenditure: CapitalExpenditure | None = None,\n    purchase_year: int = 0,\n    warranty_expiration_date: date | None = None,\n)\n</code></pre> <p>Represents the financial element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>capital_expenditure</code> <code>CapitalExpenditure | None</code> <p>The equipment is a capital expenditure.</p> <code>None</code> <code>purchase_year</code> <code>int</code> <p>The (approximate) year that the equipment was purchased. A value of <code>0</code> represents that the year is unknown.</p> <code>0</code> <code>warranty_expiration_date</code> <code>date | None</code> <p>Approximate date that the warranty expires.</p> <code>None</code>"},{"location":"schema/financial/#msl.equipment.schema.Financial.capital_expenditure","title":"capital_expenditure  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>capital_expenditure: CapitalExpenditure | None = None\n</code></pre> <p>The equipment is a capital expenditure.</p>"},{"location":"schema/financial/#msl.equipment.schema.Financial.purchase_year","title":"purchase_year  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>purchase_year: int = 0\n</code></pre> <p>The (approximate) year that the equipment was purchased. A value of <code>0</code> represents that the year is unknown.</p>"},{"location":"schema/financial/#msl.equipment.schema.Financial.warranty_expiration_date","title":"warranty_expiration_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>warranty_expiration_date: date | None = None\n</code></pre> <p>Approximate date that the warranty expires.</p>"},{"location":"schema/financial/#msl.equipment.schema.Financial.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Financial\n</code></pre> <p>Convert an XML element into a Financial instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A financial XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Financial</code> <p>The Financial instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Financial:\n    \"\"\"Convert an XML element into a [Financial][msl.equipment.schema.Financial] instance.\n\n    Args:\n        element: A [financial][type_financial] XML element from an equipment register.\n\n    Returns:\n        The [Financial][msl.equipment.schema.Financial] instance.\n    \"\"\"\n    # Schema defines &lt;financial&gt; using xsd:all, which allows sub-elements to appear (or not appear) in any order\n    # Using str.endswith() allows for ignoring XML namespaces that may be associated with each tag\n    cap_ex, warranty, year = None, None, 0\n    for child in element:\n        if child.tag.endswith(\"capitalExpenditure\"):\n            cap_ex = CapitalExpenditure.from_xml(child)\n        elif child.tag.endswith(\"warrantyExpirationDate\"):\n            warranty = _date.fromisoformat(child.text or \"\")\n        else:\n            year = int(child.text or 0)\n    return cls(capital_expenditure=cap_ex, purchase_year=year, warranty_expiration_date=warranty)\n</code></pre>"},{"location":"schema/financial/#msl.equipment.schema.Financial.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Financial class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Financial as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Financial][msl.equipment.schema.Financial] class into an XML element.\n\n    Returns:\n        The [Financial][msl.equipment.schema.Financial] as an XML element.\n    \"\"\"\n    e = Element(\"financial\")\n\n    if self.capital_expenditure is not None:\n        e.append(self.capital_expenditure.to_xml())\n\n    if self.purchase_year &gt; 0:\n        py = SubElement(e, \"purchaseYear\")\n        py.text = str(self.purchase_year)\n\n    if self.warranty_expiration_date is not None:\n        wed = SubElement(e, \"warrantyExpirationDate\")\n        wed.text = self.warranty_expiration_date.isoformat()\n\n    return e\n</code></pre>"},{"location":"schema/firmware/","title":"Firmware","text":""},{"location":"schema/firmware/#msl.equipment.schema.Firmware","title":"Firmware  <code>dataclass</code>","text":"<pre><code>Firmware(version: str, date: date)\n</code></pre> <p>Represents a firmware <code>&lt;version&gt;</code> sub-element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>Firmware version number.</p> required <code>date</code> <code>date</code> <p>The date that the firmware was initially at or changed to <code>version</code>.</p> required"},{"location":"schema/firmware/#msl.equipment.schema.Firmware.date","title":"date  <code>instance-attribute</code>","text":"<pre><code>date: date\n</code></pre> <p>The date that the firmware was initially at or changed to <code>version</code>.</p>"},{"location":"schema/firmware/#msl.equipment.schema.Firmware.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str\n</code></pre> <p>Firmware version number.</p>"},{"location":"schema/firmware/#msl.equipment.schema.Firmware.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Firmware\n</code></pre> <p>Convert an XML element into a Firmware instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A firmware <code>&lt;version&gt;</code> XML sub-element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Firmware</code> <p>The Firmware instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Firmware:\n    \"\"\"Convert an XML element into a [Firmware][msl.equipment.schema.Firmware] instance.\n\n    Args:\n        element: A [firmware][type_firmware] `&lt;version&gt;` XML sub-element\n            from an equipment register.\n\n    Returns:\n        The [Firmware][msl.equipment.schema.Firmware] instance.\n    \"\"\"\n    return cls(version=element.text or \"\", date=_date.fromisoformat(element.attrib[\"date\"]))\n</code></pre>"},{"location":"schema/firmware/#msl.equipment.schema.Firmware.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Firmware class into a <code>&lt;version&gt;</code> XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Firmware as a <code>&lt;version&gt;</code> XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Firmware][msl.equipment.schema.Firmware] class into a `&lt;version&gt;` XML element.\n\n    Returns:\n        The [Firmware][msl.equipment.schema.Firmware] as a `&lt;version&gt;` XML element.\n    \"\"\"\n    e = Element(\"version\", attrib={\"date\": self.date.isoformat()})\n    e.text = self.version\n    return e\n</code></pre>"},{"location":"schema/maintenance/","title":"Maintenance","text":""},{"location":"schema/maintenance/#msl.equipment.schema.Maintenance","title":"Maintenance  <code>dataclass</code>","text":"<pre><code>Maintenance(\n    planned: tuple[PlannedTask, ...] = (),\n    completed: tuple[CompletedTask, ...] = (),\n)\n</code></pre> <p>Represents the maintenance element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>planned</code> <code>tuple[PlannedTask, ...]</code> <p>Maintenance tasks that are planned to be performed.</p> <code>()</code> <code>completed</code> <code>tuple[CompletedTask, ...]</code> <p>Maintenance tasks that have been completed.</p> <code>()</code>"},{"location":"schema/maintenance/#msl.equipment.schema.Maintenance.completed","title":"completed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>completed: tuple[CompletedTask, ...] = ()\n</code></pre> <p>Maintenance tasks that have been completed.</p>"},{"location":"schema/maintenance/#msl.equipment.schema.Maintenance.planned","title":"planned  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>planned: tuple[PlannedTask, ...] = ()\n</code></pre> <p>Maintenance tasks that are planned to be performed.</p>"},{"location":"schema/maintenance/#msl.equipment.schema.Maintenance.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Maintenance\n</code></pre> <p>Convert an XML element into a Maintenance instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A maintenance XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Maintenance</code> <p>The Maintenance instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Maintenance:\n    \"\"\"Convert an XML element into a [Maintenance][msl.equipment.schema.Maintenance] instance.\n\n    Args:\n        element: A [maintenance][type_maintenance] XML element from an equipment register.\n\n    Returns:\n        The [Maintenance][msl.equipment.schema.Maintenance] instance.\n    \"\"\"\n    if len(element) == 0:\n        return cls()\n\n    # Schema forces order, planned tasks then completed tasks (and both sub-elements must exist)\n    return cls(\n        planned=tuple(PlannedTask.from_xml(e) for e in element[0]),\n        completed=tuple(CompletedTask.from_xml(e) for e in element[1]),\n    )\n</code></pre>"},{"location":"schema/maintenance/#msl.equipment.schema.Maintenance.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Maintenance class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Maintenance as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Maintenance][msl.equipment.schema.Maintenance] class into an XML element.\n\n    Returns:\n        The [Maintenance][msl.equipment.schema.Maintenance] as an XML element.\n    \"\"\"\n    e = Element(\"maintenance\")\n    if not (self.planned or self.completed):\n        return e  # no maintenance plan\n\n    # planned must come before completed\n    planned = SubElement(e, \"planned\")\n    planned.extend(p.to_xml() for p in self.planned)\n    completed = SubElement(e, \"completed\")\n    completed.extend(c.to_xml() for c in self.completed)\n    return e\n</code></pre>"},{"location":"schema/measurand/","title":"Measurand","text":""},{"location":"schema/measurand/#msl.equipment.schema.Measurand","title":"Measurand  <code>dataclass</code>","text":"<pre><code>Measurand(\n    quantity: str,\n    calibration_interval: float,\n    components: tuple[Component, ...] = (),\n)\n</code></pre> <p>Represents the measurand element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>str</code> <p>The kind of quantity that is measured.</p> required <code>calibration_interval</code> <code>float</code> <p>The number of years that may pass between a calibration or a performance check. For equipment that do not have a required and periodic interval, but are calibrated on demand, set the value to <code>0</code>.</p> required <code>components</code> <code>tuple[Component, ...]</code> <p>The components of the equipment that measure the <code>quantity</code>.</p> <code>()</code>"},{"location":"schema/measurand/#msl.equipment.schema.Measurand.calibration_interval","title":"calibration_interval  <code>instance-attribute</code>","text":"<pre><code>calibration_interval: float\n</code></pre> <p>The number of years that may pass between a calibration or a performance check.</p> <p>For equipment that do not have a required and periodic interval, but are calibrated on demand, the value is <code>0</code>.</p>"},{"location":"schema/measurand/#msl.equipment.schema.Measurand.components","title":"components  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>components: tuple[Component, ...] = ()\n</code></pre> <p>The components of the equipment that measure the <code>quantity</code>.</p>"},{"location":"schema/measurand/#msl.equipment.schema.Measurand.quantity","title":"quantity  <code>instance-attribute</code>","text":"<pre><code>quantity: str\n</code></pre> <p>The kind of quantity that is measured.</p>"},{"location":"schema/measurand/#msl.equipment.schema.Measurand.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Measurand\n</code></pre> <p>Convert an XML element into a Measurand instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A measurand XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Measurand</code> <p>The Measurand instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Measurand:\n    \"\"\"Convert an XML element into a [Measurand][msl.equipment.schema.Measurand] instance.\n\n    Args:\n        element: A [measurand][type_measurand] XML element from an equipment register.\n\n    Returns:\n        The [Measurand][msl.equipment.schema.Measurand] instance.\n    \"\"\"\n    return cls(\n        quantity=element.attrib[\"quantity\"],\n        calibration_interval=float(element.attrib[\"calibrationInterval\"]),\n        components=tuple(Component.from_xml(c) for c in element),\n    )\n</code></pre>"},{"location":"schema/measurand/#msl.equipment.schema.Measurand.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Measurand class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Measurand as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Measurand][msl.equipment.schema.Measurand] class into an XML element.\n\n    Returns:\n        The [Measurand][msl.equipment.schema.Measurand] as an XML element.\n    \"\"\"\n    attrib = {\"quantity\": self.quantity, \"calibrationInterval\": str(self.calibration_interval)}\n    e = Element(\"measurand\", attrib=attrib)\n    e.extend(c.to_xml() for c in self.components)\n    return e\n</code></pre>"},{"location":"schema/performance_check/","title":"PerformanceCheck","text":""},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck","title":"PerformanceCheck  <code>dataclass</code>","text":"<pre><code>PerformanceCheck(\n    completed_date: date,\n    competency: Competency,\n    entered_by: str = \"\",\n    checked_by: str = \"\",\n    checked_date: date | None = None,\n    conditions: Conditions = Conditions(),\n    cvd_equations: tuple[CVDEquation, ...] = (),\n    deserialisers: tuple[Deserialised, ...] = (),\n    equations: tuple[Equation, ...] = (),\n    files: tuple[File, ...] = (),\n    tables: tuple[Table, ...] = (),\n)\n</code></pre> <p>Represents the performanceCheck element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>completed_date</code> <code>date</code> <p>The date that the performance check was completed.</p> required <code>competency</code> <code>Competency</code> <p>The competent people who accomplished the performance check and the technical procedure that was executed.</p> required <code>entered_by</code> <code>str</code> <p>The name of the person who initially entered the <code>&lt;performanceCheck&gt;</code> element in the register.</p> <code>''</code> <code>checked_by</code> <code>str</code> <p>The name of the person who checked the information in the <code>&lt;performanceCheck&gt;</code> element.</p> <code>''</code> <code>checked_date</code> <code>date | None</code> <p>The date that the information in the <code>&lt;performanceCheck&gt;</code> element was last checked.</p> <code>None</code> <code>conditions</code> <code>Conditions</code> <p>The conditions under which the performance check is valid.</p> <code>Conditions()</code> <code>cvd_equations</code> <code>tuple[CVDEquation, ...]</code> <p>Performance-check data is expressed as Callendar-Van Dusen equations.</p> <code>()</code> <code>deserialisers</code> <code>tuple[Deserialised, ...]</code> <p>Performance-check data is stored in serialised formats and deserialised.</p> <code>()</code> <code>equations</code> <code>tuple[Equation, ...]</code> <p>Performance-check data is expressed as equations.</p> <code>()</code> <code>files</code> <code>tuple[File, ...]</code> <p>Performance-check data is stored in other files (not in the equipment register).</p> <code>()</code> <code>tables</code> <code>tuple[Table, ...]</code> <p>Performance-check data is stored as Comma Separated Values (CSV) tables.</p> <code>()</code>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.checked_by","title":"checked_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_by: str = ''\n</code></pre> <p>The name of the person who checked the information in the <code>&lt;performanceCheck&gt;</code> element.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.checked_date","title":"checked_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_date: date | None = None\n</code></pre> <p>The date that the information in the <code>&lt;performanceCheck&gt;</code> element was last checked.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.competency","title":"competency  <code>instance-attribute</code>","text":"<pre><code>competency: Competency\n</code></pre> <p>The competent people who accomplished the performance check and the technical procedure that was executed.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.completed_date","title":"completed_date  <code>instance-attribute</code>","text":"<pre><code>completed_date: date\n</code></pre> <p>The date that the performance check was completed.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.conditions","title":"conditions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>conditions: Conditions = field(default_factory=Conditions)\n</code></pre> <p>The conditions under which the performance check is valid.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.cvd_equation","title":"cvd_equation  <code>property</code>","text":"<pre><code>cvd_equation: CVDEquation\n</code></pre> <p>Returns the first item in the cvd_equations tuple.</p> <p>Raises IndexError if the performance check does not contain Callendar-Van Dusen equations.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.cvd_equations","title":"cvd_equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cvd_equations: tuple[CVDEquation, ...] = ()\n</code></pre> <p>Performance-check data is expressed as Callendar-Van Dusen equations.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.deserialised","title":"deserialised  <code>property</code>","text":"<pre><code>deserialised: Deserialised\n</code></pre> <p>Returns the first item in the deserialisers tuple.</p> <p>Raises IndexError if the performance check does not contain serialised data.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.deserialisers","title":"deserialisers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>deserialisers: tuple[Deserialised, ...] = ()\n</code></pre> <p>Performance-check data is stored in serialised formats and deserialised.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.entered_by","title":"entered_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entered_by: str = ''\n</code></pre> <p>The name of the person who initially entered the <code>&lt;performanceCheck&gt;</code> element in the register.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.equation","title":"equation  <code>property</code>","text":"<pre><code>equation: Equation\n</code></pre> <p>Returns the first item in the equations tuple.</p> <p>Raises IndexError if the performance check does not contain equations.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.equations","title":"equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>equations: tuple[Equation, ...] = ()\n</code></pre> <p>Performance-check data is expressed as equations.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.file","title":"file  <code>property</code>","text":"<pre><code>file: File\n</code></pre> <p>Returns the first item in the files tuple.</p> <p>Raises IndexError if the performance check does not contain files.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.files","title":"files  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>files: tuple[File, ...] = ()\n</code></pre> <p>Performance-check data is stored in other files (not in the equipment register).</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.table","title":"table  <code>property</code>","text":"<pre><code>table: Table\n</code></pre> <p>Returns the first item in the tables tuple.</p> <p>Raises IndexError if the performance check does not contain tables.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.tables","title":"tables  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tables: tuple[Table, ...] = ()\n</code></pre> <p>Performance-check data is stored as Comma Separated Values (CSV) tables.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; PerformanceCheck\n</code></pre> <p>Convert an XML element into a PerformanceCheck instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A performanceCheck XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>PerformanceCheck</code> <p>The PerformanceCheck instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; PerformanceCheck:\n    \"\"\"Convert an XML element into a [PerformanceCheck][msl.equipment.schema.PerformanceCheck] instance.\n\n    Args:\n        element: A [performanceCheck][type_performanceCheck] XML element from an\n            equipment register.\n\n    Returns:\n        The [PerformanceCheck][msl.equipment.schema.PerformanceCheck] instance.\n    \"\"\"\n    # Schema forces order for `competency` and `conditions` but uses xsd:choice,\n    # which allows sub-elements to appear (or not appear) in any order, for the data elements.\n    # Using str.endswith() allows for ignoring XML namespaces that may be associated with each tag\n    cvd_equations: list[CVDEquation] = []\n    equations: list[Equation] = []\n    files: list[File] = []\n    deserialisers: list[Deserialised] = []\n    tables: list[Table] = []\n    for child in element[2:]:\n        tag = child.tag\n        if tag.endswith(\"equation\"):\n            equations.append(Equation.from_xml(child))\n        elif tag.endswith(\"table\"):\n            tables.append(Table.from_xml(child))\n        elif tag.endswith(\"cvdCoefficients\"):\n            cvd_equations.append(CVDEquation.from_xml(child))\n        elif tag.endswith(\"file\"):\n            files.append(File.from_xml(child))\n        else:\n            deserialisers.append(Deserialised.from_xml(child))\n\n    a = element.attrib\n    return cls(\n        completed_date=_date.fromisoformat(a[\"completedDate\"] or \"\"),\n        entered_by=a[\"enteredBy\"] or \"\",\n        checked_by=a.get(\"checkedBy\", \"\"),\n        checked_date=None if not a.get(\"checkedDate\") else _date.fromisoformat(a[\"checkedDate\"]),\n        competency=Competency.from_xml(element[0]),\n        conditions=Conditions.from_xml(element[1]),\n        cvd_equations=tuple(cvd_equations),\n        deserialisers=tuple(deserialisers),\n        equations=tuple(equations),\n        files=tuple(files),\n        tables=tuple(tables),\n    )\n</code></pre>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the PerformanceCheck class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The PerformanceCheck as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [PerformanceCheck][msl.equipment.schema.PerformanceCheck] class into an XML element.\n\n    Returns:\n        The [PerformanceCheck][msl.equipment.schema.PerformanceCheck] as an XML element.\n    \"\"\"\n    a = {\"completedDate\": self.completed_date.isoformat(), \"enteredBy\": self.entered_by}\n    if self.checked_by:\n        a[\"checkedBy\"] = self.checked_by\n    if self.checked_date is not None:\n        a[\"checkedDate\"] = self.checked_date.isoformat()\n\n    e = Element(\"performanceCheck\", attrib=a)\n    e.append(self.competency.to_xml())\n    e.append(self.conditions)\n    e.extend(equation.to_xml() for equation in self.equations)\n    e.extend(table.to_xml() for table in self.tables)\n    e.extend(cvd.to_xml() for cvd in self.cvd_equations)\n    e.extend(file.to_xml() for file in self.files)\n    e.extend(deserialised.to_xml() for deserialised in self.deserialisers)\n    return e\n</code></pre>"},{"location":"schema/planned_task/","title":"PlannedTask","text":""},{"location":"schema/planned_task/#msl.equipment.schema.PlannedTask","title":"PlannedTask  <code>dataclass</code>","text":"<pre><code>PlannedTask(\n    task: str, due_date: date, performed_by: str = \"\"\n)\n</code></pre> <p>Represents the plannedTask element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>str</code> <p>A description of the task that is planned.</p> required <code>due_date</code> <code>date</code> <p>The date that the planned maintenance task is due to be completed.</p> required <code>performed_by</code> <code>str</code> <p>The person or company that will perform the planned maintenance task.</p> <code>''</code>"},{"location":"schema/planned_task/#msl.equipment.schema.PlannedTask.due_date","title":"due_date  <code>instance-attribute</code>","text":"<pre><code>due_date: date\n</code></pre> <p>The date that the planned maintenance task is due to be completed.</p>"},{"location":"schema/planned_task/#msl.equipment.schema.PlannedTask.performed_by","title":"performed_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performed_by: str = ''\n</code></pre> <p>The person or company that will perform the planned maintenance task.</p>"},{"location":"schema/planned_task/#msl.equipment.schema.PlannedTask.task","title":"task  <code>instance-attribute</code>","text":"<pre><code>task: str\n</code></pre> <p>A description of the task that is planned.</p>"},{"location":"schema/planned_task/#msl.equipment.schema.PlannedTask.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; PlannedTask\n</code></pre> <p>Convert an XML element into a PlannedTask instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A plannedTask XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>PlannedTask</code> <p>The PlannedTask instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; PlannedTask:\n    \"\"\"Convert an XML element into a [PlannedTask][msl.equipment.schema.PlannedTask] instance.\n\n    Args:\n        element: A [plannedTask][type_plannedTask] XML element from an equipment register.\n\n    Returns:\n        The [PlannedTask][msl.equipment.schema.PlannedTask] instance.\n    \"\"\"\n    return cls(\n        task=element.text or \"\",\n        due_date=_date.fromisoformat(element.attrib[\"dueDate\"]),\n        performed_by=element.get(\"performedBy\", \"\"),\n    )\n</code></pre>"},{"location":"schema/planned_task/#msl.equipment.schema.PlannedTask.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the PlannedTask class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The PlannedTask as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [PlannedTask][msl.equipment.schema.PlannedTask] class into an XML element.\n\n    Returns:\n        The [PlannedTask][msl.equipment.schema.PlannedTask] as an XML element.\n    \"\"\"\n    attrib = {\"dueDate\": self.due_date.isoformat()}\n    if self.performed_by:\n        attrib[\"performedBy\"] = self.performed_by\n\n    e = Element(\"task\", attrib=attrib)\n    e.text = self.task\n    return e\n</code></pre>"},{"location":"schema/quality_manual/","title":"QualityManual","text":""},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual","title":"QualityManual  <code>dataclass</code>","text":"<pre><code>QualityManual(\n    accessories: Accessories = Accessories(),\n    documentation: str = \"\",\n    financial: Financial = Financial(),\n    personnel_restrictions: str = \"\",\n    service_agent: str = \"\",\n    technical_procedures: tuple[str, ...] = (),\n)\n</code></pre> <p>Represents the qualityManual element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>accessories</code> <code>Accessories</code> <p>Additional accessories that may be required to use the equipment.</p> <code>Accessories()</code> <code>documentation</code> <code>str</code> <p>Information (such as URLs) about the manuals, datasheets, etc. for the equipment.</p> <code>''</code> <code>financial</code> <code>Financial</code> <p>Financial information about the equipment.</p> <code>Financial()</code> <code>personnel_restrictions</code> <code>str</code> <p>Information about the people (or team) who are qualified to use the equipment.</p> <code>''</code> <code>service_agent</code> <code>str</code> <p>Information about the people or company that are qualified to perform alterations and/or maintenance to the equipment.</p> <code>''</code> <code>technical_procedures</code> <code>tuple[str, ...]</code> <p>The technical procedures that depend on this equipment.</p> <code>()</code>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.accessories","title":"accessories  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>accessories: Accessories = field(\n    default_factory=Accessories\n)\n</code></pre> <p>Additional accessories that may be required to use the equipment.</p>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.documentation","title":"documentation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>documentation: str = ''\n</code></pre> <p>Information (such as URLs) about the manuals, datasheets, etc. for the equipment.</p>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.financial","title":"financial  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>financial: Financial = field(default_factory=Financial)\n</code></pre> <p>Financial information about the equipment.</p>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.personnel_restrictions","title":"personnel_restrictions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>personnel_restrictions: str = ''\n</code></pre> <p>Information about the people (or team) who are qualified to use the equipment.</p>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.service_agent","title":"service_agent  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>service_agent: str = ''\n</code></pre> <p>Information about the people or company that are qualified to perform alterations and/or maintenance to the equipment.</p>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.technical_procedures","title":"technical_procedures  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>technical_procedures: tuple[str, ...] = ()\n</code></pre> <p>The technical procedures that depend on this equipment.</p>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; QualityManual\n</code></pre> <p>Convert an XML element into an QualityManual instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A qualityManual XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>QualityManual</code> <p>The QualityManual instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; QualityManual:\n    \"\"\"Convert an XML element into an [QualityManual][msl.equipment.schema.QualityManual] instance.\n\n    Args:\n        element: A [qualityManual][type_qualityManual] XML element from an equipment register.\n\n    Returns:\n        The [QualityManual][msl.equipment.schema.QualityManual] instance.\n    \"\"\"\n    # Schema defines &lt;qualityManual&gt; using xsd:all, which allows sub-elements to appear (or not appear) in any order\n    # Using str.endswith() allows for ignoring XML namespaces that may be associated with each tag\n    tp: tuple[str, ...] = ()\n    a, d, f, pr, sa = Accessories(), \"\", Financial(), \"\", \"\"\n    for child in element:\n        if child.tag.endswith(\"accessories\"):\n            a = Accessories.from_xml(child)\n        elif child.tag.endswith(\"documentation\"):\n            d = child.text or \"\"\n        elif child.tag.endswith(\"financial\"):\n            f = Financial.from_xml(child)\n        elif child.tag.endswith(\"personnelRestrictions\"):\n            pr = child.text or \"\"\n        elif child.tag.endswith(\"serviceAgent\"):\n            sa = child.text or \"\"\n        else:\n            tp = tuple(i.text for i in child if i.text)\n\n    return cls(\n        accessories=a,\n        documentation=d,\n        financial=f,\n        personnel_restrictions=pr,\n        service_agent=sa,\n        technical_procedures=tp,\n    )\n</code></pre>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the QualityManual class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The QualityManual as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [QualityManual][msl.equipment.schema.QualityManual] class into an XML element.\n\n    Returns:\n        The [QualityManual][msl.equipment.schema.QualityManual] as an XML element.\n    \"\"\"\n    e = Element(\"qualityManual\")\n\n    if len(self.accessories) or len(self.accessories.attrib):\n        e.append(self.accessories)\n\n    if self.documentation:\n        d = SubElement(e, \"documentation\")\n        d.text = self.documentation\n\n    if self.financial != Financial():\n        e.append(self.financial.to_xml())\n\n    if self.personnel_restrictions:\n        pr = SubElement(e, \"personnelRestrictions\")\n        pr.text = self.personnel_restrictions\n\n    if self.service_agent:\n        sa = SubElement(e, \"serviceAgent\")\n        sa.text = self.service_agent\n\n    if self.technical_procedures:\n        tp = SubElement(e, \"technicalProcedures\")\n        for procedure in self.technical_procedures:\n            sub = SubElement(tp, \"id\")\n            sub.text = procedure\n\n    return e\n</code></pre>"},{"location":"schema/reference_materials/","title":"ReferenceMaterials","text":""},{"location":"schema/reference_materials/#msl.equipment.schema.ReferenceMaterials","title":"ReferenceMaterials","text":"<pre><code>ReferenceMaterials(**attributes: str)\n</code></pre> <p>               Bases: <code>Any</code></p> <p>Documentation of reference materials, results, acceptance criteria, relevant dates and the period of validity.</p> <p>Since this class is currently represented by the any type in the XML Schema Definition, it is simply a subclass of Element. It may be updated to be a more specific class at a later date.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any] type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/reference_materials/#msl.equipment.schema.ReferenceMaterials.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str = 'referenceMaterials'\n</code></pre> <p>The element's name.</p>"},{"location":"schema/reference_materials/#msl.equipment.schema.ReferenceMaterials.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/register/","title":"Register","text":"<p>An equipment register can be stored in a single XML file or distributed across multiple XML files. In this example we load a single XML file.</p> <pre><code>&gt;&gt;&gt; from msl.equipment import Register\n&gt;&gt;&gt; register = Register(\"tests/resources/mass/register.xml\")\n</code></pre> <p>Printing the <code>register</code> object shows the name of the team that is responsible for the equipment register and the number of Equipment items that are in the register.</p> <pre><code>&gt;&gt;&gt; register\nRegister(team='Mass' (2 equipment))\n&gt;&gt;&gt; register.team\n'Mass'\n</code></pre> <p>A register behaves like a sequence of Equipment items. You can get the number of items in the sequence and iterate over the sequence,</p> <pre><code>&gt;&gt;&gt; len(register)\n2\n&gt;&gt;&gt; for equipment in register:\n...     print(equipment.id)\n...\nMSLE.M.001\nMSLE.M.092\n</code></pre> <p>access equipment by its index, its equipment id or its alias.</p> <pre><code>&gt;&gt;&gt; register[1].id  # index\n'MSLE.M.092'\n&gt;&gt;&gt; register[\"MSLE.M.092\"].id  # equipment id\n'MSLE.M.092'\n&gt;&gt;&gt; register[\"Bob\"].id  # alias\n'MSLE.M.092'\n</code></pre> <p>The get method will attempt to get the Equipment at the specified index, id or alias, but will return <code>None</code> (instead of raising an exception) if the Equipment cannot be found in the register.</p> <pre><code>&gt;&gt;&gt; assert register.get(4) is None  # invalid index\n&gt;&gt;&gt; assert register.get(\"MSLE.M.999\") is None  # invalid equipment id\n&gt;&gt;&gt; register.get(\"Bob\")  # valid alias\nEquipment(id='MSLE.M.092', manufacturer='XYZ', model='A', serial='b' (4 reports))\n</code></pre> <p>The find method searches the register to find equipment that contain certain text. You may use a regular-expression pattern to find matching equipment items. Here we find all equipment that have the text <code>Hygrometer</code> in one of the Equipment attribute values that are considered in the search.</p> <pre><code>&gt;&gt;&gt; for hygrometer in register.find(\"Hygrometer\"):\n...    print(hygrometer)\nEquipment(id='MSLE.M.092', manufacturer='XYZ', model='A', serial='b' (4 reports))\n</code></pre> <p>We see that one equipment was found and that there are four calibration reports associated with the equipment. From the Equipment instance, we can get the latest calibration report for a certain Component name and Measurand quantity.</p> <p>Tip</p> <p>If the equipment contains only one Measurand and one Component you do not need to specify the name and quantity keyword arguments.</p> <pre><code>&gt;&gt;&gt; report = hygrometer.latest_report(name=\"Probe 1\", quantity=\"Humidity\")\n&gt;&gt;&gt; report\nLatestReport(name='Probe 1', quantity='Humidity', id='Humidity/2023/583' (1 equation))\n</code></pre> <p>We see that the calibration report contains one Equation. We can use the equation to apply a correction to measured values and to calculate the uncertainty.</p> <pre><code>&gt;&gt;&gt; value = report.equation.value\n&gt;&gt;&gt; value.equation\n'R - 7.131e-2 - 3.951e-2*R + 3.412e-4*pow(R,2) + 2.465e-3*t + 1.034e-3*R*t - 5.297e-6*pow(R,2)*t'\n&gt;&gt;&gt; value(R=[45.5, 46.1], t=[20.1, 20.0])\narray([45.1121266, 45.7099039])\n&gt;&gt;&gt; report.equation.uncertainty(R=[45.5, 46.1], t=[20.1, 20.0])\narray([0.355, 0.355])\n&gt;&gt;&gt; report.equation.unit\n'%rh'\n</code></pre> <p>From the LatestReport instance, we can, for example, get the date when the next calibration is due.</p> <pre><code>&gt;&gt;&gt; report.next_calibration_date\ndatetime.date(2028, 8, 14)\n</code></pre>"},{"location":"schema/register/#msl.equipment.schema.Register","title":"Register","text":"<pre><code>Register(*sources: XMLSource | Element[str])\n</code></pre> <p>Represents the register element in an equipment register.</p> <p>Specifying multiple sources allows for storing an equipment register across multiple files for the same team. Not specifying a source creates a new (empty) register.</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>XMLSource | Element[str]</code> <p>The path-like, file-like or Element objects that represent an equipment register.</p> <code>()</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, *sources: XMLSource | Element[str]) -&gt; None:\n    \"\"\"Represents the [register][element_register] element in an equipment register.\n\n    Specifying multiple sources allows for storing an equipment register across multiple\n    files for the same team. Not specifying a source creates a new (empty) register.\n\n    Args:\n        sources: The [path-like][path-like object], [file-like][file-like object] or\n            [Element][xml.etree.ElementTree.Element] objects that represent an equipment register.\n    \"\"\"\n    team = \"\"\n    self._elements: list[Element[str]] = []\n    for source in sources:\n        root = source if isinstance(source, Element) else ElementTree().parse(source)\n        t = root.attrib.get(\"team\", \"\")\n        if not team:\n            team = t\n\n        if team != t:\n            msg = f\"Cannot merge equipment registers from different teams, {team!r} != {t!r}\"\n            raise ValueError(msg)\n\n        self._elements.extend(root)\n\n    self._team: str = team\n    self._equipment: list[Equipment | None] = [None] * len(self._elements)\n\n    # a mapping between the alias/id and the index number in the register\n    self._index_map: dict[str, int] = {str(e[0].text): i for i, e in enumerate(self._elements)}  # e[0] is the ID\n    self._index_map.update({e.attrib[\"alias\"]: i for i, e in enumerate(self._elements) if e.attrib.get(\"alias\")})\n</code></pre>"},{"location":"schema/register/#msl.equipment.schema.Register.NAMESPACE","title":"NAMESPACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NAMESPACE: str = (\n    \"https://measurement.govt.nz/equipment-register\"\n)\n</code></pre> <p>Default XML namespace.</p>"},{"location":"schema/register/#msl.equipment.schema.Register.team","title":"team  <code>property</code> <code>writable</code>","text":"<pre><code>team: str\n</code></pre> <p>str \u2014 The name of the team that is responsible for the equipment register.</p>"},{"location":"schema/register/#msl.equipment.schema.Register.add","title":"add","text":"<pre><code>add(equipment: Equipment) -&gt; None\n</code></pre> <p>Add equipment to the register.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>The equipment to add.</p> required Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def add(self, equipment: Equipment) -&gt; None:\n    \"\"\"Add equipment to the register.\n\n    Args:\n        equipment: The equipment to add.\n    \"\"\"\n    if equipment.id:\n        self._index_map[equipment.id] = len(self._equipment)\n    if equipment.alias:\n        self._index_map[equipment.alias] = len(self._equipment)\n    self._equipment.append(equipment)\n</code></pre>"},{"location":"schema/register/#msl.equipment.schema.Register.find","title":"find","text":"<pre><code>find(\n    pattern: str | Pattern[str], *, flags: int = 0\n) -&gt; Iterator[Equipment]\n</code></pre> <p>Find equipment in the register.</p> <p>The following attributes are used in the search:</p> <ul> <li>keywords: Equipment</li> <li>description: Equipment</li> <li>manufacturer: Equipment</li> <li>model: Equipment</li> <li>serial: Equipment</li> <li>id: Equipment, Report, DigitalReport</li> <li>location: Equipment</li> <li>quantity: Measurand</li> <li>name: Component</li> <li>entered_by: Equipment, PerformanceCheck, Report</li> <li>checked_by: Equipment, PerformanceCheck, Report</li> <li>performed_by: Alteration, CompletedTask, PlannedTask</li> <li>comment: CVDEquation, Equation, File, Table, Deserialised, DigitalReport</li> <li>format: DigitalReport</li> <li>details: Alteration, Adjustment</li> <li>task: CompletedTask, PlannedTask</li> <li>asset_number: CapitalExpenditure</li> <li>service_agent: QualityManual</li> <li>technical_procedures: QualityManual</li> </ul> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str | Pattern[str]</code> <p>A regular-expression pattern to use to find equipment.</p> required <code>flags</code> <code>int</code> <p>The flags to use to compile the <code>pattern</code>. See re.compile for more details.</p> <code>0</code> <p>Yields:</p> Type Description <code>Equipment</code> <p>Equipment that match the <code>pattern</code>.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def find(self, pattern: str | re.Pattern[str], *, flags: int = 0) -&gt; Iterator[Equipment]:  # noqa: C901\n    \"\"\"Find equipment in the register.\n\n    The following attributes are used in the search:\n\n    * keywords: [Equipment][msl.equipment.schema.Equipment]\n    * description: [Equipment][msl.equipment.schema.Equipment]\n    * manufacturer: [Equipment][msl.equipment.schema.Equipment]\n    * model: [Equipment][msl.equipment.schema.Equipment]\n    * serial: [Equipment][msl.equipment.schema.Equipment]\n    * id: [Equipment][msl.equipment.schema.Equipment], [Report][msl.equipment.schema.Report], [DigitalReport][msl.equipment.schema.DigitalReport]\n    * location: [Equipment][msl.equipment.schema.Equipment]\n    * quantity: [Measurand][msl.equipment.schema.Measurand]\n    * name: [Component][msl.equipment.schema.Component]\n    * entered_by: [Equipment][msl.equipment.schema.Equipment], [PerformanceCheck][msl.equipment.schema.PerformanceCheck], [Report][msl.equipment.schema.Report]\n    * checked_by: [Equipment][msl.equipment.schema.Equipment], [PerformanceCheck][msl.equipment.schema.PerformanceCheck], [Report][msl.equipment.schema.Report]\n    * performed_by: [Alteration][msl.equipment.schema.Alteration], [CompletedTask][msl.equipment.schema.CompletedTask], [PlannedTask][msl.equipment.schema.PlannedTask]\n    * comment: [CVDEquation][msl.equipment.schema.CVDEquation], [Equation][msl.equipment.schema.Equation], [File][msl.equipment.schema.File], [Table][msl.equipment.schema.Table], [Deserialised][msl.equipment.schema.Deserialised], [DigitalReport][msl.equipment.schema.DigitalReport]\n    * format: [DigitalReport][msl.equipment.schema.DigitalReport]\n    * details: [Alteration][msl.equipment.schema.Alteration], [Adjustment][msl.equipment.schema.Adjustment]\n    * task: [CompletedTask][msl.equipment.schema.CompletedTask], [PlannedTask][msl.equipment.schema.PlannedTask]\n    * asset_number: [CapitalExpenditure][msl.equipment.schema.CapitalExpenditure]\n    * service_agent: [QualityManual][msl.equipment.schema.QualityManual]\n    * technical_procedures: [QualityManual][msl.equipment.schema.QualityManual]\n\n    Args:\n        pattern: A [regular-expression pattern](https://regexr.com/) to use to find equipment.\n        flags: The flags to use to compile the `pattern`. See [re.compile][] for more details.\n\n    Yields:\n        Equipment that match the `pattern`.\n    \"\"\"  # noqa: E501\n\n    def comment_search(item: Report | PerformanceCheck) -&gt; bool:\n        for cvd_equation in item.cvd_equations:\n            if regex.search(cvd_equation.comment) is not None:\n                return True\n        for equation in item.equations:\n            if regex.search(equation.comment) is not None:\n                return True\n        for file in item.files:\n            if regex.search(file.comment) is not None:\n                return True\n        for table in item.tables:\n            if regex.search(table.comment) is not None:\n                return True\n        return any(regex.search(deserialised.comment) is not None for deserialised in item.deserialisers)\n\n    def task_search(m: Maintenance) -&gt; bool:\n        for c in m.completed:\n            if regex.search(c.task) is not None:\n                return True\n            if regex.search(c.performed_by) is not None:\n                return True\n        for p in m.planned:\n            if regex.search(p.task) is not None:\n                return True\n            if regex.search(p.performed_by) is not None:\n                return True\n        return False\n\n    def alteration_search(alterations: tuple[Alteration, ...]) -&gt; bool:\n        for a in alterations:\n            if regex.search(a.details) is not None:\n                return True\n            if regex.search(a.performed_by) is not None:\n                return True\n        return False\n\n    def calibrations_search(e: Equipment) -&gt; bool:  # noqa: C901, PLR0911, PLR0912\n        for m in e.calibrations:\n            if regex.search(m.quantity) is not None:\n                return True\n            for c in m.components:\n                if regex.search(c.name) is not None:\n                    return True\n                for r in c.reports:\n                    if regex.search(r.entered_by) is not None:\n                        return True\n                    if regex.search(r.checked_by) is not None:\n                        return True\n                    if comment_search(r):\n                        return True\n                    if regex.search(r.id) is not None:\n                        return True\n                for pc in c.performance_checks:\n                    if regex.search(pc.entered_by) is not None:\n                        return True\n                    if regex.search(pc.checked_by) is not None:\n                        return True\n                    if comment_search(pc):\n                        return True\n                for a in c.adjustments:\n                    if regex.search(a.details) is not None:\n                        return True\n                for dr in c.digital_reports:\n                    if regex.search(dr.format.value) is not None:\n                        return True\n                    if regex.search(dr.id) is not None:\n                        return True\n                    if regex.search(dr.comment) is not None:\n                        return True\n        return False\n\n    def asset_number_search(f: Financial) -&gt; bool:\n        if f.capital_expenditure is None:\n            return False\n        return regex.search(f.capital_expenditure.asset_number) is not None\n\n    regex = re.compile(pattern, flags=flags)\n    for equipment in self:\n        if (\n            regex.search(\" \".join(equipment.keywords)) is not None\n            or regex.search(equipment.description) is not None\n            or regex.search(equipment.manufacturer) is not None\n            or regex.search(equipment.model) is not None\n            or regex.search(equipment.serial) is not None\n            or regex.search(equipment.id) is not None\n            or regex.search(equipment.location) is not None\n            or regex.search(equipment.entered_by) is not None\n            or regex.search(equipment.checked_by) is not None\n            or calibrations_search(equipment)\n            or alteration_search(equipment.alterations)\n            or task_search(equipment.maintenance)\n            or asset_number_search(equipment.quality_manual.financial)\n            or regex.search(equipment.quality_manual.service_agent) is not None\n            or regex.search(\" \".join(equipment.quality_manual.technical_procedures)) is not None\n        ):\n            yield equipment\n</code></pre>"},{"location":"schema/register/#msl.equipment.schema.Register.get","title":"get","text":"<pre><code>get(item: int | str) -&gt; Equipment | None\n</code></pre> <p>Get an Equipment item from the register.</p> <p>This method will ignore all errors if the register does not contain the requested Equipment item.</p> <p>Tip</p> <p>You can also treat a register instance as a sequence of Equipment items.</p> <p>Using the indexable notation on a register instance to access an Equipment item by using the alias of the equipment or the index within the register could raise an exception</p> <pre><code>&gt;&gt;&gt; register[\"unknown-alias\"]\nTraceback (most recent call last):\n...\nValueError: No equipment exists with the alias or id 'unknown-alias'\n\n&gt;&gt;&gt; register[243]\nTraceback (most recent call last):\n...\nIndexError: list index out of range\n</code></pre> <p>whereas these errors can be silenced by using the get method</p> <pre><code>&gt;&gt;&gt; assert register.get(\"unknown\") is None\n&gt;&gt;&gt; assert register.get(243) is None\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>int | str</code> <p>The index number, equipment id value or the equipment alias value in the register.</p> required <p>Returns:</p> Type Description <code>Equipment | None</code> <p>The Equipment item if <code>item</code> is valid, otherwise <code>None</code>.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def get(self, item: int | str) -&gt; Equipment | None:\n    \"\"\"Get an [Equipment][msl.equipment.schema.Equipment] item from the register.\n\n    This method will ignore all errors if the register does not contain the requested\n    [Equipment][msl.equipment.schema.Equipment] item.\n\n    !!! tip\n        You can also treat a _register_ instance as a sequence of [Equipment][msl.equipment.schema.Equipment] items.\n\n    &lt;!--\n    &gt;&gt;&gt; from msl.equipment import Register\n    &gt;&gt;&gt; register = Register(\"tests/resources/mass/register.xml\")\n\n    --&gt;\n\n    Using the _indexable_ notation on a _register_ instance to access an [Equipment][msl.equipment.schema.Equipment]\n    item by using the alias of the equipment or the index within the register could raise an exception\n\n    ```pycon\n    &gt;&gt;&gt; register[\"unknown-alias\"]\n    Traceback (most recent call last):\n    ...\n    ValueError: No equipment exists with the alias or id 'unknown-alias'\n\n    &gt;&gt;&gt; register[243]\n    Traceback (most recent call last):\n    ...\n    IndexError: list index out of range\n\n    ```\n\n    whereas these errors can be silenced by using the [get][msl.equipment.schema.Register.get] method\n\n    ```pycon\n    &gt;&gt;&gt; assert register.get(\"unknown\") is None\n    &gt;&gt;&gt; assert register.get(243) is None\n\n    ```\n\n    Args:\n        item: The index number, equipment id value or the equipment alias value in the register.\n\n    Returns:\n        The [Equipment][msl.equipment.schema.Equipment] item if `item` is valid, otherwise `None`.\n    \"\"\"\n    try:\n        return self[item]\n    except (ValueError, IndexError):\n        return None\n</code></pre>"},{"location":"schema/register/#msl.equipment.schema.Register.tree","title":"tree","text":"<pre><code>tree(\n    namespace: str | None = \"DEFAULT\", indent: int = 4\n) -&gt; ElementTree[Element[str]]\n</code></pre> <p>Convert the Register class into an XML element tree.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str | None</code> <p>The namespace to associate with the root element. If the value is <code>DEFAULT</code>, uses the value of NAMESPACE as the namespace. If <code>None</code>, or an empty string, no namespace is associated with the root element.</p> <code>'DEFAULT'</code> <code>indent</code> <code>int</code> <p>The number of spaces to indent sub elements. The value must be \u2265 0. This parameter is ignored if the version of Python is &lt; 3.9.</p> <code>4</code> <p>Returns:</p> Type Description <code>ElementTree[Element[str]]</code> <p>The Register as an ElementTree.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def tree(self, namespace: str | None = \"DEFAULT\", indent: int = 4) -&gt; ElementTree[Element[str]]:\n    \"\"\"Convert the [Register][msl.equipment.schema.Register] class into an XML element tree.\n\n    Args:\n        namespace: The namespace to associate with the root element. If the value is\n            `DEFAULT`, uses the value of [NAMESPACE][msl.equipment.schema.Register.NAMESPACE]\n            as the namespace. If `None`, or an empty string, no namespace is associated\n            with the root element.\n        indent: The number of spaces to indent sub elements. The value must be &amp;ge; 0.\n            This parameter is ignored if the version of Python is &amp;lt; 3.9.\n\n    Returns:\n        The [Register][msl.equipment.schema.Register] as an\n            [ElementTree][xml.etree.ElementTree.ElementTree].\n    \"\"\"\n    if indent &lt; 0:\n        msg = f\"Indentation must be &gt;= 0, got {indent}\"\n        raise ValueError(msg)\n\n    attrib = {\"team\": self.team}\n    if namespace:\n        if namespace == \"DEFAULT\":\n            namespace = self.NAMESPACE\n        attrib[\"xmlns\"] = namespace\n\n    # The &lt;table&gt;&lt;data&gt; element is 7 levels deep from &lt;register&gt;\n    _Indent.table_data = (7 * indent) + len(\"&lt;data&gt;\")\n\n    e = Element(\"register\", attrib=attrib)\n    e.extend(equipment.to_xml() for equipment in self)\n    tree: ElementTree[Element[str]] = ElementTree(element=e)\n\n    if indent &gt; 0 and sys.version_info &gt;= (3, 9):\n        from xml.etree.ElementTree import indent as pretty  # noqa: PLC0415\n\n        pretty(tree, space=\" \" * indent)\n\n    return tree\n</code></pre>"},{"location":"schema/report/","title":"Report","text":""},{"location":"schema/report/#msl.equipment.schema.Report","title":"Report  <code>dataclass</code>","text":"<pre><code>Report(\n    id: str,\n    report_issue_date: date,\n    measurement_start_date: date,\n    measurement_stop_date: date,\n    issuing_laboratory: IssuingLaboratory = IssuingLaboratory(),\n    technical_procedure: str = \"\",\n    entered_by: str = \"\",\n    checked_by: str = \"\",\n    checked_date: date | None = None,\n    conditions: Conditions = Conditions(),\n    acceptance_criteria: AcceptanceCriteria = AcceptanceCriteria(),\n    cvd_equations: tuple[CVDEquation, ...] = (),\n    deserialisers: tuple[Deserialised, ...] = (),\n    equations: tuple[Equation, ...] = (),\n    files: tuple[File, ...] = (),\n    tables: tuple[Table, ...] = (),\n)\n</code></pre> <p>Represents the report element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The report identification number.</p> required <code>report_issue_date</code> <code>date</code> <p>The date that the report was issued.</p> required <code>measurement_start_date</code> <code>date</code> <p>The date that the calibration measurement started.</p> required <code>measurement_stop_date</code> <code>date</code> <p>The date that the calibration measurement stopped.</p> required <code>issuing_laboratory</code> <code>IssuingLaboratory</code> <p>Information about the laboratory that issued the calibration report.</p> <code>IssuingLaboratory()</code> <code>technical_procedure</code> <code>str</code> <p>The technical procedure(s) that was(were) followed to perform the calibration.</p> <code>''</code> <code>entered_by</code> <code>str</code> <p>The name of the person who initially entered the <code>&lt;report&gt;</code> element in the register.</p> <code>''</code> <code>checked_by</code> <code>str</code> <p>The name of the person who checked the information in the <code>&lt;report&gt;</code> element.</p> <code>''</code> <code>checked_date</code> <code>date | None</code> <p>The date that the information in the <code>&lt;report&gt;</code> element was last checked.</p> <code>None</code> <code>conditions</code> <code>Conditions</code> <p>The conditions under which the report is valid.</p> <code>Conditions()</code> <code>acceptance_criteria</code> <code>AcceptanceCriteria</code> <p>Acceptance criteria for the calibration report.</p> <code>AcceptanceCriteria()</code> <code>cvd_equations</code> <code>tuple[CVDEquation, ...]</code> <p>Calibration data is expressed as Callendar-Van Dusen equations.</p> <code>()</code> <code>deserialisers</code> <code>tuple[Deserialised, ...]</code> <p>Calibration data is stored in serialised formats and deserialised.</p> <code>()</code> <code>equations</code> <code>tuple[Equation, ...]</code> <p>Calibration data is expressed as equations.</p> <code>()</code> <code>files</code> <code>tuple[File, ...]</code> <p>Calibration data is stored in other files (not in the equipment register).</p> <code>()</code> <code>tables</code> <code>tuple[Table, ...]</code> <p>Calibration data is stored as Comma Separated Values (CSV) tables.</p> <code>()</code>"},{"location":"schema/report/#msl.equipment.schema.Report.acceptance_criteria","title":"acceptance_criteria  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acceptance_criteria: AcceptanceCriteria = field(\n    default_factory=AcceptanceCriteria\n)\n</code></pre> <p>Acceptance criteria for the calibration report.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.checked_by","title":"checked_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_by: str = ''\n</code></pre> <p>The name of the person who checked the information in the <code>&lt;report&gt;</code> element.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.checked_date","title":"checked_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_date: date | None = None\n</code></pre> <p>The date that the information in the <code>&lt;report&gt;</code> element was last checked.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.conditions","title":"conditions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>conditions: Conditions = field(default_factory=Conditions)\n</code></pre> <p>The conditions under which the report is valid.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.cvd_equation","title":"cvd_equation  <code>property</code>","text":"<pre><code>cvd_equation: CVDEquation\n</code></pre> <p>Returns the first item in the cvd_equations tuple.</p> <p>Raises IndexError if the report does not contain Callendar-Van Dusen equations.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.cvd_equations","title":"cvd_equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cvd_equations: tuple[CVDEquation, ...] = ()\n</code></pre> <p>Calibration data is expressed as Callendar-Van Dusen equations.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.deserialised","title":"deserialised  <code>property</code>","text":"<pre><code>deserialised: Deserialised\n</code></pre> <p>Returns the first item in the deserialisers tuple.</p> <p>Raises IndexError if the report does not contain serialised data.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.deserialisers","title":"deserialisers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>deserialisers: tuple[Deserialised, ...] = ()\n</code></pre> <p>Calibration data is stored in serialised formats and deserialised.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.entered_by","title":"entered_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entered_by: str = ''\n</code></pre> <p>The name of the person who initially entered the <code>&lt;report&gt;</code> element in the register.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.equation","title":"equation  <code>property</code>","text":"<pre><code>equation: Equation\n</code></pre> <p>Returns the first item in the equations tuple.</p> <p>Raises IndexError if the report does not contain equations.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.equations","title":"equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>equations: tuple[Equation, ...] = ()\n</code></pre> <p>Calibration data is expressed as equations.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.file","title":"file  <code>property</code>","text":"<pre><code>file: File\n</code></pre> <p>Returns the first item in the files tuple.</p> <p>Raises IndexError if the report does not contain files.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.files","title":"files  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>files: tuple[File, ...] = ()\n</code></pre> <p>Calibration data is stored in other files (not in the equipment register).</p>"},{"location":"schema/report/#msl.equipment.schema.Report.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>The report identification number.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.issuing_laboratory","title":"issuing_laboratory  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>issuing_laboratory: IssuingLaboratory = field(\n    default_factory=IssuingLaboratory\n)\n</code></pre> <p>Information about the laboratory that issued the calibration report.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.measurement_start_date","title":"measurement_start_date  <code>instance-attribute</code>","text":"<pre><code>measurement_start_date: date\n</code></pre> <p>The date that the calibration measurement started.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.measurement_stop_date","title":"measurement_stop_date  <code>instance-attribute</code>","text":"<pre><code>measurement_stop_date: date\n</code></pre> <p>The date that the calibration measurement stopped.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.report_issue_date","title":"report_issue_date  <code>instance-attribute</code>","text":"<pre><code>report_issue_date: date\n</code></pre> <p>The date that the report was issued.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.table","title":"table  <code>property</code>","text":"<pre><code>table: Table\n</code></pre> <p>Returns the first item in the tables tuple.</p> <p>Raises IndexError if the report does not contain tables.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.tables","title":"tables  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tables: tuple[Table, ...] = ()\n</code></pre> <p>Calibration data is stored as Comma Separated Values (CSV) tables.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.technical_procedure","title":"technical_procedure  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>technical_procedure: str = ''\n</code></pre> <p>The technical procedure(s) that was(were) followed to perform the calibration.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Report\n</code></pre> <p>Convert an XML element into a Report instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A report XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Report</code> <p>The Report instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Report:\n    \"\"\"Convert an XML element into a [Report][msl.equipment.schema.Report] instance.\n\n    Args:\n        element: A [report][type_report] XML element from an equipment register.\n\n    Returns:\n        The [Report][msl.equipment.schema.Report] instance.\n    \"\"\"\n    # Schema forces order until `acceptanceCriteria` and then uses xsd:choice, which\n    # allows sub-elements to appear (or not appear) in any order, for the data elements.\n    # Using str.endswith() allows for ignoring XML namespaces that may be associated with each tag\n    cvd_equations: list[CVDEquation] = []\n    deserialisers: list[Deserialised] = []\n    equations: list[Equation] = []\n    files: list[File] = []\n    tables: list[Table] = []\n    for child in element[7:]:\n        tag = child.tag\n        if tag.endswith(\"equation\"):\n            equations.append(Equation.from_xml(child))\n        elif tag.endswith(\"table\"):\n            tables.append(Table.from_xml(child))\n        elif tag.endswith(\"cvdCoefficients\"):\n            cvd_equations.append(CVDEquation.from_xml(child))\n        elif tag.endswith(\"file\"):\n            files.append(File.from_xml(child))\n        else:\n            deserialisers.append(Deserialised.from_xml(child))\n\n    a = element.attrib\n    return cls(\n        id=a[\"id\"] or \"\",\n        entered_by=a[\"enteredBy\"] or \"\",\n        checked_by=a.get(\"checkedBy\", \"\"),\n        checked_date=None if not a.get(\"checkedDate\") else _date.fromisoformat(a[\"checkedDate\"]),\n        report_issue_date=_date.fromisoformat(element[0].text or \"\"),\n        measurement_start_date=_date.fromisoformat(element[1].text or \"\"),\n        measurement_stop_date=_date.fromisoformat(element[2].text or \"\"),\n        issuing_laboratory=IssuingLaboratory.from_xml(element[3]),\n        technical_procedure=element[4].text or \"\",\n        conditions=Conditions.from_xml(element[5]),\n        acceptance_criteria=AcceptanceCriteria.from_xml(element[6]),\n        cvd_equations=tuple(cvd_equations),\n        deserialisers=tuple(deserialisers),\n        equations=tuple(equations),\n        files=tuple(files),\n        tables=tuple(tables),\n    )\n</code></pre>"},{"location":"schema/report/#msl.equipment.schema.Report.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Report class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Report as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Report][msl.equipment.schema.Report] class into an XML element.\n\n    Returns:\n        The [Report][msl.equipment.schema.Report] as an XML element.\n    \"\"\"\n    a = {\"id\": self.id, \"enteredBy\": self.entered_by}\n    if self.checked_by:\n        a[\"checkedBy\"] = self.checked_by\n    if self.checked_date is not None:\n        a[\"checkedDate\"] = self.checked_date.isoformat()\n\n    e = Element(\"report\", attrib=a)\n\n    rid = SubElement(e, \"reportIssueDate\")\n    rid.text = self.report_issue_date.isoformat()\n\n    start = SubElement(e, \"measurementStartDate\")\n    start.text = self.measurement_start_date.isoformat()\n\n    stop = SubElement(e, \"measurementStopDate\")\n    stop.text = self.measurement_stop_date.isoformat()\n\n    e.append(self.issuing_laboratory.to_xml())\n\n    tp = SubElement(e, \"technicalProcedure\")\n    tp.text = self.technical_procedure\n\n    e.append(self.conditions)\n    e.append(self.acceptance_criteria)\n    e.extend(equation.to_xml() for equation in self.equations)\n    e.extend(table.to_xml() for table in self.tables)\n    e.extend(cvd.to_xml() for cvd in self.cvd_equations)\n    e.extend(file.to_xml() for file in self.files)\n    e.extend(deserialised.to_xml() for deserialised in self.deserialisers)\n    return e\n</code></pre>"},{"location":"schema/report/#msl.equipment.schema.IssuingLaboratory","title":"IssuingLaboratory  <code>dataclass</code>","text":"<pre><code>IssuingLaboratory(lab: str = '', person: str = '')\n</code></pre> <p>Information about the laboratory that issued a calibration report.</p> <p>Parameters:</p> Name Type Description Default <code>lab</code> <code>str</code> <p>The name of the laboratory that issued the calibration report.</p> <code>''</code> <code>person</code> <code>str</code> <p>The name of a person at the <code>laboratory</code> that authorised the report.</p> <code>''</code>"},{"location":"schema/report/#msl.equipment.schema.IssuingLaboratory.lab","title":"lab  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lab: str = ''\n</code></pre> <p>The name of the laboratory that issued the calibration report.</p>"},{"location":"schema/report/#msl.equipment.schema.IssuingLaboratory.person","title":"person  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>person: str = ''\n</code></pre> <p>The name of a person at the laboratory that authorised the report.</p>"},{"location":"schema/report/#msl.equipment.schema.IssuingLaboratory.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; IssuingLaboratory\n</code></pre> <p>Convert an XML element into a IssuingLaboratory instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An <code>&lt;issuingLaboratory&gt;</code> element from a report element in an equipment register.</p> required <p>Returns:</p> Type Description <code>IssuingLaboratory</code> <p>The IssuingLaboratory instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; IssuingLaboratory:\n    \"\"\"Convert an XML element into a [IssuingLaboratory][msl.equipment.schema.IssuingLaboratory] instance.\n\n    Args:\n        element: An `&lt;issuingLaboratory&gt;` element from a [report][type_report] element\n            in an equipment register.\n\n    Returns:\n        The [IssuingLaboratory][msl.equipment.schema.IssuingLaboratory] instance.\n    \"\"\"\n    return cls(\n        lab=element.text or \"\",\n        person=element.attrib.get(\"person\", \"\"),\n    )\n</code></pre>"},{"location":"schema/report/#msl.equipment.schema.IssuingLaboratory.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the IssuingLaboratory class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The IssuingLaboratory as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [IssuingLaboratory][msl.equipment.schema.IssuingLaboratory] class into an XML element.\n\n    Returns:\n        The [IssuingLaboratory][msl.equipment.schema.IssuingLaboratory] as an XML element.\n    \"\"\"\n    a = {\"person\": self.person} if self.person else {}\n    e = Element(\"issuingLaboratory\", attrib=a)\n    e.text = self.lab\n    return e\n</code></pre>"},{"location":"schema/specifications/","title":"Specifications","text":""},{"location":"schema/specifications/#msl.equipment.schema.Specifications","title":"Specifications","text":"<pre><code>Specifications(**attributes: str)\n</code></pre> <p>               Bases: <code>Any</code></p> <p>Specifications provided by the manufacturer of the equipment.</p> <p>Typically, the specifications are specified on the website, datasheet and/or technical notes that a manufacturer provides.</p> <p>Since this class is currently represented by the any type in the XML Schema Definition, it is simply a subclass of Element. It may be updated to be a more specific class at a later date.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any] type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/specifications/#msl.equipment.schema.Specifications.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str = 'specifications'\n</code></pre> <p>The element's name.</p>"},{"location":"schema/specifications/#msl.equipment.schema.Specifications.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/specified_requirements/","title":"SpecifiedRequirements","text":""},{"location":"schema/specified_requirements/#msl.equipment.schema.SpecifiedRequirements","title":"SpecifiedRequirements","text":"<pre><code>SpecifiedRequirements(**attributes: str)\n</code></pre> <p>               Bases: <code>Any</code></p> <p>Verification that equipment conforms with specified requirements before being placed or returned into service.</p> <p>Since this class is currently represented by the any type in the XML Schema Definition, it is simply a subclass of Element. It may be updated to be a more specific class at a later date.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any] type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/specified_requirements/#msl.equipment.schema.SpecifiedRequirements.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str = 'specifiedRequirements'\n</code></pre> <p>The element's name.</p>"},{"location":"schema/specified_requirements/#msl.equipment.schema.SpecifiedRequirements.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/status/","title":"Status","text":""},{"location":"schema/status/#msl.equipment.schema.Status","title":"Status","text":"<p>               Bases: <code>Enum</code></p> <p>Represents the status enumeration in an equipment register.</p> <p>Attributes:</p> Name Type Description <code>Active</code> <code>str</code> <p>The equipment is operable and may be used.</p> <code>Damaged</code> <code>str</code> <p>The equipment is damaged and is no longer usable.</p> <code>Disposed</code> <code>str</code> <p>The equipment has been disposed of and is no longer at available (e.g., the equipment was sent to the landfill or to be recycled).</p> <code>Dormant</code> <code>str</code> <p>The equipment is still operable, it is no longer in use but may be used again (e.g., the equipment was replaced with a newer model, and it is kept as a backup).</p> <code>Lost</code> <code>str</code> <p>The equipment is lost, but if found may be put back into service.</p> <code>Retired</code> <code>str</code> <p>The equipment is still operable, but there are no intentions of using it again (e.g., the equipment depends on other equipment that is not available or is no longer manufactured).</p>"},{"location":"schema/table/","title":"Table","text":"<p>Suppose you have a variable named <code>table</code> (which is an instance of Table) that represents the following information in an equipment register for equipment that measures spectral irradiance</p> <pre><code>&lt;table comment=\"Spectral\"&gt;\n  &lt;type&gt;   int       ,    double ,    double     &lt;/type&gt;\n  &lt;unit&gt;   nm        ,    W/m^2  ,    W/m^2      &lt;/unit&gt;\n  &lt;header&gt; Wavelength, Irradiance, u(Irradiance) &lt;/header&gt;\n  &lt;data&gt;   250       ,    0.01818,   0.02033\n           300       ,    0.18478,   0.01755\n           350       ,    0.80845,   0.01606\n           400       ,    2.21355,   0.01405\n           450       ,    4.49004,   0.01250\n           500       ,    7.45135,   0.01200\n           550       ,   10.75753,   0.01152\n           600       ,   14.03809,   0.01102\n           650       ,   16.99469,   0.01103\n           700       ,   19.44093,   0.01077\n  &lt;/data&gt;\n&lt;/table&gt;\n</code></pre> <p>The <code>table</code> instance is a numpy structured array that has the header values as the field name of each column</p> <pre><code>&gt;&gt;&gt; table.header\narray(['Wavelength', 'Irradiance', 'u(Irradiance)'], dtype='&lt;U13')\n&gt;&gt;&gt; table[\"Wavelength\"]\nTable([250, 300, 350, 400, 450, 500, 550, 600, 650, 700])\n&gt;&gt;&gt; table.types[\"Irradiance\"]\narray(dtype('float64'), dtype=object)\n&gt;&gt;&gt; assert table.units[\"u(Irradiance)\"] == \"W/m^2\"\n</code></pre> <p>Since <code>table</code> is a numpy array, you can index it</p> <pre><code>&gt;&gt;&gt; print(table[0])\n(250, 0.01818, 0.02033)\n&gt;&gt;&gt; sliced=table[:3]\n&gt;&gt;&gt; print(sliced)\n[(250, 0.01818, 0.02033) (300, 0.18478, 0.01755) (350, 0.80845, 0.01606)]\n</code></pre> <p>and since <code>sliced</code> is another Table instance, the attributes of the original <code>table</code> are available</p> <pre><code>&gt;&gt;&gt; sliced.comment\n'Spectral'\n&gt;&gt;&gt; sliced.header\narray(['Wavelength', 'Irradiance', 'u(Irradiance)'], dtype='&lt;U13')\n</code></pre> <p>You can also perform mathematical operations and call numpy functions directly with the <code>table</code> instance</p> <pre><code>&gt;&gt;&gt; np.cos(1 + table[\"Irradiance\"])\nTable([ 0.52491592,  0.37650087, -0.2354229 , -0.99741219,  0.70160756,\n       -0.56246854,  0.6903377 , -0.78390036,  0.65631968, -0.0205763 ])\n</code></pre> <p>Suppose you wanted to get all Irradiance values in the table that are for UV light (i.e., wavelengths &lt; 400 nm)</p> <pre><code>&gt;&gt;&gt; table[\"Irradiance\"][ table[\"Wavelength\"] &lt; 400 ]\nTable([0.01818, 0.18478, 0.80845])\n</code></pre> <p>If you prefer to work with unstructured data, you can convert the <code>table</code> by calling the unstructured method</p> <pre><code>&gt;&gt;&gt; unstructured = table.unstructured()\n&gt;&gt;&gt; unstructured\nTable([[2.500000e+02, 1.818000e-02, 2.033000e-02],\n       [3.000000e+02, 1.847800e-01, 1.755000e-02],\n       [3.500000e+02, 8.084500e-01, 1.606000e-02],\n       [4.000000e+02, 2.213550e+00, 1.405000e-02],\n       [4.500000e+02, 4.490040e+00, 1.250000e-02],\n       [5.000000e+02, 7.451350e+00, 1.200000e-02],\n       [5.500000e+02, 1.075753e+01, 1.152000e-02],\n       [6.000000e+02, 1.403809e+01, 1.102000e-02],\n       [6.500000e+02, 1.699469e+01, 1.103000e-02],\n       [7.000000e+02, 1.944093e+01, 1.077000e-02]])\n&gt;&gt;&gt; print(unstructured[0, 0])\n250.0\n</code></pre>"},{"location":"schema/table/#msl.equipment.schema.Table","title":"Table","text":"<p>               Bases: <code>ndarray</code></p> <p>Represents the table element in an equipment register.</p>"},{"location":"schema/table/#msl.equipment.schema.Table.comment","title":"comment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comment: str = ''\n</code></pre> <p>A comment that is associated with the table.</p>"},{"location":"schema/table/#msl.equipment.schema.Table.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header: NDArray[void] = empty(0, dtype=object)\n</code></pre> <p>The header value of each column.</p>"},{"location":"schema/table/#msl.equipment.schema.Table.types","title":"types  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>types: NDArray[void] = empty(0, dtype=object)\n</code></pre> <p>The data type of each column.</p>"},{"location":"schema/table/#msl.equipment.schema.Table.units","title":"units  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>units: NDArray[void] = empty(0, dtype=object)\n</code></pre> <p>The unit of each column.</p>"},{"location":"schema/table/#msl.equipment.schema.Table.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Table\n</code></pre> <p>Convert an XML element into a Table instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A table XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Table</code> <p>A Table is an subclass of a numpy structured array, where the <code>header</code> is used as the field names. This allows for accessing a column by the header value rather than by the index of a column. If you prefer to work with unstructured data, call unstructured on the returned object.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Table:\n    \"\"\"Convert an XML element into a [Table][msl.equipment.schema.Table] instance.\n\n    Args:\n        element: A [table][type_table] XML element from an equipment register.\n\n    Returns:\n        A [Table][msl.equipment.schema.Table] is an subclass of a numpy\n            [structured array][structured_arrays], where the `header` is used as\n            the *field names*. This allows for accessing a column by the header value rather than by\n            the index of a column. If you prefer to work with unstructured data, call\n            [unstructured][msl.equipment.schema.Table.unstructured] on the returned object.\n    \"\"\"\n    booleans = {\"True\", \"true\", \"TRUE\", \"1\", b\"True\", b\"true\", b\"TRUE\", b\"1\"}\n\n    def convert_bool(value: str | bytes) -&gt; bool:\n        # the value can be of type bytes for numpy &lt; 2.0\n        return value.strip() in booleans\n\n    def strip_string(value: str | bytes) -&gt; str:\n        # the value can be of type bytes for numpy &lt; 2.0\n        stripped = value.strip()\n        if isinstance(stripped, bytes):\n            return stripped.decode()  # pragma: no cover\n        return stripped\n\n    # Schema forces order\n    _type = [s.strip() for s in (element[0].text or \"\").split(\",\")]\n    _unit = [s.strip() for s in (element[1].text or \"\").split(\",\")]\n    _header = [s.strip() for s in (element[2].text or \"\").split(\",\")]\n    _file = StringIO((element[3].text or \"\").strip())\n\n    # must handle boolean column and string column separately\n    conv: dict[int, Callable[[str | bytes], str | bool]] = {\n        i: convert_bool for i, v in enumerate(_type) if v == \"bool\"\n    }\n    conv.update({i: strip_string for i, v in enumerate(_type) if v == \"string\"})\n\n    dtype = np.dtype([(h, schema_numpy_map[t]) for h, t in zip(_header, _type)])\n    data = np.loadtxt(_file, dtype=dtype, delimiter=\",\", converters=conv)  # type: ignore[arg-type]  # pyright: ignore[reportCallIssue, reportArgumentType, reportUnknownVariableType]\n    data.setflags(write=False)  # pyright: ignore[reportUnknownMemberType]\n\n    header = np.asarray(_header)\n    header.setflags(write=False)  # make it readonly by default\n\n    units = np.asarray(tuple(_unit), np.dtype([(h, object) for h in _header]))\n    units.setflags(write=False)  # make it readonly by default\n\n    assert data.dtype.fields is not None  # pyright: ignore[reportUnknownMemberType]  # noqa: S101\n    types = np.asarray(tuple(v[0] for v in data.dtype.fields.values()), dtype=[(h, object) for h in _header])  # pyright: ignore[reportUnknownMemberType, reportUnknownVariableType, reportUnknownArgumentType]\n    types.setflags(write=False)  # make it readonly by default\n\n    return cls(types=types, units=units, header=header, data=data, comment=element.attrib.get(\"comment\", \"\"))  # pyright: ignore[reportUnknownArgumentType]\n</code></pre>"},{"location":"schema/table/#msl.equipment.schema.Table.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Table class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Table as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Table][msl.equipment.schema.Table] class into an XML element.\n\n    Returns:\n        The [Table][msl.equipment.schema.Table] as an XML element.\n    \"\"\"\n    attrib = {\"comment\": self.comment} if self.comment else {}\n    e = Element(\"table\", attrib=attrib)\n\n    types = SubElement(e, \"type\")\n    dtypes = [numpy_schema_map[t.char] for t in self.types.tolist()]\n    types.text = \",\".join(dtypes)\n\n    units = SubElement(e, \"unit\")\n    units.text = \",\".join(self.units.tolist())\n\n    header = SubElement(e, \"header\")\n    header.text = \",\".join(self.header)\n\n    buffer = StringIO()\n    newline = \"\\n\" + \" \" * _Indent.table_data\n    np.savetxt(buffer, self, fmt=\"%s\", delimiter=\",\", newline=newline)\n    data = SubElement(e, \"data\")\n    data.text = buffer.getvalue().rstrip() + \"\\n\" + \" \" * max(0, _Indent.table_data - len(\"&lt;data&gt;\"))\n\n    return e\n</code></pre>"},{"location":"schema/table/#msl.equipment.schema.Table.unstructured","title":"unstructured","text":"<pre><code>unstructured(\n    *,\n    dtype: DTypeLike = None,\n    copy: bool = False,\n    casting: Literal[\n        \"no\", \"equiv\", \"safe\", \"same_kind\", \"unsafe\"\n    ] = \"unsafe\"\n) -&gt; NDArray[Any]\n</code></pre> <p>Converts the structured array into an unstructured array.</p> <p>See structured_to_unstructured for more details.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>DTypeLike</code> <p>The dtype of the output unstructured array.</p> <code>None</code> <code>copy</code> <code>bool</code> <p>If <code>True</code>, always return a copy. If <code>False</code>, a view is returned if possible.</p> <code>False</code> <code>casting</code> <code>Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe']</code> <p>Controls what kind of data casting may occur. See the casting argument of astype for more details.</p> <code>'unsafe'</code> <p>Returns:</p> Type Description <code>NDArray[Any]</code> <p>The unstructured array. This method may return a numpy ndarray instance instead of a Table instance if the table consists of numbers and strings and the appropriate <code>dtype</code> is not specified.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def unstructured(\n    self,\n    *,\n    dtype: DTypeLike = None,\n    copy: bool = False,\n    casting: Literal[\"no\", \"equiv\", \"safe\", \"same_kind\", \"unsafe\"] = \"unsafe\",\n) -&gt; NDArray[_Any]:\n    \"\"\"Converts the structured array into an unstructured array.\n\n    See [structured_to_unstructured][numpy.lib.recfunctions.structured_to_unstructured]\n    for more details.\n\n    Args:\n        dtype: The _dtype_ of the output unstructured array.\n        copy: If `True`, always return a copy. If `False`, a view is returned if possible.\n        casting: Controls what kind of data casting may occur. See the *casting* argument of\n            [astype][numpy.ndarray.astype] for more details.\n\n    Returns:\n        The unstructured array. This method may return a numpy [ndarray][numpy.ndarray] instance\n            instead of a [Table][msl.equipment.schema.Table] instance if the table consists of\n            numbers and strings and the appropriate `dtype` is not specified.\n    \"\"\"\n    from numpy.lib.recfunctions import structured_to_unstructured  # noqa: PLC0415\n\n    try:\n        return structured_to_unstructured(self, dtype=dtype, copy=copy, casting=casting)\n    except (TypeError, ValueError):\n        return np.array(self.tolist(), dtype=object)\n</code></pre>"}]}