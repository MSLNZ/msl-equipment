{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Info</p> <p>The docs are being rewritten. See here for the old docs.</p> <p>The purpose of <code>msl-equipment</code> is to manage information about equipment and to interface with equipment for computer control. The information that is managed is focused on testing and calibration laboratories that are accredited for the ISO/IEC 17025 standard, but the information may also be selectively specified for laboratories that are not required to meet the standard. See the Getting Started page to learn how information is managed and how equipment is controlled.</p>"},{"location":"#install","title":"Install","text":"<p>The <code>msl-equipment</code> repository is organised as a workspace project that is split across multiple packages: <code>msl-equipment</code>, msl-equipment-resources, msl-equipment-validate, and msl-equipment-webapp.</p> <p>The core package is <code>msl-equipment</code> and it is available through the Python Package Index. It can be installed using a variety of package managers</p> pipuvpoetrypdm <pre><code>pip install msl-equipment\n</code></pre> <pre><code>uv add msl-equipment\n</code></pre> <pre><code>poetry add msl-equipment\n</code></pre> <pre><code>pdm add msl-equipment\n</code></pre>"},{"location":"#dependencies","title":"Dependencies","text":"<p>The <code>msl-equipment</code> package depends on the following packages: msl-loadlib, numpy, pyserial, pyzmq</p> <p>The following packages are optional dependencies that may be installed to interface with equipment: msl-equipment-resources, NI-DAQmx, PyVISA, PyVISA-py</p>"},{"location":"license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2017 - 2025, Measurement Standards Laboratory of New Zealand\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#020-2025-03-28","title":"0.2.0 (2025-03-28)","text":"<p>Added:</p> <ul> <li>support for Python 3.12 and 3.13</li> <li><code>find-equipment</code> console script</li> <li><code>msl.equipment.connection_gpib.ConnectionGPIB</code> class</li> <li><code>msl.equipment.resources.greisinger.gmh3000.GMH3000</code> resource</li> <li><code>msl.equipment.resources.isotech.millik.MilliK</code> resource</li> <li><code>msl.equipment.resources.vaisala.ptu300.PTU300</code> resource</li> <li><code>msl.equipment.resources.vaisala.ptb330.PTB330</code> resource</li> </ul> <p>Fixed:</p> <ul> <li>issue #9 \u2014 Missing functions from Avantes AvaSpec DLL</li> <li>issue #8 \u2014 Invalid URL for LXI XML identification document</li> </ul> <p>Removed:</p> <ul> <li>support for Python 2.7, 3.5, 3.6 and 3.7</li> </ul>"},{"location":"release-notes/#010-2023-06-18","title":"0.1.0 (2023-06-18)","text":"<p>Initial release.</p> <p>It is also the last release to support Python 2.7, 3.5, 3.6 and 3.7</p>"},{"location":"validate/","title":"Validate","text":"<p>You may use any XML validating tool to validate equipment registers and connection files against the schema; however, some of the values of the XML elements are not completely validated by the schema alone. For example, the value of an element in an equipment register could be the SHA-256 checksum of a file. The schema will validate that the SHA-256 checksum value has the correct string length and that the checksum only contains the allowed alphanumeric characters, but, the schema does not validate that the checksum value is correct for the associated file. For these additional validation steps, another tool must be used. The <code>msl-equipment-validate</code> command-line tool validates the XML files against the schema and also provides the additional validation steps.</p>"},{"location":"validate/#validate-install","title":"Install","text":"<p><code>msl-equipment-validate</code> is available on PyPI and can be installed with a variety of Python package managers</p> pippipxuv <pre><code>pip install msl-equipment-validate\n</code></pre> <pre><code>pipx install msl-equipment-validate\n</code></pre> <pre><code>uv tool install msl-equipment-validate\n</code></pre> <p>This will install a command-line tool that you can use to validate the content of equipment registers and connection files.</p> <p>If you used a package manager that does not automatically add the <code>msl-equipment-validate</code> executable to your PATH environment variable (without activating a virtual environment), you may want to add the directory to where the <code>msl-equipment-validate</code> executable is located to your PATH. This will allow you to validate XML documents from any directory without having to first activate a virtual environment.</p>"},{"location":"validate/#command-alias","title":"Command alias","text":"<p>You may also want to create a command alias, since the executable name <code>msl-equipment-validate</code> is rather long. The following assigns an alias <code>check</code> for the <code>msl-equipment-validate</code> executable.</p> UnixWindows <p>Add the following to your <code>.bashrc</code> (or <code>.zshrc</code>) file</p> <pre><code>alias check=\"msl-equipment-validate\"\n</code></pre> <p>You can create an alias in your PowerShell profile script. To determine where this file is located, run the following command from your terminal, e.g., PowerShell or Windows Terminal (not Command Prompt)</p> <pre><code>echo $PROFILE\n</code></pre> <p>Open (or create) the <code>Microsoft.PowerShell_profile.ps1</code> file that was displayed in the previous command in a text editor and add the following line</p> <pre><code>Set-Alias check C:\\Update\\to\\be\\the\\path\\to\\msl-equipment-validate.exe\n</code></pre> <p>save it then open a new terminal (or run <code>. $PROFILE</code> in the current terminal to reload the PowerShell profile).</p> <p>Caution</p> <p>If you get an error that the profile script cannot be loaded because running scripts is disabled on this system, run the following command in an elevated (admin) terminal</p> <pre><code>Set-ExecutionPolicy -ExecutionPolicy RemoteSigned\n</code></pre> <p>then restart the terminal.</p>"},{"location":"validate/#validate-usage","title":"Usage","text":"<p>To see the help for the tool run</p> <pre><code>msl-equipment-validate --help\n</code></pre> <p>To recursively validate all XML files (that are used by <code>msl-equipment</code>) in the current working directory and all sub directories, run the command without arguments</p> <pre><code>msl-equipment-validate\n</code></pre> <p>or specify a specific file to validate</p> <pre><code>msl-equipment-validate my/equipment/register.xml\nmsl-equipment-validate my/equipment/connections.xml\n</code></pre> <p>If the <code>msl-equipment</code> package is also installed, you can use its command-line interface to validate documents. (Note the removal of the hyphen between <code>equipment</code> and <code>validate</code>.)</p> <pre><code>msl-equipment validate\n</code></pre> <p>or to display the help</p> <pre><code>msl-equipment help validate\n</code></pre>"},{"location":"webapp/","title":"Web Application","text":"<p>Info</p> <p>Development on the web application has not started.</p> <p>The web application provides a server for running a website that allows people to search for equipment records with equipment registers and (maybe) to add equipment records to a register.</p>"},{"location":"webapp/#install","title":"Install","text":"<p>Eventually...</p> <pre><code>pip install msl-equipment-webapp\n</code></pre>"},{"location":"api/","title":"API Overview","text":"<p>Although this package contains many classes and functions, the classes that you may typically create instances of are</p> <ul> <li>Config \u2014 if you want to load equipment registers and communicate with equipment</li> <li>Connection \u2014 if you are only interested in communicating with equipment</li> <li>Register \u2014 if you only want to load an equipment register</li> </ul> <p>and there are enumeration classes.</p> <p>Interfaces are available to communicate with equipment, Backends may be used to interface with equipment using external packages and possibly Resources may be available.</p> <p>Tip</p> <p>You do not need to create instances of these communication classes. Calling the Equipment.connect() or Connection.connect() method will automatically use the correct object for communication.</p> <p>If you are using type annotations and/or an editor that supports code completion, you can annotate the type of the returned object to get support for these features, for example,</p> <pre><code>from msl.equipment import GPIB, Connection\n\ndevice: GPIB = Connection(\"GPIB::22\").connect()\n</code></pre> <p>The MSLConnectionError and MSLTimeoutError classes are raised if there are issues when communicating with equipment.</p>"},{"location":"api/config/","title":"Config","text":"<p>A configuration file is useful when you want to perform a measurement.</p>"},{"location":"api/config/#msl.equipment.config.Config","title":"Config","text":"<pre><code>Config(source: XMLSource)\n</code></pre> <p>Load a configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>XMLSource</code> <p>A path-like or file-like object containing the configuration data.</p> required Source code in <code>src/msl/equipment/config.py</code> <pre><code>def __init__(self, source: XMLSource) -&gt; None:  # noqa: C901\n    \"\"\"Load a configuration file.\n\n    Args:\n        source: A [path-like][path-like object] or [file-like][file-like object]\n            object containing the configuration data.\n    \"\"\"\n    logger.debug(\"load configuration %s\", source)\n    self._source: XMLSource = source\n    self._root: Element[str] = parse(source).getroot()  # noqa: S314\n    self._registers: dict[str, Register] | None = None\n    self._config_equipment: ConfigEquipment = ConfigEquipment(self)\n\n    element = self.find(\"gpib_library\")\n    if element is not None and element.text:\n        os.environ[\"GPIB_LIBRARY\"] = element.text\n        logger.debug(\"update GPIB_LIBRARY=%s\", element.text)\n\n    element = self.find(\"pyvisa_library\")\n    if element is not None and element.text:\n        os.environ[\"PYVISA_LIBRARY\"] = element.text\n        logger.debug(\"update PyVISA_LIBRARY=%s\", element.text)\n\n    path_elements = self.findall(\"path\")\n    if path_elements:\n        paths: list[str] = []\n        os_paths: set[str] = set(os.environ[\"PATH\"].split(os.pathsep))\n        for element in path_elements:\n            path = element.text\n            if not path or not os.path.isdir(path):  # noqa: PTH112\n                logger.warning(\"skipped append to PATH: %r\", path)\n            elif element.attrib.get(\"recursive\", \"false\").lower() == \"true\":\n                for directory, _, _ in os.walk(path):\n                    if directory not in os_paths and directory not in paths:\n                        paths.append(directory)\n                        logger.debug(\"append to PATH: %r\", path)\n            elif path not in os_paths and path not in paths:\n                paths.append(path)\n                logger.debug(\"append to PATH: %r\", path)\n\n        os.environ[\"PATH\"] += os.pathsep + os.pathsep.join(paths)\n\n    for element in self.findall(\"connections\"):\n        connections.add(*_sources(element.text, \"connections\"))\n</code></pre>"},{"location":"api/config/#msl.equipment.config.Config.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: ConfigEquipment\n</code></pre> <p>Returns the <code>&lt;equipment/&gt;</code> elements in the configuration file like a sequence of Equipment items.</p> <p>Using the returned object you can access Equipment items by index (based on the order that <code>&lt;equipment/&gt;</code> elements are defined in the configuration file), by the <code>eid</code> attribute value or by the <code>name</code> attribute value. You can also iterate over the Equipment items in the sequence.</p> <p>See here for examples.</p>"},{"location":"api/config/#msl.equipment.config.Config.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>The path to the configuration file.</p>"},{"location":"api/config/#msl.equipment.config.Config.registers","title":"registers  <code>property</code>","text":"<pre><code>registers: dict[str, Register]\n</code></pre> <p>Returns all equipment registers that are specified in the configuration file.</p> <p>The key in the returned dict is the team value of the corresponding Register.</p>"},{"location":"api/config/#msl.equipment.config.Config.root","title":"root  <code>property</code>","text":"<pre><code>root: Element[str]\n</code></pre> <p>The root element (the first node) in the configuration file.</p>"},{"location":"api/config/#msl.equipment.config.Config.attrib","title":"attrib","text":"<pre><code>attrib(path: str) -&gt; dict[str, bool | float | str]\n</code></pre> <p>Get the attributes of the first matching element by tag name or path.</p> <p>If possible, the value is converted to a bool (<code>true</code> or <code>false</code> case-insensitive), an int or a float, otherwise the value remains a str.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Either an element tag name or an XPath.</p> required <p>Returns:</p> Type Description <code>dict[str, bool | float | str]</code> <p>The attributes of the matching <code>path</code> element.</p> Source code in <code>src/msl/equipment/config.py</code> <pre><code>def attrib(self, path: str) -&gt; dict[str, bool | float | str]:\n    \"\"\"Get the attributes of the first matching element by tag name or path.\n\n    If possible, the value is converted to a [bool][] (`true` or `false` case-insensitive),\n    an [int][] or a [float][], otherwise the value remains a [str][].\n\n    Args:\n        path: Either an element tag name or an XPath.\n\n    Returns:\n        The attributes of the matching `path` element.\n    \"\"\"\n    element = self.find(path)\n    if element is None:\n        return {}\n    return {k: to_primitive(v) for k, v in element.attrib.items()}\n</code></pre>"},{"location":"api/config/#msl.equipment.config.Config.find","title":"find","text":"<pre><code>find(path: str) -&gt; Element[str] | None\n</code></pre> <p>Find the first matching element by tag name or path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Either an element tag name or an XPath.</p> required <p>Returns:</p> Type Description <code>Element[str] | None</code> <p>The element or <code>None</code> if an element was not found at <code>path</code>.</p> Source code in <code>src/msl/equipment/config.py</code> <pre><code>def find(self, path: str) -&gt; Element[str] | None:\n    \"\"\"Find the first matching element by tag name or path.\n\n    Args:\n        path: Either an element tag name or an XPath.\n\n    Returns:\n        The element or `None` if an element was not found at `path`.\n    \"\"\"\n    return self._root.find(path)\n</code></pre>"},{"location":"api/config/#msl.equipment.config.Config.findall","title":"findall","text":"<pre><code>findall(path: str) -&gt; list[Element[str]]\n</code></pre> <p>Find all matching sub-elements by tag name or path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Either an element tag name or an XPath.</p> required <p>Returns:</p> Type Description <code>list[Element[str]]</code> <p>All matching elements in document order.</p> Source code in <code>src/msl/equipment/config.py</code> <pre><code>def findall(self, path: str) -&gt; list[Element[str]]:\n    \"\"\"Find all matching sub-elements by tag name or path.\n\n    Args:\n        path: Either an element tag name or an XPath.\n\n    Returns:\n        All matching elements in document order.\n    \"\"\"\n    return self._root.findall(path)\n</code></pre>"},{"location":"api/config/#msl.equipment.config.Config.value","title":"value","text":"<pre><code>value(\n    path: str, default: None = None\n) -&gt; bool | float | str | None\n</code></pre><pre><code>value(path: str, default: bool) -&gt; bool\n</code></pre><pre><code>value(path: str, default: int) -&gt; int\n</code></pre><pre><code>value(path: str, default: float) -&gt; float\n</code></pre><pre><code>value(path: str, default: str) -&gt; str\n</code></pre> <pre><code>value(\n    path: str, default: bool | float | str | None = None\n) -&gt; bool | float | str | None\n</code></pre> <p>Gets the value (text) associated with the first matching element.</p> <p>If possible, the value is converted to a bool (<code>true</code> or <code>false</code> case-insensitive), an int or a float, otherwise the value remains a str.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Either an element tag name or an XPath.</p> required <code>default</code> <code>bool | float | str | None</code> <p>The default value if an element cannot be found.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | float | str | None</code> <p>The value of the element or <code>default</code> if an element was not found at <code>path</code>.</p> Source code in <code>src/msl/equipment/config.py</code> <pre><code>def value(self, path: str, default: bool | float | str | None = None) -&gt; bool | float | str | None:  # noqa: FBT001\n    \"\"\"Gets the value (text) associated with the first matching element.\n\n    If possible, the value is converted to a [bool][] (`true` or `false` case-insensitive),\n    an [int][] or a [float][], otherwise the value remains a [str][].\n\n    Args:\n        path: Either an element tag name or an XPath.\n        default: The default value if an element cannot be found.\n\n    Returns:\n        The value of the element or `default` if an element was not found at `path`.\n    \"\"\"\n    element = self.find(path)\n    if element is None:\n        return default\n    if element.text is None:\n        return None\n    return to_primitive(element.text)\n</code></pre>"},{"location":"api/config/#msl.equipment.config.ConfigEquipment","title":"ConfigEquipment","text":"<pre><code>ConfigEquipment(cfg: Config)\n</code></pre> <p>Access <code>&lt;equipment/&gt;</code> elements in a configuration file like a sequence of Equipment items.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>Config</code> <p>The configuration instance.</p> required Source code in <code>src/msl/equipment/config.py</code> <pre><code>def __init__(self, cfg: Config) -&gt; None:\n    \"\"\"Access `&lt;equipment/&gt;` elements in a configuration file like a sequence of [Equipment][] items.\n\n    Args:\n        cfg: The configuration instance.\n    \"\"\"\n    self._cfg: Config = cfg\n    self._elements: list[Element[str]] = cfg.findall(\"equipment\")\n    self._equipment: dict[str, Equipment] = {}  # key=eid\n    self._index_map: dict[int, str] = {i: e.attrib[\"eid\"] for i, e in enumerate(self._elements)}\n    self._name_map: dict[str, str] = {\n        e.attrib[\"name\"]: e.attrib[\"eid\"] for e in self._elements if e.attrib.get(\"name\")\n    }\n</code></pre>"},{"location":"api/config/#msl.equipment.config.ConfigEquipment.eids","title":"eids  <code>property</code>","text":"<pre><code>eids: tuple[str, ...]\n</code></pre> <p>Returns the value of the <code>eid</code> attribute for each <code>&lt;equipment/&gt;</code> element in a configuration file.</p>"},{"location":"api/config/#msl.equipment.config.ConfigEquipment.names","title":"names  <code>property</code>","text":"<pre><code>names: tuple[str, ...]\n</code></pre> <p>Returns the value of the <code>name</code> attribute for each <code>&lt;equipment/&gt;</code> element in a configuration file.</p>"},{"location":"api/connection/","title":"Connection","text":""},{"location":"api/connection/#msl.equipment.schema.Connection","title":"Connection","text":"<pre><code>Connection(\n    address: str,\n    *,\n    backend: (\n        Literal[\"MSL\", \"PyVISA\", \"NIDAQ\"] | Backend\n    ) = MSL,\n    eid: str = \"\",\n    manufacturer: str = \"\",\n    model: str = \"\",\n    serial: str = \"\",\n    **properties: Any\n)\n</code></pre> <p>Information about how to interface with equipment.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The VISA-style address of the connection (see here for examples).</p> required <code>backend</code> <code>Literal['MSL', 'PyVISA', 'NIDAQ'] | Backend</code> <p>The backend to use to communicate with the equipment.</p> <code>MSL</code> <code>eid</code> <code>str</code> <p>The equipment id to associate with the Connection instance.</p> <code>''</code> <code>manufacturer</code> <code>str</code> <p>The name of the manufacturer of the equipment.</p> <code>''</code> <code>model</code> <code>str</code> <p>The model number of the equipment.</p> <code>''</code> <code>serial</code> <code>str</code> <p>The serial number (or unique identifier) of the equipment.</p> <code>''</code> <code>properties</code> <code>Any</code> <p>Additional key-value pairs to use when communicating with the equipment. For example, the baud_rate and parity values for an RS-232 connection.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(  # noqa: PLR0913\n    self,\n    address: str,\n    *,\n    backend: Literal[\"MSL\", \"PyVISA\", \"NIDAQ\"] | Backend = Backend.MSL,\n    eid: str = \"\",\n    manufacturer: str = \"\",\n    model: str = \"\",\n    serial: str = \"\",\n    **properties: _Any,  # noqa: ANN401\n) -&gt; None:\n    \"\"\"Information about how to interface with equipment.\n\n    Args:\n        address: The VISA-style address of the connection (see [here][address-syntax] for examples).\n        backend: The [backend][msl.equipment.enumerations.Backend] to use to communicate with the equipment.\n        eid: The [equipment id][msl.equipment.schema.Equipment.id] to associate with the [Connection][] instance.\n        manufacturer: The name of the manufacturer of the equipment.\n        model: The model number of the equipment.\n        serial: The serial number (or unique identifier) of the equipment.\n        properties: Additional key-value pairs to use when communicating with the equipment.\n            For example, the _baud_rate_ and _parity_ values for an _RS-232_ connection.\n    \"\"\"\n    self.address: str = address\n    \"\"\"The VISA-style address of the connection (see [here][address-syntax] for examples).\"\"\"\n\n    self.backend: Backend = Backend(backend)\n    \"\"\"The [backend][msl.equipment.enumerations.Backend] that is used to communicate with the equipment.\"\"\"\n\n    self.eid: str = eid\n    \"\"\"The [equipment id][msl.equipment.schema.Equipment.id] associated with the [Connection][] instance.\"\"\"\n\n    self.manufacturer: str = manufacturer\n    \"\"\"The name of the manufacturer of the equipment.\"\"\"\n\n    self.model: str = model\n    \"\"\"The model number of the equipment.\"\"\"\n\n    # check for a properties key being explicitly defined and the value is a dict\n    properties = (  # pyright: ignore[reportUnknownVariableType]\n        properties[\"properties\"]\n        if (\"properties\" in properties and isinstance(properties[\"properties\"], dict))\n        else properties\n    )\n\n    self.properties: dict[str, _Any] = properties\n    \"\"\"Additional key-value pairs to use when communicating with the equipment.\n\n    For example, the _baud_rate_ and _parity_ values for an _RS-232_ connection.\n    \"\"\"\n\n    self.serial: str = serial\n    \"\"\"The serial number (or unique identifier) of the equipment.\"\"\"\n</code></pre>"},{"location":"api/connection/#msl.equipment.schema.Connection.address","title":"address  <code>instance-attribute</code>","text":"<pre><code>address: str = address\n</code></pre> <p>The VISA-style address of the connection (see here for examples).</p>"},{"location":"api/connection/#msl.equipment.schema.Connection.backend","title":"backend  <code>instance-attribute</code>","text":"<pre><code>backend: Backend = Backend(backend)\n</code></pre> <p>The backend that is used to communicate with the equipment.</p>"},{"location":"api/connection/#msl.equipment.schema.Connection.eid","title":"eid  <code>instance-attribute</code>","text":"<pre><code>eid: str = eid\n</code></pre> <p>The equipment id associated with the Connection instance.</p>"},{"location":"api/connection/#msl.equipment.schema.Connection.manufacturer","title":"manufacturer  <code>instance-attribute</code>","text":"<pre><code>manufacturer: str = manufacturer\n</code></pre> <p>The name of the manufacturer of the equipment.</p>"},{"location":"api/connection/#msl.equipment.schema.Connection.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model: str = model\n</code></pre> <p>The model number of the equipment.</p>"},{"location":"api/connection/#msl.equipment.schema.Connection.properties","title":"properties  <code>instance-attribute</code>","text":"<pre><code>properties: dict[str, Any] = properties\n</code></pre> <p>Additional key-value pairs to use when communicating with the equipment.</p> <p>For example, the baud_rate and parity values for an RS-232 connection.</p>"},{"location":"api/connection/#msl.equipment.schema.Connection.serial","title":"serial  <code>instance-attribute</code>","text":"<pre><code>serial: str = serial\n</code></pre> <p>The serial number (or unique identifier) of the equipment.</p>"},{"location":"api/connection/#msl.equipment.schema.Connection.connect","title":"connect","text":"<pre><code>connect() -&gt; Any\n</code></pre> <p>Connect to the equipment.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def connect(self) -&gt; _Any:  # noqa: ANN401\n    \"\"\"Connect to the equipment.\"\"\"\n    equipment = Equipment(\n        id=self.eid,\n        manufacturer=self.manufacturer,\n        model=self.model,\n        serial=self.serial,\n        connection=self,\n    )\n    return equipment.connect()\n</code></pre>"},{"location":"api/enumerations/","title":"enumerations","text":"<p>Enumeration constants.</p>"},{"location":"api/enumerations/#msl.equipment.enumerations.Backend","title":"Backend","text":"<p>               Bases: <code>Enum</code></p> <p>The backend library to use for communication with the equipment.</p> <p>Attributes:</p> Name Type Description <code>MSL</code> <code>str</code> <p>\"MSL\"</p> <code>PyVISA</code> <code>str</code> <p>\"PyVISA\"</p> <code>NIDAQ</code> <code>str</code> <p>\"NIDAQ\"</p>"},{"location":"api/enumerations/#msl.equipment.enumerations.DataBits","title":"DataBits","text":"<p>               Bases: <code>IntEnum</code></p> <p>The number of data bits to use for Serial communication.</p> <p>Attributes:</p> Name Type Description <code>FIVE</code> <code>int</code> <p>5</p> <code>SIX</code> <code>int</code> <p>6</p> <code>SEVEN</code> <code>int</code> <p>7</p> <code>EIGHT</code> <code>int</code> <p>8</p>"},{"location":"api/enumerations/#msl.equipment.enumerations.Parity","title":"Parity","text":"<p>               Bases: <code>Enum</code></p> <p>The parity type to use for Serial communication.</p> <p>Attributes:</p> Name Type Description <code>NONE</code> <code>str</code> <p>\"N\"</p> <code>ODD</code> <code>str</code> <p>\"O\"</p> <code>EVEN</code> <code>str</code> <p>\"E\"</p> <code>MARK</code> <code>str</code> <p>\"M\"\"</p> <code>SPACE</code> <code>str</code> <p>\"S\"</p>"},{"location":"api/enumerations/#msl.equipment.enumerations.StopBits","title":"StopBits","text":"<p>               Bases: <code>Enum</code></p> <p>The number of stop bits to use for Serial communication.</p> <p>Attributes:</p> Name Type Description <code>ONE</code> <code>int</code> <p>1</p> <code>ONE_POINT_FIVE</code> <code>float</code> <p>1.5</p> <code>TWO</code> <code>int</code> <p>2</p>"},{"location":"api/exceptions/","title":"exceptions","text":""},{"location":"api/exceptions/#msl.equipment.interfaces.message_based.MSLConnectionError","title":"MSLConnectionError","text":"<pre><code>MSLConnectionError(interface: Interface, message: str)\n</code></pre> <p>               Bases: <code>OSError</code></p> <p>Base class for connection-related exceptions.</p> <p>Parameters:</p> Name Type Description Default <code>interface</code> <code>Interface</code> <p>An interface subclass.</p> required <code>message</code> <code>str</code> <p>A message to append to the generic error message.</p> required Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def __init__(self, interface: Interface, message: str) -&gt; None:\n    \"\"\"Base class for connection-related exceptions.\n\n    Args:\n        interface: An interface subclass.\n        message: A message to append to the generic error message.\n    \"\"\"\n    logger.error(\"%r %s\", interface, message)\n    super().__init__(f\"{interface!r}\\n{message}\")\n</code></pre>"},{"location":"api/exceptions/#msl.equipment.interfaces.message_based.MSLTimeoutError","title":"MSLTimeoutError","text":"<pre><code>MSLTimeoutError(interface: MessageBased, message: str = '')\n</code></pre> <p>               Bases: <code>TimeoutError</code></p> <p>A timeout exception for I/O operations.</p> <p>Parameters:</p> Name Type Description Default <code>interface</code> <code>MessageBased</code> <p>A message-based interface subclass.</p> required <code>message</code> <code>str</code> <p>An optional message to append to the generic timeout error message.</p> <code>''</code> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def __init__(self, interface: MessageBased, message: str = \"\") -&gt; None:\n    \"\"\"A timeout exception for I/O operations.\n\n    Args:\n        interface: A message-based interface subclass.\n        message: An optional message to append to the generic timeout error message.\n    \"\"\"\n    msg = f\"Timeout occurred after {interface.timeout} second(s). {message}\"\n    logger.error(\"%r %s\", interface, msg)\n    super().__init__(f\"{interface!r}\\n{msg}\")\n</code></pre>"},{"location":"api/types/","title":"types","text":"<p>Custom type annotations.</p>"},{"location":"api/types/#msl.equipment._types.EnumType","title":"EnumType  <code>module-attribute</code>","text":"<pre><code>EnumType = TypeVar('EnumType', bound=Enum)\n</code></pre> <p>An Enum subclass.</p>"},{"location":"api/types/#msl.equipment._types.MessageDataType","title":"MessageDataType  <code>module-attribute</code>","text":"<pre><code>MessageDataType = (\n    type[int] | type[float] | str | type[number]\n)\n</code></pre> <p>Data type to use to read(write) bytes from(to) equipment.</p> <p>The data type to use to convert each element in Sequence1D to. If MessageFormat is <code>ascii</code> then <code>dtype</code> must be of type str and it is used as the <code>format_spec</code> argument in format to first convert each element in Sequence1D to a string, and then it is encoded (e.g., <code>'.2e'</code> converts each element to scientific notation with two digits after the decimal point). If the data type includes a byte-order character, it is ignored. For all other values of MessageFormat, the data type can be any object that numpy.dtype supports (e.g., <code>'H'</code>, <code>'uint16'</code> and numpy.ushort are equivalent values to convert each element to an unsigned short). If a byte-order character is specified then it is used, otherwise the native byte order of the CPU architecture is used. See struct-format-strings for more details.</p>"},{"location":"api/types/#msl.equipment._types.MessageFormat","title":"MessageFormat  <code>module-attribute</code>","text":"<pre><code>MessageFormat = Literal['ascii', 'hp', 'ieee'] | None\n</code></pre> <p>Format to use to read(write) bytes from(to) equipment.</p> <p>Possible values are:</p> <ul> <li> <p><code>None</code> \u2014 do not use a header.</p> <p>Format</p> <p><code>&lt;byte&gt;&lt;byte&gt;&lt;byte&gt;...</code></p> </li> <li> <p><code>ascii</code> \u2014 comma-separated ASCII characters, see the         <code>&lt;PROGRAM DATA SEPARATOR&gt;</code> standard that is defined in Section 7.4.2.2 of         IEEE 488.2-1992.</p> <p>Format</p> <p><code>&lt;string&gt;,&lt;string&gt;,&lt;string&gt;,...</code></p> </li> <li> <p><code>ieee</code> \u2014 arbitrary block data for <code>SCPI</code> messages, see the         <code>&lt;DEFINITE LENGTH ARBITRARY BLOCK RESPONSE DATA&gt;</code> standard that is defined in         Section 8.7.9 of IEEE 488.2-1992.</p> <p>Format</p> <p><code>#&lt;length of num bytes value&gt;&lt;num bytes&gt;&lt;byte&gt;&lt;byte&gt;&lt;byte&gt;...</code></p> </li> <li> <p><code>hp</code> \u2014 the HP-IB data transfer standard, i.e., the <code>FORM#</code> command         option. See the programming guide for an         HP 8530A         for more details.</p> <p>Format</p> <p><code>#A&lt;num bytes as uint16&gt;&lt;byte&gt;&lt;byte&gt;&lt;byte&gt;...</code></p> </li> </ul>"},{"location":"api/types/#msl.equipment._types.NumpyArray1D","title":"NumpyArray1D  <code>module-attribute</code>","text":"<pre><code>NumpyArray1D = ndarray[tuple[int], dtype[number]]\n</code></pre> <p>A 1-dimensional numpy.array of numbers.</p>"},{"location":"api/types/#msl.equipment._types.PathLike","title":"PathLike  <code>module-attribute</code>","text":"<pre><code>PathLike = Union[str, bytes, PathLike[str], PathLike[bytes]]\n</code></pre> <p>A path-like object.</p>"},{"location":"api/types/#msl.equipment._types.Sequence1D","title":"Sequence1D  <code>module-attribute</code>","text":"<pre><code>Sequence1D = Sequence[float] | NumpyArray1D\n</code></pre> <p>A 1-dimensional sequence of numbers.</p>"},{"location":"api/types/#msl.equipment._types.XMLSource","title":"XMLSource  <code>module-attribute</code>","text":"<pre><code>XMLSource = Union[\n    int, PathLike, SupportsRead[bytes] | SupportsRead[str]\n]\n</code></pre> <p>A path-like object or a file-like object for parsing XML content.</p>"},{"location":"api/types/#msl.equipment._types.SupportsRead","title":"SupportsRead","text":"<p>               Bases: <code>Protocol[_T_co]</code></p> <p>A file-like object that has a <code>read</code> method.</p>"},{"location":"api/types/#msl.equipment._types.SupportsRead.read","title":"read","text":"<pre><code>read(size: int | None = -1) -&gt; _T_co\n</code></pre> <p>Read from the stream.</p> Source code in <code>src/msl/equipment/_types.py</code> <pre><code>def read(self, size: int | None = -1, /) -&gt; _T_co:\n    \"\"\"Read from the stream.\"\"\"\n    ...\n</code></pre>"},{"location":"api/backends/","title":"Backends","text":"<p>The following classes may be used to interface with equipment using external packages</p> <ul> <li>NIDAQ \u2014 Use the NIDAQmx package to establish a connection to the equipment</li> <li>PyVISA \u2014 Use the PyVISA package to establish a connection to the equipment</li> </ul>"},{"location":"api/backends/nidaq/","title":"NIDAQ","text":""},{"location":"api/backends/nidaq/#msl.equipment.interfaces.nidaq.NIDAQ","title":"NIDAQ","text":"<pre><code>NIDAQ(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Use NI-DAQmx as the backend to communicate with the equipment.</p> <p>The backend value must be equal to <code>NIDAQ</code> to use this class for the communication backend.</p> <p>The returned object from calling the connect method is equivalent to importing the NI-DAQmx package, e.g.,</p> <pre><code>from msl.equipment import Backend, Connection\n\nconnection = Connection(address=\"Dev1\", backend=Backend.NIDAQ)\nnidaqmx = connection.connect()\n\nwith nidaqmx.Task() as task:\n    task.ai_channels.add_ai_voltage_chan(f\"{nidaqmx.address}/ai0\")\n    voltage = task.read()\n</code></pre> <p>is equivalent to</p> <pre><code>import nidaqmx\n\nwith nidaqmx.Task() as task:\n    task.ai_channels.add_ai_voltage_chan(\"Dev1/ai0\")\n    voltage = task.read()\n</code></pre> <p>You can also combine the packages, use <code>msl-equipment</code> for managing information about the equipment and directly use <code>nidaqmx</code> for the connection. If you use this combination, the editor you use to develop your code may have better support for features like code completion and type checking.</p> <pre><code>import nidaqmx\nfrom msl.equipment import Config\n\n# config.xml contains &lt;equipment eid=\"MSLE.0.142\" name=\"daq\" manufacturer=\"NI\"/&gt;\n# and specifies where the equipment registers are and the connections file.\ncfg = Config(\"config.xml\")\nequipment = cfg.equipment[\"daq\"]\naddress = equipment.connection.address\n\nwith nidaqmx.Task() as task:\n    task.ai_channels.add_ai_voltage_chan(f\"{address}/ai0\")\n    voltage = task.read()\n\n    # You could now use the `equipment` instance to apply a correction to the `voltage`\n</code></pre> <p>See the examples on the NI-DAQmx repository to learn how to use the <code>nidaqmx</code> package.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>src/msl/equipment/interfaces/nidaq.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Use [NI-DAQmx] as the backend to communicate with the equipment.\n\n    The [backend][msl.equipment.schema.Connection.backend] value must be equal\n    to `NIDAQ` to use this class for the communication backend.\n\n    The returned object from calling the [connect][msl.equipment.schema.Equipment.connect]\n    method is equivalent to importing the [NI-DAQmx] package, e.g.,\n\n    ```python\n    from msl.equipment import Backend, Connection\n\n    connection = Connection(address=\"Dev1\", backend=Backend.NIDAQ)\n    nidaqmx = connection.connect()\n\n    with nidaqmx.Task() as task:\n        task.ai_channels.add_ai_voltage_chan(f\"{nidaqmx.address}/ai0\")\n        voltage = task.read()\n    ```\n\n    is equivalent to\n\n    ```python\n    import nidaqmx\n\n    with nidaqmx.Task() as task:\n        task.ai_channels.add_ai_voltage_chan(\"Dev1/ai0\")\n        voltage = task.read()\n    ```\n\n    You can also combine the packages, use `msl-equipment` for managing information\n    about the equipment and directly use `nidaqmx` for the connection. If you use this\n    combination, the editor you use to develop your code may have better support for\n    features like code completion and type checking.\n\n    ```python\n    import nidaqmx\n    from msl.equipment import Config\n\n    # config.xml contains &lt;equipment eid=\"MSLE.0.142\" name=\"daq\" manufacturer=\"NI\"/&gt;\n    # and specifies where the equipment registers are and the connections file.\n    cfg = Config(\"config.xml\")\n    equipment = cfg.equipment[\"daq\"]\n    address = equipment.connection.address\n\n    with nidaqmx.Task() as task:\n        task.ai_channels.add_ai_voltage_chan(f\"{address}/ai0\")\n        voltage = task.read()\n\n        # You could now use the `equipment` instance to apply a correction to the `voltage`\n    ```\n\n    See the [examples](https://github.com/ni/nidaqmx-python/tree/master/examples)\n    on the [NI-DAQmx repository](https://github.com/ni/nidaqmx-python) to learn\n    how to use the `nidaqmx` package.\n\n    [NI-DAQmx]: https://nidaqmx-python.readthedocs.io/en/stable/index.html\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"\n    super().__init__(equipment)\n\n    if nidaqmx is None:  # pragma: no branch\n        msg = \"nidaqmx is not installed, run: pip install nidaqmx\"\n        raise RuntimeError(msg)\n</code></pre>"},{"location":"api/backends/nidaq/#msl.equipment.interfaces.nidaq.NIDAQ.address","title":"address  <code>property</code>","text":"<pre><code>address: str\n</code></pre> <p>Returns the address of the Connection.</p>"},{"location":"api/backends/nidaq/#msl.equipment.interfaces.nidaq.NIDAQ.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/backends/nidaq/#msl.equipment.interfaces.nidaq.NIDAQ.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the equipment.</p> <p>This method can be overridden in the subclass if the subclass must implement tasks that need to be performed in order to safely disconnect from the equipment.</p> <p>For example,</p> <ul> <li>to clean up system resources from memory (e.g., if using a manufacturer's SDK)</li> <li>to configure the equipment to be in a state that is safe for people   working in the lab when the equipment is not in use</li> </ul> <p>Tip</p> <p>This method gets called automatically when the Interface instance gets garbage collected, which happens when the reference count is 0.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from the equipment.\n\n    This method can be overridden in the subclass if the subclass must implement\n    tasks that need to be performed in order to safely disconnect from the equipment.\n\n    For example,\n\n    * to clean up system resources from memory (e.g., if using a manufacturer's SDK)\n    * to configure the equipment to be in a state that is safe for people\n      working in the lab when the equipment is not in use\n\n    !!! tip\n        This method gets called automatically when the [Interface][msl.equipment.schema.Interface]\n        instance gets garbage collected, which happens when the reference count is 0.\n    \"\"\"\n    logger.debug(\"Disconnected from %r\", self)\n</code></pre>"},{"location":"api/backends/pyvisa/","title":"PyVISA","text":""},{"location":"api/backends/pyvisa/#msl.equipment.interfaces.pyvisa.PyVISA","title":"PyVISA","text":"<pre><code>PyVISA(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Use PyVISA as the backend to communicate with the equipment.</p> <p>The backend value must be equal to <code>PyVISA</code> to use this class for the communication backend.</p> <p>The <code>PYVISA_LIBRARY</code> environment variable is used (if it exists) to create the ResourceManager. This environment variable can be defined in a configuration file or by defining the environment variable in your code before connecting to the equipment using PyVISA for the first time. The default value is <code>@ivi</code> if this environment variable is not defined.</p> <p>The returned object using <code>msl-equipment</code> to connect to the equipment is equivalent to calling open_resource, e.g.,</p> <pre><code>from msl.equipment import Backend, Connection\n\nconnection = Connection(\"GPIB::12\", backend=Backend.PyVISA)\ninst = connection.connect()\nprint(inst.query(\"*IDN?\"))\n</code></pre> <p>is equivalent to</p> <pre><code>import pyvisa\n\nrm = pyvisa.ResourceManager()\ninst = rm.open_resource(\"GPIB::12\")\nprint(inst.query(\"*IDN?\"))\n</code></pre> <p>You can also combine the packages, use <code>msl-equipment</code> for managing information about the equipment and directly use <code>pyvisa</code> for the connection. If you use this combination, the editor you use to develop your code may have better support for features like code completion and type checking.</p> <pre><code>import pyvisa\nfrom msl.equipment import Config\n\n# config.xml contains &lt;equipment eid=\"MSLE.0.063\" name=\"dmm\"/&gt;\n# and specifies where the equipment registers are and the connections file.\ncfg = Config(\"config.xml\")\nequipment = cfg.equipment[\"dmm\"]\n\nrm = pyvisa.ResourceManager()\ninst = rm.open_resource(equipment.connection.address)\ndata = inst.query(\"READ?\")\n\n# You could now use the `equipment` instance to apply a correction to the `data`\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>src/msl/equipment/interfaces/pyvisa.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Use [PyVISA] as the backend to communicate with the equipment.\n\n    The [backend][msl.equipment.schema.Connection.backend] value must be equal to\n    `PyVISA` to use this class for the communication backend.\n\n    The `PYVISA_LIBRARY` environment variable is used (if it exists) to create the\n    [ResourceManager][pyvisa.highlevel.ResourceManager]. This environment variable\n    can be defined in a [configuration file][config-xml-example] or by defining the\n    environment variable in your code before connecting to the equipment using\n    [PyVISA][msl.equipment.interfaces.pyvisa.PyVISA] for the first time. The default\n    value is `@ivi` if this environment variable is not defined.\n\n    The returned object using `msl-equipment` to connect to the equipment is equivalent\n    to calling [open_resource][pyvisa.highlevel.ResourceManager.open_resource], e.g.,\n\n    ```python\n    from msl.equipment import Backend, Connection\n\n    connection = Connection(\"GPIB::12\", backend=Backend.PyVISA)\n    inst = connection.connect()\n    print(inst.query(\"*IDN?\"))\n    ```\n\n    is equivalent to\n\n    ```python\n    import pyvisa\n\n    rm = pyvisa.ResourceManager()\n    inst = rm.open_resource(\"GPIB::12\")\n    print(inst.query(\"*IDN?\"))\n    ```\n\n    You can also combine the packages, use `msl-equipment` for managing information\n    about the equipment and directly use `pyvisa` for the connection. If you use this\n    combination, the editor you use to develop your code may have better support for\n    features like code completion and type checking.\n\n    ```python\n    import pyvisa\n    from msl.equipment import Config\n\n    # config.xml contains &lt;equipment eid=\"MSLE.0.063\" name=\"dmm\"/&gt;\n    # and specifies where the equipment registers are and the connections file.\n    cfg = Config(\"config.xml\")\n    equipment = cfg.equipment[\"dmm\"]\n\n    rm = pyvisa.ResourceManager()\n    inst = rm.open_resource(equipment.connection.address)\n    data = inst.query(\"READ?\")\n\n    # You could now use the `equipment` instance to apply a correction to the `data`\n    ```\n\n    [PyVISA]: https://pyvisa.readthedocs.io/en/stable/\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"\n    self._resource: Resource | None = None\n    super().__init__(equipment)\n\n    if pyvisa is None:  # pragma: no branch\n        msg = \"pyvisa is not installed, run: pip install pyvisa\"  # type: ignore[unreachable]\n        raise RuntimeError(msg)\n\n    assert equipment.connection is not None  # noqa: S101\n    kwargs = _prepare_kwargs(equipment.connection.properties)\n\n    if PyVISA.rm is None:\n        PyVISA.rm = pyvisa.ResourceManager()\n\n    self._resource = PyVISA.rm.open_resource(equipment.connection.address, **kwargs)\n</code></pre>"},{"location":"api/backends/pyvisa/#msl.equipment.interfaces.pyvisa.PyVISA.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/backends/pyvisa/#msl.equipment.interfaces.pyvisa.PyVISA.rm","title":"rm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rm: ResourceManager | None = None\n</code></pre> <p>PyVISA Resource Manager.</p>"},{"location":"api/backends/pyvisa/#msl.equipment.interfaces.pyvisa.PyVISA.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Calls pyvisa.resources.Resource.close.</p> Source code in <code>src/msl/equipment/interfaces/pyvisa.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Calls [pyvisa.resources.Resource.close][].\"\"\"\n    if self._resource is not None:\n        self._resource.close()\n        logger.debug(\"Disconnected from %s\", self)\n        self._resource = None\n    super().disconnect()\n</code></pre>"},{"location":"api/interfaces/","title":"Interfaces","text":"<p>Generic interface classes for computer control</p> <ul> <li>Interface \u2014 Base class for all interfaces</li> <li>MessageBased \u2014 Base class for all message-based interfaces</li> </ul>"},{"location":"api/interfaces/#msl.equipment.schema.Interface","title":"Interface","text":"<pre><code>Interface(equipment: Equipment)\n</code></pre> <p>Base class for all interfaces.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Base class for all interfaces.\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"\n    assert equipment.connection is not None  # noqa: S101\n    self._equipment: Equipment = equipment\n\n    # __str__ and __repr__ can be called often for logging message, cache values\n    self.__str: str = f\"{self.__class__.__name__}&lt;{equipment.manufacturer}|{equipment.model}|{equipment.serial}&gt;\"\n    self.__repr: str = (\n        f\"{self.__class__.__name__}\"\n        f\"&lt;{equipment.manufacturer}|{equipment.model}|{equipment.serial} at {equipment.connection.address}&gt;\"\n    )\n\n    logger.debug(\"Connecting to %r\", self)\n</code></pre>"},{"location":"api/interfaces/#msl.equipment.schema.Interface.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/#msl.equipment.schema.Interface.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the equipment.</p> <p>This method can be overridden in the subclass if the subclass must implement tasks that need to be performed in order to safely disconnect from the equipment.</p> <p>For example,</p> <ul> <li>to clean up system resources from memory (e.g., if using a manufacturer's SDK)</li> <li>to configure the equipment to be in a state that is safe for people   working in the lab when the equipment is not in use</li> </ul> <p>Tip</p> <p>This method gets called automatically when the Interface instance gets garbage collected, which happens when the reference count is 0.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from the equipment.\n\n    This method can be overridden in the subclass if the subclass must implement\n    tasks that need to be performed in order to safely disconnect from the equipment.\n\n    For example,\n\n    * to clean up system resources from memory (e.g., if using a manufacturer's SDK)\n    * to configure the equipment to be in a state that is safe for people\n      working in the lab when the equipment is not in use\n\n    !!! tip\n        This method gets called automatically when the [Interface][msl.equipment.schema.Interface]\n        instance gets garbage collected, which happens when the reference count is 0.\n    \"\"\"\n    logger.debug(\"Disconnected from %r\", self)\n</code></pre>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased","title":"MessageBased","text":"<pre><code>MessageBased(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Base class for equipment that use message-based communication.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for message-based communication.</p> <p>Connection Properties:</p> Name Type Description <code>encoding</code> <code>str</code> <p>Encoding to used for read and write operations. Default: <code>utf-8</code></p> <code>max_read_size</code> <code>int</code> <p>Maximum number of bytes that can be read. Default: <code>1048576</code> (1 MB)</p> <code>read_termination</code> <code>bytes | str</code> <p>Termination character(s) to use for read messages. Default: <code>\\n</code></p> <code>rstrip</code> <code>bool</code> <p>Whether to remove trailing whitespace from read messages. Default: <code>False</code></p> <code>termination</code> <code>bytes | str</code> <p>Sets both <code>read_termination</code> and <code>write_termination</code> to the same termination character(s).</p> <code>timeout</code> <code>float | None</code> <p>Timeout, in seconds, for read and write operations. Default: <code>None</code></p> <code>write_termination</code> <code>bytes | str</code> <p>Termination character(s) to use for write messages. Default: <code>\\r\\n</code></p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    r\"\"\"Base class for equipment that use message-based communication.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following\n    _properties_ for message-based communication.\n\n    Attributes: Connection Properties:\n        encoding (str): Encoding to used for\n            [read][msl.equipment.interfaces.message_based.MessageBased.read] and\n            [write][msl.equipment.interfaces.message_based.MessageBased.write] operations.\n            _Default: `utf-8`_\n        max_read_size (int): Maximum number of bytes that can be\n            [read][msl.equipment.interfaces.message_based.MessageBased.read].\n            _Default: `1048576` (1 MB)_\n        read_termination (bytes | str): Termination character(s) to use for\n            [read][msl.equipment.interfaces.message_based.MessageBased.read] messages.\n            _Default: `\\n`_\n        rstrip (bool): Whether to remove trailing whitespace from\n            [read][msl.equipment.interfaces.message_based.MessageBased.read] messages.\n            _Default: `False`_\n        termination (bytes | str): Sets both `read_termination` and `write_termination`\n            to the same termination character(s).\n        timeout (float | None): Timeout, in seconds, for\n            [read][msl.equipment.interfaces.message_based.MessageBased.read] and\n            [write][msl.equipment.interfaces.message_based.MessageBased.write] operations.\n            _Default: `None`_\n        write_termination (bytes | str): Termination character(s) to use for\n            [write][msl.equipment.interfaces.message_based.MessageBased.write] messages.\n            _Default: `\\r\\n`_\n    \"\"\"\n    super().__init__(equipment)\n    assert equipment.connection is not None  # noqa: S101\n\n    self._encoding: str = \"utf-8\"\n    self._read_termination: bytes | None = None\n    self._write_termination: bytes | None = None\n    self._max_read_size: int = 1048576  # 1 &lt;&lt; 20 (1 MB)\n    self._timeout: float | None = None\n    self._rstrip: bool = False\n\n    p = equipment.connection.properties\n\n    self.max_read_size = p.get(\"max_read_size\", self._max_read_size)\n    self.timeout = p.get(\"timeout\", self._timeout)\n    self.encoding = p.get(\"encoding\", self._encoding)\n    self.rstrip = p.get(\"rstrip\", self._rstrip)\n\n    if \"termination\" in p:\n        self.read_termination = p[\"termination\"]\n        self.write_termination = p[\"termination\"]\n    else:\n        self.read_termination = p.get(\"read_termination\", b\"\\n\")\n        self.write_termination = p.get(\"write_termination\", b\"\\r\\n\")\n</code></pre>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.read_termination","title":"read_termination  <code>property</code> <code>writable</code>","text":"<pre><code>read_termination: bytes | None\n</code></pre> <p>The termination character sequence that is used for a read operation.</p> <p>Reading stops when the equipment stops sending data or the <code>read_termination</code> character sequence is detected. If you set the <code>read_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.write_termination","title":"write_termination  <code>property</code> <code>writable</code>","text":"<pre><code>write_termination: bytes | None\n</code></pre> <p>The termination character sequence that is appended to write messages.</p> <p>If you set the <code>write_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the equipment.</p> <p>This method can be overridden in the subclass if the subclass must implement tasks that need to be performed in order to safely disconnect from the equipment.</p> <p>For example,</p> <ul> <li>to clean up system resources from memory (e.g., if using a manufacturer's SDK)</li> <li>to configure the equipment to be in a state that is safe for people   working in the lab when the equipment is not in use</li> </ul> <p>Tip</p> <p>This method gets called automatically when the Interface instance gets garbage collected, which happens when the reference count is 0.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from the equipment.\n\n    This method can be overridden in the subclass if the subclass must implement\n    tasks that need to be performed in order to safely disconnect from the equipment.\n\n    For example,\n\n    * to clean up system resources from memory (e.g., if using a manufacturer's SDK)\n    * to configure the equipment to be in a state that is safe for people\n      working in the lab when the equipment is not in use\n\n    !!! tip\n        This method gets called automatically when the [Interface][msl.equipment.schema.Interface]\n        instance gets garbage collected, which happens when the reference count is 0.\n    \"\"\"\n    logger.debug(\"Disconnected from %r\", self)\n</code></pre>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(  # noqa: PLR0913\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"api/interfaces/gpib/","title":"GPIB","text":""},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB","title":"GPIB","text":"<pre><code>GPIB(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MessageBased</code></p> <p>Base class for GPIB communication.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for the GPIB communication protocol, as well as the properties defined in MessageBased.</p> <p>Connection Properties:</p> Name Type Description <code>eos_mode</code> <code>int</code> <p>The end-of-string mode. Default: <code>0</code></p> <code>send_eoi</code> <code>bool</code> <p>Whether to enable (<code>True</code>) or disable (<code>False</code>) the assertion of the EOI signal. Default: <code>True</code></p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Base class for GPIB communication.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for the GPIB communication protocol, as well as the _properties_ defined in\n    [MessageBased][msl.equipment.interfaces.message_based.MessageBased].\n\n    Attributes: Connection Properties:\n        eos_mode (int): The end-of-string mode. _Default: `0`_\n        send_eoi (bool): Whether to enable (`True`) or disable (`False`) the assertion of the EOI signal.\n            _Default: `True`_\n    \"\"\"\n    self._own: bool = True\n    self._handle: int = -1\n    super().__init__(equipment)\n\n    assert equipment.connection is not None  # noqa: S101\n    info = parse_gpib_address(equipment.connection.address)\n    if not info:\n        msg = f\"Invalid GPIB address {equipment.connection.address!r}\"\n        raise ValueError(msg)\n\n    props = equipment.connection.properties\n    _ = props.setdefault(\"read_termination\", None)\n\n    _load_library(self._error_check)\n    assert GPIB.gpib_library is not None  # noqa: S101\n    self._lib: Any = GPIB.gpib_library.lib\n\n    if info.name:\n        # a board or device object from a name in a gpib.conf file\n        self._handle = self._get_ibfind_handle(info.name)\n    elif info.pad is None:\n        # a board object with the given board number\n        self._handle = info.board\n        self._own = False\n    else:\n        # a device object\n        send_eoi = int(props.get(\"send_eoi\", 1))\n        eos_mode = int(props.get(\"eos_mode\", 0))\n        sad = 0 if info.sad is None else info.sad\n        if sad != 0 and sad &lt; 0x60:  # noqa: PLR2004\n            sad += 0x60\n        info.sad = sad\n        timeout = _convert_timeout(props.get(\"timeout\", None))\n        self._handle = self._get_ibdev_handle(info.board, info.pad, sad, timeout, send_eoi, eos_mode)\n\n    # keep this reference assignment after the if/else condition since the\n    # value of the secondary address may have been updated\n    self._address_info: ParsedGPIBAddress = info\n\n    # check if the handle corresponds to a system controller (INTFC)\n    self._is_board: bool\n    try:\n        self._is_board = bool(self.ask(0xA))  # IbaSC = 0xa\n    except MSLConnectionError:\n        # asking IbaSC for a GPIB device raises EHDL error\n        self._is_board = False\n\n    if not self._is_board:\n        self._set_interface_timeout()\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.handle","title":"handle  <code>property</code>","text":"<pre><code>handle: int\n</code></pre> <p>Returns the handle of the instantiated board or device.</p>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.read_termination","title":"read_termination  <code>property</code> <code>writable</code>","text":"<pre><code>read_termination: bytes | None\n</code></pre> <p>The termination character sequence that is used for the read method.</p> <p>By default, reading stops when the EOI line is asserted.</p>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.write_termination","title":"write_termination  <code>property</code> <code>writable</code>","text":"<pre><code>write_termination: bytes | None\n</code></pre> <p>The termination character sequence that is appended to write messages.</p> <p>If you set the <code>write_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.ask","title":"ask","text":"<pre><code>ask(option: int, *, handle: int | None = None) -&gt; int\n</code></pre> <p>Get a configuration setting (board or device).</p> <p>This method is the ibask function, it should not be confused with the query method.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>int</code> <p>A configuration setting to get the value of.</p> required <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The value of the configuration setting.</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def ask(self, option: int, *, handle: int | None = None) -&gt; int:\n    \"\"\"Get a configuration setting (board or device).\n\n    This method is the [ibask](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibask.html)\n    function, it should not be confused with the [query][msl.equipment.interfaces.message_based.MessageBased.query]\n    method.\n\n    Args:\n        option: A configuration setting to get the value of.\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The value of the configuration setting.\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    setting = c_int()\n    self._lib.ibask(handle, option, byref(setting))\n    return setting.value\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.clear","title":"clear","text":"<pre><code>clear(*, handle: int | None = None) -&gt; int\n</code></pre> <p>Send the clear command (device).</p> <p>This method is the ibclr function.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def clear(self, *, handle: int | None = None) -&gt; int:\n    \"\"\"Send the clear command (device).\n\n    This method is the [ibclr](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibclr.html) function.\n\n    Args:\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibclr(handle)\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.command","title":"command","text":"<pre><code>command(data: bytes, *, handle: int | None = None) -&gt; int\n</code></pre> <p>Write command bytes (board).</p> <p>This method is the ibcmd function.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The commands to write to the bus.</p> required <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def command(self, data: bytes, *, handle: int | None = None) -&gt; int:\n    \"\"\"Write command bytes (board).\n\n    This method is the [ibcmd](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibcmd.html) function.\n\n    Args:\n        data: The [commands](https://linux-gpib.sourceforge.io/doc_html/gpib-protocol.html#REFERENCE-COMMAND-BYTES)\n            to write to the bus.\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibcmd(handle, data, len(data))\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.config","title":"config","text":"<pre><code>config(\n    option: int, value: int, *, handle: int | None = None\n) -&gt; int\n</code></pre> <p>Change configuration settings (board or device).</p> <p>This method is the ibconfig function.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>int</code> <p>A configuration setting to change the value of.</p> required <code>value</code> <code>int</code> <p>The new configuration setting value.</p> required <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def config(self, option: int, value: int, *, handle: int | None = None) -&gt; int:\n    \"\"\"Change configuration settings (board or device).\n\n    This method is the [ibconfig](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibconfig.html)\n    function.\n\n    Args:\n        option: A configuration setting to change the value of.\n        value: The new configuration setting value.\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibconfig(handle, option, value)\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.control_atn","title":"control_atn","text":"<pre><code>control_atn(\n    state: int, *, handle: int | None = None\n) -&gt; int\n</code></pre> <p>Set the state of the ATN line (board).</p> <p>This method mimics the PyVISA-py implementation.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>The state of the ATN line or the active controller. Allowed values are:</p> <ul> <li>0: ATN_DEASSERT</li> <li>1: ATN_ASSERT</li> <li>2: ATN_DEASSERT_HANDSHAKE</li> <li>3: ATN_ASSERT_IMMEDIATE</li> </ul> required <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def control_atn(self, state: int, *, handle: int | None = None) -&gt; int:\n    \"\"\"Set the state of the ATN line (board).\n\n    This method mimics the PyVISA-py implementation.\n\n    Args:\n        state: The state of the ATN line or the active controller. Allowed values are:\n\n            * 0: ATN_DEASSERT\n            * 1: ATN_ASSERT\n            * 2: ATN_DEASSERT_HANDSHAKE\n            * 3: ATN_ASSERT_IMMEDIATE\n\n    Args:\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    ibsta: int\n    if handle is None:\n        handle = self._handle\n    if state == ATN_DEASSERT:\n        ibsta = self._lib.ibgts(handle, 0)\n        return ibsta\n    if state == ATN_ASSERT:\n        ibsta = self._lib.ibcac(handle, 0)\n        return ibsta\n    if state == ATN_DEASSERT_HANDSHAKE:\n        ibsta = self._lib.ibgts(handle, 1)\n        return ibsta\n    if state == ATN_ASSERT_IMMEDIATE:\n        ibsta = self._lib.ibcac(handle, 1)\n        return ibsta\n\n    msg = f\"Invalid ATN {state=}\"\n    raise MSLConnectionError(self, message=msg)\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.control_ren","title":"control_ren","text":"<pre><code>control_ren(\n    state: int, *, handle: int | None = None\n) -&gt; int\n</code></pre> <p>Controls the state of the GPIB Remote Enable (REN) interface line.</p> <p>Optionally the remote/local state of the device is also controlled.</p> <p>This method mimics the PyVISA-py implementation.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>Specifies the state of the REN line and optionally the device remote/local state. Allowed values are:</p> <ul> <li>0: REN_DEASSERT</li> <li>1: REN_ASSERT</li> <li>2: REN_DEASSERT_GTL</li> <li>3: REN_ASSERT_ADDRESS</li> <li>4: REN_ASSERT_LLO</li> <li>5: REN_ASSERT_ADDRESS_LLO</li> <li>6: REN_ADDRESS_GTL</li> </ul> required <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def control_ren(self, state: int, *, handle: int | None = None) -&gt; int:\n    \"\"\"Controls the state of the GPIB Remote Enable (REN) interface line.\n\n    Optionally the remote/local state of the device is also controlled.\n\n    This method mimics the PyVISA-py implementation.\n\n    Args:\n        state: Specifies the state of the REN line and optionally the device remote/local state.\n            Allowed values are:\n\n            * 0: REN_DEASSERT\n            * 1: REN_ASSERT\n            * 2: REN_DEASSERT_GTL\n            * 3: REN_ASSERT_ADDRESS\n            * 4: REN_ASSERT_LLO\n            * 5: REN_ASSERT_ADDRESS_LLO\n            * 6: REN_ADDRESS_GTL\n\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n\n    ibsta = 0\n    if self._is_board and state not in (REN_ASSERT, REN_DEASSERT, REN_ASSERT_LLO):\n        msg = f\"Invalid REN {state=} for INTFC\"\n        raise MSLConnectionError(self, message=msg)\n\n    if state == REN_DEASSERT_GTL:\n        ibsta = self.command(b\"\\x01\", handle=handle)  # GTL = 0x1\n\n    if state in (REN_DEASSERT, REN_DEASSERT_GTL):\n        ibsta = self.remote_enable(state=False, handle=handle)\n\n    if state == REN_ASSERT_LLO:\n        ibsta = self.command(b\"\\x11\", handle=handle)  # LLO = 0x11\n    elif state == REN_ADDRESS_GTL:\n        ibsta = self.command(b\"\\x01\", handle=handle)  # GTL = 0x1\n    elif state == REN_ASSERT_ADDRESS_LLO:\n        pass\n    elif state in (REN_ASSERT, REN_ASSERT_ADDRESS):\n        ibsta = self.remote_enable(state=True, handle=handle)\n        if not self._is_board and state == REN_ASSERT_ADDRESS:\n            assert self._address_info.pad is not None  # noqa: S101\n            ibsta = int(self.listener(self._address_info.pad, sad=self._address_info.sad or 0, handle=handle))\n\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.count","title":"count","text":"<pre><code>count() -&gt; int\n</code></pre> <p>Get the number of bytes sent or received.</p> <p>This method is the ibcntl function.</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def count(self) -&gt; int:\n    \"\"\"Get the number of bytes sent or received.\n\n    This method is the [ibcntl](https://linux-gpib.sourceforge.io/doc_html/reference-globals-ibcnt.html) function.\n    \"\"\"\n    return int(self._lib.ibcntl())\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Close the GPIB connection.</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Close the GPIB connection.\"\"\"\n    if self._own and self._handle &gt; 0:\n        with contextlib.suppress(MSLConnectionError):\n            _ = self.online(state=False, handle=self._handle)\n        self._handle = -1\n        super().disconnect()\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.interface_clear","title":"interface_clear","text":"<pre><code>interface_clear(*, handle: int | None = None) -&gt; int\n</code></pre> <p>Perform interface clear (board).</p> <p>Resets the GPIB bus by asserting the interface clear (IFC) bus line for a duration of at least 100 microseconds.</p> <p>This method is the ibsic function.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def interface_clear(self, *, handle: int | None = None) -&gt; int:\n    \"\"\"Perform interface clear (board).\n\n    Resets the GPIB bus by asserting the *interface clear* (IFC) bus line for a duration of at\n    least 100 microseconds.\n\n    This method is the [ibsic](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibsic.html)\n    function.\n\n    Args:\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibsic(handle)\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.lines","title":"lines","text":"<pre><code>lines(*, handle: int | None = None) -&gt; int\n</code></pre> <p>Returns the status of the control and handshaking bus lines (board).</p> <p>This method is the iblines function.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def lines(self, *, handle: int | None = None) -&gt; int:\n    \"\"\"Returns the status of the control and handshaking bus lines (board).\n\n    This method is the [iblines](https://linux-gpib.sourceforge.io/doc_html/reference-function-iblines.html)\n    function.\n\n    Args:\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    status = c_short()\n    self._lib.iblines(handle, byref(status))\n    return status.value\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.listener","title":"listener","text":"<pre><code>listener(\n    pad: int, sad: int = 0, *, handle: int | None = None\n) -&gt; bool\n</code></pre> <p>Check if a listener is present (board or device).</p> <p>This method is the ibln function.</p> <p>Parameters:</p> Name Type Description Default <code>pad</code> <code>int</code> <p>Primary address of the GPIB device.</p> required <code>sad</code> <code>int</code> <p>Secondary address of the GPIB device.</p> <code>0</code> <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether a listener is present.</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def listener(self, pad: int, sad: int = 0, *, handle: int | None = None) -&gt; bool:\n    \"\"\"Check if a listener is present (board or device).\n\n    This method is the [ibln](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibln.html)\n    function.\n\n    Args:\n        pad: Primary address of the GPIB device.\n        sad: Secondary address of the GPIB device.\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        Whether a listener is present.\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    listener = c_short()\n    self._lib.ibln(handle, pad, sad, byref(listener))\n    return bool(listener.value)\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.local","title":"local","text":"<pre><code>local(*, handle: int | None = None) -&gt; int\n</code></pre> <p>Go to local mode (board or device).</p> <p>This method is the ibloc function.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> Return <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def local(self, *, handle: int | None = None) -&gt; int:\n    \"\"\"Go to local mode (board or device).\n\n    This method is the [ibloc](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibloc.html)\n    function.\n\n    Args:\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Return:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibloc(handle)\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.online","title":"online","text":"<pre><code>online(*, state: bool, handle: int | None = None) -&gt; int\n</code></pre> <p>Close or reinitialize descriptor (board or device).</p> <p>This method is the ibonl function.</p> <p>If you want to close the connection for the GPIB board or device that was instantiated, use disconnect.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>If <code>False</code>, closes the connection. If <code>True</code>, then all settings associated with the descriptor (GPIB address, end-of-string mode, timeout, etc.) are reset to their default values. The default values are the settings the descriptor had when it was first obtained.</p> required <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def online(self, *, state: bool, handle: int | None = None) -&gt; int:\n    \"\"\"Close or reinitialize descriptor (board or device).\n\n    This method is the [ibonl](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibonl.html)\n    function.\n\n    If you want to close the connection for the GPIB board or device that was instantiated,\n    use [disconnect][msl.equipment.interfaces.gpib.GPIB.disconnect].\n\n    Args:\n        state: If `False`, closes the connection. If `True`, then all settings associated with the\n            descriptor (GPIB address, end-of-string mode, timeout, etc.) are reset to their *default*\n            values. The *default* values are the settings the descriptor had when it was first obtained.\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibonl(handle, int(state))\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.pass_control","title":"pass_control","text":"<pre><code>pass_control(\n    *,\n    handle: int | None = None,\n    name: str | None = None,\n    board: int | None = None,\n    pad: int = 0,\n    sad: int = NO_SEC_ADDR\n) -&gt; int\n</code></pre> <p>Set a GPIB board or device to become the controller-in-charge (CIC).</p> <p>This method is the ibpct function.</p> <p>If no arguments are specified, the instantiated class becomes the CIC.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. If specified, <code>name</code>, <code>board</code>, <code>pad</code> and <code>sad</code> are ignored.</p> <code>None</code> <code>name</code> <code>str | None</code> <p>The name of a GPIB board or device. If specified, <code>board</code>, <code>pad</code> and <code>sad</code> are ignored.</p> <code>None</code> <code>board</code> <code>int | None</code> <p>Index of the GPIB interface board.</p> <code>None</code> <code>pad</code> <code>int</code> <p>Primary address of the GPIB device.</p> <code>0</code> <code>sad</code> <code>int</code> <p>Secondary address of the GPIB device.</p> <code>NO_SEC_ADDR</code> <p>Returns:</p> Type Description <code>int</code> <p>The handle of the board or device that became CIC.</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def pass_control(\n    self,\n    *,\n    handle: int | None = None,\n    name: str | None = None,\n    board: int | None = None,\n    pad: int = 0,\n    sad: int = NO_SEC_ADDR,\n) -&gt; int:\n    \"\"\"Set a GPIB board or device to become the controller-in-charge (CIC).\n\n    This method is the [ibpct](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibpct.html)\n    function.\n\n    If no arguments are specified, the instantiated class becomes the CIC.\n\n    Args:\n        handle: Board or device descriptor. If specified, `name`, `board`, `pad` and `sad` are ignored.\n        name: The name of a GPIB board or device. If specified, `board`, `pad` and `sad` are ignored.\n        board: Index of the GPIB interface board.\n        pad: Primary address of the GPIB device.\n        sad: Secondary address of the GPIB device.\n\n    Returns:\n        The handle of the board or device that became CIC.\n    \"\"\"\n    if handle is not None:\n        pass\n    elif name is not None:\n        handle = self._get_ibfind_handle(name)\n    elif board is not None:\n        handle = self._get_ibdev_handle(board, pad, sad, 13, 1, 0)  # T10s = 13\n    else:\n        handle = self._handle\n\n    self._lib.ibpct(handle)\n    return handle\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(  # noqa: PLR0913\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.remote_enable","title":"remote_enable","text":"<pre><code>remote_enable(\n    *, state: bool, handle: int | None = None\n) -&gt; int\n</code></pre> <p>Set remote enable (board).</p> <p>This method is the ibsre function.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>If <code>True</code>, the board asserts the REN line. Otherwise, the REN line is not asserted. The board must be the system controller.</p> required <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns: The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def remote_enable(self, *, state: bool, handle: int | None = None) -&gt; int:\n    \"\"\"Set remote enable (board).\n\n    This method is the [ibsre](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibsre.html)\n    function.\n\n    Args:\n        state: If `True`, the board asserts the REN line. Otherwise, the REN line is not asserted.\n            The board must be the system controller.\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns: The status value (`ibsta`).\n    \"\"\"\n    # ibsre was removed from ni4882.dll, use ibconfig instead (IbcSRE = 0xb)\n    ibsta: int = self.config(0xB, int(state), handle=handle)\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.serial_poll","title":"serial_poll","text":"<pre><code>serial_poll(*, handle: int | None = None) -&gt; int\n</code></pre> <p>Read status byte / serial poll (device).</p> <p>This method is the ibrsp function.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status byte.</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def serial_poll(self, *, handle: int | None = None) -&gt; int:\n    \"\"\"Read status byte / serial poll (device).\n\n    This method is the [ibrsp](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibrsp.html)\n    function.\n\n    Args:\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status byte.\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    status = create_string_buffer(1)\n    self._lib.ibrsp(handle, status)\n    return ord(status.value)\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.spoll_bytes","title":"spoll_bytes","text":"<pre><code>spoll_bytes(*, handle: int | None = None) -&gt; int\n</code></pre> <p>Get the length of the serial poll bytes queue (device).</p> <p>This method is the ibspb function.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def spoll_bytes(self, *, handle: int | None = None) -&gt; int:\n    \"\"\"Get the length of the serial poll bytes queue (device).\n\n    This method is the [ibspb](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibspb.html)\n    function.\n\n    Args:\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    length = c_short()\n    self._lib.ibspb(handle, byref(length))\n    return length.value\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.status","title":"status","text":"<pre><code>status() -&gt; int\n</code></pre> <p>Returns the status value ibsta.</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def status(self) -&gt; int:\n    \"\"\"Returns the status value [ibsta](https://linux-gpib.sourceforge.io/doc_html/reference-globals-ibsta.html).\"\"\"\n    return int(self._lib.ThreadIbsta())\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.trigger","title":"trigger","text":"<pre><code>trigger(*, handle: int | None = None) -&gt; int\n</code></pre> <p>Trigger device.</p> <p>This method is the ibtrg function.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def trigger(self, *, handle: int | None = None) -&gt; int:\n    \"\"\"Trigger device.\n\n    This method is the [ibtrg](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibtrg.html)\n    function.\n\n    Args:\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibtrg(handle)\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.version","title":"version","text":"<pre><code>version() -&gt; str\n</code></pre> <p>Returns the version of the GPIB library (linux only).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def version(self) -&gt; str:\n    \"\"\"Returns the version of the GPIB library (linux only).\"\"\"\n    try:\n        version = c_char_p()\n        self._lib.ibvers(byref(version))\n        assert version.value is not None  # noqa: S101\n        return version.value.decode()\n    except AttributeError:\n        return \"\"\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.wait","title":"wait","text":"<pre><code>wait(mask: int, *, handle: int | None = None) -&gt; int\n</code></pre> <p>Wait for an event (board or device).</p> <p>This method is the ibwait function.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>int</code> <p>Wait until one of the conditions specified in <code>mask</code> is true.</p> required <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def wait(self, mask: int, *, handle: int | None = None) -&gt; int:\n    \"\"\"Wait for an event (board or device).\n\n    This method is the [ibwait](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibwait.html)\n    function.\n\n    Args:\n        mask: Wait until one of the conditions specified in `mask` is true.\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibwait(handle, mask)\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.wait_for_srq","title":"wait_for_srq","text":"<pre><code>wait_for_srq(*, handle: int | None = None) -&gt; int\n</code></pre> <p>Wait for the SRQ line to be asserted (board or device).</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def wait_for_srq(self, *, handle: int | None = None) -&gt; int:\n    \"\"\"Wait for the SRQ line to be asserted (board or device).\n\n    Args:\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    return self.wait(0x1000, handle=handle)  # SRQI = 0x1000\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.write_async","title":"write_async","text":"<pre><code>write_async(\n    message: bytes, *, handle: int | None = None\n) -&gt; int\n</code></pre> <p>Write a message asynchronously (board or device).</p> <p>This method is the ibwrta function.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes</code> <p>The data to send.</p> required <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def write_async(self, message: bytes, *, handle: int | None = None) -&gt; int:\n    \"\"\"Write a message asynchronously (board or device).\n\n    This method is the [ibwrta](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibwrta.html) function.\n\n    Args:\n        message: The data to send.\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibwrta(handle, message, len(message))\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/hislip/","title":"HiSLIP","text":""},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP","title":"HiSLIP","text":"<pre><code>HiSLIP(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MessageBased</code></p> <p>Base class for the HiSLIP communication protocol.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for the HiSLIP communication protocol, as well as the properties defined in MessageBased.</p> <p>Connection Properties:</p> Name Type Description <code>buffer_size</code> <code>int</code> <p>The maximum number of bytes to read at a time. Default: <code>4096</code></p> <code>lock_timeout</code> <code>float</code> <p>The timeout (in seconds) to wait for a lock (0 means wait forever). Default: <code>0</code></p> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Base class for the [HiSLIP] communication protocol.\n\n    [HiSLIP]: https://www.ivifoundation.org/downloads/Protocol%20Specifications/IVI-6.1_HiSLIP-2.0-2020-04-23.pdf\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for the HiSLIP communication protocol, as well as the _properties_ defined in\n    [MessageBased][msl.equipment.interfaces.message_based.MessageBased].\n\n    Attributes: Connection Properties:\n        buffer_size (int): The maximum number of bytes to read at a time. _Default: `4096`_\n        lock_timeout (float): The timeout (in seconds) to wait for a lock (0 means wait forever). _Default: `0`_\n    \"\"\"\n    super().__init__(equipment)\n\n    assert equipment.connection is not None  # noqa: S101\n\n    info = parse_hislip_address(equipment.connection.address)\n    if info is None:\n        msg = f\"Invalid HiSLIP address {equipment.connection.address!r}\"\n        raise ValueError(msg)\n\n    self._info: ParsedHiSLIPAddress = info\n\n    # HiSLIP does not support termination characters\n    self.write_termination = None  # pyright: ignore[reportUnannotatedClassAttribute]\n    self.read_termination = None  # pyright: ignore[reportUnannotatedClassAttribute]\n\n    props = equipment.connection.properties\n    self._buffer_size: int = props.get(\"buffer_size\", 4096)\n    self._lock_timeout: float = props.get(\"lock_timeout\", 0)\n    self.lock_timeout = self._lock_timeout\n\n    self._sync: SyncClient\n    self._async: AsyncClient\n    self._connect()\n    self._set_interface_timeout()\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.asynchronous","title":"asynchronous  <code>property</code>","text":"<pre><code>asynchronous: AsyncClient\n</code></pre> <p>The reference to the asynchronous client.</p>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.lock_timeout","title":"lock_timeout  <code>property</code> <code>writable</code>","text":"<pre><code>lock_timeout: float\n</code></pre> <p>The time, in seconds, to wait to acquire a lock.</p> <p>Setting the value to \u22640 (or <code>None</code>) means wait forever.</p>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.synchronous","title":"synchronous  <code>property</code>","text":"<pre><code>synchronous: SyncClient\n</code></pre> <p>The reference to the synchronous client.</p>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Send the <code>clear</code> command to the device.</p> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Send the `clear` command to the device.\"\"\"\n    # IVI-6.1: IVI High-Speed LAN Instrument Protocol (HiSLIP)\n    # 23 April 2020 (Revision 2.0)\n    # Section 6.12: Device Clear Transaction\n    #\n    # This Connection class does not use the asynchronous client in an\n    # asynchronous manner, therefore there should not be any pending\n    # requests that need to be waited on to finish\n    acknowledged = self._async.async_device_clear()\n    _ = self._sync.device_clear_complete(acknowledged.feature_bitmap)\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Close the connection to the HiSLIP server.</p> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Close the connection to the HiSLIP server.\"\"\"\n    if not hasattr(self, \"_async\"):\n        return\n\n    if self._async.socket is None and self._sync.socket is None:\n        return\n\n    self._async.close()\n    self._sync.close()\n    super().disconnect()\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.lock","title":"lock","text":"<pre><code>lock(lock_string: str = '') -&gt; bool\n</code></pre> <p>Acquire the device's lock.</p> <p>Parameters:</p> Name Type Description Default <code>lock_string</code> <code>str</code> <p>An ASCII string that identifies this lock. If not specified, then an exclusive lock is requested, otherwise the string indicates an identification of a shared-lock request.</p> <code>''</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether acquiring the lock was successful.</p> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def lock(self, lock_string: str = \"\") -&gt; bool:\n    \"\"\"Acquire the device's lock.\n\n    Args:\n        lock_string: An ASCII string that identifies this lock. If not specified, then\n            an exclusive lock is requested, otherwise the string indicates an\n            identification of a shared-lock request.\n\n    Returns:\n        Whether acquiring the lock was successful.\n    \"\"\"\n    status = self._async.async_lock_request(timeout=self._lock_timeout, lock_string=lock_string)\n    return status.success\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.lock_status","title":"lock_status","text":"<pre><code>lock_status() -&gt; tuple[bool, int]\n</code></pre> <p>Request the lock status from the HiSLIP server.</p> <p>Returns:</p> Type Description <code>tuple[bool, int]</code> <p>Whether the HiSLIP server has an exclusive lock with a client and the number of HiSLIP clients that have a lock with the HiSLIP server.</p> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def lock_status(self) -&gt; tuple[bool, int]:\n    \"\"\"Request the lock status from the HiSLIP server.\n\n    Returns:\n        Whether the HiSLIP server has an exclusive lock with a client and\n            the number of HiSLIP clients that have a lock with the HiSLIP server.\n    \"\"\"\n    reply = self._async.async_lock_info()\n    return reply.exclusive, reply.num_locks\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(  # noqa: PLR0913\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.read_stb","title":"read_stb","text":"<pre><code>read_stb() -&gt; int\n</code></pre> <p>Read the status byte from the device.</p> <p>Returns:</p> Type Description <code>int</code> <p>The status byte.</p> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def read_stb(self) -&gt; int:\n    \"\"\"Read the status byte from the device.\n\n    Returns:\n        The status byte.\n    \"\"\"\n    reply = self._async.async_status_query(self._sync)\n    return reply.status\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.reconnect","title":"reconnect","text":"<pre><code>reconnect(max_attempts: int = 1) -&gt; None\n</code></pre> <p>Reconnect to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>max_attempts</code> <code>int</code> <p>The maximum number of attempts to try to reconnect with the equipment. If &lt;1, keep trying until a connection is successful. If the maximum number of attempts has been reached then an exception is raise.</p> <code>1</code> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def reconnect(self, max_attempts: int = 1) -&gt; None:\n    \"\"\"Reconnect to the equipment.\n\n    Args:\n        max_attempts: The maximum number of attempts to try to reconnect with the equipment.\n            If &amp;lt;1, keep trying until a connection is successful. If the maximum number\n            of attempts has been reached then an exception is raise.\n    \"\"\"\n    attempt = 0\n    while True:\n        attempt += 1\n        try:\n            return self._connect()\n        except (MSLConnectionError, MSLTimeoutError):\n            if 0 &lt; max_attempts &lt;= attempt:\n                raise\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.remote_local_control","title":"remote_local_control","text":"<pre><code>remote_local_control(request: int) -&gt; None\n</code></pre> <p>Send a GPIB-like remote/local control request.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>int</code> <p>The request to perform.</p> <ul> <li>0 \u2014 Disable remote, <code>VI_GPIB_REN_DEASSERT</code></li> <li>1 \u2014 Enable remote, <code>VI_GPIB_REN_ASSERT</code></li> <li>2 \u2014 Disable remote and go to local, <code>VI_GPIB_REN_DEASSERT_GTL</code></li> <li>3 \u2014 Enable Remote and go to remote, <code>VI_GPIB_REN_ASSERT_ADDRESS</code></li> <li>4 \u2014 Enable remote and lock out local, <code>VI_GPIB_REN_ASSERT_LLO</code></li> <li>5 \u2014 Enable remote, go to remote, and set local lockout, <code>VI_GPIB_REN_ASSERT_ADDRESS_LLO</code></li> <li>6 \u2014 Go to local without changing REN or lockout state, <code>VI_GPIB_REN_ADDRESS_GTL</code></li> </ul> required Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def remote_local_control(self, request: int) -&gt; None:\n    \"\"\"Send a GPIB-like remote/local control request.\n\n    Args:\n        request: The request to perform.\n\n            * 0 &amp;mdash; Disable remote, `VI_GPIB_REN_DEASSERT`\n            * 1 &amp;mdash; Enable remote, `VI_GPIB_REN_ASSERT`\n            * 2 &amp;mdash; Disable remote and go to local, `VI_GPIB_REN_DEASSERT_GTL`\n            * 3 &amp;mdash; Enable Remote and go to remote, `VI_GPIB_REN_ASSERT_ADDRESS`\n            * 4 &amp;mdash; Enable remote and lock out local, `VI_GPIB_REN_ASSERT_LLO`\n            * 5 &amp;mdash; Enable remote, go to remote, and set local lockout, `VI_GPIB_REN_ASSERT_ADDRESS_LLO`\n            * 6 &amp;mdash; Go to local without changing REN or lockout state, `VI_GPIB_REN_ADDRESS_GTL`\n    \"\"\"\n    _ = self._async.async_remote_local_control(request, self._sync.message_id)\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.trigger","title":"trigger","text":"<pre><code>trigger() -&gt; None\n</code></pre> <p>Send the trigger message (emulates a GPIB Group Execute Trigger event).</p> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def trigger(self) -&gt; None:\n    \"\"\"Send the trigger message (emulates a GPIB Group Execute Trigger event).\"\"\"\n    self._sync.trigger()\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.unlock","title":"unlock","text":"<pre><code>unlock() -&gt; bool\n</code></pre> <p>Release the lock acquired by lock.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether releasing the lock was successful.</p> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def unlock(self) -&gt; bool:\n    \"\"\"Release the lock acquired by [lock][msl.equipment.interfaces.hislip.HiSLIP.lock].\n\n    Returns:\n        Whether releasing the lock was successful.\n    \"\"\"\n    status = self._async.async_lock_release(self._sync.message_id)\n    return status.success\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"api/interfaces/prologix/","title":"Prologix","text":""},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix","title":"Prologix","text":"<pre><code>Prologix(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Use Prologix hardware to establish a connection.</p> <p>For the GPIB-ETHERNET Controller, the format of the address string is <code>Prologix::HOST::1234::PAD[::SAD]</code>, where <code>HOST</code> is the hostname or IP address of the Prologix hardware, <code>1234</code> is the ethernet port that is open on the Prologix hardware, PAD (Primary GPIB Address) is an integer value between 0 and 30, and SAD (Secondary GPIB Address) is an integer value between 96 and 126 (SAD is optional). For example,</p> <ul> <li><code>Prologix::192.168.1.110::1234::6</code></li> <li><code>Prologix::192.168.1.110::1234::6::96</code></li> <li><code>Prologix::prologix-00-21-69-01-31-04::1234::6</code>     (typically, the hostname is <code>prologix-&lt;MAC Address&gt;</code>)</li> </ul> <p>For the GPIB-USB Controller, the format of the address string is <code>Prologix::PORT::PAD[::SAD]</code>, where <code>PORT</code> is the name of the serial port of the Prologix hardware, <code>PAD</code> (Primary GPIB Address) is an integer value between 0 and 30, and SAD (Secondary GPIB Address) is an integer value between 96 and 126 (SAD is optional). For example,</p> <ul> <li><code>Prologix::COM3::6</code></li> <li><code>Prologix::/dev/ttyUSB0::6::112</code></li> </ul> <p>Alternatively, to clearly separate the Prologix hardware address from the GPIB address you may include <code>GPIB::</code> in the address, for example,</p> <ul> <li><code>Prologix::192.168.1.110::1234::GPIB::6</code></li> <li><code>Prologix::COM3::GPIB::22::96</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for using Prologix hardware, as well as the properties defined in, Serial (for a GPIB-USB Controller) and in Socket (for a GPIB-ETHERNET Controller).</p> <p>Connection Properties:</p> Name Type Description <code>eoi</code> <code>int</code> <p>Whether to use the End or Identify line, either <code>0</code> (disable) or <code>1</code> (enable).</p> <code>eos</code> <code>int</code> <p>GPIB termination character(s): 0 (CR+LF), 1 (CR), 2 (LF) or 3 (no termination).</p> <code>eot_char</code> <code>int</code> <p>A user-specified character to append to network output when <code>eot_enable</code> is set to 1 and EOI is detected. Must be an ASCII value &lt;256, e.g., <code>eot_char=42</code> appends <code>*</code> (ASCII 42) when EOI is detected.</p> <code>eot_enable</code> <code>int</code> <p>Enables (1) or disables (0) the appending of a user-specified character, <code>eot_char</code>.</p> <code>mode</code> <code>int</code> <p>Configure the Prologix hardware to be a CONTROLLER (1) or DEVICE (0). Default: <code>1</code></p> <code>read_tmo_ms</code> <code>int</code> <p>The inter-character timeout value, in milliseconds, to be used in the read command and the spoll command, i.e., the delay since the last character was read. The <code>read_tmo_ms</code> timeout value is not to be confused with the total time for which data is read. The <code>read_tmo_ms</code> value must be between 1 and 3000 milliseconds.</p> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Use [Prologix](https://prologix.biz/) hardware to establish a connection.\n\n    For the GPIB-ETHERNET Controller, the format of the [address][msl.equipment.schema.Connection.address]\n    string is `Prologix::HOST::1234::PAD[::SAD]`, where `HOST` is the hostname or IP address of the Prologix\n    hardware, `1234` is the ethernet port that is open on the Prologix hardware, PAD (Primary GPIB Address)\n    is an integer value between 0 and 30, and SAD (Secondary GPIB Address) is an integer value between\n    96 and 126 (SAD is optional). For example,\n\n    * `Prologix::192.168.1.110::1234::6`\n    * `Prologix::192.168.1.110::1234::6::96`\n    * `Prologix::prologix-00-21-69-01-31-04::1234::6` &lt;br/&gt;\n       (typically, the hostname is `prologix-&lt;MAC Address&gt;`)\n\n    For the GPIB-USB Controller, the format of the [address][msl.equipment.schema.Connection.address]\n    string is `Prologix::PORT::PAD[::SAD]`, where `PORT` is the name of the serial port of the Prologix\n    hardware, `PAD` (Primary GPIB Address) is an integer value between 0 and 30, and SAD (Secondary\n    GPIB Address) is an integer value between 96 and 126 (SAD is optional). For example,\n\n    * `Prologix::COM3::6`\n    * `Prologix::/dev/ttyUSB0::6::112`\n\n    Alternatively, to clearly separate the Prologix hardware address from the GPIB address you may include\n    `GPIB::` in the address, for example,\n\n    * `Prologix::192.168.1.110::1234::GPIB::6`\n    * `Prologix::COM3::GPIB::22::96`\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for using Prologix hardware, as well as the _properties_ defined in,\n    [Serial][msl.equipment.interfaces.serial.Serial] (for a GPIB-USB Controller) and in\n    [Socket][msl.equipment.interfaces.socket.Socket] (for a GPIB-ETHERNET Controller).\n\n    Attributes: Connection Properties:\n        eoi (int): Whether to use the End or Identify line, either `0` (disable) or `1` (enable).\n        eos (int): GPIB termination character(s): 0 (CR+LF), 1 (CR), 2 (LF) or 3 (no termination).\n        eot_char (int): A user-specified character to append to network output when `eot_enable`\n            is set to 1 and EOI is detected. Must be an ASCII value &amp;lt;256, e.g., `eot_char=42`\n            appends `*` (ASCII 42) when EOI is detected.\n        eot_enable (int): Enables (1) or disables (0) the appending of a user-specified character, `eot_char`.\n        mode (int): Configure the Prologix hardware to be a CONTROLLER (1) or DEVICE (0). _Default: `1`_\n        read_tmo_ms (int): The inter-character timeout value, in milliseconds, to be used in the _read_\n            command and the _spoll_ command, i.e., the delay since the last character was read. The\n            `read_tmo_ms` timeout value is not to be confused with the total time for which data is\n            read. The `read_tmo_ms` value must be between 1 and 3000 milliseconds.\n    \"\"\"\n    self._addr: str = \"\"\n    super().__init__(equipment)\n\n    assert equipment.connection is not None  # noqa: S101\n    info = parse_prologix_address(equipment.connection.address)\n    if info is None:\n        msg = f\"Invalid Prologix address {equipment.connection.address!r}\"\n        raise ValueError(msg)\n\n    pad = info.pad\n    if pad &lt; MIN_PAD_ADDRESS or pad &gt; MAX_PAD_ADDRESS:\n        msg = f\"Invalid primary GPIB address {pad}, must be in the range [{MIN_PAD_ADDRESS}, {MAX_PAD_ADDRESS}]\"\n        raise ValueError(msg)\n\n    sad = info.sad\n    if sad is not None and (sad &lt; MIN_SAD_ADDRESS or sad &gt; MAX_SAD_ADDRESS):\n        msg = f\"Invalid secondary GPIB address {sad}, must be in the range [{MIN_SAD_ADDRESS}, {MAX_SAD_ADDRESS}]\"\n        raise ValueError(msg)\n\n    self._addr = f\"++addr {pad}\" if sad is None else f\"++addr {pad} {sad}\"\n    self._query_auto: bool = True\n    self._hw_address: str = info.hw_address\n\n    props = equipment.connection.properties\n\n    try:\n        self._controller: Serial | Socket = Prologix._controllers[self._hw_address]\n    except KeyError:\n        address = f\"TCP::{self._hw_address}::{info.enet_port}\" if info.enet_port else f\"ASRL{self._hw_address}\"\n        e = Equipment(connection=Connection(address, **props))\n        self._controller = PrologixEthernet(e) if info.enet_port else PrologixUSB(e)\n        Prologix._controllers[self._hw_address] = self._controller\n        Prologix._selected_addresses[self._hw_address] = \"\"\n\n    # default is CONTROLLER mode\n    mode = props.get(\"mode\", 1)\n    _ = self._controller.write(f\"++mode {mode}\")\n\n    # set the options provided by the user\n    for option in [\"eoi\", \"eos\", \"eot_enable\", \"eot_char\", \"read_tmo_ms\"]:\n        value = props.get(option)\n        if value is not None:\n            _ = self._controller.write(f\"++{option} {value}\")\n\n    self._ensure_gpib_address_selected()\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.controller","title":"controller  <code>property</code>","text":"<pre><code>controller: Serial | Socket\n</code></pre> <p>The connection to the Prologix Controller for this equipment.</p> <p>The returned type depends on whether a GPIB-USB or a GPIB-ETHERNET Controller is used to communicate with the equipment.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.query_auto","title":"query_auto  <code>property</code> <code>writable</code>","text":"<pre><code>query_auto: bool\n</code></pre> <p>Whether to send <code>++auto 1</code> before and <code>++auto 0</code> after a query to the Prologix Controller.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.read_termination","title":"read_termination  <code>property</code> <code>writable</code>","text":"<pre><code>read_termination: bytes | None\n</code></pre> <p>The termination character sequence that is used for a read operation.</p> <p>Reading stops when the equipment stops sending data or the <code>read_termination</code> character sequence is detected. If you set the <code>read_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, to use for the connection to the Prologix hardware.</p> <p>This timeout value is not to be confused with the <code>read_tmo_ms</code> command that Prologix Controllers accept. To set the inter-character delay, i.e., the delay since the last character was read or for the spoll command, write the <code>++read_tmo_ms &lt;time&gt;</code> message to the Controller.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.write_termination","title":"write_termination  <code>property</code> <code>writable</code>","text":"<pre><code>write_termination: bytes | None\n</code></pre> <p>The termination character sequence that is appended to write messages.</p> <p>If you set the <code>write_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the equipment.</p> <p>Calling this method does not close the underlying Serial or Socket connection to the Prologix Controller since the connection to the Prologix Controller may still be required to send messages to other GPIB devices that are attached to the Controller.</p> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Disconnect from the equipment.\n\n    Calling this method does not close the underlying [Serial][msl.equipment.interfaces.serial.Serial]\n    or [Socket][msl.equipment.interfaces.socket.Socket] connection to the Prologix Controller since\n    the connection to the Prologix Controller may still be required to send messages to other GPIB\n    devices that are attached to the Controller.\n    \"\"\"\n    if self._addr:\n        self._addr = \"\"\n        super().disconnect()\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.group_execute_trigger","title":"group_execute_trigger","text":"<pre><code>group_execute_trigger(*addresses: int) -&gt; int\n</code></pre> <p>Send the Group Execute Trigger command to equipment at the specified addresses.</p> <p>Up to 15 addresses may be specified. If no address is specified then the Group Execute Trigger command is issued to the currently-addressed equipment.</p> <p>Parameters:</p> Name Type Description Default <code>addresses</code> <code>int</code> <p>The primary (and optional secondary) GPIB addresses. If a secondary address is specified then it must follow its corresponding primary address, for example,</p> <ul> <li>group_execute_trigger(1, 11, 17) \u2192 primary, primary, primary</li> <li>group_execute_trigger(3, 96, 12, 21) \u2192 primary, secondary, primary, primary</li> </ul> <code>()</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def group_execute_trigger(self, *addresses: int) -&gt; int:\n    \"\"\"Send the Group Execute Trigger command to equipment at the specified addresses.\n\n    Up to 15 addresses may be specified. If no address is specified then the\n    Group Execute Trigger command is issued to the currently-addressed equipment.\n\n    Args:\n        addresses: The primary (and optional secondary) GPIB addresses. If a secondary address is\n            specified then it must follow its corresponding primary address, for example,\n\n            * group_execute_trigger(1, 11, 17) &amp;#8594; primary, primary, primary\n            * group_execute_trigger(3, 96, 12, 21) &amp;#8594; primary, secondary, primary, primary\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    command = \"++trg\"\n    if addresses:\n        command += \" \" + \" \".join(str(a) for a in addresses)\n    return self._controller.write(command)\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as an numpy.ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def query(  # noqa: PLR0913\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.prologix.Prologix.write]\n    followed by a [read][msl.equipment.interfaces.prologix.Prologix.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as an [numpy.ndarray][], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    self._ensure_gpib_address_selected()\n\n    if self._query_auto:\n        _ = self._controller.write(b\"++auto 1\")\n\n    reply = self._controller.query(message, delay=delay, decode=decode, dtype=dtype, fmt=fmt, size=size)  # type: ignore[arg-type]\n\n    if self._query_auto:\n        _ = self._controller.write(b\"++auto 0\")\n\n    return reply\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>See MessageBased.read() for more details.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    See [MessageBased.read()][msl.equipment.interfaces.message_based.MessageBased.read] for more details.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    self._ensure_gpib_address_selected()\n    return self._controller.read(decode=decode, dtype=dtype, fmt=fmt, size=size)  # type: ignore[arg-type]\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    self._ensure_gpib_address_selected()\n    return self._controller.write(message, data=data, fmt=fmt, dtype=dtype)\n</code></pre>"},{"location":"api/interfaces/sdk/","title":"SDK","text":""},{"location":"api/interfaces/sdk/#msl.equipment.interfaces.sdk.SDK","title":"SDK","text":"<pre><code>SDK(\n    equipment: Equipment,\n    libtype: LibType | None = None,\n    path: PathLike | None = None,\n)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Base class for equipment that use the manufacturer's Software Development Kit (SDK).</p> <p>You can use the configuration file to add the directory that the SDK is located at to the <code>PATH</code> environment variable.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <code>libtype</code> <code>LibType | None</code> <p>The library type. See LoadLibrary for more details.</p> <code>None</code> <code>path</code> <code>PathLike | None</code> <p>The path to the SDK. Specifying this value will take precedence over the address value.</p> <code>None</code> Source code in <code>src/msl/equipment/interfaces/sdk.py</code> <pre><code>def __init__(self, equipment: Equipment, libtype: LibType | None = None, path: PathLike | None = None) -&gt; None:\n    \"\"\"Base class for equipment that use the manufacturer's Software Development Kit (SDK).\n\n    You can use the [configuration file][config-xml-example] to add the directory that the SDK\n    is located at to the `PATH` environment variable.\n\n    Args:\n        equipment: An [Equipment][] instance.\n        libtype: The library type. See [LoadLibrary][msl.loadlib.load_library.LoadLibrary] for more details.\n        path: The path to the SDK. Specifying this value will take precedence over the\n            [address][msl.equipment.schema.Connection.address] value.\n    \"\"\"\n    super().__init__(equipment)\n\n    if path is None:\n        assert equipment.connection is not None  # noqa: S101\n        info = parse_sdk_address(equipment.connection.address)\n        if info is None:\n            msg = f\"Invalid SDK interface address {equipment.connection.address!r}\"\n            raise ValueError(msg)\n        path = info.path\n\n    self._load_library: LoadLibrary = LoadLibrary(path, libtype)\n    self._sdk: Any = self._load_library.lib\n</code></pre>"},{"location":"api/interfaces/sdk/#msl.equipment.interfaces.sdk.SDK.assembly","title":"assembly  <code>property</code>","text":"<pre><code>assembly: Any\n</code></pre> <p>assembly \u2014 The reference to the .NET assembly.</p>"},{"location":"api/interfaces/sdk/#msl.equipment.interfaces.sdk.SDK.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/sdk/#msl.equipment.interfaces.sdk.SDK.gateway","title":"gateway  <code>property</code>","text":"<pre><code>gateway: Any\n</code></pre> <p>gateway \u2014 The reference to the JAVA gateway.</p>"},{"location":"api/interfaces/sdk/#msl.equipment.interfaces.sdk.SDK.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>str \u2014 The path to the SDK file.</p>"},{"location":"api/interfaces/sdk/#msl.equipment.interfaces.sdk.SDK.sdk","title":"sdk  <code>property</code>","text":"<pre><code>sdk: Any\n</code></pre> <p>lib \u2014 The reference to the SDK object.</p>"},{"location":"api/interfaces/sdk/#msl.equipment.interfaces.sdk.SDK.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Cleanup references to the SDK library.</p> Source code in <code>src/msl/equipment/interfaces/sdk.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Cleanup references to the SDK library.\"\"\"\n    if hasattr(self, \"_sdk\") and self._sdk is not None:\n        self._load_library.cleanup()\n        self._sdk = None\n        super().disconnect()\n</code></pre>"},{"location":"api/interfaces/sdk/#msl.equipment.interfaces.sdk.SDK.log_errcheck","title":"log_errcheck","text":"<pre><code>log_errcheck(\n    result: Any, func: Any, arguments: tuple[Any, ...]\n) -&gt; Any\n</code></pre> <p>Convenience method for logging an errcheck from ctypes.</p> Source code in <code>src/msl/equipment/interfaces/sdk.py</code> <pre><code>def log_errcheck(self, result: Any, func: Any, arguments: tuple[Any, ...]) -&gt; Any:  # noqa: ANN401\n    \"\"\"Convenience method for logging an [errcheck][ctypes._CFuncPtr.errcheck] from [ctypes][].\"\"\"\n    logger.debug(\"%s.%s%s -&gt; %s\", self.__class__.__name__, func.__name__, arguments, result)\n    return result\n</code></pre>"},{"location":"api/interfaces/serial/","title":"Serial","text":""},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial","title":"Serial","text":"<pre><code>Serial(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MessageBased</code></p> <p>Base class for equipment that is connected through a serial port.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for the serial communication protocol, as well as the properties defined in MessageBased. The DataBits, Parity and StopBits enumeration names and values may also be used. For properties that specify an alias, you may also use the alternative name as the property name. See serial.Serial for more details.</p> <p>Connection Properties:</p> Name Type Description <code>baud_rate</code> <code>int</code> <p>The baud rate (alias: baudrate). Default: <code>9600</code></p> <code>data_bits</code> <code>int</code> <p>The number of data bits, e.g. 5, 6, 7, 8 (alias: bytesize). Default: <code>8</code></p> <code>dsr_dtr</code> <code>bool</code> <p>Whether to enable hardware (DSR/DTR) flow control (alias: dsrdtr). Default: <code>False</code></p> <code>inter_byte_timeout</code> <code>float | None</code> <p>The inter-character timeout. Default: <code>None</code></p> <code>parity</code> <code>str</code> <p>Parity checking, e.g. 'even', 'odd'. Default: <code>none</code></p> <code>rts_cts</code> <code>bool</code> <p>Whether to enable hardware (RTS/CTS) flow control (alias: rtscts). Default: <code>False</code></p> <code>stop_bits</code> <code>int | float</code> <p>The number of stop bits, e.g. 1, 1.5, 2 (alias: stopbits). Default: <code>1</code></p> <code>xon_xoff</code> <code>bool</code> <p>Whether to enable software flow control (alias: xonxoff). Default: <code>False</code></p> Source code in <code>src/msl/equipment/interfaces/serial.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Base class for equipment that is connected through a serial port.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for the serial communication protocol, as well as the _properties_ defined in\n    [MessageBased][msl.equipment.interfaces.message_based.MessageBased]. The\n    [DataBits][msl.equipment.enumerations.DataBits], [Parity][msl.equipment.enumerations.Parity]\n    and [StopBits][msl.equipment.enumerations.StopBits] enumeration names and values may also\n    be used. For properties that specify an _alias_, you may also use the alternative name as\n    the property name. See [serial.Serial][] for more details.\n\n    Attributes: Connection Properties:\n        baud_rate (int): The baud rate (_alias:_ baudrate). _Default: `9600`_\n        data_bits (int): The number of data bits, e.g. 5, 6, 7, 8 (_alias:_ bytesize). _Default: `8`_\n        dsr_dtr (bool): Whether to enable hardware (DSR/DTR) flow control (_alias:_ dsrdtr). _Default: `False`_\n        inter_byte_timeout (float | None): The inter-character timeout. _Default: `None`_\n        parity (str): Parity checking, e.g. 'even', 'odd'. _Default: `none`_\n        rts_cts (bool): Whether to enable hardware (RTS/CTS) flow control (_alias:_ rtscts). _Default: `False`_\n        stop_bits (int | float): The number of stop bits, e.g. 1, 1.5, 2 (_alias:_ stopbits). _Default: `1`_\n        xon_xoff (bool): Whether to enable software flow control (_alias:_ xonxoff). _Default: `False`_\n    \"\"\"\n    super().__init__(equipment)\n\n    assert equipment.connection is not None  # noqa: S101\n    info = parse_serial_address(equipment.connection.address)\n    if info is None:\n        msg = f\"Invalid serial address {equipment.connection.address!r}\"\n        raise ValueError(msg)\n\n    self._serial: serial.Serial = _init_serial(info.port, equipment.connection.properties)\n    self._set_interface_timeout()\n\n    try:\n        self._serial.open()\n    except serial.SerialException as e:\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.read_termination","title":"read_termination  <code>property</code> <code>writable</code>","text":"<pre><code>read_termination: bytes | None\n</code></pre> <p>The termination character sequence that is used for a read operation.</p> <p>Reading stops when the equipment stops sending data or the <code>read_termination</code> character sequence is detected. If you set the <code>read_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.serial","title":"serial  <code>property</code>","text":"<pre><code>serial: Serial\n</code></pre> <p>Returns the reference to the serial instance.</p>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.write_termination","title":"write_termination  <code>property</code> <code>writable</code>","text":"<pre><code>write_termination: bytes | None\n</code></pre> <p>The termination character sequence that is appended to write messages.</p> <p>If you set the <code>write_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Close the serial port.</p> Source code in <code>src/msl/equipment/interfaces/serial.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Close the serial port.\"\"\"\n    if hasattr(self, \"_serial\") and self._serial.is_open:\n        self._serial.close()\n        super().disconnect()\n</code></pre>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(  # noqa: PLR0913\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"api/interfaces/socket/","title":"Socket","text":""},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket","title":"Socket","text":"<pre><code>Socket(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MessageBased</code></p> <p>Base class for equipment that is connected through a socket.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for the socket communication protocol, as well as the properties defined in MessageBased.</p> <p>Connection Properties:</p> Name Type Description <code>buffer_size</code> <code>int</code> <p>The maximum number of bytes to read at a time. Default: <code>4096</code></p> Source code in <code>src/msl/equipment/interfaces/socket.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Base class for equipment that is connected through a socket.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for the socket communication protocol, as well as the _properties_ defined in\n    [MessageBased][msl.equipment.interfaces.message_based.MessageBased].\n\n    Attributes: Connection Properties:\n        buffer_size (int): The maximum number of bytes to read at a time. _Default: `4096`_\n    \"\"\"\n    super().__init__(equipment)\n\n    assert equipment.connection is not None  # noqa: S101\n\n    info = parse_socket_address(equipment.connection.address)\n    if info is None:\n        msg = f\"Invalid socket address {equipment.connection.address!r}\"\n        raise ValueError(msg)\n\n    self._info: ParsedSocketAddress = info\n\n    props = equipment.connection.properties\n    self._buffer_size: int = props.get(\"buffer_size\", 4096)\n    self._byte_buffer: bytearray = bytearray()\n\n    typ: int = socket.SOCK_DGRAM if equipment.connection.address.startswith(\"UDP\") else socket.SOCK_STREAM\n    self._is_stream: bool = typ == socket.SOCK_STREAM\n    self._socket: socket.socket = socket.socket(family=socket.AF_INET, type=typ)\n    self._connect()\n</code></pre>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.read_termination","title":"read_termination  <code>property</code> <code>writable</code>","text":"<pre><code>read_termination: bytes | None\n</code></pre> <p>The termination character sequence that is used for a read operation.</p> <p>Reading stops when the equipment stops sending data or the <code>read_termination</code> character sequence is detected. If you set the <code>read_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.socket","title":"socket  <code>property</code>","text":"<pre><code>socket: socket\n</code></pre> <p>Returns a reference to the underlying socket.</p>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.write_termination","title":"write_termination  <code>property</code> <code>writable</code>","text":"<pre><code>write_termination: bytes | None\n</code></pre> <p>The termination character sequence that is appended to write messages.</p> <p>If you set the <code>write_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Close the socket.</p> Source code in <code>src/msl/equipment/interfaces/socket.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Close the socket.\"\"\"\n    if hasattr(self, \"_socket\") and self._socket.fileno() != -1:\n        self._socket.close()\n        super().disconnect()\n</code></pre>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(  # noqa: PLR0913\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.reconnect","title":"reconnect","text":"<pre><code>reconnect(max_attempts: int = 1) -&gt; None\n</code></pre> <p>Reconnect to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>max_attempts</code> <code>int</code> <p>The maximum number of attempts to try to reconnect with the equipment. If &lt;1, keep trying until a connection is successful. If the maximum number of attempts has been reached then an exception is raise.</p> <code>1</code> Source code in <code>src/msl/equipment/interfaces/socket.py</code> <pre><code>def reconnect(self, max_attempts: int = 1) -&gt; None:\n    \"\"\"Reconnect to the equipment.\n\n    Args:\n        max_attempts: The maximum number of attempts to try to reconnect with the equipment.\n            If &amp;lt;1, keep trying until a connection is successful. If the maximum number\n            of attempts has been reached then an exception is raise.\n    \"\"\"\n    self._socket.close()\n    self._socket = socket.socket(family=self._socket.family, type=self._socket.type)\n\n    attempt = 0\n    while True:\n        attempt += 1\n        try:\n            return self._connect()\n        except (MSLConnectionError, MSLTimeoutError):\n            if 0 &lt; max_attempts &lt;= attempt:\n                raise\n</code></pre>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"api/interfaces/vxi11/","title":"VXI11","text":""},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11","title":"VXI11","text":"<pre><code>VXI11(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MessageBased</code></p> <p>Base class for the VXI-11 communication protocol.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for the VXI-11 communication protocol, as well as the properties defined in MessageBased.</p> <p>Connection Properties:</p> Name Type Description <code>buffer_size</code> <code>int</code> <p>The maximum number of bytes to read at a time. Default: <code>4096</code></p> <code>lock_timeout</code> <code>float</code> <p>The timeout (in seconds) to wait for a lock (0 means wait forever). Default: <code>0</code></p> <code>port</code> <code>int</code> <p>The port to use instead of calling the RPC Port Mapper function.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Base class for the [VXI-11](http://www.vxibus.org/specifications.html) communication protocol.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for the [VXI-11](http://www.vxibus.org/specifications.html) communication protocol, as well\n    as the _properties_ defined in [MessageBased][msl.equipment.interfaces.message_based.MessageBased].\n\n    Attributes: Connection Properties:\n        buffer_size (int): The maximum number of bytes to read at a time. _Default: `4096`_\n        lock_timeout (float): The timeout (in seconds) to wait for a lock (0 means wait forever). _Default: `0`_\n        port (int): The port to use instead of calling the RPC Port Mapper function.\n    \"\"\"\n    # the following must be defined before calling super()\n    self._core_client: CoreClient | None = None\n    self._abort_client: AsyncClient | None = None\n    self._lock_timeout: float = 0  # updated in lock_timeout.setter\n    super().__init__(equipment)\n\n    assert equipment.connection is not None  # noqa: S101\n    info = parse_vxi_address(equipment.connection.address)\n    if info is None:\n        msg = f\"Invalid VXI-11 address {equipment.connection.address!r}\"\n        raise ValueError(msg)\n\n    self._info: ParsedVXI11Address = info\n\n    props = equipment.connection.properties\n    self._buffer_size: int = props.get(\"buffer_size\", 4096)\n    self._core_port: int = props.get(\"port\", -1)  # updated in _connect if -1\n    self._abort_port: int = -1  # updated in _connect\n    self._max_recv_size: int = -1  # updated in _connect\n    self._link_id: int = -1  # updated in _connect\n    self._io_timeout_ms: int = -1  # updated in _set_interface_timeout\n    self._lock_timeout_ms: int = -1  # updated in lock_timeout.setter\n    self.lock_timeout = props.get(\"lock_timeout\", 0)\n\n    # A non-empty read_termination value is applied by default in\n    # MessageBased if the user did not specify one. Set it back\n    # to None if a read-termination character was not explicitly specified.\n    if \"read_termination\" not in props and \"termination\" not in props:\n        self.read_termination = None  # pyright: ignore[reportUnannotatedClassAttribute]\n\n    # VXI-11 does not support write-termination characters\n    self.write_termination = None  # pyright: ignore[reportUnannotatedClassAttribute]\n\n    self._connect()\n    self._set_interface_timeout()\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.lock_timeout","title":"lock_timeout  <code>property</code> <code>writable</code>","text":"<pre><code>lock_timeout: float\n</code></pre> <p>The time, in seconds, to wait to acquire a lock.</p> <p>Setting the value to \u22640 (or <code>None</code>) means wait forever.</p>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.socket","title":"socket  <code>property</code>","text":"<pre><code>socket: socket | None\n</code></pre> <p>Returns the reference to the underlying socket.</p>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.abort","title":"abort","text":"<pre><code>abort() -&gt; None\n</code></pre> <p>Stop an in-progress request.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def abort(self) -&gt; None:\n    \"\"\"Stop an in-progress request.\"\"\"\n    if self._abort_client is None:\n        self._abort_client = AsyncClient(self._info.host)\n        self._abort_client.connect(self._abort_port, timeout=self.timeout)\n    self._abort_client.device_abort(self._link_id)\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Send the <code>clear</code> command to the device.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Send the `clear` command to the device.\"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.device_clear(\n        lid=self._link_id,\n        flags=self._init_flag(),\n        lock_timeout=self._lock_timeout_ms,\n        io_timeout=self._io_timeout_ms,\n    )\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.create_intr_chan","title":"create_intr_chan","text":"<pre><code>create_intr_chan(\n    host_addr: int,\n    host_port: int,\n    prog_num: int,\n    prog_vers: int,\n    prog_family: int,\n) -&gt; None\n</code></pre> <p>Inform the network instrument server to establish an interrupt channel.</p> <p>Parameters:</p> Name Type Description Default <code>host_addr</code> <code>int</code> <p>Address of the host servicing the interrupt.</p> required <code>host_port</code> <code>int</code> <p>Valid port number on the client.</p> required <code>prog_num</code> <code>int</code> <p>Program number.</p> required <code>prog_vers</code> <code>int</code> <p>Program version number.</p> required <code>prog_family</code> <code>int</code> <p>The underlying socket protocol family type (<code>IPPROTO_TCP</code> or <code>IPPROTO_UDP</code>).</p> required Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def create_intr_chan(self, host_addr: int, host_port: int, prog_num: int, prog_vers: int, prog_family: int) -&gt; None:\n    \"\"\"Inform the network instrument server to establish an interrupt channel.\n\n    Args:\n        host_addr: Address of the host servicing the interrupt.\n        host_port: Valid port number on the client.\n        prog_num: Program number.\n        prog_vers: Program version number.\n        prog_family: The underlying socket protocol family type (`IPPROTO_TCP` or `IPPROTO_UDP`).\n    \"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.create_intr_chan(\n        host_addr=host_addr, host_port=host_port, prog_num=prog_num, prog_vers=prog_vers, prog_family=prog_family\n    )\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.destroy_intr_chan","title":"destroy_intr_chan","text":"<pre><code>destroy_intr_chan() -&gt; None\n</code></pre> <p>Inform the network instrument server to close its interrupt channel.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def destroy_intr_chan(self) -&gt; None:\n    \"\"\"Inform the network instrument server to close its interrupt channel.\"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.destroy_intr_chan()\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.destroy_link","title":"destroy_link","text":"<pre><code>destroy_link() -&gt; None\n</code></pre> <p>Destroy the link with the device.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def destroy_link(self) -&gt; None:\n    \"\"\"Destroy the link with the device.\"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.destroy_link(self._link_id)\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Unlink and close the sockets.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Unlink and close the sockets.\"\"\"\n    if self._abort_client is None and self._core_client is None:\n        return\n\n    if self._abort_client is not None:\n        self._abort_client.close()\n        self._abort_client = None\n\n    if self._core_client is not None:\n        if self._link_id != -1:\n            with contextlib.suppress(ConnectionError):\n                self._core_client.destroy_link(self._link_id)\n            self._link_id = -1\n\n        self._core_client.close()\n        self._core_client = None\n\n    super().disconnect()\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.docmd","title":"docmd","text":"<pre><code>docmd(cmd: int, value: float, fmt: str) -&gt; bytes\n</code></pre> <p>Allows for a variety of commands to be executed.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>int</code> <p>An IEEE 488 command messages. For example, to send the Group Execute Trigger command, GET, the value of <code>cmd</code> is <code>0x08</code>.</p> required <code>value</code> <code>float</code> <p>The value to use with <code>cmd</code>. Can be of type bool, int or float.</p> required <code>fmt</code> <code>str</code> <p>How to format <code>value</code>. See format-characters for more details. Do not include the byte-order character. Network (big-endian) order is always used.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The results defined by <code>cmd</code>.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def docmd(self, cmd: int, value: float, fmt: str) -&gt; bytes:\n    \"\"\"Allows for a variety of commands to be executed.\n\n    Args:\n        cmd: An IEEE 488 command messages. For example, to send the Group Execute Trigger\n            command, _GET_, the value of `cmd` is `0x08`.\n        value: The value to use with `cmd`. Can be of type [bool][], [int][] or [float][].\n        fmt: How to format `value`. See [format-characters][] for more details. Do not\n            include the byte-order character. Network (big-endian) order is always used.\n\n    Returns:\n        The results defined by `cmd`.\n    \"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    # always use network (big-endian) byte order\n    s = Struct(\"!\" + fmt.lstrip(\"@=&lt;&gt;!\"))\n    return self._core_client.device_docmd(\n        lid=self._link_id,\n        flags=self._init_flag(),\n        io_timeout=self._io_timeout_ms,\n        lock_timeout=self._lock_timeout_ms,\n        cmd=cmd,\n        network_order=True,\n        size=s.size,\n        data=s.pack(value),\n    )\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.enable_sqr","title":"enable_sqr","text":"<pre><code>enable_sqr(*, state: bool, handle: bytes) -&gt; None\n</code></pre> <p>Enable or disable the sending of <code>device_intr_srq</code> RPCs by the network instrument server.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>Whether to enable or disable interrupts.</p> required <code>handle</code> <code>bytes</code> <p>Host specific data (maximum length is 40 characters).</p> required Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def enable_sqr(self, *, state: bool, handle: bytes) -&gt; None:\n    \"\"\"Enable or disable the sending of `device_intr_srq` RPCs by the network instrument server.\n\n    Args:\n        state: Whether to enable or disable interrupts.\n        handle: Host specific data (maximum length is 40 characters).\n    \"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.device_enable_srq(lid=self._link_id, state=state, handle=handle)\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.local","title":"local","text":"<pre><code>local() -&gt; None\n</code></pre> <p>Place the device in a local state wherein all programmable local controls are enabled.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def local(self) -&gt; None:\n    \"\"\"Place the device in a local state wherein all programmable local controls are enabled.\"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.device_local(\n        lid=self._link_id,\n        flags=self._init_flag(),\n        lock_timeout=self._lock_timeout_ms,\n        io_timeout=self._io_timeout_ms,\n    )\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.lock","title":"lock","text":"<pre><code>lock() -&gt; None\n</code></pre> <p>Acquire the device's lock.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def lock(self) -&gt; None:\n    \"\"\"Acquire the device's lock.\"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.device_lock(lid=self._link_id, flags=self._init_flag(), lock_timeout=self._lock_timeout_ms)\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(  # noqa: PLR0913\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.read_stb","title":"read_stb","text":"<pre><code>read_stb() -&gt; int\n</code></pre> <p>Read the status byte from the device.</p> <p>Returns:</p> Type Description <code>int</code> <p>The status byte.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def read_stb(self) -&gt; int:\n    \"\"\"Read the status byte from the device.\n\n    Returns:\n        The status byte.\n    \"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    return self._core_client.device_readstb(\n        lid=self._link_id,\n        flags=self._init_flag(),\n        lock_timeout=self._lock_timeout_ms,\n        io_timeout=self._io_timeout_ms,\n    )\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.reconnect","title":"reconnect","text":"<pre><code>reconnect(max_attempts: int = 1) -&gt; None\n</code></pre> <p>Reconnect to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>max_attempts</code> <code>int</code> <p>The maximum number of attempts to try to reconnect with the equipment. If &lt;1, keep trying until a connection is successful. If the maximum number of attempts has been reached then an exception is raise.</p> <code>1</code> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def reconnect(self, max_attempts: int = 1) -&gt; None:\n    \"\"\"Reconnect to the equipment.\n\n    Args:\n        max_attempts: The maximum number of attempts to try to reconnect with the equipment.\n            If &amp;lt;1, keep trying until a connection is successful. If the maximum number\n            of attempts has been reached then an exception is raise.\n    \"\"\"\n    attempt = 0\n    while True:\n        attempt += 1\n        try:\n            return self._connect()\n        except (MSLConnectionError, MSLTimeoutError):\n            if 0 &lt; max_attempts &lt;= attempt:\n                raise\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.remote","title":"remote","text":"<pre><code>remote() -&gt; None\n</code></pre> <p>Place the device in a remote state wherein all programmable local controls are disabled.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def remote(self) -&gt; None:\n    \"\"\"Place the device in a remote state wherein all programmable local controls are disabled.\"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.device_remote(\n        lid=self._link_id,\n        flags=self._init_flag(),\n        lock_timeout=self._lock_timeout_ms,\n        io_timeout=self._io_timeout_ms,\n    )\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.trigger","title":"trigger","text":"<pre><code>trigger() -&gt; None\n</code></pre> <p>Send a trigger to the device.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def trigger(self) -&gt; None:\n    \"\"\"Send a trigger to the device.\"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.device_trigger(\n        lid=self._link_id,\n        flags=self._init_flag(),\n        lock_timeout=self._lock_timeout_ms,\n        io_timeout=self._io_timeout_ms,\n    )\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.unlock","title":"unlock","text":"<pre><code>unlock() -&gt; None\n</code></pre> <p>Release the lock acquired by lock.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def unlock(self) -&gt; None:\n    \"\"\"Release the lock acquired by [lock][msl.equipment.interfaces.vxi11.VXI11.lock].\"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.device_unlock(self._link_id)\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"api/interfaces/zeromq/","title":"ZeroMQ","text":""},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ","title":"ZeroMQ","text":"<pre><code>ZeroMQ(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MessageBased</code></p> <p>Base class for equipment that use the ZeroMQ communication protocol.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for the ZeroMQ communication protocol, as well as the properties defined in MessageBased. The ZeroMQ protocol does not use termination characters, so if termination characters are specified the value is ignored and is set to <code>None</code>.</p> <p>Connection Properties:</p> Name Type Description <code>protocol</code> <code>str</code> <p>ZeroMQ protocol (<code>tcp</code>, <code>udp</code>, <code>pgm</code>, <code>inproc</code>, <code>ipc</code>) Default: <code>tcp</code></p> <code>socket_type</code> <code>int | str</code> <p>ZeroMQ socket type. Default: <code>REQ</code></p> Source code in <code>src/msl/equipment/interfaces/zeromq.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Base class for equipment that use the [ZeroMQ](https://zeromq.org/) communication protocol.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for the [ZeroMQ](https://zeromq.org/) communication protocol, as well as the _properties_\n    defined in [MessageBased][msl.equipment.interfaces.message_based.MessageBased].\n    The [ZeroMQ](https://zeromq.org/) protocol does not use termination characters, so if\n    termination characters are specified the value is ignored and is set to `None`.\n\n    Attributes: Connection Properties:\n        protocol (str): ZeroMQ protocol (`tcp`, `udp`, `pgm`, `inproc`, `ipc`) _Default: `tcp`_\n        socket_type (int | str): ZeroMQ [socket type][zmq.SocketType]. _Default: `REQ`_\n    \"\"\"\n    super().__init__(equipment)\n\n    assert equipment.connection is not None  # noqa: S101\n\n    address = parse_zmq_address(equipment.connection.address)\n    if address is None:\n        msg = f\"Invalid ZeroMQ address {equipment.connection.address!r}\"\n        raise ValueError(msg)\n\n    p = equipment.connection.properties\n    socket_type = to_enum(p.get(\"socket_type\", \"REQ\"), SocketType, to_upper=True)\n    protocol: str = p.get(\"protocol\", \"tcp\")\n\n    # ZeroMQ does not use termination characters\n    self.read_termination = None  # pyright: ignore[reportUnannotatedClassAttribute]\n    self.write_termination = None  # pyright: ignore[reportUnannotatedClassAttribute]\n\n    self._context: Context[SyncSocket] = zmq.Context()\n    self._socket: SyncSocket = self._context.socket(socket_type)\n    self._set_interface_timeout()\n    self._set_interface_max_read_size()\n\n    # Calling zmq.Socket.connect() does not verify that the host:port value until the\n    # socket is used to write/read bytes. An error raised here would be for an an invalid\n    # ZeroMQ addr value\n    try:\n        _ = self._socket.connect(f\"{protocol}://{address.host}:{address.port}\")\n    except zmq.ZMQError as e:\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n</code></pre>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.socket","title":"socket  <code>property</code>","text":"<pre><code>socket: SyncSocket\n</code></pre> <p>Returns a reference to the underlying socket.</p>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Close the socket connection and terminate the context.</p> Source code in <code>src/msl/equipment/interfaces/zeromq.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Close the socket connection and terminate the context.\"\"\"\n    if hasattr(self, \"_socket\") and not self._socket.closed:\n        self._context.set(zmq.BLOCKY, 0)\n        self._socket.setsockopt(zmq.LINGER, 0)\n        self._socket.close()\n        self._context.term()\n        super().disconnect()\n</code></pre>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(  # noqa: PLR0913\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Three concepts are used by <code>msl-equipment</code></p> <ol> <li>Equipment registers \u2014 to comply with the ISO/IEC 17025 standard</li> <li>Connections \u2014 to interface with equipment for computer control</li> <li>Configuration files \u2014 define requirements for a measurement (links items 1 and 2 together)</li> </ol> <p>You do not need to use all three concepts for your application. You can choose to only use the equipment-register classes to help manage information about the equipment in your laboratory and use a different Python package to communicate with equipment. Similarly, you can choose to use one of the supported backends for communication. You can choose to ignore the equipment registers concept and solely use the package to communicate with equipment. You can also choose to not use <code>msl-equipment</code> at all, but just use the Schema to create equipment registers that comply with ISO/IEC 17025. Since an equipment register is written in the eXtensible Markup Language (XML) file format, it may be parsed by many programming languages. This allows people to share a common equipment register but use different programming languages to read information from the same equipment register.</p>"},{"location":"getting-started/configuration-files/","title":"Configuration Files","text":"<p>A configuration file is useful when you want to perform a measurement. You can use it to specify</p> <ul> <li>equipment that is required to perform the measurement</li> <li>locations of the equipment registers and connections that the equipment can be found in</li> <li>user-specific information that the measurement procedure requires for data acquisition.</li> </ul> <p>A configuration file uses the eXtensible Markup Language (XML) file format to specify this information.</p>"},{"location":"getting-started/configuration-files/#config-xml-example","title":"XML Example","text":"<p>The following illustrates an example configuration file.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;config&gt; &lt;!-- The name of the root tag can be anything you want. --&gt;\n\n  &lt;!-- OPTIONAL: Set the path to a GPIB library file (for GPIB communication).\n\n    This creates/overwrites the value of the GPIB_LIBRARY environment variable.\n    Specifying this element is only necessary if the default file location is\n    not automatically found or if you want to use a different GPIB library\n    instead of the default library.\n  --&gt;\n  &lt;gpib_library&gt;/opt/gpib/libgpib.so.0&lt;/gpib_library&gt;\n\n  &lt;!-- OPTIONAL: Set the PyVISA backend library to use for PyVISA communication.\n\n    This creates/overwrites the value of the PYVISA_LIBRARY environment\n    variable. Possible values are:\n      @ivi (PyVISA &gt;=1.11, default)\n      @ni  (PyVISA &lt; 1.11)\n      @py  (PyVISA-py)\n      @sim (PyVISA-sim)\n  --&gt;\n  &lt;pyvisa_library&gt;@py&lt;/pyvisa_library&gt;\n\n  &lt;!-- OPTIONAL: Add paths to where library files are located.\n\n    The paths are appended to the PATH environment variable. If a\n    recursive=\"true\" attribute is included, then recursively adds the\n    specified directory and all sub-directories to PATH. Adding &lt;path&gt;\n    elements is useful if communication to equipment requires the\n    manufacturer's Software Development Kit (SDK). The &lt;path&gt; element\n    may be specified multiple times.\n  --&gt;\n  &lt;path&gt;C:\\Program Files\\Manufacturer\\lib&lt;/path&gt;\n  &lt;path recursive=\"true\"&gt;D:\\code\\SDKs&lt;/path&gt;\n\n  &lt;!-- Specify the equipment that is required to perform the measurement.\n\n    The `eid` attribute (equipment ID from an equipment register) is mandatory,\n    and the `name` attribute is optional. If you define a `name`, you can access\n    the equipment by its name instead of the index number based on the order\n    that &lt;equipment/&gt; elements are defined in the configuration file. You can\n    also access the equipment by its `eid` value. All other attributes are\n    ignored by msl-equipment. Additional attributes may be helpful for a person\n    to know what the equipment is when they read the configuration file.\n\n    Not all &lt;equipment/&gt; elements that are defined need to be for communication\n    purposes. Cables, amplifiers, filters and adaptors can all be important\n    equipment that may be required to perform a measurement. Defining this kind\n    of equipment is useful to have access to during data acquisition since you\n    can save the &lt;equipment/&gt; information (or just the equipment IDs) to the\n    output file.\n   --&gt;\n  &lt;equipment eid=\"MSLE.M.092\" name=\"dmm\" comment=\"borrowed from Kibble lab\"/&gt;\n  &lt;equipment eid=\"MSLE.O.103\" name=\"photodiode\" manufacturer=\"MSL\" std=\"B03\"/&gt;\n  &lt;equipment eid=\"MSLE.O.061\" name=\"monochromator\"/&gt;\n\n  &lt;!-- Equipment registers that the equipment above can be found in.\n\n    The value can be a single XML file or a directory that contains multiple\n    XML files (if your register spans multiple files). If a directory, the\n    specified directory and all sub-directories will be searched for equipment\n    registers.\n\n    The value supports the ~ character to represent the users HOME directory.\n    The &lt;register&gt; element can be specified multiple times.\n  --&gt;\n  &lt;register&gt;~\\Equipment\\register.xml&lt;/register&gt;\n  &lt;register&gt;M:\\Mass\\Register&lt;/register&gt;\n\n  &lt;!-- Connection files for equipment that require computer control.\n\n    The value can be a single XML file or a directory that contains multiple\n    XML files. If a directory, the specified directory and all sub-directories\n    will be searched for connection files.\n\n    The value supports the ~ character to represent the users HOME directory.\n    The &lt;connections&gt; element can be specified multiple times.\n  --&gt;\n  &lt;connections&gt;C:\\DATA\\Connections\\transmittance.xml&lt;/connections&gt;\n\n  &lt;!-- USER SPECIFIC: You may define your own elements. --&gt;\n  &lt;max_temperature unit=\"\u00b0C\"&gt;30&lt;/max_temperature&gt;\n  &lt;auto_zero&gt;true&lt;/auto_zero&gt;\n  &lt;nd_filter&gt;OD: 2.0&lt;/nd_filter&gt;\n  &lt;smtp&gt;\n    &lt;host&gt;smtp.server.nz&lt;/host&gt;\n    &lt;port&gt;25&lt;/port&gt;\n    &lt;recipient&gt;me@measurement.govt.nz&lt;/recipient&gt;\n    &lt;recipient&gt;you@measurement.govt.nz&lt;/recipient&gt;\n  &lt;/smtp&gt;\n\n&lt;/config&gt;\n</code></pre>"},{"location":"getting-started/configuration-files/#config-python-example","title":"Python Example","text":"<p>The Config class is used to load a configuration file</p> <pre><code>&gt;&gt;&gt; from msl.equipment import Config\n&gt;&gt;&gt; cfg = Config(\"tests/resources/config.xml\")\n</code></pre> <p>You can then access the equipment registers,</p> <pre><code>&gt;&gt;&gt; for team, register in cfg.registers.items():\n...    print(f\"{team}:\", register)\nMass: &lt;Register team='Mass' (3 equipment)&gt;\nLight: &lt;Register team='Light' (4 equipment)&gt;\n</code></pre> <p>iterate over and access <code>&lt;equipment/&gt;</code> elements that have been defined in the configuration file to access the Equipment instances,</p> <pre><code>&gt;&gt;&gt; for equipment in cfg.equipment:\n...     print(equipment.id)\nMSLE.M.092\nMSLE.O.103\nMSLE.O.061\n&gt;&gt;&gt; cfg.equipment[0].id  # use the index\n'MSLE.M.092'\n&gt;&gt;&gt; cfg.equipment[\"MSLE.M.092\"].id  # use the equipment id\n'MSLE.M.092'\n&gt;&gt;&gt; cfg.equipment[\"dmm\"].id  # use the name attribute\n'MSLE.M.092'\n</code></pre> <p>access XML elements defined in the configuration file by using the tag name or the path to the element,</p> <pre><code>&gt;&gt;&gt; cfg.attrib(\"max_temperature\")\n{'unit': '\u00b0C'}\n&gt;&gt;&gt; cfg.find(\"max_temperature\")\n&lt;Element 'max_temperature' at ...&gt;\n&gt;&gt;&gt; cfg.findall(\"smtp/recipient\")\n[&lt;Element 'recipient' at ...&gt;, &lt;Element 'recipient' at ...&gt;]\n</code></pre> <p>and if the value of an XML element is a boolean (<code>true</code>, <code>false</code> case-insensitive) an integer or a floating-point number, you can use the value method to convert the text value to the appropriate Python data type (otherwise the text value will remain as a string).</p> <pre><code>&gt;&gt;&gt; cfg.value(\"auto_zero\")\nTrue\n&gt;&gt;&gt; cfg.value(\"max_temperature\") / 2\n15.0\n&gt;&gt;&gt; cfg.value(\"nd_filter\")\n'OD: 2.0'\n</code></pre>"},{"location":"getting-started/connections/","title":"Connections","text":"<p>The information about how to interface with equipment for computer control is based on the definitions in the Schema and may either be saved in the eXtensible Markup Language (XML) file format or in a Python module. When using the XML format, you would specify the XML file that contains the connection information as a <code>&lt;connections&gt;</code> element in your configuration file. When the configuration file is loaded (via Config), it links a Connection instance with the corresponding Equipment instance based on the equipment id.</p>"},{"location":"getting-started/connections/#connections-xml","title":"XML Schema","text":"<p>Schema definition for connection information. See this section for details on how to validate the contents of a connections XML file against the schema.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;xsd:schema version=\"1.0.0\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"&gt;\n    &lt;xsd:element name=\"connections\"&gt;\n        &lt;xsd:complexType&gt;\n            &lt;xsd:sequence minOccurs=\"0\" maxOccurs=\"unbounded\"&gt;\n                &lt;xsd:element name=\"connection\"&gt;\n                    &lt;xsd:complexType&gt;\n                        &lt;xsd:all&gt;\n                            &lt;xsd:element name=\"eid\" type=\"xsd:string\"&gt;\n                                &lt;xsd:annotation&gt;\n                                    &lt;xsd:documentation&gt;\n                                        The equipment ID from an equipment register.\n                                    &lt;/xsd:documentation&gt;\n                                &lt;/xsd:annotation&gt;\n                            &lt;/xsd:element&gt;\n                            &lt;xsd:element name=\"address\" type=\"xsd:string\"&gt;\n                                &lt;xsd:annotation&gt;\n                                    &lt;xsd:documentation&gt;\n                                        The VISA-style address to use for the connection.\n                                    &lt;/xsd:documentation&gt;\n                                &lt;/xsd:annotation&gt;\n                            &lt;/xsd:element&gt;\n                            &lt;xsd:element name=\"backend\" minOccurs=\"0\"&gt;\n                                &lt;xsd:annotation&gt;\n                                    &lt;xsd:documentation&gt;\n                                        The backend package to use to communicate with the equipment.\n                                        Default is MSL if not defined.\n                                    &lt;/xsd:documentation&gt;\n                                &lt;/xsd:annotation&gt;\n                                &lt;xsd:simpleType&gt;\n                                    &lt;xsd:restriction base=\"xsd:string\"&gt;\n                                        &lt;xsd:enumeration value=\"MSL\"/&gt;\n                                        &lt;xsd:enumeration value=\"PyVISA\"/&gt;\n                                        &lt;xsd:enumeration value=\"NIDAQ\"/&gt;\n                                    &lt;/xsd:restriction&gt;\n                                &lt;/xsd:simpleType&gt;\n                            &lt;/xsd:element&gt;\n                            &lt;xsd:element name=\"manufacturer\" type=\"xsd:string\" minOccurs=\"0\"&gt;\n                                &lt;xsd:annotation&gt;\n                                    &lt;xsd:documentation&gt;\n                                        The name of the manufacturer of the equipment.\n                                    &lt;/xsd:documentation&gt;\n                                &lt;/xsd:annotation&gt;\n                            &lt;/xsd:element&gt;\n                            &lt;xsd:element name=\"model\" type=\"xsd:string\" minOccurs=\"0\"&gt;\n                                &lt;xsd:annotation&gt;\n                                    &lt;xsd:documentation&gt;\n                                        The model number of the equipment.\n                                    &lt;/xsd:documentation&gt;\n                                &lt;/xsd:annotation&gt;\n                            &lt;/xsd:element&gt;\n                            &lt;xsd:element name=\"serial\" type=\"xsd:string\" minOccurs=\"0\"&gt;\n                                &lt;xsd:annotation&gt;\n                                    &lt;xsd:documentation&gt;\n                                        The serial number (or unique identifier) of the equipment.\n                                    &lt;/xsd:documentation&gt;\n                                &lt;/xsd:annotation&gt;\n                            &lt;/xsd:element&gt;\n                            &lt;xsd:element name=\"properties\" minOccurs=\"0\"&gt;\n                                &lt;xsd:annotation&gt;\n                                    &lt;xsd:documentation&gt;\n                                        Additional name-value pairs that are required to communicate with the equipment.\n                                    &lt;/xsd:documentation&gt;\n                                &lt;/xsd:annotation&gt;\n                                &lt;xsd:complexType&gt;\n                                    &lt;xsd:sequence&gt;\n                                        &lt;xsd:any processContents=\"skip\" minOccurs=\"0\" maxOccurs=\"unbounded\"/&gt;\n                                    &lt;/xsd:sequence&gt;\n                                &lt;/xsd:complexType&gt;\n                            &lt;/xsd:element&gt;\n                        &lt;/xsd:all&gt;\n                    &lt;/xsd:complexType&gt;\n                &lt;/xsd:element&gt;\n            &lt;/xsd:sequence&gt;\n        &lt;/xsd:complexType&gt;\n    &lt;/xsd:element&gt;\n&lt;/xsd:schema&gt;\n</code></pre>"},{"location":"getting-started/connections/#connections-xml-example","title":"Example","text":"<p>Example XML file to specify connection information. Only the <code>&lt;eid&gt;</code> and <code>&lt;address&gt;</code> elements are required, all other elements are optional.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;connections&gt;\n    &lt;connection&gt;\n        &lt;eid&gt;MSLE.M.041&lt;/eid&gt;\n        &lt;address&gt;TCPIP::192.168.1.10::hislip0&lt;/address&gt;\n    &lt;/connection&gt;\n    &lt;connection&gt;\n        &lt;eid&gt;MSLE.M.023&lt;/eid&gt;\n        &lt;address&gt;ASRL/dev/ttyS1&lt;/address&gt;\n        &lt;backend&gt;PyVISA&lt;/backend&gt;\n        &lt;manufacturer&gt;Manufacturer&lt;/manufacturer&gt;\n        &lt;model&gt;Model&lt;/model&gt;\n        &lt;serial&gt;Serial&lt;/serial&gt;\n        &lt;properties&gt;\n            &lt;baud_rate&gt;19200&lt;/baud_rate&gt;\n            &lt;read_termination&gt;\\r&lt;/read_termination&gt;\n            &lt;write_termination&gt;\\r&lt;/write_termination&gt;\n            &lt;timeout&gt;10&lt;/timeout&gt;\n        &lt;/properties&gt;\n    &lt;/connection&gt;\n&lt;/connections&gt;\n</code></pre>"},{"location":"getting-started/connections/#address-syntax","title":"Address Syntax","text":"<p>The following are examples of VISA-style addresses that may be used to connect to equipment.</p> Interface Address Description GPIB GPIB::10 GPIB device at board=0 (default), primary address=10, no secondary address GPIB GPIB0::voltmeter GPIB device at board=0, interface name=\"voltmeter\" (see gpib.conf for more details about the \"name\" option) GPIB GPIB1::6::97::INSTR GPIB device at board=1, primary address=6, secondary address=97 GPIB GPIB2::INTFC GPIB interface at board=2 HiSLIP TCPIP::dev.company.com::hislip0 A HiSLIP LAN instrument, host=dev.company.com HiSLIP TCPIP::10.12.114.50::hislip0,5000::INSTR A HiSLIP LAN instrument, host=10.12.114.50, port=5000 PROLOGIX Prologix::192.168.1.110::1234::6 The GPIB-ETHERNET Controller, host=192.168.1.110, port=1234, primary GPIB address=6 PROLOGIX Prologix::192.168.1.70::1234::6::112 The GPIB-ETHERNET Controller, host=192.168.1.70, port=1234, primary GPIB address=6, secondary GPIB address=112 PROLOGIX Prologix::192.168.1.70::1234::GPIB::6::112 The GPIB-ETHERNET Controller, host=192.168.1.70, port=1234, primary GPIB address=6, secondary GPIB address=112 PROLOGIX Prologix::COM3::6 The GPIB-USB Controller, port=COM3, primary GPIB address=6 PROLOGIX Prologix::COM3::GPIB::6 The GPIB-USB Controller, port=COM3, primary GPIB address=6 PROLOGIX Prologix::/dev/ttyS0::4::96 The GPIB-USB Controller, port=/dev/ttyS0, primary GPIB address=4, secondary GPIB address=96 SDK SDK::C:/Manufacturer/library.dll Specify the full path to the SDK SDK SDK::library.dll Specify only the filename if the path to where the SDK file is located has been added to the <code>PATH</code> environment variable SERIAL COM2 A serial port on Windows SERIAL ASRL/dev/ttyS1 A serial port on Linux SERIAL ASRL2::INSTR Compatible with National Instruments syntax SERIAL ASRLCOM2 Compatible with PyVISA-py syntax SOCKET TCP::192.168.1.100::5000 Use the TCP protocol, host=192.168.1.100, port=5000 SOCKET UDP::192.168.1.100::5000 Use the UDP protocol, host=192.168.1.100, port=5000 SOCKET TCPIP::192.168.1.100::5000::SOCKET Compatible with National Instruments syntax VXI-11 TCPIP::dev.company.com::INSTR A VXI-11.3 LAN instrument, host=dev.company.com (uses the default LAN Device Name inst0) VXI-11 TCPIP::10.6.56.21::gpib0,2::INSTR A VXI-11.2 GPIB device, host=10.6.56.21, gpib address=2 VXI-11 TCPIP::192.168.1.100 A VXI-11.3 LAN instrument, host=192.168.1.100 (default values for board 0 and LAN device name inst0 are used) ZMQ ZMQ::192.168.20.90::5555 Use the ZeroMQ messaging library to connect to a device, host=192.168.20.90, port=5555 <p>National Instruments also provides examples if you are using PyVISA as the backend.</p>"},{"location":"getting-started/connections/#connections-interfaces","title":"Interfaces","text":"<p>The following interface classes are available</p> <ul> <li>GPIB \u2014 Base class for GPIB communication</li> <li>HiSLIP \u2014 Base class for the HiSLIP communication protocol</li> <li>Prologix \u2014 Use Prologix hardware to establish a connection</li> <li>SDK \u2014 Use the Software Development Kit (SDK) provided by the manufacturer</li> <li>Serial \u2014 Base class for equipment that is connected through a serial port</li> <li>Socket \u2014 Base class for equipment that is connected through a socket</li> <li>VXI11 \u2014 Base class for the VXI-11 communication protocol</li> <li>ZeroMQ \u2014 Communicate via the ZeroMQ protocol</li> </ul>"},{"location":"getting-started/connections/#connections-backend","title":"Backends","text":"<p>When a Connection instance is created, the <code>backend</code> keyword argument decides which backend to use when interfacing with the equipment. There are different Backends to choose from: <code>MSL</code> (default), <code>PyVISA</code> or <code>NIDAQ</code>.</p> <p>The interface class can be used if the <code>backend</code> is <code>MSL</code>. The corresponding interface classes for the external backends are PyVISA and NIDAQ.</p>"},{"location":"getting-started/connections/#connections-python-module","title":"Python Module","text":"<p>If you are primarily interested in using <code>msl-equipment</code> for interfacing with equipment (and not the Equipment Registers aspect), the simplest approach is to create Connection instances in a module and call the connect method.</p> <pre><code>from msl.equipment import Connection\n\ndevice = Connection(\"COM3\").connect()\nprint(device.query(\"*IDN?\"))\n</code></pre> <p>If you have multiple equipment that you want to communicate with and you also want to include some additional metadata so that you can keep track of which device is associated with the corresponding address, you could do something like the following.</p> <pre><code>from msl.equipment import Connection\n\n# Assign custom names to associate with each equipment\nconnections = {\n    \"alice\": Connection(\"GPIB::22\", model=\"3458A\"),\n    \"bob\": Connection(\"COM3\", manufacturer=\"HP\", model=\"34401A\"),\n\n    # not used below but is available to use for another day\n    \"eve\": Connection(\"SDK::company.dll\", model=\"Scope-20\", resolution=\"16bit\"),\n}\n\n# Connect to the equipment using the names that were assigned\nalice = connections[\"alice\"].connect()\nbob = connections[\"bob\"].connect()\n\n# Query the identity\nprint(alice.query(\"ID?\"))\nprint(bob.query(\"*IDN?\"))\n</code></pre>"},{"location":"getting-started/equipment-registers/","title":"Equipment Registers","text":"<p>Laboratories that use equipment for traceable calibration measurements are required to manage information about the equipment by following the ISO/IEC 17025 standard. This information is saved in files that are referred to as equipment registers.</p> <p>An equipment register is based on the definitions in the Schema and may either be saved in the eXtensible Markup Language (XML) file format or in a Python module. Using the XML format is the preferred way to save the information since XML files can be easily validated against the Schema to ensure data integrity and it allows for equipment registers to be parsed by many programming languages. An equipment register can be saved in a single XML file or distributed across multiple XML files.</p> <p>The Schema Classes section of the documentation shows how an equipment register can be used in a Python program.</p>"},{"location":"getting-started/equipment-registers/#er-schema","title":"XML Schema","text":"<p>The documentation for the equipment-register schema is available here and development of the schema is performed in the repository.</p> <p>Currently, the schema is targeting equipment that is located at the Measurement Standards Laboratory of New Zealand (in particular, enumeration values and pattern-string matches). If you work at a calibration laboratory and are interested in using the schema within your Quality Management System, please contact us or open an issue.</p> <p>See this section for details on how to validate the contents of an equipment register against the schema.</p>"},{"location":"getting-started/equipment-registers/#er-python-module","title":"Python Module","text":"<p>You may save the information about the equipment you are using in Python modules instead of in XML files.</p> <pre><code>from datetime import date\n\nfrom msl.equipment import (\n    CompletedTask,\n    Component,\n    Connection,\n    Equation,\n    Equipment,\n    Evaluable,\n    Maintenance,\n    Measurand,\n    Range,\n    Report,\n)\n\nequipment = Equipment(\n    manufacturer=\"HP\",\n    model=\"3458A\",\n    connection=Connection(\"GPIB::22\"),\n    maintenance=Maintenance(\n        completed=(\n            CompletedTask(\n                task=\"Clean fan\",\n                due_date=date(2025, 3, 4),\n                completed_date=date(2025, 3, 5),\n                performed_by=\"John\",\n            ),\n        )\n    ),\n    calibrations=(\n        Measurand(\n            quantity=\"Voltage DC\",\n            calibration_interval=1,\n            components=(\n                Component(\n                    reports=(\n                        Report(\n                            id=\"Report No.\",\n                            report_issue_date=date(2024, 8, 13),\n                            measurement_start_date=date(2024, 8, 5),\n                            measurement_stop_date=date(2024, 8, 6),\n                            equations=(\n                                Equation(\n                                    value=Evaluable(\n                                        equation=\"0.9999862*v + 1.024e-5\",\n                                        variables=(\"v\",),\n                                        ranges={\"v\": Range(1, 10)}\n                                    ),\n                                    uncertainty=Evaluable(equation=\"3.2e-6\"),\n                                    unit=\"V\",\n                                ),\n                            ),\n                        ),\n                    )\n                ),\n            ),\n        ),\n    ),\n)\n\n# Connect to the digital multimeter and query its identity\ndmm = equipment.connect()\nprint(dmm.query(\"ID?\"))\n\n# Configure the multimeter, fetch voltage readings, convert to float(s)\nvoltages = ...\n\n# Apply the calibration equation to correct the voltage readings\ncorrection = equipment.latest_report().equation\nprint(correction.value(v=voltages))\nprint(correction.uncertainty(v=voltages))\n</code></pre>"},{"location":"resources/","title":"Resources","text":"<p>Resources are custom classes for interfacing with specific equipment. In previous releases of <code>msl-equipment</code> (versions &lt; 1.0), the resources were automatically bundled with <code>msl-equipment</code>. As of v1.0, the resources are maintained in another package, <code>msl-equipment-resources</code>, that must be installed separately.</p> <p>Some of the resources might not work in your application because the resource might depend on an external dependency, e.g., the Software Development Kit (SDK) provided by a manufacturer, and this external dependency might not be available for your operating system.</p> <p>Attention</p> <p>Companies that sell equipment that are used for scientific research are identified in this guide in order to illustrate how to adequately use <code>msl-equipment-resources</code> in your application. Such identification is not intended to imply recommendation or endorsement by the Measurement Standards Laboratory of New Zealand, nor is it intended to imply that the companies identified are necessarily the best for the purpose.</p>"},{"location":"resources/#install","title":"Install","text":"<p>Installing <code>msl-equipment-resources</code> will also install <code>msl-equipment</code></p> <pre><code>pip install msl-equipment-resources\n</code></pre>"},{"location":"resources/#create-a-new-resource","title":"Create a new resource","text":""},{"location":"schema/","title":"Schema Classes","text":"<p>Class representations of the XML Schema Definition for an equipment register.</p> <p>The primary class is Register which contains a sequence of Equipment classes that are each composed of the following classes:</p> <ul> <li>AcceptanceCriteria</li> <li>Accessories</li> <li>Adjustment</li> <li>Alteration</li> <li>CapitalExpenditure</li> <li>Competency</li> <li>CompletedTask</li> <li>Component</li> <li>Conditions</li> <li>CVDEquation (Callendar-Van Dusen equation, uses the cvdCoefficients)</li> <li>Deserialised (opposite of serialised)</li> <li>DigitalReport</li> <li>Equation</li> <li>File</li> <li>Financial</li> <li>Firmware</li> <li>Maintenance</li> <li>Measurand</li> <li>PerformanceCheck</li> <li>PlannedTask</li> <li>QualityManual</li> <li>ReferenceMaterials</li> <li>Report</li> <li>Specifications</li> <li>SpecifiedRequirements</li> <li>Status</li> <li>Table</li> </ul> <p>The Any class is used as a base class for elements that are currently represented by the any type in the XML Schema Definition.</p>"},{"location":"schema/acceptance_criteria/","title":"AcceptanceCriteria","text":""},{"location":"schema/acceptance_criteria/#msl.equipment.schema.AcceptanceCriteria","title":"AcceptanceCriteria","text":"<pre><code>AcceptanceCriteria(**attributes: str)\n</code></pre> <p>               Bases: <code>Any</code></p> <p>Represents the acceptance criteria in a calibration report.</p> <p>Since this class is currently represented by the any type in the XML Schema Definition, it is simply a subclass of Element. It may be updated to be a more specific class at a later date.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any] type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/acceptance_criteria/#msl.equipment.schema.AcceptanceCriteria.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str = 'acceptanceCriteria'\n</code></pre> <p>The element's name.</p>"},{"location":"schema/acceptance_criteria/#msl.equipment.schema.AcceptanceCriteria.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/accessories/","title":"Accessories","text":""},{"location":"schema/accessories/#msl.equipment.schema.Accessories","title":"Accessories","text":"<pre><code>Accessories(**attributes: str)\n</code></pre> <p>               Bases: <code>Any</code></p> <p>Additional accessories that may be required to use the equipment.</p> <p>Since this class is currently represented by the any type in the XML Schema Definition, it is simply a subclass of Element. It may be updated to be a more specific class at a later date.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any] type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/accessories/#msl.equipment.schema.Accessories.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str = 'accessories'\n</code></pre> <p>The element's name.</p>"},{"location":"schema/accessories/#msl.equipment.schema.Accessories.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/adjustment/","title":"Adjustment","text":""},{"location":"schema/adjustment/#msl.equipment.schema.Adjustment","title":"Adjustment  <code>dataclass</code>","text":"<pre><code>Adjustment(details: str, date: date)\n</code></pre> <p>An adjustment of the equipment.</p> <p>An example of an adjustment is cleaning the equipment (e.g., a spectral filter) and then performing another calibration measurement.</p> <p>This XML element is found in component.</p> <p>Parameters:</p> Name Type Description Default <code>details</code> <code>str</code> <p>The details of the adjustment that was performed.</p> required <code>date</code> <code>date</code> <p>The date that the adjustment was performed.</p> required"},{"location":"schema/adjustment/#msl.equipment.schema.Adjustment.date","title":"date  <code>instance-attribute</code>","text":"<pre><code>date: date\n</code></pre> <p>The date that the adjustment was performed.</p>"},{"location":"schema/adjustment/#msl.equipment.schema.Adjustment.details","title":"details  <code>instance-attribute</code>","text":"<pre><code>details: str\n</code></pre> <p>The details of the adjustment that was performed.</p>"},{"location":"schema/adjustment/#msl.equipment.schema.Adjustment.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Adjustment\n</code></pre> <p>Convert an XML element into a Adjustment instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An <code>&lt;adjustment&gt;</code> XML element from an equipment register (see component).</p> required <p>Returns:</p> Type Description <code>Adjustment</code> <p>The Adjustment instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Adjustment:\n    \"\"\"Convert an XML element into a [Adjustment][msl.equipment.schema.Adjustment] instance.\n\n    Args:\n        element: An `&lt;adjustment&gt;` XML element from an equipment register\n            (see [component][type_component]).\n\n    Returns:\n        The [Adjustment][msl.equipment.schema.Adjustment] instance.\n    \"\"\"\n    return cls(details=element.text or \"\", date=_date.fromisoformat(element.attrib[\"date\"]))\n</code></pre>"},{"location":"schema/adjustment/#msl.equipment.schema.Adjustment.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Adjustment class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Adjustment as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Adjustment][msl.equipment.schema.Adjustment] class into an XML element.\n\n    Returns:\n        The [Adjustment][msl.equipment.schema.Adjustment] as an XML element.\n    \"\"\"\n    e = Element(\"adjustment\", attrib={\"date\": self.date.isoformat()})\n    e.text = self.details\n    return e\n</code></pre>"},{"location":"schema/alteration/","title":"Alteration","text":""},{"location":"schema/alteration/#msl.equipment.schema.Alteration","title":"Alteration  <code>dataclass</code>","text":"<pre><code>Alteration(date: date, details: str, performed_by: str)\n</code></pre> <p>Represents the alteration element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>date</code> <p>The date that the alteration was performed.</p> required <code>details</code> <code>str</code> <p>The details of the alteration.</p> required <code>performed_by</code> <code>str</code> <p>The person or company that performed the alteration.</p> required"},{"location":"schema/alteration/#msl.equipment.schema.Alteration.date","title":"date  <code>instance-attribute</code>","text":"<pre><code>date: date\n</code></pre> <p>The date that the alteration was performed.</p>"},{"location":"schema/alteration/#msl.equipment.schema.Alteration.details","title":"details  <code>instance-attribute</code>","text":"<pre><code>details: str\n</code></pre> <p>The details of the alteration.</p>"},{"location":"schema/alteration/#msl.equipment.schema.Alteration.performed_by","title":"performed_by  <code>instance-attribute</code>","text":"<pre><code>performed_by: str\n</code></pre> <p>The person or company that performed the alteration.</p>"},{"location":"schema/alteration/#msl.equipment.schema.Alteration.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Alteration\n</code></pre> <p>Convert an XML element into an Alteration instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An alteration XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Alteration</code> <p>The Alteration instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Alteration:\n    \"\"\"Convert an XML element into an [Alteration][msl.equipment.schema.Alteration] instance.\n\n    Args:\n        element: An [alteration][type_alteration] XML element from an equipment register.\n\n    Returns:\n        The [Alteration][msl.equipment.schema.Alteration] instance.\n    \"\"\"\n    return cls(\n        date=_date.fromisoformat(element.attrib[\"date\"]),\n        details=element.text or \"\",\n        performed_by=element.attrib[\"performedBy\"],\n    )\n</code></pre>"},{"location":"schema/alteration/#msl.equipment.schema.Alteration.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Alteration class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Alteration as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Alteration][msl.equipment.schema.Alteration] class into an XML element.\n\n    Returns:\n        The [Alteration][msl.equipment.schema.Alteration] as an XML element.\n    \"\"\"\n    e = Element(\"alteration\", attrib={\"date\": self.date.isoformat(), \"performedBy\": self.performed_by})\n    e.text = self.details\n    return e\n</code></pre>"},{"location":"schema/any/","title":"Any","text":""},{"location":"schema/any/#msl.equipment.schema.Any","title":"Any","text":"<pre><code>Any(**attributes: str)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Base class that represents the any type in the XML Schema Definition.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any] type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/any/#msl.equipment.schema.Any.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/capital_expenditure/","title":"CapitalExpenditure","text":""},{"location":"schema/capital_expenditure/#msl.equipment.schema.CapitalExpenditure","title":"CapitalExpenditure  <code>dataclass</code>","text":"<pre><code>CapitalExpenditure(\n    asset_number: str,\n    depreciation_end_year: int,\n    price: float,\n    currency: str,\n)\n</code></pre> <p>Represents the capitalExpenditure element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>asset_number</code> <code>str</code> <p>The asset number in the financial system.</p> required <code>depreciation_end_year</code> <code>int</code> <p>The year (inclusive) that depreciation ends for the asset.</p> required <code>price</code> <code>float</code> <p>The purchase price of the asset.</p> required <code>currency</code> <code>str</code> <p>The currency associated with the <code>price</code>.</p> required"},{"location":"schema/capital_expenditure/#msl.equipment.schema.CapitalExpenditure.asset_number","title":"asset_number  <code>instance-attribute</code>","text":"<pre><code>asset_number: str\n</code></pre> <p>The asset number in the financial system.</p>"},{"location":"schema/capital_expenditure/#msl.equipment.schema.CapitalExpenditure.currency","title":"currency  <code>instance-attribute</code>","text":"<pre><code>currency: str\n</code></pre> <p>The currency associated with the <code>price</code>.</p>"},{"location":"schema/capital_expenditure/#msl.equipment.schema.CapitalExpenditure.depreciation_end_year","title":"depreciation_end_year  <code>instance-attribute</code>","text":"<pre><code>depreciation_end_year: int\n</code></pre> <p>The year (inclusive) that depreciation ends for the asset.</p>"},{"location":"schema/capital_expenditure/#msl.equipment.schema.CapitalExpenditure.price","title":"price  <code>instance-attribute</code>","text":"<pre><code>price: float\n</code></pre> <p>The price of the asset.</p>"},{"location":"schema/capital_expenditure/#msl.equipment.schema.CapitalExpenditure.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; CapitalExpenditure\n</code></pre> <p>Convert an XML element into a CapitalExpenditure instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A capitalExpenditure XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>CapitalExpenditure</code> <p>The CapitalExpenditure instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; CapitalExpenditure:\n    \"\"\"Convert an XML element into a [CapitalExpenditure][msl.equipment.schema.CapitalExpenditure] instance.\n\n    Args:\n        element: A [capitalExpenditure][type_capitalExpenditure] XML element\n            from an equipment register.\n\n    Returns:\n        The [CapitalExpenditure][msl.equipment.schema.CapitalExpenditure] instance.\n    \"\"\"\n    # Schema forces order\n    return cls(\n        asset_number=element[0].text or \"\",\n        depreciation_end_year=int(element[1].text or 0),\n        price=float(element[2].text or 0),\n        currency=element[2].attrib[\"currency\"],\n    )\n</code></pre>"},{"location":"schema/capital_expenditure/#msl.equipment.schema.CapitalExpenditure.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the CapitalExpenditure class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The CapitalExpenditure as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [CapitalExpenditure][msl.equipment.schema.CapitalExpenditure] class into an XML element.\n\n    Returns:\n        The [CapitalExpenditure][msl.equipment.schema.CapitalExpenditure] as an XML element.\n    \"\"\"\n    e = Element(\"capitalExpenditure\")\n\n    an = SubElement(e, \"assetNumber\")\n    an.text = self.asset_number\n\n    dey = SubElement(e, \"depreciationEndYear\")\n    dey.text = str(self.depreciation_end_year)\n\n    p = SubElement(e, \"price\", attrib={\"currency\": self.currency})\n    p.text = f\"{self.price:.14g}\"\n\n    return e\n</code></pre>"},{"location":"schema/competency/","title":"Competency","text":""},{"location":"schema/competency/#msl.equipment.schema.Competency","title":"Competency  <code>dataclass</code>","text":"<pre><code>Competency(\n    worker: str, checker: str, technical_procedure: str\n)\n</code></pre> <p>Represents the competency element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>worker</code> <code>str</code> <p>The competent person who executed the technical procedure to accomplish the performance check.</p> required <code>checker</code> <code>str</code> <p>The competent person who reviewed the work done by the <code>worker</code>.</p> required <code>technical_procedure</code> <code>str</code> <p>The technical procedure that was executed to accomplish the performance check.</p> required"},{"location":"schema/competency/#msl.equipment.schema.Competency.checker","title":"checker  <code>instance-attribute</code>","text":"<pre><code>checker: str\n</code></pre> <p>The competent person who reviewed the work done by the <code>worker</code>.</p>"},{"location":"schema/competency/#msl.equipment.schema.Competency.technical_procedure","title":"technical_procedure  <code>instance-attribute</code>","text":"<pre><code>technical_procedure: str\n</code></pre> <p>The technical procedure that was executed to accomplish the performance check.</p>"},{"location":"schema/competency/#msl.equipment.schema.Competency.worker","title":"worker  <code>instance-attribute</code>","text":"<pre><code>worker: str\n</code></pre> <p>The competent person who executed the technical procedure to accomplish the performance check.</p>"},{"location":"schema/competency/#msl.equipment.schema.Competency.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Competency\n</code></pre> <p>Convert an XML element into a Competency instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A competency XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Competency</code> <p>The Competency instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Competency:\n    \"\"\"Convert an XML element into a [Competency][msl.equipment.schema.Competency] instance.\n\n    Args:\n        element: A [competency][type_competency] XML element from an equipment register.\n\n    Returns:\n        The [Competency][msl.equipment.schema.Competency] instance.\n    \"\"\"\n    # Schema forces order\n    return cls(\n        worker=element[0].text or \"\",\n        checker=element[1].text or \"\",\n        technical_procedure=element[2].text or \"\",\n    )\n</code></pre>"},{"location":"schema/competency/#msl.equipment.schema.Competency.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Competency class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Competency as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Competency][msl.equipment.schema.Competency] class into an XML element.\n\n    Returns:\n        The [Competency][msl.equipment.schema.Competency] as an XML element.\n    \"\"\"\n    e = Element(\"competency\")\n    worker = SubElement(e, \"worker\")\n    worker.text = self.worker\n    checker = SubElement(e, \"checker\")\n    checker.text = self.checker\n    tp = SubElement(e, \"technicalProcedure\")\n    tp.text = self.technical_procedure\n    return e\n</code></pre>"},{"location":"schema/completed_task/","title":"CompletedTask","text":""},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask","title":"CompletedTask  <code>dataclass</code>","text":"<pre><code>CompletedTask(\n    task: str,\n    due_date: date,\n    performed_by: str,\n    completed_date: date,\n)\n</code></pre> <p>Represents the completedTask element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>str</code> <p>A description of the task that was completed.</p> required <code>due_date</code> <code>date</code> <p>The date that the maintenance task was due to be completed.</p> required <code>performed_by</code> <code>str</code> <p>The person or company that performed the maintenance task.</p> required <code>completed_date</code> <code>date</code> <p>The date that the maintenance task was completed.</p> required"},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask.completed_date","title":"completed_date  <code>instance-attribute</code>","text":"<pre><code>completed_date: date\n</code></pre> <p>The date that the maintenance task was completed.</p>"},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask.due_date","title":"due_date  <code>instance-attribute</code>","text":"<pre><code>due_date: date\n</code></pre> <p>The date that the maintenance task was due to be completed.</p>"},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask.performed_by","title":"performed_by  <code>instance-attribute</code>","text":"<pre><code>performed_by: str\n</code></pre> <p>The person or company that performed the maintenance task.</p>"},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask.task","title":"task  <code>instance-attribute</code>","text":"<pre><code>task: str\n</code></pre> <p>A description of the task that was completed.</p>"},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; CompletedTask\n</code></pre> <p>Convert an XML element into a CompletedTask instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A completedTask XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>CompletedTask</code> <p>The CompletedTask instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; CompletedTask:\n    \"\"\"Convert an XML element into a [CompletedTask][msl.equipment.schema.CompletedTask] instance.\n\n    Args:\n        element: A [completedTask][type_completedTask] XML element from an equipment register.\n\n    Returns:\n        The [CompletedTask][msl.equipment.schema.CompletedTask] instance.\n    \"\"\"\n    return cls(\n        task=element.text or \"\",\n        due_date=_date.fromisoformat(element.attrib[\"dueDate\"]),\n        performed_by=element.attrib[\"performedBy\"],\n        completed_date=_date.fromisoformat(element.attrib[\"completedDate\"]),\n    )\n</code></pre>"},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the CompletedTask class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The CompletedTask as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [CompletedTask][msl.equipment.schema.CompletedTask] class into an XML element.\n\n    Returns:\n        The [CompletedTask][msl.equipment.schema.CompletedTask] as an XML element.\n    \"\"\"\n    attrib = {\n        \"dueDate\": self.due_date.isoformat(),\n        \"completedDate\": self.completed_date.isoformat(),\n        \"performedBy\": self.performed_by,\n    }\n\n    e = Element(\"task\", attrib=attrib)\n    e.text = self.task\n    return e\n</code></pre>"},{"location":"schema/component/","title":"Component","text":""},{"location":"schema/component/#msl.equipment.schema.Component","title":"Component  <code>dataclass</code>","text":"<pre><code>Component(\n    name: str = \"\",\n    adjustments: tuple[Adjustment, ...] = (),\n    digital_reports: tuple[DigitalReport, ...] = (),\n    performance_checks: tuple[PerformanceCheck, ...] = (),\n    reports: tuple[Report, ...] = (),\n)\n</code></pre> <p>Represents the component element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name to associate with this component. The value must be unique amongst the other component elements within the same measurand element. An empty string is permitted.</p> <code>''</code> <code>adjustments</code> <code>tuple[Adjustment, ...]</code> <p>The history of adjustments.</p> <code>()</code> <code>digital_reports</code> <code>tuple[DigitalReport, ...]</code> <p>The history of digital calibration reports.</p> <code>()</code> <code>performance_checks</code> <code>tuple[PerformanceCheck, ...]</code> <p>The history of performance checks.</p> <code>()</code> <code>reports</code> <code>tuple[Report, ...]</code> <p>The history of calibration reports.</p> <code>()</code>"},{"location":"schema/component/#msl.equipment.schema.Component.adjustments","title":"adjustments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>adjustments: tuple[Adjustment, ...] = ()\n</code></pre> <p>The history of adjustments.</p>"},{"location":"schema/component/#msl.equipment.schema.Component.digital_reports","title":"digital_reports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>digital_reports: tuple[DigitalReport, ...] = ()\n</code></pre> <p>The history of digital calibration reports.</p>"},{"location":"schema/component/#msl.equipment.schema.Component.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = ''\n</code></pre> <p>The name associated with this component.</p>"},{"location":"schema/component/#msl.equipment.schema.Component.performance_checks","title":"performance_checks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performance_checks: tuple[PerformanceCheck, ...] = ()\n</code></pre> <p>The history of performance checks.</p>"},{"location":"schema/component/#msl.equipment.schema.Component.reports","title":"reports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reports: tuple[Report, ...] = ()\n</code></pre> <p>The history of calibration reports.</p>"},{"location":"schema/component/#msl.equipment.schema.Component.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Component\n</code></pre> <p>Convert an XML element into a Component instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A component XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Component</code> <p>The Component instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Component:\n    \"\"\"Convert an XML element into a [Component][msl.equipment.schema.Component] instance.\n\n    Args:\n        element: A [component][type_component] XML element from an equipment register.\n\n    Returns:\n        The [Component][msl.equipment.schema.Component] instance.\n    \"\"\"\n    # Schema defines &lt;component&gt; using xsd:choice, which allows sub-elements to appear (or not appear) in any order\n    # Using str.endswith() allows for ignoring XML namespaces that may be associated with each tag\n    a: list[Adjustment] = []\n    dr: list[DigitalReport] = []\n    pc: list[PerformanceCheck] = []\n    r: list[Report] = []\n    for child in element:\n        tag = child.tag\n        if tag.endswith(\"report\"):\n            r.append(Report.from_xml(child))\n        elif tag.endswith(\"performanceCheck\"):\n            pc.append(PerformanceCheck.from_xml(child))\n        elif tag.endswith(\"adjustment\"):\n            a.append(Adjustment.from_xml(child))\n        else:\n            dr.append(DigitalReport.from_xml(child))\n\n    return cls(\n        name=element.attrib[\"name\"],\n        adjustments=tuple(a),\n        digital_reports=tuple(dr),\n        performance_checks=tuple(pc),\n        reports=tuple(r),\n    )\n</code></pre>"},{"location":"schema/component/#msl.equipment.schema.Component.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Component class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Component as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Component][msl.equipment.schema.Component] class into an XML element.\n\n    Returns:\n        The [Component][msl.equipment.schema.Component] as an XML element.\n    \"\"\"\n    e = Element(\"component\", attrib={\"name\": self.name})\n\n    # the order is not important since xsd:choice is used\n    e.extend(r.to_xml() for r in self.reports)\n    e.extend(p.to_xml() for p in self.performance_checks)\n    e.extend(a.to_xml() for a in self.adjustments)\n    e.extend(d.to_xml() for d in self.digital_reports)\n    return e\n</code></pre>"},{"location":"schema/conditions/","title":"Conditions","text":""},{"location":"schema/conditions/#msl.equipment.schema.Conditions","title":"Conditions","text":"<pre><code>Conditions(**attributes: str)\n</code></pre> <p>               Bases: <code>Any</code></p> <p>Conditions under which a performance check or calibration report is valid.</p> <p>Since this class is currently represented by the any type in the XML Schema Definition, it is simply a subclass of Element. It may be updated to be a more specific class at a later date.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any] type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/conditions/#msl.equipment.schema.Conditions.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str = 'conditions'\n</code></pre> <p>The element's name.</p>"},{"location":"schema/conditions/#msl.equipment.schema.Conditions.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/cvd_equation/","title":"CVDEquation","text":"<p>The Callendar-Van Dusen (CVD) equation describes the relationship between resistance, \\(R\\), and temperature, \\(t\\), of platinum resistance thermometers (PRT). It is defined in two temperature ranges</p> \\[ \\frac{R(t)}{R_0} = \\begin{cases}     1 + A \\cdot t + B \\cdot t^2 + D \\cdot t^3 &amp; R(t) \\geq R_0 \\\\     1 + A \\cdot t + B \\cdot t^2 + C \\cdot t^3 \\cdot (t-100) &amp; R(t) \\lt R_0 \\\\ \\end{cases} \\] <p>where, \\(R_0 = R(0~^{\\circ}\\text{C})\\) is the resistance at \\(t=0~^{\\circ}\\text{C}\\) and \\(A\\), \\(B\\), \\(C\\) and \\(D\\) are the CVD coefficients. The \\(D\\) coefficient is typically zero but may be non-zero if \\(t \\gtrsim 200~^{\\circ}\\text{C}\\).</p> <p>Suppose you have a variable named <code>cvd</code> (which is an instance of CVDEquation) that represents the following information in an equipment register for a PRT</p> <pre><code>&lt;cvdCoefficients&gt;\n  &lt;R0&gt;100.0189&lt;/R0&gt;\n  &lt;A&gt;3.913e-3&lt;/A&gt;\n  &lt;B&gt;-6.056e-7&lt;/B&gt;\n  &lt;C&gt;1.372e-12&lt;/C&gt;\n  &lt;D&gt;0&lt;/D&gt;\n  &lt;uncertainty variables=\"\"&gt;0.0056/2&lt;/uncertainty&gt;\n  &lt;range&gt;\n    &lt;minimum&gt;-10&lt;/minimum&gt;\n    &lt;maximum&gt;70&lt;/maximum&gt;\n  &lt;/range&gt;\n&lt;/cvdCoefficients&gt;\n</code></pre> <p>You can access the CVD coefficients, degrees of freedom and comment as attributes of <code>cvd</code>,</p> <pre><code>&gt;&gt;&gt; cvd.R0\n100.0189\n&gt;&gt;&gt; cvd.A\n0.003913\n&gt;&gt;&gt; cvd.B\n-6.056e-07\n&gt;&gt;&gt; cvd.C\n1.372e-12\n&gt;&gt;&gt; cvd.D\n0.0\n&gt;&gt;&gt; cvd.degree_freedom\ninf\n&gt;&gt;&gt; cvd.comment\n''\n</code></pre> <p>evaluate the uncertainty,</p> <pre><code>&gt;&gt;&gt; print(cvd.uncertainty())\n0.0026\n</code></pre> <p>calculate resistance from temperature,</p> <pre><code>&gt;&gt;&gt; print(cvd.resistance(12.4))\n104.86262358516764\n&gt;&gt;&gt; cvd.resistance([-5, 0, 5, 10, 15, 20, 25])\narray([ 98.06051774, 100.0189    , 101.97425549, 103.92658241,\n       105.87588076, 107.82215054, 109.76539174])\n</code></pre> <p>and calculate temperature from resistance</p> <pre><code>&gt;&gt;&gt; print(cvd.temperature(109.1))\n23.287055698724505\n&gt;&gt;&gt; cvd.temperature([98.7, 99.2, 100.4, 101.7, 103.8])\narray([-3.36816839, -2.09169544,  0.9738958 ,  4.29823964,  9.67558125])\n</code></pre> <p>A number or any sequence of numbers, i.e., a list, tuple or ndarray may be used to calculate the temperature or resistance (tip: using ndarray will improve performance since a copy of the values is not required).</p> <p>When calculating resistance or temperature, the values of the inputs are checked to ensure that the values are within the range that the CVD coefficients are valid for. The XML data above shows that the temperature must be in the range \\(-10~^\\circ\\text{C}\\) to \\(70~^\\circ\\text{C}\\), which has a corresponding resistance range of \\(96.099~\\Omega\\) to \\(127.118~\\Omega\\) from the equation above. If you calculate resistance from \\(t=-10.2~^\\circ\\text{C}\\) or temperature from \\(R=96.0~\\Omega\\) a ValueError is raised, since the value is outside the range.</p> <pre><code>&gt;&gt;&gt; cvd.ranges\n{'t': Range(minimum=-10, maximum=70), 'r': Range(minimum=96.099, maximum=127.118)}\n\n&gt;&gt;&gt; cvd.resistance(-10.2)\nTraceback (most recent call last):\n...\nValueError: The value -10.2 is not within the range [-10, 70]\n\n&gt;&gt;&gt; cvd.temperature(96)\nTraceback (most recent call last):\n...\nValueError: The value 96.0 is not within the range [96.099, 127.118]\n</code></pre> <p>You can bypass range checking by including a <code>check_range=False</code> keyword argument</p> <pre><code>&gt;&gt;&gt; print(cvd.resistance(-10.2, check_range=False))\n96.02059984653798\n&gt;&gt;&gt; print(cvd.temperature(96, check_range=False))\n-10.252469261526016\n</code></pre>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation","title":"CVDEquation  <code>dataclass</code>","text":"<pre><code>CVDEquation(\n    R0: float,\n    A: float,\n    B: float,\n    C: float,\n    D: float,\n    uncertainty: Evaluable,\n    ranges: dict[str, Range] = dict(),\n    degree_freedom: float = float(\"inf\"),\n    comment: str = \"\",\n)\n</code></pre> <p>The Callendar-Van Dusen (CVD) equation based on the cvdCoefficients element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>R0</code> <code>float</code> <p>The value, in \\(\\Omega\\), of the resistance at \\(0~^\\circ\\text{C}\\), \\(R_0\\).</p> required <code>A</code> <code>float</code> <p>The value, in \\((^\\circ\\text{C})^{-1}\\), of the A coefficient, \\(A \\cdot t\\).</p> required <code>B</code> <code>float</code> <p>The value, in \\((^\\circ\\text{C})^{-2}\\), of the B coefficient, \\(B \\cdot t^2\\).</p> required <code>C</code> <code>float</code> <p>The value, in \\((^\\circ\\text{C})^{-4}\\), of the C coefficient, \\(C \\cdot t^3 \\cdot (t-100)\\).</p> required <code>D</code> <code>float</code> <p>The value, in \\((^\\circ\\text{C})^{-3}\\), of the D coefficient, \\(D \\cdot t^3\\). The \\(D\\) coefficient is typically zero but may be non-zero if \\(t \\gtrsim 200~^{\\circ}\\text{C}\\). If a calibration report does not specify the \\(D\\) coefficient, set the value to be 0.</p> required <code>uncertainty</code> <code>Evaluable</code> <p>The equation to evaluate to calculate the standard uncertainty.</p> required <code>ranges</code> <code>dict[str, Range]</code> <p>The temperature range, in \\((^\\circ)\\text{C}\\), and the resistance range, in \\(\\Omega\\), that the CVD coefficients are valid. The temperature key must be <code>\"t\"</code> and the resistance key <code>\"r\"</code>.</p> <code>dict()</code> <code>degree_freedom</code> <code>float</code> <p>The degrees of freedom.</p> <code>float('inf')</code> <code>comment</code> <code>str</code> <p>A comment to associate with the CVD equation.</p> <code>''</code>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.A","title":"A  <code>instance-attribute</code>","text":"<pre><code>A: float\n</code></pre> <p>The value, in \\((^\\circ\\text{C})^{-1}\\), of the A coefficient, \\(A \\cdot t\\).</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.B","title":"B  <code>instance-attribute</code>","text":"<pre><code>B: float\n</code></pre> <p>The value, in \\((^\\circ\\text{C})^{-2}\\), of the B coefficient, \\(B \\cdot t^2\\).</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.C","title":"C  <code>instance-attribute</code>","text":"<pre><code>C: float\n</code></pre> <p>The value, in \\((^\\circ\\text{C})^{-4}\\), of the C coefficient, \\(C \\cdot t^3 \\cdot (t-100)\\).</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.D","title":"D  <code>instance-attribute</code>","text":"<pre><code>D: float\n</code></pre> <p>The value, in \\((^\\circ\\text{C})^{-3}\\), of the D coefficient, \\(D \\cdot t^3\\).</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.R0","title":"R0  <code>instance-attribute</code>","text":"<pre><code>R0: float\n</code></pre> <p>The value, in \\(\\Omega\\), of the resistance at \\(0~^\\circ\\text{C}\\), \\(R_0\\).</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.comment","title":"comment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comment: str = ''\n</code></pre> <p>A comment associated with the Callendar-Van Dusen equation.</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.degree_freedom","title":"degree_freedom  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>degree_freedom: float = float('inf')\n</code></pre> <p>The degrees of freedom.</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.ranges","title":"ranges  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ranges: dict[str, Range] = field(default_factory=dict)\n</code></pre> <p>The temperature range, in \\(^\\circ\\text{C}\\), and the resistance range, in \\(\\Omega\\), that the Callendar-Van Dusen coefficients are valid.</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.uncertainty","title":"uncertainty  <code>instance-attribute</code>","text":"<pre><code>uncertainty: Evaluable\n</code></pre> <p>The equation to evaluate to calculate the standard uncertainty.</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; CVDEquation\n</code></pre> <p>Convert an XML element into a CVDEquation instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A cvdCoefficients XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>CVDEquation</code> <p>The CVDEquation instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; CVDEquation:\n    \"\"\"Convert an XML element into a [CVDEquation][msl.equipment.schema.CVDEquation] instance.\n\n    Args:\n        element: A [cvdCoefficients][type_cvdCoefficients] XML element\n            from an equipment register.\n\n    Returns:\n        The [CVDEquation][msl.equipment.schema.CVDEquation] instance.\n    \"\"\"\n    # Schema forces order\n    r0 = float(element[0].text or 0)\n    a = float(element[1].text or 0)\n    b = float(element[2].text or 0)\n    c = float(element[3].text or 0)\n    d = float(element[4].text or 0)\n\n    r = element[6]\n    _range = Range(float(r[0].text or -200), float(r[1].text or 661))\n    ranges = {\n        \"t\": _range,\n        \"r\": Range(\n            minimum=round(float(_cvd_resistance(_range.minimum, r0, a, b, c, d)), 3),\n            maximum=round(float(_cvd_resistance(_range.maximum, r0, a, b, c, d)), 3),\n        ),\n    }\n\n    u = element[5]\n    uncertainty = Evaluable(\n        equation=u.text or \"\",\n        variables=tuple(u.attrib[\"variables\"].split()),\n        ranges=ranges,\n    )\n\n    return cls(\n        R0=r0,\n        A=a,\n        B=b,\n        C=c,\n        D=d,\n        uncertainty=uncertainty,\n        ranges=ranges,\n        degree_freedom=float(element[7].text or np.inf) if len(element) &gt; 7 else np.inf,  # noqa: PLR2004\n        comment=element.attrib.get(\"comment\", \"\"),\n    )\n</code></pre>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.resistance","title":"resistance","text":"<pre><code>resistance(\n    temperature: ArrayLike, *, check_range: bool = True\n) -&gt; NDArray[float64]\n</code></pre> <p>Calculate resistance from temperature.</p> <p>Parameters:</p> Name Type Description Default <code>temperature</code> <code>ArrayLike</code> <p>The temperature values, in \\(^\\circ\\text{C}\\).</p> required <code>check_range</code> <code>bool</code> <p>Whether to check that the temperature values are within the allowed range.</p> <code>True</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The resistance values.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def resistance(self, temperature: ArrayLike, *, check_range: bool = True) -&gt; NDArray[np.float64]:\n    r\"\"\"Calculate resistance from temperature.\n\n    Args:\n        temperature: The temperature values, in $^\\circ\\text{C}$.\n        check_range: Whether to check that the temperature values are within the allowed range.\n\n    Returns:\n        The resistance values.\n    \"\"\"\n    array = np.asarray(temperature, dtype=float)\n    if check_range and self.ranges[\"t\"].check_within_range(array):\n        pass  # check_within_range() will raise an error, if one occurred\n\n    return _cvd_resistance(array, self.R0, self.A, self.B, self.C, self.D)\n</code></pre>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.temperature","title":"temperature","text":"<pre><code>temperature(\n    resistance: ArrayLike, *, check_range: bool = True\n) -&gt; NDArray[float64]\n</code></pre> <p>Calculate temperature from resistance.</p> <p>Parameters:</p> Name Type Description Default <code>resistance</code> <code>ArrayLike</code> <p>The resistance values, in \\(\\Omega\\).</p> required <code>check_range</code> <code>bool</code> <p>Whether to check that the resistance values are within the allowed range.</p> <code>True</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The temperature values.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def temperature(self, resistance: ArrayLike, *, check_range: bool = True) -&gt; NDArray[np.float64]:\n    r\"\"\"Calculate temperature from resistance.\n\n    Args:\n        resistance: The resistance values, in $\\Omega$.\n        check_range: Whether to check that the resistance values are within the allowed range.\n\n    Returns:\n        The temperature values.\n    \"\"\"\n    array: NDArray[np.float64] = np.asarray(resistance, dtype=float)\n    if check_range and self.ranges[\"r\"].check_within_range(array):\n        pass  # check_within_range raised an error, if one occurred\n\n    def positive_quadratic(r: NDArray[np.float64]) -&gt; NDArray[np.float64]:\n        # rearrange CVD equation to be: a*x^2 + b*x + c = 0\n        #   a -&gt; B, b -&gt; A, c -&gt; 1 - R/R0\n        # then use the quadratic formula\n        return (-self.A + np.sqrt(self.A**2 - 4.0 * self.B * (1.0 - r / self.R0))) / (2.0 * self.B)\n\n    def positive_cubic(r: NDArray[np.float64]) -&gt; NDArray[np.float64]:\n        # rearrange CVD equation to be: a*x^3 + b*x^2 + c*x + d = 0\n        a = self.D\n        b = self.B\n        c = self.A\n        d = 1.0 - (r / self.R0)\n\n        # then use Cardano's Formula\n        # https://proofwiki.org/wiki/Cardano's_Formula#Real_Coefficients\n        Q: float = (3.0 * a * c - b**2) / (9.0 * a**2)  # noqa: N806\n        R: NDArray[np.float64] = (9.0 * a * b * c - 27.0 * a**2 * d - 2.0 * b**3) / (54.0 * a**3)  # noqa: N806\n        sqrt: NDArray[np.float64] = np.sqrt(Q**3 + R**2)\n        S: NDArray[np.float64] = np.cbrt(R + sqrt)  # noqa: N806\n        T: NDArray[np.float64] = np.cbrt(R - sqrt)  # noqa: N806\n        return S + T - (b / (3.0 * a))  # x1 equation\n\n    def negative(r: NDArray[np.float64]) -&gt; NDArray[np.float64]:\n        # rearrange CVD equation to be: a*x^4 + b*x^3 + c*x^2 + d*x + e = 0\n        a = self.C\n        b = -100.0 * self.C\n        c = self.B\n        d = self.A\n        e = 1.0 - (r / self.R0)\n\n        # https://en.wikipedia.org/wiki/Quartic_function#Solving_a_quartic_equation]\n        # See Section \"General formula for roots\" for the definitions of these variables\n        p = (8 * a * c - 3 * b**2) / (8 * a**2)\n        q = (b**3 - 4 * a * b * c + 8 * a**2 * d) / (8 * a**3)\n        delta_0 = c**2 - 3 * b * d + 12 * a * e\n        delta_1 = 2 * c**3 - 9 * b * c * d + 27 * b**2 * e + 27 * a * d**2 - 72 * a * c * e\n        Q = np.cbrt((delta_1 + np.sqrt(delta_1**2 - 4 * delta_0**3)) / 2)  # noqa: N806\n        S = 0.5 * np.sqrt(-2 * p / 3 + 1 / (3 * a) * (Q + delta_0 / Q))  # noqa: N806\n\n        # decide which root of the quartic to use by looking at the value under the\n        # square root in the x1,2 and x3,4 equations\n        t1 = -4 * S**2 - 2 * p\n        t2 = q / S\n        t3 = t1 - t2\n        return np.piecewise(\n            t3,\n            [t3 &gt;= 0, t3 &lt; 0],\n            [\n                lambda x: -b / (4.0 * a) + S - 0.5 * np.sqrt(x),  # x4 equation\n                lambda x: -b / (4.0 * a) - S + 0.5 * np.sqrt(x + 2.0 * t2),  # x1 equation\n            ],\n        )\n\n    positive = positive_quadratic if self.D == 0 else positive_cubic\n    return np.piecewise(array, [array &lt; self.R0, array &gt;= self.R0], [negative, positive])\n</code></pre>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the CVDEquation class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The CVDEquation as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [CVDEquation][msl.equipment.schema.CVDEquation] class into an XML element.\n\n    Returns:\n        The [CVDEquation][msl.equipment.schema.CVDEquation] as an XML element.\n    \"\"\"\n    attrib = {\"comment\": self.comment} if self.comment else {}\n    e = Element(\"cvdCoefficients\", attrib=attrib)\n\n    r0 = SubElement(e, \"R0\")\n    r0.text = str(self.R0)\n\n    a = SubElement(e, \"A\")\n    a.text = str(self.A)\n\n    b = SubElement(e, \"B\")\n    b.text = str(self.B)\n\n    c = SubElement(e, \"C\")\n    c.text = str(self.C)\n\n    d = SubElement(e, \"D\")\n    d.text = str(self.D)\n\n    u = SubElement(e, \"uncertainty\", attrib={\"variables\": \" \".join(self.uncertainty.variables)})\n    u.text = str(self.uncertainty.equation)\n\n    rng = SubElement(e, \"range\")\n    mn = SubElement(rng, \"minimum\")\n    mn.text = str(self.ranges[\"t\"].minimum)\n    mx = SubElement(rng, \"maximum\")\n    mx.text = str(self.ranges[\"t\"].maximum)\n\n    if not isinf(self.degree_freedom):\n        dof = SubElement(e, \"degreeFreedom\")\n        dof.text = str(self.degree_freedom)\n\n    return e\n</code></pre>"},{"location":"schema/deserialised/","title":"Deserialised","text":""},{"location":"schema/deserialised/#msl.equipment.schema.Deserialised","title":"Deserialised  <code>dataclass</code>","text":"<pre><code>Deserialised(value: Any, comment: str = '')\n</code></pre> <p>Represents the opposite of the serialised element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value of the deserialised object.</p> required <code>comment</code> <code>str</code> <p>A comment to associate with the (de)serialised object.</p> <code>''</code>"},{"location":"schema/deserialised/#msl.equipment.schema.Deserialised.comment","title":"comment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comment: str = ''\n</code></pre> <p>A comment associated with the (de)serialised object.</p>"},{"location":"schema/deserialised/#msl.equipment.schema.Deserialised.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: Any\n</code></pre> <p>The value of the deserialised object. For example, an Archive object from GTC.</p>"},{"location":"schema/deserialised/#msl.equipment.schema.Deserialised.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Deserialised\n</code></pre> <p>Convert a serialised XML element into a Deserialised instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A serialised XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Deserialised</code> <p>The Deserialised instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Deserialised:\n    \"\"\"Convert a [serialised][type_serialised] XML element into a [Deserialised][msl.equipment.schema.Deserialised] instance.\n\n    Args:\n        element: A [serialised][type_serialised] XML element from an equipment register.\n\n    Returns:\n        The [Deserialised][msl.equipment.schema.Deserialised] instance.\n    \"\"\"  # noqa: E501\n    e = element[0]\n    comment = element.attrib.get(\"comment\", \"\")\n\n    # GTC is not required for msl-equipment, so we import it here\n    if e.tag.endswith(\"gtcArchive\"):\n        from GTC.xml_format import (  # type: ignore[import-untyped]  # pyright: ignore[reportMissingTypeStubs]  # noqa: PLC0415\n            xml_to_archive,  # pyright: ignore[reportUnknownVariableType]\n        )\n\n        return cls(value=xml_to_archive(e), comment=comment)\n\n    if e.tag.endswith(\"gtcArchiveJSON\"):\n        from GTC import (  # type: ignore[import-untyped]  # pyright: ignore[reportMissingTypeStubs]  # noqa: PLC0415\n            pr,  # pyright: ignore[reportUnknownVariableType]\n        )\n\n        return cls(value=pr.loads_json(e.text), comment=comment)  # pyright: ignore[reportUnknownMemberType]\n\n    # Use the Element object rather than raising an exception that the deserializer has not been implemented yet\n    return cls(value=e, comment=comment)\n</code></pre>"},{"location":"schema/deserialised/#msl.equipment.schema.Deserialised.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Deserialised class into a serialised XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The serialised XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Deserialised][msl.equipment.schema.Deserialised] class into a [serialised][type_serialised] XML element.\n\n    Returns:\n        The [serialised][type_serialised] XML element.\n    \"\"\"  # noqa: E501\n    attrib = {\"comment\": self.comment} if self.comment else {}\n    e = Element(\"serialised\", attrib=attrib)\n\n    if isinstance(self.value, Element):\n        e.append(self.value)  # pyright: ignore[reportUnknownMemberType, reportUnknownArgumentType]\n        return e\n\n    # Currently, only a GTC Archive is supported so we don't need to check how to serialise it\n    # GTC is not required for msl-equipment, so we import it here\n    from GTC.persistence import (  # type: ignore[import-untyped]  # pyright: ignore[reportMissingTypeStubs]  # noqa: PLC0415\n        Archive,  # pyright: ignore[reportUnknownVariableType]\n    )\n    from GTC.xml_format import (  # pyright: ignore[reportMissingTypeStubs]  # noqa: PLC0415\n        archive_to_xml,  # pyright: ignore[reportUnknownVariableType]\n    )\n\n    e.append(archive_to_xml(Archive.copy(self.value)))  # pyright: ignore[reportUnknownArgumentType, reportUnknownMemberType]\n    return e\n</code></pre>"},{"location":"schema/digital_report/","title":"DigitalReport","text":""},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport","title":"DigitalReport  <code>dataclass</code>","text":"<pre><code>DigitalReport(\n    url: str,\n    format: DigitalFormat,\n    id: str,\n    sha256: str,\n    attributes: dict[str, str] = dict(),\n    comment: str = \"\",\n)\n</code></pre> <p>Represents the digitalReport element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The location of the digital report. The syntax follows RFC 1738 <code>scheme:scheme-specific-part</code>. If <code>scheme:</code> is not specified, it is assumed to be <code>file:</code>.</p> required <code>format</code> <code>DigitalFormat</code> <p>The format of the digital calibration report.</p> required <code>id</code> <code>str</code> <p>The report identification number.</p> required <code>sha256</code> <code>str</code> <p>The SHA-256 checksum of the digital report.</p> required <code>attributes</code> <code>dict[str, str]</code> <p>XML attributes associated with the <code>&lt;url&gt;</code> element.</p> <code>dict()</code> <code>comment</code> <code>str</code> <p>A comment to associate with the digital report.</p> <code>''</code>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.attributes","title":"attributes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attributes: dict[str, str] = field(default_factory=dict)\n</code></pre> <p>XML attributes associated with the <code>&lt;url&gt;</code> element.</p>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.comment","title":"comment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comment: str = ''\n</code></pre> <p>A comment associated with the digital report.</p>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.format","title":"format  <code>instance-attribute</code>","text":"<pre><code>format: DigitalFormat\n</code></pre> <p>The format of the digital calibration report.</p>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>The report identification number.</p>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.sha256","title":"sha256  <code>instance-attribute</code>","text":"<pre><code>sha256: str\n</code></pre> <p>The SHA-256 checksum of the digital report.</p>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: str\n</code></pre> <p>The location of the digital report. The syntax follows RFC 1738 <code>scheme:scheme-specific-part</code>. If <code>scheme:</code> is not specified, it is assumed to be <code>file:</code>.</p>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; DigitalReport\n</code></pre> <p>Convert an XML element into a DigitalReport instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A digitalReport XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>DigitalReport</code> <p>The DigitalReport instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; DigitalReport:\n    \"\"\"Convert an XML element into a [DigitalReport][msl.equipment.schema.DigitalReport] instance.\n\n    Args:\n        element: A [digitalReport][type_digitalReport] XML element from an equipment register.\n\n    Returns:\n        The [DigitalReport][msl.equipment.schema.DigitalReport] instance.\n    \"\"\"\n    # Schema forces order\n    return cls(\n        url=element[0].text or \"\",\n        format=DigitalFormat(element.attrib[\"format\"]),\n        id=element.attrib[\"id\"],\n        sha256=element[1].text or \"\",\n        attributes=element[0].attrib,\n        comment=element.attrib.get(\"comment\", \"\"),\n    )\n</code></pre>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the DigitalReport class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The DigitalReport as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [DigitalReport][msl.equipment.schema.DigitalReport] class into an XML element.\n\n    Returns:\n        The [DigitalReport][msl.equipment.schema.DigitalReport] as an XML element.\n    \"\"\"\n    attrib = {\"format\": self.format.value, \"id\": self.id}\n    if self.comment:\n        attrib[\"comment\"] = self.comment\n    e = Element(\"digitalReport\", attrib=attrib)\n    url = SubElement(e, \"url\", attrib=self.attributes)\n    url.text = self.url\n    sha256 = SubElement(e, \"sha256\")\n    sha256.text = self.sha256\n    return e\n</code></pre>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalFormat","title":"DigitalFormat","text":"<p>               Bases: <code>Enum</code></p> <p>Represents the digitalFormatEnumerationString enumeration in an equipment register.</p> <p>Attributes:</p> Name Type Description <code>MSL_PDF</code> <code>str</code> <p><code>\"MSL PDF/A-3\"</code> (MSL's PDF/A-3 format).</p> <code>PTB_DCC</code> <code>str</code> <p><code>\"PTB DCC\"</code> (PTB's Digital Calibration Certificate).</p>"},{"location":"schema/equation/","title":"Equation","text":"<p>Suppose you have a variable named <code>equation</code> (which is an instance of Equation) that represents the following information in an equipment register for equipment that measures relative humidity. The corrected value depends on two variables (<code>r</code> and <code>t</code>) and the standard uncertainty is a constant.</p> <pre><code>&lt;equation&gt;\n  &lt;value variables=\"r t\"&gt;r-0.71-0.04*r+3.4e-4*pow(r,2)+2.4e-3*t+1.3e-3*r*t&lt;/value&gt;\n  &lt;uncertainty variables=\"\"&gt;0.355&lt;/uncertainty&gt;\n  &lt;unit&gt;%rh&lt;/unit&gt;\n  &lt;ranges&gt;\n    &lt;range variable=\"r\"&gt;\n      &lt;minimum&gt;30&lt;/minimum&gt;\n      &lt;maximum&gt;80&lt;/maximum&gt;\n    &lt;/range&gt;\n    &lt;range variable=\"t\"&gt;\n      &lt;minimum&gt;15&lt;/minimum&gt;\n      &lt;maximum&gt;25&lt;/maximum&gt;\n    &lt;/range&gt;\n  &lt;/ranges&gt;\n&lt;/equation&gt;\n</code></pre> <p>You can access the unit, degrees of freedom and comment as attributes of <code>equation</code></p> <pre><code>&gt;&gt;&gt; equation.unit\n'%rh'\n&gt;&gt;&gt; equation.degree_freedom\ninf\n&gt;&gt;&gt; equation.comment\n''\n</code></pre> <p>To evaluate an equation, call the appropriate attribute with the variable(s) that are required to evaluate the equation with</p> <pre><code>&gt;&gt;&gt; equation.value.variables\n('r', 't')\n&gt;&gt;&gt; equation.uncertainty.variables\n()\n&gt;&gt;&gt; assert equation.value(r=50.3, t=20.4) == 49.8211466\n&gt;&gt;&gt; assert equation.uncertainty() == 0.355\n</code></pre> <p>A variable can have multiple values. Any sequence of numbers, i.e., a list, tuple, ndarray, etc., may be used (tip: using ndarray will improve performance since a copy of the values is not required),</p> <pre><code>&gt;&gt;&gt; equation.value(r=[50.3, 52.1, 48.7], t=[20.4, 19.7, 20.0])\narray([49.8211466, 51.6104604, 48.1625746])\n</code></pre> <p>the values of the variables do not need to be 1-dimensional arrays,</p> <pre><code>&gt;&gt;&gt; equation.value(r=[(50.3, 52.1), (48.7, 47.9)], t=[(20.4, 19.7), (20.0, 19.6)])\narray([[49.8211466, 51.6104604],\n       [48.1625746, 47.3216314]])\n</code></pre> <p>and the array broadcasting rules of numpy also apply, i.e., multiple <code>r</code> values and a single <code>t</code> value</p> <pre><code>&gt;&gt;&gt; equation.value(r=(50.3, 52.1, 48.7), t=20.4)\narray([49.8211466, 51.6595514, 48.1888586])\n</code></pre> <p>If you forget to specify a variable (in the following case, <code>t</code>) a NameError will be raised,</p> <pre><code>&gt;&gt;&gt; equation.value(r=50.3)\nTraceback (most recent call last):\n...\nNameError: name 't' is not defined\n</code></pre> <p>however, if you specify more variables than are required to evaluate the equation, the additional variables are ignored <pre><code>&gt;&gt;&gt; equation.uncertainty(r=50.3, t=20.4)\narray(0.355)\n</code></pre></p> <p>Notice in the last returned value that the result was printed as <code>array(0.355)</code> even though a single <code>r</code> and <code>t</code> value was specified (although these variables were ignored in this particular example, since the standard uncertainty is a constant, the principle remains the same if they were not ignored). All evaluated returned types are an instance of a numpy ndarray even if a single value is specified. These particular returned array instances are referred to as 0-dimensional array scalars in numpy terminology.</p> <p>When evaluating an equation, the value(s) of the input variables are checked to ensure that the value(s) are within the ranges that the equation is valid for. The XML data above shows that the temperature, <code>t</code>, value must be in the range <code>15</code> to <code>25</code>. If you evaluate the corrected value at <code>t=30</code> a ValueError is raised</p> <pre><code>&gt;&gt;&gt; equation.value.ranges\n{'r': Range(minimum=30, maximum=80), 't': Range(minimum=15, maximum=25)}\n&gt;&gt;&gt; equation.value(r=50.3, t=30)\nTraceback (most recent call last):\n...\nValueError: The value 30.0 is not within the range [15, 25]\n</code></pre> <p>You can bypass range checking by including a <code>check_range=False</code> keyword argument</p> <pre><code>&gt;&gt;&gt; equation.value(r=50.3, t=30, check_range=False)\narray(50.4719306)\n</code></pre>"},{"location":"schema/equation/#msl.equipment.schema.Equation","title":"Equation  <code>dataclass</code>","text":"<pre><code>Equation(\n    value: Evaluable,\n    uncertainty: Evaluable,\n    unit: str,\n    degree_freedom: float = float(\"inf\"),\n    comment: str = \"\",\n)\n</code></pre> <p>Represents the equation element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Evaluable</code> <p>The equation to evaluate to calculate the corrected value.</p> required <code>uncertainty</code> <code>Evaluable</code> <p>The equation to evaluate to calculate the standard uncertainty.</p> required <code>unit</code> <code>str</code> <p>The unit of the measured quantity.</p> required <code>degree_freedom</code> <code>float</code> <p>The degrees of freedom.</p> <code>float('inf')</code> <code>comment</code> <code>str</code> <p>A comment to associate with the equation.</p> <code>''</code>"},{"location":"schema/equation/#msl.equipment.schema.Equation.comment","title":"comment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comment: str = ''\n</code></pre> <p>A comment associated with the equation.</p>"},{"location":"schema/equation/#msl.equipment.schema.Equation.degree_freedom","title":"degree_freedom  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>degree_freedom: float = float('inf')\n</code></pre> <p>The degrees of freedom.</p>"},{"location":"schema/equation/#msl.equipment.schema.Equation.uncertainty","title":"uncertainty  <code>instance-attribute</code>","text":"<pre><code>uncertainty: Evaluable\n</code></pre> <p>The equation to evaluate to calculate the standard uncertainty.</p>"},{"location":"schema/equation/#msl.equipment.schema.Equation.unit","title":"unit  <code>instance-attribute</code>","text":"<pre><code>unit: str\n</code></pre> <p>The unit of the measured quantity.</p>"},{"location":"schema/equation/#msl.equipment.schema.Equation.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: Evaluable\n</code></pre> <p>The equation to evaluate to calculate the corrected value.</p>"},{"location":"schema/equation/#msl.equipment.schema.Equation.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Equation\n</code></pre> <p>Convert an XML element into an Equation instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An equation XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Equation</code> <p>The Equation instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Equation:\n    \"\"\"Convert an XML element into an [Equation][msl.equipment.schema.Equation] instance.\n\n    Args:\n        element: An [equation][type_equation] XML element from an equipment register.\n\n    Returns:\n        The [Equation][msl.equipment.schema.Equation] instance.\n    \"\"\"\n    # Schema forces order\n    value = element[0]\n    uncertainty = element[1]\n    ranges = {\n        r.attrib[\"variable\"]: Range(minimum=float(r[0].text or -np.inf), maximum=float(r[1].text or np.inf))\n        for r in element[3]\n    }\n\n    return cls(\n        value=Evaluable(\n            equation=value.text or \"\", variables=tuple(value.attrib[\"variables\"].split()), ranges=ranges\n        ),\n        uncertainty=Evaluable(\n            equation=uncertainty.text or \"\", variables=tuple(uncertainty.attrib[\"variables\"].split()), ranges=ranges\n        ),\n        unit=element[2].text or \"\",\n        degree_freedom=float(element[4].text or np.inf) if len(element) &gt; 4 else np.inf,  # noqa: PLR2004\n        comment=element.attrib.get(\"comment\", \"\"),\n    )\n</code></pre>"},{"location":"schema/equation/#msl.equipment.schema.Equation.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Equation class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Equation as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Equation][msl.equipment.schema.Equation] class into an XML element.\n\n    Returns:\n        The [Equation][msl.equipment.schema.Equation] as an XML element.\n    \"\"\"\n    attrib = {\"comment\": self.comment} if self.comment else {}\n    e = Element(\"equation\", attrib=attrib)\n    value = SubElement(e, \"value\", attrib={\"variables\": \" \".join(self.value.variables)})\n    value.text = self.value.equation\n    uncertainty = SubElement(e, \"uncertainty\", attrib={\"variables\": \" \".join(self.uncertainty.variables)})\n    uncertainty.text = self.uncertainty.equation\n    unit = SubElement(e, \"unit\")\n    unit.text = self.unit\n\n    ranges = SubElement(e, \"ranges\")\n    for name, _range in self.value.ranges.items():  # self.value.ranges and self.uncertainty.ranges are the same\n        rng = SubElement(ranges, \"range\", attrib={\"variable\": name})\n        mn = SubElement(rng, \"minimum\")\n        mn.text = str(_range.minimum)\n        mx = SubElement(rng, \"maximum\")\n        mx.text = str(_range.maximum)\n\n    if not isinf(self.degree_freedom):\n        dof = SubElement(e, \"degreeFreedom\")\n        dof.text = str(self.degree_freedom)\n\n    return e\n</code></pre>"},{"location":"schema/equation/#msl.equipment.schema.Evaluable","title":"Evaluable  <code>dataclass</code>","text":"<pre><code>Evaluable(\n    equation: str,\n    variables: tuple[str, ...] = (),\n    ranges: dict[str, Range] = dict(),\n)\n</code></pre> <p>Represents the <code>&lt;value&gt;</code> and <code>&lt;uncertainty&gt;</code> XML elements in an equation.</p> <p>Parameters:</p> Name Type Description Default <code>equation</code> <code>str</code> <p>The string representation of the equation to evaluate.</p> required <code>variables</code> <code>tuple[str, ...]</code> <p>The names of the variables in the equation.</p> <code>()</code> <code>ranges</code> <code>dict[str, Range]</code> <p>The numeric range for a variable that the <code>equation</code> is valid for. The keys are the variable names. A range does not need to be defined for every variable. If a range is not defined then a range of \\([-\\infty, +\\infty]\\) is assumed.</p> <code>dict()</code>"},{"location":"schema/equation/#msl.equipment.schema.Evaluable.equation","title":"equation  <code>instance-attribute</code>","text":"<pre><code>equation: str\n</code></pre> <p>The string representation of the equation to evaluate.</p>"},{"location":"schema/equation/#msl.equipment.schema.Evaluable.ranges","title":"ranges  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ranges: dict[str, Range] = field(default_factory=dict)\n</code></pre> <p>The numeric range for each variable that the <code>equation</code> is valid for. The keys are the variable names.</p>"},{"location":"schema/equation/#msl.equipment.schema.Evaluable.variables","title":"variables  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variables: tuple[str, ...] = ()\n</code></pre> <p>The names of the variables in the equation.</p>"},{"location":"schema/equation/#msl.equipment.schema.Range","title":"Range","text":"<p>               Bases: <code>NamedTuple</code></p> <p>The numeric range of a variable that an equation is valid for.</p> <p>Parameters:</p> Name Type Description <code>minimum</code> <code>float</code> <p>Minimum value in range.</p> <code>maximum</code> <code>float</code> <p>Maximum value in range.</p>"},{"location":"schema/equation/#msl.equipment.schema.Range.maximum","title":"maximum  <code>instance-attribute</code>","text":"<pre><code>maximum: float\n</code></pre> <p>Maximum value in range.</p>"},{"location":"schema/equation/#msl.equipment.schema.Range.minimum","title":"minimum  <code>instance-attribute</code>","text":"<pre><code>minimum: float\n</code></pre> <p>Minimum value in range.</p>"},{"location":"schema/equation/#msl.equipment.schema.Range.check_within_range","title":"check_within_range","text":"<pre><code>check_within_range(\n    value: float | ArrayLike,\n) -&gt; Literal[True]\n</code></pre> <p>Check that the values are within the range.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float | ArrayLike</code> <p>The values to check, raises</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>Always returns <code>True</code>. Raises ValueError if <code>value</code> is not within the range.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def check_within_range(self, value: float | ArrayLike) -&gt; Literal[True]:\n    \"\"\"Check that the values are within the range.\n\n    Args:\n        value: The values to check, raises\n\n    Returns:\n        Always returns `True`. Raises [ValueError][] if\n            `value` is not within the range.\n    \"\"\"\n    if isinstance(value, (int, float)) or (isinstance(value, np.ndarray) and value.ndim == 0):\n        if value &lt; self.minimum or value &gt; self.maximum:\n            msg = f\"The value {value} is not within the range [{self.minimum}, {self.maximum}]\"\n            raise ValueError(msg)\n    elif np.any(np.less(value, self.minimum)) or np.any(np.greater(value, self.maximum)):  # pyright: ignore[reportUnknownArgumentType]\n        msg = f\"A value in the sequence is not within the range [{self.minimum}, {self.maximum}]\"\n        raise ValueError(msg)\n    return True\n</code></pre>"},{"location":"schema/equipment/","title":"Equipment","text":""},{"location":"schema/equipment/#msl.equipment.schema.Equipment","title":"Equipment  <code>dataclass</code>","text":"<pre><code>Equipment(\n    entered_by: str = \"\",\n    checked_by: str = \"\",\n    checked_date: date | None = None,\n    alias: str = \"\",\n    keywords: tuple[str, ...] = (),\n    id: str = \"\",\n    manufacturer: str = \"\",\n    model: str = \"\",\n    serial: str = \"\",\n    description: str = \"\",\n    specifications: Specifications = Specifications(),\n    location: str = \"\",\n    status: Status = Active,\n    loggable: bool = False,\n    traceable: bool = False,\n    calibrations: tuple[Measurand, ...] = (),\n    maintenance: Maintenance = Maintenance(),\n    alterations: tuple[Alteration, ...] = (),\n    firmware: tuple[Firmware, ...] = (),\n    specified_requirements: SpecifiedRequirements = SpecifiedRequirements(),\n    reference_materials: ReferenceMaterials = ReferenceMaterials(),\n    quality_manual: QualityManual = QualityManual(),\n    connection: Connection | None = None,\n)\n</code></pre> <p>Represents the equipment element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>entered_by</code> <code>str</code> <p>The name of the person who initially entered the <code>&lt;equipment&gt;</code> element in the register.</p> <code>''</code> <code>checked_by</code> <code>str</code> <p>The name of the person who checked the information in the <code>&lt;equipment&gt;</code> element.</p> <code>''</code> <code>checked_date</code> <code>date | None</code> <p>The date that the information in the <code>&lt;equipment&gt;</code> element was last checked.</p> <code>None</code> <code>alias</code> <code>str</code> <p>An alternative name to associate with the equipment.</p> <code>''</code> <code>keywords</code> <code>tuple[str, ...]</code> <p>Keywords that describe the equipment.</p> <code>()</code> <code>id</code> <code>str</code> <p>Identity in an equipment register.</p> <code>''</code> <code>manufacturer</code> <code>str</code> <p>Name of manufacturer.</p> <code>''</code> <code>model</code> <code>str</code> <p>Manufacturer's model number (or type identification).</p> <code>''</code> <code>serial</code> <code>str</code> <p>Manufacturer's serial number (or other unique identification).</p> <code>''</code> <code>description</code> <code>str</code> <p>A short description about the equipment.</p> <code>''</code> <code>specifications</code> <code>Specifications</code> <p>Specifications provided by the manufacturer of the equipment.</p> <code>Specifications()</code> <code>location</code> <code>str</code> <p>The usual location (laboratory) that the equipment is found in.</p> <code>''</code> <code>status</code> <code>Status</code> <p>The status of the equipment is an indication of whether the equipment is active (in use) or inactive (not in use).</p> <code>Active</code> <code>loggable</code> <code>bool</code> <p>Whether measurements from the equipment should be logged. Equipment that monitor (for example) pressure, temperature or humidity of a laboratory environment are considered as loggable.</p> <code>False</code> <code>traceable</code> <code>bool</code> <p>Whether the equipment is used for a traceable measurement.</p> <code>False</code> <code>calibrations</code> <code>tuple[Measurand, ...]</code> <p>The calibration history.</p> <code>()</code> <code>maintenance</code> <code>Maintenance</code> <p>The maintenance history and maintenance plan.</p> <code>Maintenance()</code> <code>alterations</code> <code>tuple[Alteration, ...]</code> <p>The alteration history.</p> <code>()</code> <code>firmware</code> <code>tuple[Firmware, ...]</code> <p>The firmware version history.</p> <code>()</code> <code>specified_requirements</code> <code>SpecifiedRequirements</code> <p>Verification that equipment conforms with specified requirements before being placed or returned into service.</p> <code>SpecifiedRequirements()</code> <code>reference_materials</code> <code>ReferenceMaterials</code> <p>Documentation of reference materials, results, acceptance criteria, relevant dates and the period of validity.</p> <code>ReferenceMaterials()</code> <code>quality_manual</code> <code>QualityManual</code> <p>Information that is specified in Section 4.3.6 of the MSL Quality Manual.</p> <code>QualityManual()</code> <code>connection</code> <code>Connection | None</code> <p>The connection to the equipment for computer control.</p> <code>None</code>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.alias","title":"alias  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alias: str = ''\n</code></pre> <p>An alternative name to associate with the equipment.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.alterations","title":"alterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alterations: tuple[Alteration, ...] = ()\n</code></pre> <p>The alteration history.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.calibrations","title":"calibrations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>calibrations: tuple[Measurand, ...] = ()\n</code></pre> <p>The calibration history.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.checked_by","title":"checked_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_by: str = ''\n</code></pre> <p>The name of the person who checked the information in the <code>&lt;equipment&gt;</code> element.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.checked_date","title":"checked_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_date: date | None = None\n</code></pre> <p>The date that the information in the <code>&lt;equipment&gt;</code> element was last checked.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.connection","title":"connection  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>connection: Connection | None = None\n</code></pre> <p>The connection to use for computer control.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = ''\n</code></pre> <p>A short description about the equipment.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.entered_by","title":"entered_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entered_by: str = ''\n</code></pre> <p>The name of the person who initially entered the <code>&lt;equipment&gt;</code> element in the register.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.firmware","title":"firmware  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>firmware: tuple[Firmware, ...] = ()\n</code></pre> <p>The firmware version history.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = ''\n</code></pre> <p>Identity in an equipment register.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.keywords","title":"keywords  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keywords: tuple[str, ...] = ()\n</code></pre> <p>Keywords that describe the equipment.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.location","title":"location  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>location: str = ''\n</code></pre> <p>The usual location (laboratory) that the equipment is found in.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.loggable","title":"loggable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>loggable: bool = False\n</code></pre> <p>Whether measurements from the equipment should be logged.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.maintenance","title":"maintenance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>maintenance: Maintenance = field(\n    default_factory=Maintenance\n)\n</code></pre> <p>The maintenance history and maintenance plan.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.manufacturer","title":"manufacturer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>manufacturer: str = ''\n</code></pre> <p>Name of manufacturer.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.model","title":"model  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model: str = ''\n</code></pre> <p>Manufacturer's model number (or type identification).</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.quality_manual","title":"quality_manual  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quality_manual: QualityManual = field(\n    default_factory=QualityManual\n)\n</code></pre> <p>Information that is specified in Section 4.3.6 of the MSL Quality Manual.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.reference_materials","title":"reference_materials  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reference_materials: ReferenceMaterials = field(\n    default_factory=ReferenceMaterials\n)\n</code></pre> <p>Documentation of reference materials, results, acceptance criteria, relevant dates and the period of validity.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.serial","title":"serial  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>serial: str = ''\n</code></pre> <p>Manufacturer's serial number (or other unique identification).</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.specifications","title":"specifications  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>specifications: Specifications = field(\n    default_factory=Specifications\n)\n</code></pre> <p>Specifications provided by the manufacturer of the equipment.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.specified_requirements","title":"specified_requirements  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>specified_requirements: SpecifiedRequirements = field(\n    default_factory=SpecifiedRequirements\n)\n</code></pre> <p>Verification that equipment conforms with specified requirements before being placed or returned into service.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.status","title":"status  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>status: Status = Active\n</code></pre> <p>The status of the equipment is an indication of whether the equipment is active (in use) or inactive (not in use).</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.traceable","title":"traceable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traceable: bool = False\n</code></pre> <p>Whether the equipment is used for a traceable measurement.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.connect","title":"connect","text":"<pre><code>connect() -&gt; Any\n</code></pre> <p>Connect to the equipment.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def connect(self) -&gt; _Any:  # noqa: ANN401\n    \"\"\"Connect to the equipment.\"\"\"\n    if self.connection is None:\n        super().__setattr__(\"connection\", connections[self.id])\n        assert self.connection is not None  # noqa: S101\n\n    for backend in backends:\n        if backend.handles(self.connection):\n            return backend.cls(self)\n\n    for resource in resources:\n        if resource.handles(self):\n            return resource.cls(self)\n\n    address = self.connection.address\n    for interface in interfaces:\n        if interface.handles(address):\n            return interface.cls(self)\n\n    msg = f\"Cannot determine the interface from the address {address!r}\"\n    raise ValueError(msg)\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Equipment\n</code></pre> <p>Convert an XML element into an Equipment instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An equipment XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Equipment</code> <p>The Equipment instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Equipment:\n    \"\"\"Convert an XML element into an [Equipment][msl.equipment.schema.Equipment] instance.\n\n    Args:\n        element: An [equipment][type_equipment] XML element from an equipment register.\n\n    Returns:\n        The [Equipment][msl.equipment.schema.Equipment] instance.\n    \"\"\"\n    # Schema forces order\n    a = element.attrib\n    return cls(\n        entered_by=a[\"enteredBy\"],\n        checked_by=a.get(\"checkedBy\", \"\"),\n        checked_date=None if not a.get(\"checkedDate\") else _date.fromisoformat(a[\"checkedDate\"]),\n        alias=a.get(\"alias\", \"\"),\n        keywords=tuple(a.get(\"keywords\", \"\").split()),\n        id=element[0].text or \"\",\n        manufacturer=element[1].text or \"\",\n        model=element[2].text or \"\",\n        serial=element[3].text or \"\",\n        description=element[4].text or \"\",\n        specifications=Specifications.from_xml(element[5]),\n        location=element[6].text or \"\",\n        status=Status(element[7].text),\n        loggable=element[8].text in {\"1\", \"true\"},\n        traceable=element[9].text in {\"1\", \"true\"},\n        calibrations=tuple(Measurand.from_xml(e) for e in element[10]),\n        maintenance=Maintenance.from_xml(element[11]),\n        alterations=tuple(Alteration.from_xml(e) for e in element[12]),\n        firmware=tuple(Firmware.from_xml(e) for e in element[13]),\n        specified_requirements=SpecifiedRequirements.from_xml(element[14]),\n        reference_materials=ReferenceMaterials.from_xml(element[15]),\n        quality_manual=QualityManual.from_xml(element[16]),\n    )\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.latest_performance_check","title":"latest_performance_check","text":"<pre><code>latest_performance_check(\n    *, quantity: str = \"\", name: str = \"\"\n) -&gt; LatestPerformanceCheck | None\n</code></pre> <p>Returns the latest performance check.</p> <p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>str</code> <p>The measurand quantity.</p> <code>''</code> <code>name</code> <code>str</code> <p>The component name.</p> <code>''</code> <p>Returns:</p> Type Description <code>LatestPerformanceCheck | None</code> <p>The LatestPerformanceCheck for the specified <code>quantity</code> and <code>name</code>. If the equipment has only one measurand and only one component then you do not need to specify a value for the <code>quantity</code> and <code>name</code>. Returns <code>None</code> if there are no performance checks that match the <code>quantity</code> and <code>name</code> criteria or if the equipment does not have performance checks entered in the register.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def latest_performance_check(self, *, quantity: str = \"\", name: str = \"\") -&gt; LatestPerformanceCheck | None:\n    \"\"\"Returns the latest performance check.\n\n    Args:\n        quantity: The measurand [quantity][msl.equipment.schema.Measurand.quantity].\n        name: The component [name][msl.equipment.schema.Component.name].\n\n    Returns:\n        The [LatestPerformanceCheck][msl.equipment.schema.LatestPerformanceCheck] for the specified\n            `quantity` and `name`. If the equipment has only one _measurand_ and only one _component_\n            then you do not need to specify a value for the `quantity` and `name`. Returns `None` if\n            there are no performance checks that match the `quantity` and `name` criteria or if\n            the equipment does not have performance checks entered in the register.\n    \"\"\"\n    return _latest(items=list(self.latest_performance_checks()), quantity=quantity, name=name)\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.latest_performance_checks","title":"latest_performance_checks","text":"<pre><code>latest_performance_checks() -&gt; (\n    Iterator[LatestPerformanceCheck]\n)\n</code></pre> <p>Yields the latest performance check for every measurand and component.</p> <p>Yields:</p> Type Description <code>LatestPerformanceCheck</code> <p>The latest performance check.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def latest_performance_checks(self) -&gt; Iterator[LatestPerformanceCheck]:\n    \"\"\"Yields the latest performance check for every _measurand_ and _component_.\n\n    Yields:\n        The latest performance check.\n    \"\"\"\n    default = _date(1875, 5, 20)\n    for m in self.calibrations:\n        for c in m.components:\n            latest = default\n            check: PerformanceCheck | None = None\n            for pc in c.performance_checks:\n                if pc.completed_date &gt; latest:\n                    check = pc\n                    latest = pc.completed_date\n\n            if check is not None:\n                yield LatestPerformanceCheck(\n                    calibration_interval=m.calibration_interval,\n                    name=c.name,\n                    next_calibration_date=_future_date(latest, m.calibration_interval),\n                    quantity=m.quantity,\n                    completed_date=check.completed_date,\n                    competency=check.competency,\n                    entered_by=check.entered_by,\n                    checked_by=check.checked_by,\n                    checked_date=check.checked_date,\n                    conditions=check.conditions,\n                    cvd_equations=check.cvd_equations,\n                    deserialisers=check.deserialisers,\n                    equations=check.equations,\n                    files=check.files,\n                    tables=check.tables,\n                )\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.latest_report","title":"latest_report","text":"<pre><code>latest_report(\n    *,\n    quantity: str = \"\",\n    name: str = \"\",\n    date: Literal[\"issue\", \"start\", \"stop\"] = \"stop\"\n) -&gt; LatestReport | None\n</code></pre> <p>Returns the latest calibration report.</p> <p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>str</code> <p>The measurand quantity.</p> <code>''</code> <code>name</code> <code>str</code> <p>The component name.</p> <code>''</code> <code>date</code> <code>Literal['issue', 'start', 'stop']</code> <p>Which date in a report to use to determine what latest refers to:</p> <ul> <li><code>issue</code>: Report issue date</li> <li><code>start</code>: Measurement start date</li> <li><code>stop</code>: Measurement stop date</li> </ul> <code>'stop'</code> <p>Returns:</p> Type Description <code>LatestReport | None</code> <p>The LatestReport for the specified <code>quantity</code> and <code>name</code>. If the equipment has only one measurand and only one component then you do not need to specify a value for the <code>quantity</code> and <code>name</code>. Returns <code>None</code> if there are no calibration reports that match the <code>quantity</code> and <code>name</code> criteria or if the equipment does not have calibration reports entered in the register.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def latest_report(\n    self, *, quantity: str = \"\", name: str = \"\", date: Literal[\"issue\", \"start\", \"stop\"] = \"stop\"\n) -&gt; LatestReport | None:\n    \"\"\"Returns the latest calibration report.\n\n    Args:\n        quantity: The measurand [quantity][msl.equipment.schema.Measurand.quantity].\n        name: The component [name][msl.equipment.schema.Component.name].\n        date: Which date in a report to use to determine what _latest_ refers to:\n\n            * `issue`: Report issue date\n            * `start`: Measurement start date\n            * `stop`: Measurement stop date\n\n    Returns:\n        The [LatestReport][msl.equipment.schema.LatestReport] for the specified `quantity` and `name`.\n            If the equipment has only one _measurand_ and only one _component_ then you do not need\n            to specify a value for the `quantity` and `name`. Returns `None` if there are no calibration\n            reports that match the `quantity` and `name` criteria or if the equipment does not have\n            calibration reports entered in the register.\n    \"\"\"\n    return _latest(items=list(self.latest_reports(date=date)), quantity=quantity, name=name)\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.latest_reports","title":"latest_reports","text":"<pre><code>latest_reports(\n    date: Literal[\"issue\", \"start\", \"stop\"] = \"stop\",\n) -&gt; Iterator[LatestReport]\n</code></pre> <p>Yields the latest calibration report for every measurand and component.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>Literal['issue', 'start', 'stop']</code> <p>Which date in a report to use to determine what latest refers to:</p> <ul> <li><code>issue</code>: Report issue date</li> <li><code>start</code>: Measurement start date</li> <li><code>stop</code>: Measurement stop date</li> </ul> <code>'stop'</code> <p>Yields:</p> Type Description <code>LatestReport</code> <p>The latest calibration report.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def latest_reports(self, date: Literal[\"issue\", \"start\", \"stop\"] = \"stop\") -&gt; Iterator[LatestReport]:\n    \"\"\"Yields the latest calibration report for every _measurand_ and _component_.\n\n    Args:\n        date: Which date in a report to use to determine what _latest_ refers to:\n\n            * `issue`: Report issue date\n            * `start`: Measurement start date\n            * `stop`: Measurement stop date\n\n    Yields:\n        The latest calibration report.\n    \"\"\"\n    default = _date(1875, 5, 20)\n    for m in self.calibrations:\n        for c in m.components:\n            latest = default\n            report: Report | None = None\n            for r in c.reports:\n                if date == \"stop\":\n                    if r.measurement_stop_date &gt; latest:\n                        report = r\n                        latest = r.measurement_stop_date\n                elif date == \"start\":\n                    if r.measurement_start_date &gt; latest:\n                        report = r\n                        latest = r.measurement_start_date\n                elif r.report_issue_date &gt; latest:\n                    report = r\n                    latest = r.report_issue_date\n\n            if report is not None:\n                yield LatestReport(\n                    calibration_interval=m.calibration_interval,\n                    name=c.name,\n                    next_calibration_date=_future_date(latest, m.calibration_interval),\n                    quantity=m.quantity,\n                    id=report.id,\n                    report_issue_date=report.report_issue_date,\n                    measurement_start_date=report.measurement_start_date,\n                    measurement_stop_date=report.measurement_stop_date,\n                    issuing_laboratory=report.issuing_laboratory,\n                    technical_procedure=report.technical_procedure,\n                    entered_by=report.entered_by,\n                    checked_by=report.checked_by,\n                    checked_date=report.checked_date,\n                    conditions=report.conditions,\n                    acceptance_criteria=report.acceptance_criteria,\n                    cvd_equations=report.cvd_equations,\n                    deserialisers=report.deserialisers,\n                    equations=report.equations,\n                    files=report.files,\n                    tables=report.tables,\n                )\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Equipment class into an XML element.</p> <p>The connection attribute is not included as an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Equipment as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Equipment][msl.equipment.schema.Equipment] class into an XML element.\n\n    The [connection][msl.equipment.schema.Equipment.connection] attribute is not included\n    as an XML element.\n\n    Returns:\n        The [Equipment][msl.equipment.schema.Equipment] as an XML element.\n    \"\"\"\n    a = {\"enteredBy\": self.entered_by}\n    if self.checked_by:\n        a[\"checkedBy\"] = self.checked_by\n    if self.checked_date is not None:\n        a[\"checkedDate\"] = self.checked_date.isoformat()\n    if self.alias:\n        a[\"alias\"] = self.alias\n    if self.keywords:\n        a[\"keywords\"] = \" \".join(self.keywords)\n\n    e = Element(\"equipment\", attrib=a)\n\n    _id = SubElement(e, \"id\")\n    _id.text = self.id\n\n    manufacturer = SubElement(e, \"manufacturer\")\n    manufacturer.text = self.manufacturer\n\n    model = SubElement(e, \"model\")\n    model.text = self.model\n\n    serial = SubElement(e, \"serial\")\n    serial.text = self.serial\n\n    description = SubElement(e, \"description\")\n    description.text = self.description\n\n    e.append(self.specifications)\n\n    location = SubElement(e, \"location\")\n    location.text = self.location\n\n    status = SubElement(e, \"status\")\n    status.text = self.status.value\n\n    loggable = SubElement(e, \"loggable\")\n    loggable.text = \"true\" if self.loggable else \"false\"\n\n    traceable = SubElement(e, \"traceable\")\n    traceable.text = \"true\" if self.traceable else \"false\"\n\n    calibrations = SubElement(e, \"calibrations\")\n    calibrations.extend(c.to_xml() for c in self.calibrations)\n\n    e.append(self.maintenance.to_xml())\n\n    alterations = SubElement(e, \"alterations\")\n    alterations.extend(a.to_xml() for a in self.alterations)\n\n    firmware = SubElement(e, \"firmware\")\n    firmware.extend(f.to_xml() for f in self.firmware)\n\n    e.append(self.specified_requirements)\n    e.append(self.reference_materials)\n    e.append(self.quality_manual.to_xml())\n    return e\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Latest","title":"Latest  <code>dataclass</code>","text":"<pre><code>Latest(\n    calibration_interval: float = 0.0,\n    name: str = \"\",\n    next_calibration_date: date = date(1875, 5, 20),\n    quantity: str = \"\",\n)\n</code></pre> <p>Base class for LatestReport and LatestPerformanceCheck.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Latest.calibration_interval","title":"calibration_interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>calibration_interval: float = 0.0\n</code></pre> <p>The number of years that may pass between a calibration or a performance check.</p> <p>For equipment that do not have a required and periodic interval, but are calibrated on demand, the value is <code>0</code>.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Latest.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = ''\n</code></pre> <p>The Component name.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Latest.next_calibration_date","title":"next_calibration_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_calibration_date: date = date(1875, 5, 20)\n</code></pre> <p>The date that the equipment is due for a re-calibration.</p> <p>If the calibration_interval is <code>0</code>, i.e., the equipment is calibrated on demand, this date is equal to the date that the equipment was last calibrated.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Latest.quantity","title":"quantity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quantity: str = ''\n</code></pre> <p>The Measurand quantity.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Latest.is_calibration_due","title":"is_calibration_due","text":"<pre><code>is_calibration_due(months: int = 0) -&gt; bool\n</code></pre> <p>Determine if the equipment needs to be re-calibrated.</p> <p>Parameters:</p> Name Type Description Default <code>months</code> <code>int</code> <p>The number of months to add to today's date to determine if the equipment needs to be re-calibrated.</p> <code>0</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether a calibration is due within the specified number of <code>months</code>.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def is_calibration_due(self, months: int = 0) -&gt; bool:\n    \"\"\"Determine if the equipment needs to be re-calibrated.\n\n    Args:\n        months: The number of months to add to today's date to determine if\n            the equipment needs to be re-calibrated.\n\n    Returns:\n        Whether a calibration is due within the specified number of `months`.\n    \"\"\"\n    if self.calibration_interval &lt;= 0:\n        return False  # calibrate on-demand\n\n    ask_date = _future_date(_date.today(), max(0.0, months / 12.0))  # noqa: DTZ011\n    return ask_date &gt;= self.next_calibration_date\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck","title":"LatestPerformanceCheck  <code>dataclass</code>","text":"<pre><code>LatestPerformanceCheck(\n    completed_date: date,\n    competency: Competency,\n    entered_by: str = \"\",\n    checked_by: str = \"\",\n    checked_date: date | None = None,\n    conditions: Conditions = Conditions(),\n    cvd_equations: tuple[CVDEquation, ...] = (),\n    deserialisers: tuple[Deserialised, ...] = (),\n    equations: tuple[Equation, ...] = (),\n    files: tuple[File, ...] = (),\n    tables: tuple[Table, ...] = (),\n    calibration_interval: float = 0.0,\n    name: str = \"\",\n    next_calibration_date: date = date(1875, 5, 20),\n    quantity: str = \"\",\n)\n</code></pre> <p>               Bases: <code>Latest</code>, <code>PerformanceCheck</code></p> <p>Latest performance check.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.calibration_interval","title":"calibration_interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>calibration_interval: float = 0.0\n</code></pre> <p>The number of years that may pass between a calibration or a performance check.</p> <p>For equipment that do not have a required and periodic interval, but are calibrated on demand, the value is <code>0</code>.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.checked_by","title":"checked_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_by: str = ''\n</code></pre> <p>The name of the person who checked the information in the <code>&lt;performanceCheck&gt;</code> element.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.checked_date","title":"checked_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_date: date | None = None\n</code></pre> <p>The date that the information in the <code>&lt;performanceCheck&gt;</code> element was last checked.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.competency","title":"competency  <code>instance-attribute</code>","text":"<pre><code>competency: Competency\n</code></pre> <p>The competent people who accomplished the performance check and the technical procedure that was executed.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.completed_date","title":"completed_date  <code>instance-attribute</code>","text":"<pre><code>completed_date: date\n</code></pre> <p>The date that the performance check was completed.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.conditions","title":"conditions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>conditions: Conditions = field(default_factory=Conditions)\n</code></pre> <p>The conditions under which the performance check is valid.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.cvd_equation","title":"cvd_equation  <code>property</code>","text":"<pre><code>cvd_equation: CVDEquation\n</code></pre> <p>Returns the first item in the cvd_equations tuple.</p> <p>Raises IndexError if the performance check does not contain Callendar-Van Dusen equations.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.cvd_equations","title":"cvd_equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cvd_equations: tuple[CVDEquation, ...] = ()\n</code></pre> <p>Performance-check data is expressed as Callendar-Van Dusen equations.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.deserialised","title":"deserialised  <code>property</code>","text":"<pre><code>deserialised: Deserialised\n</code></pre> <p>Returns the first item in the deserialisers tuple.</p> <p>Raises IndexError if the performance check does not contain serialised data.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.deserialisers","title":"deserialisers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>deserialisers: tuple[Deserialised, ...] = ()\n</code></pre> <p>Performance-check data is stored in serialised formats and deserialised.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.entered_by","title":"entered_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entered_by: str = ''\n</code></pre> <p>The name of the person who initially entered the <code>&lt;performanceCheck&gt;</code> element in the register.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.equation","title":"equation  <code>property</code>","text":"<pre><code>equation: Equation\n</code></pre> <p>Returns the first item in the equations tuple.</p> <p>Raises IndexError if the performance check does not contain equations.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.equations","title":"equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>equations: tuple[Equation, ...] = ()\n</code></pre> <p>Performance-check data is expressed as equations.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.file","title":"file  <code>property</code>","text":"<pre><code>file: File\n</code></pre> <p>Returns the first item in the files tuple.</p> <p>Raises IndexError if the performance check does not contain files.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.files","title":"files  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>files: tuple[File, ...] = ()\n</code></pre> <p>Performance-check data is stored in other files (not in the equipment register).</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = ''\n</code></pre> <p>The Component name.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.next_calibration_date","title":"next_calibration_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_calibration_date: date = date(1875, 5, 20)\n</code></pre> <p>The date that the equipment is due for a re-calibration.</p> <p>If the calibration_interval is <code>0</code>, i.e., the equipment is calibrated on demand, this date is equal to the date that the equipment was last calibrated.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.quantity","title":"quantity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quantity: str = ''\n</code></pre> <p>The Measurand quantity.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.table","title":"table  <code>property</code>","text":"<pre><code>table: Table\n</code></pre> <p>Returns the first item in the tables tuple.</p> <p>Raises IndexError if the performance check does not contain tables.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.tables","title":"tables  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tables: tuple[Table, ...] = ()\n</code></pre> <p>Performance-check data is stored as Comma Separated Values (CSV) tables.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; PerformanceCheck\n</code></pre> <p>Convert an XML element into a PerformanceCheck instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A performanceCheck XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>PerformanceCheck</code> <p>The PerformanceCheck instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; PerformanceCheck:\n    \"\"\"Convert an XML element into a [PerformanceCheck][msl.equipment.schema.PerformanceCheck] instance.\n\n    Args:\n        element: A [performanceCheck][type_performanceCheck] XML element from an\n            equipment register.\n\n    Returns:\n        The [PerformanceCheck][msl.equipment.schema.PerformanceCheck] instance.\n    \"\"\"\n    # Schema forces order for `competency` and `conditions` but uses xsd:choice,\n    # which allows sub-elements to appear (or not appear) in any order, for the data elements.\n    # Using str.endswith() allows for ignoring XML namespaces that may be associated with each tag\n    cvd_equations: list[CVDEquation] = []\n    equations: list[Equation] = []\n    files: list[File] = []\n    deserialisers: list[Deserialised] = []\n    tables: list[Table] = []\n    for child in element[2:]:\n        tag = child.tag\n        if tag.endswith(\"equation\"):\n            equations.append(Equation.from_xml(child))\n        elif tag.endswith(\"table\"):\n            tables.append(Table.from_xml(child))\n        elif tag.endswith(\"cvdCoefficients\"):\n            cvd_equations.append(CVDEquation.from_xml(child))\n        elif tag.endswith(\"file\"):\n            files.append(File.from_xml(child))\n        else:\n            deserialisers.append(Deserialised.from_xml(child))\n\n    a = element.attrib\n    return cls(\n        completed_date=_date.fromisoformat(a[\"completedDate\"] or \"\"),\n        entered_by=a[\"enteredBy\"] or \"\",\n        checked_by=a.get(\"checkedBy\", \"\"),\n        checked_date=None if not a.get(\"checkedDate\") else _date.fromisoformat(a[\"checkedDate\"]),\n        competency=Competency.from_xml(element[0]),\n        conditions=Conditions.from_xml(element[1]),\n        cvd_equations=tuple(cvd_equations),\n        deserialisers=tuple(deserialisers),\n        equations=tuple(equations),\n        files=tuple(files),\n        tables=tuple(tables),\n    )\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.is_calibration_due","title":"is_calibration_due","text":"<pre><code>is_calibration_due(months: int = 0) -&gt; bool\n</code></pre> <p>Determine if the equipment needs to be re-calibrated.</p> <p>Parameters:</p> Name Type Description Default <code>months</code> <code>int</code> <p>The number of months to add to today's date to determine if the equipment needs to be re-calibrated.</p> <code>0</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether a calibration is due within the specified number of <code>months</code>.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def is_calibration_due(self, months: int = 0) -&gt; bool:\n    \"\"\"Determine if the equipment needs to be re-calibrated.\n\n    Args:\n        months: The number of months to add to today's date to determine if\n            the equipment needs to be re-calibrated.\n\n    Returns:\n        Whether a calibration is due within the specified number of `months`.\n    \"\"\"\n    if self.calibration_interval &lt;= 0:\n        return False  # calibrate on-demand\n\n    ask_date = _future_date(_date.today(), max(0.0, months / 12.0))  # noqa: DTZ011\n    return ask_date &gt;= self.next_calibration_date\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the PerformanceCheck class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The PerformanceCheck as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [PerformanceCheck][msl.equipment.schema.PerformanceCheck] class into an XML element.\n\n    Returns:\n        The [PerformanceCheck][msl.equipment.schema.PerformanceCheck] as an XML element.\n    \"\"\"\n    a = {\"completedDate\": self.completed_date.isoformat(), \"enteredBy\": self.entered_by}\n    if self.checked_by:\n        a[\"checkedBy\"] = self.checked_by\n    if self.checked_date is not None:\n        a[\"checkedDate\"] = self.checked_date.isoformat()\n\n    e = Element(\"performanceCheck\", attrib=a)\n    e.append(self.competency.to_xml())\n    e.append(self.conditions)\n    e.extend(equation.to_xml() for equation in self.equations)\n    e.extend(table.to_xml() for table in self.tables)\n    e.extend(cvd.to_xml() for cvd in self.cvd_equations)\n    e.extend(file.to_xml() for file in self.files)\n    e.extend(deserialised.to_xml() for deserialised in self.deserialisers)\n    return e\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport","title":"LatestReport  <code>dataclass</code>","text":"<pre><code>LatestReport(\n    id: str,\n    report_issue_date: date,\n    measurement_start_date: date,\n    measurement_stop_date: date,\n    issuing_laboratory: IssuingLaboratory = IssuingLaboratory(),\n    technical_procedure: str = \"\",\n    entered_by: str = \"\",\n    checked_by: str = \"\",\n    checked_date: date | None = None,\n    conditions: Conditions = Conditions(),\n    acceptance_criteria: AcceptanceCriteria = AcceptanceCriteria(),\n    cvd_equations: tuple[CVDEquation, ...] = (),\n    deserialisers: tuple[Deserialised, ...] = (),\n    equations: tuple[Equation, ...] = (),\n    files: tuple[File, ...] = (),\n    tables: tuple[Table, ...] = (),\n    calibration_interval: float = 0.0,\n    name: str = \"\",\n    next_calibration_date: date = date(1875, 5, 20),\n    quantity: str = \"\",\n)\n</code></pre> <p>               Bases: <code>Latest</code>, <code>Report</code></p> <p>Latest calibration report.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.acceptance_criteria","title":"acceptance_criteria  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acceptance_criteria: AcceptanceCriteria = field(\n    default_factory=AcceptanceCriteria\n)\n</code></pre> <p>Acceptance criteria for the calibration report.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.calibration_interval","title":"calibration_interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>calibration_interval: float = 0.0\n</code></pre> <p>The number of years that may pass between a calibration or a performance check.</p> <p>For equipment that do not have a required and periodic interval, but are calibrated on demand, the value is <code>0</code>.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.checked_by","title":"checked_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_by: str = ''\n</code></pre> <p>The name of the person who checked the information in the <code>&lt;report&gt;</code> element.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.checked_date","title":"checked_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_date: date | None = None\n</code></pre> <p>The date that the information in the <code>&lt;report&gt;</code> element was last checked.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.conditions","title":"conditions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>conditions: Conditions = field(default_factory=Conditions)\n</code></pre> <p>The conditions under which the report is valid.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.cvd_equation","title":"cvd_equation  <code>property</code>","text":"<pre><code>cvd_equation: CVDEquation\n</code></pre> <p>Returns the first item in the cvd_equations tuple.</p> <p>Raises IndexError if the report does not contain Callendar-Van Dusen equations.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.cvd_equations","title":"cvd_equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cvd_equations: tuple[CVDEquation, ...] = ()\n</code></pre> <p>Calibration data is expressed as Callendar-Van Dusen equations.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.deserialised","title":"deserialised  <code>property</code>","text":"<pre><code>deserialised: Deserialised\n</code></pre> <p>Returns the first item in the deserialisers tuple.</p> <p>Raises IndexError if the report does not contain serialised data.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.deserialisers","title":"deserialisers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>deserialisers: tuple[Deserialised, ...] = ()\n</code></pre> <p>Calibration data is stored in serialised formats and deserialised.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.entered_by","title":"entered_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entered_by: str = ''\n</code></pre> <p>The name of the person who initially entered the <code>&lt;report&gt;</code> element in the register.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.equation","title":"equation  <code>property</code>","text":"<pre><code>equation: Equation\n</code></pre> <p>Returns the first item in the equations tuple.</p> <p>Raises IndexError if the report does not contain equations.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.equations","title":"equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>equations: tuple[Equation, ...] = ()\n</code></pre> <p>Calibration data is expressed as equations.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.file","title":"file  <code>property</code>","text":"<pre><code>file: File\n</code></pre> <p>Returns the first item in the files tuple.</p> <p>Raises IndexError if the report does not contain files.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.files","title":"files  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>files: tuple[File, ...] = ()\n</code></pre> <p>Calibration data is stored in other files (not in the equipment register).</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>The report identification number.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.issuing_laboratory","title":"issuing_laboratory  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>issuing_laboratory: IssuingLaboratory = field(\n    default_factory=IssuingLaboratory\n)\n</code></pre> <p>Information about the laboratory that issued the calibration report.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.measurement_start_date","title":"measurement_start_date  <code>instance-attribute</code>","text":"<pre><code>measurement_start_date: date\n</code></pre> <p>The date that the calibration measurement started.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.measurement_stop_date","title":"measurement_stop_date  <code>instance-attribute</code>","text":"<pre><code>measurement_stop_date: date\n</code></pre> <p>The date that the calibration measurement stopped.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = ''\n</code></pre> <p>The Component name.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.next_calibration_date","title":"next_calibration_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_calibration_date: date = date(1875, 5, 20)\n</code></pre> <p>The date that the equipment is due for a re-calibration.</p> <p>If the calibration_interval is <code>0</code>, i.e., the equipment is calibrated on demand, this date is equal to the date that the equipment was last calibrated.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.quantity","title":"quantity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quantity: str = ''\n</code></pre> <p>The Measurand quantity.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.report_issue_date","title":"report_issue_date  <code>instance-attribute</code>","text":"<pre><code>report_issue_date: date\n</code></pre> <p>The date that the report was issued.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.table","title":"table  <code>property</code>","text":"<pre><code>table: Table\n</code></pre> <p>Returns the first item in the tables tuple.</p> <p>Raises IndexError if the report does not contain tables.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.tables","title":"tables  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tables: tuple[Table, ...] = ()\n</code></pre> <p>Calibration data is stored as Comma Separated Values (CSV) tables.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.technical_procedure","title":"technical_procedure  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>technical_procedure: str = ''\n</code></pre> <p>The technical procedure(s) that was(were) followed to perform the calibration.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Report\n</code></pre> <p>Convert an XML element into a Report instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A report XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Report</code> <p>The Report instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Report:\n    \"\"\"Convert an XML element into a [Report][msl.equipment.schema.Report] instance.\n\n    Args:\n        element: A [report][type_report] XML element from an equipment register.\n\n    Returns:\n        The [Report][msl.equipment.schema.Report] instance.\n    \"\"\"\n    # Schema forces order until `acceptanceCriteria` and then uses xsd:choice, which\n    # allows sub-elements to appear (or not appear) in any order, for the data elements.\n    # Using str.endswith() allows for ignoring XML namespaces that may be associated with each tag\n    cvd_equations: list[CVDEquation] = []\n    deserialisers: list[Deserialised] = []\n    equations: list[Equation] = []\n    files: list[File] = []\n    tables: list[Table] = []\n    for child in element[7:]:\n        tag = child.tag\n        if tag.endswith(\"equation\"):\n            equations.append(Equation.from_xml(child))\n        elif tag.endswith(\"table\"):\n            tables.append(Table.from_xml(child))\n        elif tag.endswith(\"cvdCoefficients\"):\n            cvd_equations.append(CVDEquation.from_xml(child))\n        elif tag.endswith(\"file\"):\n            files.append(File.from_xml(child))\n        else:\n            deserialisers.append(Deserialised.from_xml(child))\n\n    a = element.attrib\n    return cls(\n        id=a[\"id\"] or \"\",\n        entered_by=a[\"enteredBy\"] or \"\",\n        checked_by=a.get(\"checkedBy\", \"\"),\n        checked_date=None if not a.get(\"checkedDate\") else _date.fromisoformat(a[\"checkedDate\"]),\n        report_issue_date=_date.fromisoformat(element[0].text or \"\"),\n        measurement_start_date=_date.fromisoformat(element[1].text or \"\"),\n        measurement_stop_date=_date.fromisoformat(element[2].text or \"\"),\n        issuing_laboratory=IssuingLaboratory.from_xml(element[3]),\n        technical_procedure=element[4].text or \"\",\n        conditions=Conditions.from_xml(element[5]),\n        acceptance_criteria=AcceptanceCriteria.from_xml(element[6]),\n        cvd_equations=tuple(cvd_equations),\n        deserialisers=tuple(deserialisers),\n        equations=tuple(equations),\n        files=tuple(files),\n        tables=tuple(tables),\n    )\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.is_calibration_due","title":"is_calibration_due","text":"<pre><code>is_calibration_due(months: int = 0) -&gt; bool\n</code></pre> <p>Determine if the equipment needs to be re-calibrated.</p> <p>Parameters:</p> Name Type Description Default <code>months</code> <code>int</code> <p>The number of months to add to today's date to determine if the equipment needs to be re-calibrated.</p> <code>0</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether a calibration is due within the specified number of <code>months</code>.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def is_calibration_due(self, months: int = 0) -&gt; bool:\n    \"\"\"Determine if the equipment needs to be re-calibrated.\n\n    Args:\n        months: The number of months to add to today's date to determine if\n            the equipment needs to be re-calibrated.\n\n    Returns:\n        Whether a calibration is due within the specified number of `months`.\n    \"\"\"\n    if self.calibration_interval &lt;= 0:\n        return False  # calibrate on-demand\n\n    ask_date = _future_date(_date.today(), max(0.0, months / 12.0))  # noqa: DTZ011\n    return ask_date &gt;= self.next_calibration_date\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Report class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Report as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Report][msl.equipment.schema.Report] class into an XML element.\n\n    Returns:\n        The [Report][msl.equipment.schema.Report] as an XML element.\n    \"\"\"\n    a = {\"id\": self.id, \"enteredBy\": self.entered_by}\n    if self.checked_by:\n        a[\"checkedBy\"] = self.checked_by\n    if self.checked_date is not None:\n        a[\"checkedDate\"] = self.checked_date.isoformat()\n\n    e = Element(\"report\", attrib=a)\n\n    rid = SubElement(e, \"reportIssueDate\")\n    rid.text = self.report_issue_date.isoformat()\n\n    start = SubElement(e, \"measurementStartDate\")\n    start.text = self.measurement_start_date.isoformat()\n\n    stop = SubElement(e, \"measurementStopDate\")\n    stop.text = self.measurement_stop_date.isoformat()\n\n    e.append(self.issuing_laboratory.to_xml())\n\n    tp = SubElement(e, \"technicalProcedure\")\n    tp.text = self.technical_procedure\n\n    e.append(self.conditions)\n    e.append(self.acceptance_criteria)\n    e.extend(equation.to_xml() for equation in self.equations)\n    e.extend(table.to_xml() for table in self.tables)\n    e.extend(cvd.to_xml() for cvd in self.cvd_equations)\n    e.extend(file.to_xml() for file in self.files)\n    e.extend(deserialised.to_xml() for deserialised in self.deserialisers)\n    return e\n</code></pre>"},{"location":"schema/file/","title":"File","text":"<p>Suppose you have a variable named <code>file</code> (which is an instance of File) that represents the following information in an equipment register for data that is stored in a Spreadsheet</p> <pre><code>&lt;file comment=\"FEL T647\"&gt;\n  &lt;url sheet=\"2024-May\" cells=\"A1:C11\"&gt;tests\\resources\\irradiance.xlsx&lt;/url&gt;\n  &lt;sha256&gt;7a91267cfb529388a99762b891ee4b7a12463e83b5d55809f76a0c8e76c71886&lt;/sha256&gt;\n&lt;/file&gt;\n</code></pre> <p>You can access sha256 and comment as attributes of <code>file</code></p> <pre><code>&gt;&gt;&gt; file.sha256\n'7a91267cfb529388a99762b891ee4b7a12463e83b5d55809f76a0c8e76c71886'\n&gt;&gt;&gt; file.comment\n'FEL T647'\n</code></pre> <p>The url and attributes attributes of <code>file</code> can be used with the read_table function of msl-io to read the Spreadsheet data</p> <pre><code>&gt;&gt;&gt; from msl.io import read_table\n&gt;&gt;&gt; table = read_table(file.url, **file.attributes)\n&gt;&gt;&gt; print(table.metadata.header)\n['Wavelength' 'Irradiance' 'u(Irradiance)']\n&gt;&gt;&gt; table\n&lt;Dataset 'irradiance.xlsx' shape=(10, 3) dtype='&lt;f8' (1 metadata)&gt;\n&gt;&gt;&gt; print(table)\narray([[2.500000e+02, 1.818000e-02, 2.033000e-02],\n       [3.000000e+02, 1.847800e-01, 1.755000e-02],\n       [3.500000e+02, 8.084500e-01, 1.606000e-02],\n       [4.000000e+02, 2.213550e+00, 1.405000e-02],\n       [4.500000e+02, 4.490040e+00, 1.250000e-02],\n       [5.000000e+02, 7.451350e+00, 1.200000e-02],\n       [5.500000e+02, 1.075753e+01, 1.152000e-02],\n       [6.000000e+02, 1.403809e+01, 1.102000e-02],\n       [6.500000e+02, 1.699469e+01, 1.103000e-02],\n       [7.000000e+02, 1.944093e+01, 1.077000e-02]])\n</code></pre> <p>Note</p> <p>Passing <code>**file.attributes</code> to read_table works as expected provided that the XML attributes of the <code>&lt;url&gt;</code> element are valid keyword arguments to read_table. See Read a table for more examples from msl-io, in particular, specifying <code>dtype=\"header\"</code> will return a structured dataset which would behave similar to the Table example in <code>msl-equipment</code> (i.e., accessing columns by header name).</p>"},{"location":"schema/file/#msl.equipment.schema.File","title":"File  <code>dataclass</code>","text":"<pre><code>File(\n    url: str,\n    sha256: str,\n    attributes: dict[str, str] = dict(),\n    comment: str = \"\",\n)\n</code></pre> <p>Represents the file element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The location of the file. The syntax follows RFC 1738 <code>scheme:scheme-specific-part</code>. If <code>scheme:</code> is not specified, it is assumed to be <code>file:</code>.</p> required <code>sha256</code> <code>str</code> <p>The SHA-256 checksum of the file.</p> required <code>attributes</code> <code>dict[str, str]</code> <p>XML attributes associated with the <code>&lt;url&gt;</code> element.</p> <code>dict()</code> <code>comment</code> <code>str</code> <p>A comment to associate with the file.</p> <code>''</code>"},{"location":"schema/file/#msl.equipment.schema.File.attributes","title":"attributes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attributes: dict[str, str] = field(default_factory=dict)\n</code></pre> <p>XML attributes associated with the <code>&lt;url&gt;</code> element.</p>"},{"location":"schema/file/#msl.equipment.schema.File.comment","title":"comment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comment: str = ''\n</code></pre> <p>A comment associated with the file.</p>"},{"location":"schema/file/#msl.equipment.schema.File.scheme","title":"scheme  <code>property</code>","text":"<pre><code>scheme: str\n</code></pre> <p>Returns the scheme component that is specified in the url (see RFC 1738 for more details).</p> <p>If a <code>&lt;scheme&gt;</code> is not specified, an empty string is returned (which shall be treated as the <code>file</code> scheme). Drive letters on Windows are not considered as a scheme.</p>"},{"location":"schema/file/#msl.equipment.schema.File.sha256","title":"sha256  <code>instance-attribute</code>","text":"<pre><code>sha256: str\n</code></pre> <p>The SHA-256 checksum of the file.</p>"},{"location":"schema/file/#msl.equipment.schema.File.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: str\n</code></pre> <p>The location of the file.</p> <p>The syntax follows RFC 1738 <code>&lt;scheme&gt;:&lt;scheme-specific-part&gt;</code>. If <code>&lt;scheme&gt;</code> is not specified, it shall be treated as the <code>file</code> scheme (see also scheme).</p>"},{"location":"schema/file/#msl.equipment.schema.File.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; File\n</code></pre> <p>Convert an XML element into a File instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A file XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>File</code> <p>The File instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; File:\n    \"\"\"Convert an XML element into a [File][msl.equipment.schema.File] instance.\n\n    Args:\n        element: A [file][type_file] XML element from an equipment register.\n\n    Returns:\n        The [File][msl.equipment.schema.File] instance.\n    \"\"\"\n    # Schema forces order\n    return cls(\n        url=element[0].text or \"\",\n        sha256=element[1].text or \"\",\n        attributes=element[0].attrib,\n        comment=element.attrib.get(\"comment\", \"\"),\n    )\n</code></pre>"},{"location":"schema/file/#msl.equipment.schema.File.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the File class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The File as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [File][msl.equipment.schema.File] class into an XML element.\n\n    Returns:\n        The [File][msl.equipment.schema.File] as an XML element.\n    \"\"\"\n    attrib = {\"comment\": self.comment} if self.comment else {}\n    e = Element(\"file\", attrib=attrib)\n    url = SubElement(e, \"url\", attrib=self.attributes)\n    url.text = self.url\n    sha256 = SubElement(e, \"sha256\")\n    sha256.text = self.sha256\n    return e\n</code></pre>"},{"location":"schema/financial/","title":"Financial","text":""},{"location":"schema/financial/#msl.equipment.schema.Financial","title":"Financial  <code>dataclass</code>","text":"<pre><code>Financial(\n    capital_expenditure: CapitalExpenditure | None = None,\n    purchase_year: int = 0,\n    warranty_expiration_date: date | None = None,\n)\n</code></pre> <p>Represents the financial element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>capital_expenditure</code> <code>CapitalExpenditure | None</code> <p>The equipment is a capital expenditure.</p> <code>None</code> <code>purchase_year</code> <code>int</code> <p>The (approximate) year that the equipment was purchased. A value of <code>0</code> represents that the year is unknown.</p> <code>0</code> <code>warranty_expiration_date</code> <code>date | None</code> <p>Approximate date that the warranty expires.</p> <code>None</code>"},{"location":"schema/financial/#msl.equipment.schema.Financial.capital_expenditure","title":"capital_expenditure  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>capital_expenditure: CapitalExpenditure | None = None\n</code></pre> <p>The equipment is a capital expenditure.</p>"},{"location":"schema/financial/#msl.equipment.schema.Financial.purchase_year","title":"purchase_year  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>purchase_year: int = 0\n</code></pre> <p>The (approximate) year that the equipment was purchased. A value of <code>0</code> represents that the year is unknown.</p>"},{"location":"schema/financial/#msl.equipment.schema.Financial.warranty_expiration_date","title":"warranty_expiration_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>warranty_expiration_date: date | None = None\n</code></pre> <p>Approximate date that the warranty expires.</p>"},{"location":"schema/financial/#msl.equipment.schema.Financial.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Financial\n</code></pre> <p>Convert an XML element into a Financial instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A financial XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Financial</code> <p>The Financial instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Financial:\n    \"\"\"Convert an XML element into a [Financial][msl.equipment.schema.Financial] instance.\n\n    Args:\n        element: A [financial][type_financial] XML element from an equipment register.\n\n    Returns:\n        The [Financial][msl.equipment.schema.Financial] instance.\n    \"\"\"\n    # Schema defines &lt;financial&gt; using xsd:all, which allows sub-elements to appear (or not appear) in any order\n    # Using str.endswith() allows for ignoring XML namespaces that may be associated with each tag\n    cap_ex, warranty, year = None, None, 0\n    for child in element:\n        if child.tag.endswith(\"capitalExpenditure\"):\n            cap_ex = CapitalExpenditure.from_xml(child)\n        elif child.tag.endswith(\"warrantyExpirationDate\"):\n            warranty = _date.fromisoformat(child.text or \"\")\n        else:\n            year = int(child.text or 0)\n    return cls(capital_expenditure=cap_ex, purchase_year=year, warranty_expiration_date=warranty)\n</code></pre>"},{"location":"schema/financial/#msl.equipment.schema.Financial.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Financial class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Financial as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Financial][msl.equipment.schema.Financial] class into an XML element.\n\n    Returns:\n        The [Financial][msl.equipment.schema.Financial] as an XML element.\n    \"\"\"\n    e = Element(\"financial\")\n\n    if self.capital_expenditure is not None:\n        e.append(self.capital_expenditure.to_xml())\n\n    if self.purchase_year &gt; 0:\n        py = SubElement(e, \"purchaseYear\")\n        py.text = str(self.purchase_year)\n\n    if self.warranty_expiration_date is not None:\n        wed = SubElement(e, \"warrantyExpirationDate\")\n        wed.text = self.warranty_expiration_date.isoformat()\n\n    return e\n</code></pre>"},{"location":"schema/firmware/","title":"Firmware","text":""},{"location":"schema/firmware/#msl.equipment.schema.Firmware","title":"Firmware  <code>dataclass</code>","text":"<pre><code>Firmware(version: str, date: date)\n</code></pre> <p>Represents a firmware <code>&lt;version&gt;</code> sub-element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>Firmware version number.</p> required <code>date</code> <code>date</code> <p>The date that the firmware was initially at or changed to <code>version</code>.</p> required"},{"location":"schema/firmware/#msl.equipment.schema.Firmware.date","title":"date  <code>instance-attribute</code>","text":"<pre><code>date: date\n</code></pre> <p>The date that the firmware was initially at or changed to <code>version</code>.</p>"},{"location":"schema/firmware/#msl.equipment.schema.Firmware.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str\n</code></pre> <p>Firmware version number.</p>"},{"location":"schema/firmware/#msl.equipment.schema.Firmware.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Firmware\n</code></pre> <p>Convert an XML element into a Firmware instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A firmware <code>&lt;version&gt;</code> XML sub-element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Firmware</code> <p>The Firmware instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Firmware:\n    \"\"\"Convert an XML element into a [Firmware][msl.equipment.schema.Firmware] instance.\n\n    Args:\n        element: A [firmware][type_firmware] `&lt;version&gt;` XML sub-element\n            from an equipment register.\n\n    Returns:\n        The [Firmware][msl.equipment.schema.Firmware] instance.\n    \"\"\"\n    return cls(version=element.text or \"\", date=_date.fromisoformat(element.attrib[\"date\"]))\n</code></pre>"},{"location":"schema/firmware/#msl.equipment.schema.Firmware.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Firmware class into a <code>&lt;version&gt;</code> XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Firmware as a <code>&lt;version&gt;</code> XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Firmware][msl.equipment.schema.Firmware] class into a `&lt;version&gt;` XML element.\n\n    Returns:\n        The [Firmware][msl.equipment.schema.Firmware] as a `&lt;version&gt;` XML element.\n    \"\"\"\n    e = Element(\"version\", attrib={\"date\": self.date.isoformat()})\n    e.text = self.version\n    return e\n</code></pre>"},{"location":"schema/maintenance/","title":"Maintenance","text":""},{"location":"schema/maintenance/#msl.equipment.schema.Maintenance","title":"Maintenance  <code>dataclass</code>","text":"<pre><code>Maintenance(\n    planned: tuple[PlannedTask, ...] = (),\n    completed: tuple[CompletedTask, ...] = (),\n)\n</code></pre> <p>Represents the maintenance element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>planned</code> <code>tuple[PlannedTask, ...]</code> <p>Maintenance tasks that are planned to be performed.</p> <code>()</code> <code>completed</code> <code>tuple[CompletedTask, ...]</code> <p>Maintenance tasks that have been completed.</p> <code>()</code>"},{"location":"schema/maintenance/#msl.equipment.schema.Maintenance.completed","title":"completed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>completed: tuple[CompletedTask, ...] = ()\n</code></pre> <p>Maintenance tasks that have been completed.</p>"},{"location":"schema/maintenance/#msl.equipment.schema.Maintenance.planned","title":"planned  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>planned: tuple[PlannedTask, ...] = ()\n</code></pre> <p>Maintenance tasks that are planned to be performed.</p>"},{"location":"schema/maintenance/#msl.equipment.schema.Maintenance.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Maintenance\n</code></pre> <p>Convert an XML element into a Maintenance instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A maintenance XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Maintenance</code> <p>The Maintenance instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Maintenance:\n    \"\"\"Convert an XML element into a [Maintenance][msl.equipment.schema.Maintenance] instance.\n\n    Args:\n        element: A [maintenance][type_maintenance] XML element from an equipment register.\n\n    Returns:\n        The [Maintenance][msl.equipment.schema.Maintenance] instance.\n    \"\"\"\n    if len(element) == 0:\n        return cls()\n\n    # Schema forces order, planned tasks then completed tasks (and both sub-elements must exist)\n    return cls(\n        planned=tuple(PlannedTask.from_xml(e) for e in element[0]),\n        completed=tuple(CompletedTask.from_xml(e) for e in element[1]),\n    )\n</code></pre>"},{"location":"schema/maintenance/#msl.equipment.schema.Maintenance.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Maintenance class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Maintenance as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Maintenance][msl.equipment.schema.Maintenance] class into an XML element.\n\n    Returns:\n        The [Maintenance][msl.equipment.schema.Maintenance] as an XML element.\n    \"\"\"\n    e = Element(\"maintenance\")\n    if not (self.planned or self.completed):\n        return e  # no maintenance plan\n\n    # planned must come before completed\n    planned = SubElement(e, \"planned\")\n    planned.extend(p.to_xml() for p in self.planned)\n    completed = SubElement(e, \"completed\")\n    completed.extend(c.to_xml() for c in self.completed)\n    return e\n</code></pre>"},{"location":"schema/measurand/","title":"Measurand","text":""},{"location":"schema/measurand/#msl.equipment.schema.Measurand","title":"Measurand  <code>dataclass</code>","text":"<pre><code>Measurand(\n    quantity: str,\n    calibration_interval: float,\n    components: tuple[Component, ...] = (),\n)\n</code></pre> <p>Represents the measurand element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>str</code> <p>The kind of quantity that is measured.</p> required <code>calibration_interval</code> <code>float</code> <p>The number of years that may pass between a calibration or a performance check. For equipment that do not have a required and periodic interval, but are calibrated on demand, set the value to <code>0</code>.</p> required <code>components</code> <code>tuple[Component, ...]</code> <p>The components of the equipment that measure the <code>quantity</code>.</p> <code>()</code>"},{"location":"schema/measurand/#msl.equipment.schema.Measurand.calibration_interval","title":"calibration_interval  <code>instance-attribute</code>","text":"<pre><code>calibration_interval: float\n</code></pre> <p>The number of years that may pass between a calibration or a performance check.</p> <p>For equipment that do not have a required and periodic interval, but are calibrated on demand, the value is <code>0</code>.</p>"},{"location":"schema/measurand/#msl.equipment.schema.Measurand.components","title":"components  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>components: tuple[Component, ...] = ()\n</code></pre> <p>The components of the equipment that measure the <code>quantity</code>.</p>"},{"location":"schema/measurand/#msl.equipment.schema.Measurand.quantity","title":"quantity  <code>instance-attribute</code>","text":"<pre><code>quantity: str\n</code></pre> <p>The kind of quantity that is measured.</p>"},{"location":"schema/measurand/#msl.equipment.schema.Measurand.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Measurand\n</code></pre> <p>Convert an XML element into a Measurand instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A measurand XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Measurand</code> <p>The Measurand instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Measurand:\n    \"\"\"Convert an XML element into a [Measurand][msl.equipment.schema.Measurand] instance.\n\n    Args:\n        element: A [measurand][type_measurand] XML element from an equipment register.\n\n    Returns:\n        The [Measurand][msl.equipment.schema.Measurand] instance.\n    \"\"\"\n    return cls(\n        quantity=element.attrib[\"quantity\"],\n        calibration_interval=float(element.attrib[\"calibrationInterval\"]),\n        components=tuple(Component.from_xml(c) for c in element),\n    )\n</code></pre>"},{"location":"schema/measurand/#msl.equipment.schema.Measurand.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Measurand class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Measurand as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Measurand][msl.equipment.schema.Measurand] class into an XML element.\n\n    Returns:\n        The [Measurand][msl.equipment.schema.Measurand] as an XML element.\n    \"\"\"\n    attrib = {\"quantity\": self.quantity, \"calibrationInterval\": str(self.calibration_interval)}\n    e = Element(\"measurand\", attrib=attrib)\n    e.extend(c.to_xml() for c in self.components)\n    return e\n</code></pre>"},{"location":"schema/performance_check/","title":"PerformanceCheck","text":""},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck","title":"PerformanceCheck  <code>dataclass</code>","text":"<pre><code>PerformanceCheck(\n    completed_date: date,\n    competency: Competency,\n    entered_by: str = \"\",\n    checked_by: str = \"\",\n    checked_date: date | None = None,\n    conditions: Conditions = Conditions(),\n    cvd_equations: tuple[CVDEquation, ...] = (),\n    deserialisers: tuple[Deserialised, ...] = (),\n    equations: tuple[Equation, ...] = (),\n    files: tuple[File, ...] = (),\n    tables: tuple[Table, ...] = (),\n)\n</code></pre> <p>Represents the performanceCheck element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>completed_date</code> <code>date</code> <p>The date that the performance check was completed.</p> required <code>competency</code> <code>Competency</code> <p>The competent people who accomplished the performance check and the technical procedure that was executed.</p> required <code>entered_by</code> <code>str</code> <p>The name of the person who initially entered the <code>&lt;performanceCheck&gt;</code> element in the register.</p> <code>''</code> <code>checked_by</code> <code>str</code> <p>The name of the person who checked the information in the <code>&lt;performanceCheck&gt;</code> element.</p> <code>''</code> <code>checked_date</code> <code>date | None</code> <p>The date that the information in the <code>&lt;performanceCheck&gt;</code> element was last checked.</p> <code>None</code> <code>conditions</code> <code>Conditions</code> <p>The conditions under which the performance check is valid.</p> <code>Conditions()</code> <code>cvd_equations</code> <code>tuple[CVDEquation, ...]</code> <p>Performance-check data is expressed as Callendar-Van Dusen equations.</p> <code>()</code> <code>deserialisers</code> <code>tuple[Deserialised, ...]</code> <p>Performance-check data is stored in serialised formats and deserialised.</p> <code>()</code> <code>equations</code> <code>tuple[Equation, ...]</code> <p>Performance-check data is expressed as equations.</p> <code>()</code> <code>files</code> <code>tuple[File, ...]</code> <p>Performance-check data is stored in other files (not in the equipment register).</p> <code>()</code> <code>tables</code> <code>tuple[Table, ...]</code> <p>Performance-check data is stored as Comma Separated Values (CSV) tables.</p> <code>()</code>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.checked_by","title":"checked_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_by: str = ''\n</code></pre> <p>The name of the person who checked the information in the <code>&lt;performanceCheck&gt;</code> element.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.checked_date","title":"checked_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_date: date | None = None\n</code></pre> <p>The date that the information in the <code>&lt;performanceCheck&gt;</code> element was last checked.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.competency","title":"competency  <code>instance-attribute</code>","text":"<pre><code>competency: Competency\n</code></pre> <p>The competent people who accomplished the performance check and the technical procedure that was executed.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.completed_date","title":"completed_date  <code>instance-attribute</code>","text":"<pre><code>completed_date: date\n</code></pre> <p>The date that the performance check was completed.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.conditions","title":"conditions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>conditions: Conditions = field(default_factory=Conditions)\n</code></pre> <p>The conditions under which the performance check is valid.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.cvd_equation","title":"cvd_equation  <code>property</code>","text":"<pre><code>cvd_equation: CVDEquation\n</code></pre> <p>Returns the first item in the cvd_equations tuple.</p> <p>Raises IndexError if the performance check does not contain Callendar-Van Dusen equations.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.cvd_equations","title":"cvd_equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cvd_equations: tuple[CVDEquation, ...] = ()\n</code></pre> <p>Performance-check data is expressed as Callendar-Van Dusen equations.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.deserialised","title":"deserialised  <code>property</code>","text":"<pre><code>deserialised: Deserialised\n</code></pre> <p>Returns the first item in the deserialisers tuple.</p> <p>Raises IndexError if the performance check does not contain serialised data.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.deserialisers","title":"deserialisers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>deserialisers: tuple[Deserialised, ...] = ()\n</code></pre> <p>Performance-check data is stored in serialised formats and deserialised.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.entered_by","title":"entered_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entered_by: str = ''\n</code></pre> <p>The name of the person who initially entered the <code>&lt;performanceCheck&gt;</code> element in the register.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.equation","title":"equation  <code>property</code>","text":"<pre><code>equation: Equation\n</code></pre> <p>Returns the first item in the equations tuple.</p> <p>Raises IndexError if the performance check does not contain equations.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.equations","title":"equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>equations: tuple[Equation, ...] = ()\n</code></pre> <p>Performance-check data is expressed as equations.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.file","title":"file  <code>property</code>","text":"<pre><code>file: File\n</code></pre> <p>Returns the first item in the files tuple.</p> <p>Raises IndexError if the performance check does not contain files.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.files","title":"files  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>files: tuple[File, ...] = ()\n</code></pre> <p>Performance-check data is stored in other files (not in the equipment register).</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.table","title":"table  <code>property</code>","text":"<pre><code>table: Table\n</code></pre> <p>Returns the first item in the tables tuple.</p> <p>Raises IndexError if the performance check does not contain tables.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.tables","title":"tables  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tables: tuple[Table, ...] = ()\n</code></pre> <p>Performance-check data is stored as Comma Separated Values (CSV) tables.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; PerformanceCheck\n</code></pre> <p>Convert an XML element into a PerformanceCheck instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A performanceCheck XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>PerformanceCheck</code> <p>The PerformanceCheck instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; PerformanceCheck:\n    \"\"\"Convert an XML element into a [PerformanceCheck][msl.equipment.schema.PerformanceCheck] instance.\n\n    Args:\n        element: A [performanceCheck][type_performanceCheck] XML element from an\n            equipment register.\n\n    Returns:\n        The [PerformanceCheck][msl.equipment.schema.PerformanceCheck] instance.\n    \"\"\"\n    # Schema forces order for `competency` and `conditions` but uses xsd:choice,\n    # which allows sub-elements to appear (or not appear) in any order, for the data elements.\n    # Using str.endswith() allows for ignoring XML namespaces that may be associated with each tag\n    cvd_equations: list[CVDEquation] = []\n    equations: list[Equation] = []\n    files: list[File] = []\n    deserialisers: list[Deserialised] = []\n    tables: list[Table] = []\n    for child in element[2:]:\n        tag = child.tag\n        if tag.endswith(\"equation\"):\n            equations.append(Equation.from_xml(child))\n        elif tag.endswith(\"table\"):\n            tables.append(Table.from_xml(child))\n        elif tag.endswith(\"cvdCoefficients\"):\n            cvd_equations.append(CVDEquation.from_xml(child))\n        elif tag.endswith(\"file\"):\n            files.append(File.from_xml(child))\n        else:\n            deserialisers.append(Deserialised.from_xml(child))\n\n    a = element.attrib\n    return cls(\n        completed_date=_date.fromisoformat(a[\"completedDate\"] or \"\"),\n        entered_by=a[\"enteredBy\"] or \"\",\n        checked_by=a.get(\"checkedBy\", \"\"),\n        checked_date=None if not a.get(\"checkedDate\") else _date.fromisoformat(a[\"checkedDate\"]),\n        competency=Competency.from_xml(element[0]),\n        conditions=Conditions.from_xml(element[1]),\n        cvd_equations=tuple(cvd_equations),\n        deserialisers=tuple(deserialisers),\n        equations=tuple(equations),\n        files=tuple(files),\n        tables=tuple(tables),\n    )\n</code></pre>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the PerformanceCheck class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The PerformanceCheck as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [PerformanceCheck][msl.equipment.schema.PerformanceCheck] class into an XML element.\n\n    Returns:\n        The [PerformanceCheck][msl.equipment.schema.PerformanceCheck] as an XML element.\n    \"\"\"\n    a = {\"completedDate\": self.completed_date.isoformat(), \"enteredBy\": self.entered_by}\n    if self.checked_by:\n        a[\"checkedBy\"] = self.checked_by\n    if self.checked_date is not None:\n        a[\"checkedDate\"] = self.checked_date.isoformat()\n\n    e = Element(\"performanceCheck\", attrib=a)\n    e.append(self.competency.to_xml())\n    e.append(self.conditions)\n    e.extend(equation.to_xml() for equation in self.equations)\n    e.extend(table.to_xml() for table in self.tables)\n    e.extend(cvd.to_xml() for cvd in self.cvd_equations)\n    e.extend(file.to_xml() for file in self.files)\n    e.extend(deserialised.to_xml() for deserialised in self.deserialisers)\n    return e\n</code></pre>"},{"location":"schema/planned_task/","title":"PlannedTask","text":""},{"location":"schema/planned_task/#msl.equipment.schema.PlannedTask","title":"PlannedTask  <code>dataclass</code>","text":"<pre><code>PlannedTask(\n    task: str, due_date: date, performed_by: str = \"\"\n)\n</code></pre> <p>Represents the plannedTask element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>str</code> <p>A description of the task that is planned.</p> required <code>due_date</code> <code>date</code> <p>The date that the planned maintenance task is due to be completed.</p> required <code>performed_by</code> <code>str</code> <p>The person or company that will perform the planned maintenance task.</p> <code>''</code>"},{"location":"schema/planned_task/#msl.equipment.schema.PlannedTask.due_date","title":"due_date  <code>instance-attribute</code>","text":"<pre><code>due_date: date\n</code></pre> <p>The date that the planned maintenance task is due to be completed.</p>"},{"location":"schema/planned_task/#msl.equipment.schema.PlannedTask.performed_by","title":"performed_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performed_by: str = ''\n</code></pre> <p>The person or company that will perform the planned maintenance task.</p>"},{"location":"schema/planned_task/#msl.equipment.schema.PlannedTask.task","title":"task  <code>instance-attribute</code>","text":"<pre><code>task: str\n</code></pre> <p>A description of the task that is planned.</p>"},{"location":"schema/planned_task/#msl.equipment.schema.PlannedTask.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; PlannedTask\n</code></pre> <p>Convert an XML element into a PlannedTask instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A plannedTask XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>PlannedTask</code> <p>The PlannedTask instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; PlannedTask:\n    \"\"\"Convert an XML element into a [PlannedTask][msl.equipment.schema.PlannedTask] instance.\n\n    Args:\n        element: A [plannedTask][type_plannedTask] XML element from an equipment register.\n\n    Returns:\n        The [PlannedTask][msl.equipment.schema.PlannedTask] instance.\n    \"\"\"\n    return cls(\n        task=element.text or \"\",\n        due_date=_date.fromisoformat(element.attrib[\"dueDate\"]),\n        performed_by=element.get(\"performedBy\", \"\"),\n    )\n</code></pre>"},{"location":"schema/planned_task/#msl.equipment.schema.PlannedTask.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the PlannedTask class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The PlannedTask as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [PlannedTask][msl.equipment.schema.PlannedTask] class into an XML element.\n\n    Returns:\n        The [PlannedTask][msl.equipment.schema.PlannedTask] as an XML element.\n    \"\"\"\n    attrib = {\"dueDate\": self.due_date.isoformat()}\n    if self.performed_by:\n        attrib[\"performedBy\"] = self.performed_by\n\n    e = Element(\"task\", attrib=attrib)\n    e.text = self.task\n    return e\n</code></pre>"},{"location":"schema/quality_manual/","title":"QualityManual","text":""},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual","title":"QualityManual  <code>dataclass</code>","text":"<pre><code>QualityManual(\n    accessories: Accessories = Accessories(),\n    documentation: str = \"\",\n    financial: Financial = Financial(),\n    personnel_restrictions: str = \"\",\n    service_agent: str = \"\",\n    technical_procedures: tuple[str, ...] = (),\n)\n</code></pre> <p>Represents the qualityManual element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>accessories</code> <code>Accessories</code> <p>Additional accessories that may be required to use the equipment.</p> <code>Accessories()</code> <code>documentation</code> <code>str</code> <p>Information (such as URLs) about the manuals, datasheets, etc. for the equipment.</p> <code>''</code> <code>financial</code> <code>Financial</code> <p>Financial information about the equipment.</p> <code>Financial()</code> <code>personnel_restrictions</code> <code>str</code> <p>Information about the people (or team) who are qualified to use the equipment.</p> <code>''</code> <code>service_agent</code> <code>str</code> <p>Information about the people or company that are qualified to perform alterations and/or maintenance to the equipment.</p> <code>''</code> <code>technical_procedures</code> <code>tuple[str, ...]</code> <p>The technical procedures that depend on this equipment.</p> <code>()</code>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.accessories","title":"accessories  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>accessories: Accessories = field(\n    default_factory=Accessories\n)\n</code></pre> <p>Additional accessories that may be required to use the equipment.</p>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.documentation","title":"documentation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>documentation: str = ''\n</code></pre> <p>Information (such as URLs) about the manuals, datasheets, etc. for the equipment.</p>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.financial","title":"financial  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>financial: Financial = field(default_factory=Financial)\n</code></pre> <p>Financial information about the equipment.</p>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.personnel_restrictions","title":"personnel_restrictions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>personnel_restrictions: str = ''\n</code></pre> <p>Information about the people (or team) who are qualified to use the equipment.</p>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.service_agent","title":"service_agent  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>service_agent: str = ''\n</code></pre> <p>Information about the people or company that are qualified to perform alterations and/or maintenance to the equipment.</p>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.technical_procedures","title":"technical_procedures  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>technical_procedures: tuple[str, ...] = ()\n</code></pre> <p>The technical procedures that depend on this equipment.</p>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; QualityManual\n</code></pre> <p>Convert an XML element into an QualityManual instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A qualityManual XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>QualityManual</code> <p>The QualityManual instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; QualityManual:\n    \"\"\"Convert an XML element into an [QualityManual][msl.equipment.schema.QualityManual] instance.\n\n    Args:\n        element: A [qualityManual][type_qualityManual] XML element from an equipment register.\n\n    Returns:\n        The [QualityManual][msl.equipment.schema.QualityManual] instance.\n    \"\"\"\n    # Schema defines &lt;qualityManual&gt; using xsd:all, which allows sub-elements to appear (or not appear) in any order\n    # Using str.endswith() allows for ignoring XML namespaces that may be associated with each tag\n    tp: tuple[str, ...] = ()\n    a, d, f, pr, sa = Accessories(), \"\", Financial(), \"\", \"\"\n    for child in element:\n        if child.tag.endswith(\"accessories\"):\n            a = Accessories.from_xml(child)\n        elif child.tag.endswith(\"documentation\"):\n            d = child.text or \"\"\n        elif child.tag.endswith(\"financial\"):\n            f = Financial.from_xml(child)\n        elif child.tag.endswith(\"personnelRestrictions\"):\n            pr = child.text or \"\"\n        elif child.tag.endswith(\"serviceAgent\"):\n            sa = child.text or \"\"\n        else:\n            tp = tuple(i.text for i in child if i.text)\n\n    return cls(\n        accessories=a,\n        documentation=d,\n        financial=f,\n        personnel_restrictions=pr,\n        service_agent=sa,\n        technical_procedures=tp,\n    )\n</code></pre>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the QualityManual class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The QualityManual as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [QualityManual][msl.equipment.schema.QualityManual] class into an XML element.\n\n    Returns:\n        The [QualityManual][msl.equipment.schema.QualityManual] as an XML element.\n    \"\"\"\n    e = Element(\"qualityManual\")\n\n    if len(self.accessories) or len(self.accessories.attrib):\n        e.append(self.accessories)\n\n    if self.documentation:\n        d = SubElement(e, \"documentation\")\n        d.text = self.documentation\n\n    if self.financial != Financial():\n        e.append(self.financial.to_xml())\n\n    if self.personnel_restrictions:\n        pr = SubElement(e, \"personnelRestrictions\")\n        pr.text = self.personnel_restrictions\n\n    if self.service_agent:\n        sa = SubElement(e, \"serviceAgent\")\n        sa.text = self.service_agent\n\n    if self.technical_procedures:\n        tp = SubElement(e, \"technicalProcedures\")\n        for procedure in self.technical_procedures:\n            sub = SubElement(tp, \"id\")\n            sub.text = procedure\n\n    return e\n</code></pre>"},{"location":"schema/reference_materials/","title":"ReferenceMaterials","text":""},{"location":"schema/reference_materials/#msl.equipment.schema.ReferenceMaterials","title":"ReferenceMaterials","text":"<pre><code>ReferenceMaterials(**attributes: str)\n</code></pre> <p>               Bases: <code>Any</code></p> <p>Documentation of reference materials, results, acceptance criteria, relevant dates and the period of validity.</p> <p>Since this class is currently represented by the any type in the XML Schema Definition, it is simply a subclass of Element. It may be updated to be a more specific class at a later date.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any] type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/reference_materials/#msl.equipment.schema.ReferenceMaterials.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str = 'referenceMaterials'\n</code></pre> <p>The element's name.</p>"},{"location":"schema/reference_materials/#msl.equipment.schema.ReferenceMaterials.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/register/","title":"Register","text":""},{"location":"schema/register/#msl.equipment.schema.Register","title":"Register","text":"<pre><code>Register(*sources: XMLSource | Element[str])\n</code></pre> <p>Represents the register element in an equipment register.</p> <p>Specifying multiple sources allows for storing an equipment register across multiple files for the same team. Not specifying a source creates a new (empty) register.</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>XMLSource | Element[str]</code> <p>The path-like, file-like or Element objects that are equipment registers.</p> <code>()</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, *sources: XMLSource | Element[str]) -&gt; None:\n    \"\"\"Represents the [register][element_register] element in an equipment register.\n\n    Specifying multiple sources allows for storing an equipment register across multiple\n    files for the same team. Not specifying a source creates a new (empty) register.\n\n    Args:\n        sources: The [path-like][path-like object],\n            [file-like][file-like object] or\n            [Element][xml.etree.ElementTree.Element]\n            objects that are equipment registers.\n    \"\"\"\n    team = \"\"\n    self._elements: list[Element[str]] = []\n    for source in sources:\n        root = source if isinstance(source, Element) else ElementTree().parse(source)\n        t = root.attrib.get(\"team\", \"\")\n        if not team:\n            team = t\n\n        if team != t:\n            msg = f\"Cannot merge equipment registers from different teams, {team!r} != {t!r}\"\n            raise ValueError(msg)\n\n        self._elements.extend(root)\n\n    self._team: str = team\n    self._equipment: list[Equipment | None] = [None] * len(self._elements)\n\n    # a mapping between the alias/id and the index number in the register\n    self._index_map: dict[str, int] = {str(e[0].text): i for i, e in enumerate(self._elements)}  # e[0] is the ID\n    self._index_map.update({e.attrib[\"alias\"]: i for i, e in enumerate(self._elements) if e.attrib.get(\"alias\")})\n</code></pre>"},{"location":"schema/register/#msl.equipment.schema.Register.NAMESPACE","title":"NAMESPACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NAMESPACE: str = (\n    \"https://measurement.govt.nz/equipment-register\"\n)\n</code></pre> <p>Default XML namespace.</p>"},{"location":"schema/register/#msl.equipment.schema.Register.team","title":"team  <code>property</code> <code>writable</code>","text":"<pre><code>team: str\n</code></pre> <p>str \u2014 The name of the team that is responsible for the equipment register.</p>"},{"location":"schema/register/#msl.equipment.schema.Register.add","title":"add","text":"<pre><code>add(equipment: Equipment) -&gt; None\n</code></pre> <p>Add equipment to the register.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>The equipment to add.</p> required Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def add(self, equipment: Equipment) -&gt; None:\n    \"\"\"Add equipment to the register.\n\n    Args:\n        equipment: The equipment to add.\n    \"\"\"\n    if equipment.id:\n        self._index_map[equipment.id] = len(self._equipment)\n    if equipment.alias:\n        self._index_map[equipment.alias] = len(self._equipment)\n    self._equipment.append(equipment)\n</code></pre>"},{"location":"schema/register/#msl.equipment.schema.Register.find","title":"find","text":"<pre><code>find(\n    pattern: str | Pattern[str], *, flags: int = 0\n) -&gt; Iterator[Equipment]\n</code></pre> <p>Find equipment in the register.</p> <p>The following attributes are used in the search:</p> <ul> <li>keywords: Equipment</li> <li>description: Equipment</li> <li>manufacturer: Equipment</li> <li>model: Equipment</li> <li>serial: Equipment</li> <li>id: Equipment, Report, DigitalReport</li> <li>location: Equipment</li> <li>quantity: Measurand</li> <li>name: Component</li> <li>entered_by: Equipment, PerformanceCheck, Report</li> <li>checked_by: Equipment, PerformanceCheck, Report</li> <li>performed_by: Alteration, CompletedTask, PlannedTask</li> <li>comment: CVDEquation, Equation, File, Table, Deserialised, DigitalReport</li> <li>format: DigitalReport</li> <li>details: Alteration, Adjustment</li> <li>task: CompletedTask, PlannedTask</li> <li>asset_number: CapitalExpenditure</li> <li>service_agent: QualityManual</li> <li>technical_procedures: QualityManual</li> </ul> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str | Pattern[str]</code> <p>A regular-expression pattern to use to find equipment.</p> required <code>flags</code> <code>int</code> <p>The flags to use to compile the <code>pattern</code>. See re.compile for more details.</p> <code>0</code> <p>Yields:</p> Type Description <code>Equipment</code> <p>Equipment that match the <code>pattern</code>.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def find(self, pattern: str | re.Pattern[str], *, flags: int = 0) -&gt; Iterator[Equipment]:  # noqa: C901\n    \"\"\"Find equipment in the register.\n\n    The following attributes are used in the search:\n\n    * keywords: [Equipment][msl.equipment.schema.Equipment]\n    * description: [Equipment][msl.equipment.schema.Equipment]\n    * manufacturer: [Equipment][msl.equipment.schema.Equipment]\n    * model: [Equipment][msl.equipment.schema.Equipment]\n    * serial: [Equipment][msl.equipment.schema.Equipment]\n    * id: [Equipment][msl.equipment.schema.Equipment], [Report][msl.equipment.schema.Report], [DigitalReport][msl.equipment.schema.DigitalReport]\n    * location: [Equipment][msl.equipment.schema.Equipment]\n    * quantity: [Measurand][msl.equipment.schema.Measurand]\n    * name: [Component][msl.equipment.schema.Component]\n    * entered_by: [Equipment][msl.equipment.schema.Equipment], [PerformanceCheck][msl.equipment.schema.PerformanceCheck], [Report][msl.equipment.schema.Report]\n    * checked_by: [Equipment][msl.equipment.schema.Equipment], [PerformanceCheck][msl.equipment.schema.PerformanceCheck], [Report][msl.equipment.schema.Report]\n    * performed_by: [Alteration][msl.equipment.schema.Alteration], [CompletedTask][msl.equipment.schema.CompletedTask], [PlannedTask][msl.equipment.schema.PlannedTask]\n    * comment: [CVDEquation][msl.equipment.schema.CVDEquation], [Equation][msl.equipment.schema.Equation], [File][msl.equipment.schema.File], [Table][msl.equipment.schema.Table], [Deserialised][msl.equipment.schema.Deserialised], [DigitalReport][msl.equipment.schema.DigitalReport]\n    * format: [DigitalReport][msl.equipment.schema.DigitalReport]\n    * details: [Alteration][msl.equipment.schema.Alteration], [Adjustment][msl.equipment.schema.Adjustment]\n    * task: [CompletedTask][msl.equipment.schema.CompletedTask], [PlannedTask][msl.equipment.schema.PlannedTask]\n    * asset_number: [CapitalExpenditure][msl.equipment.schema.CapitalExpenditure]\n    * service_agent: [QualityManual][msl.equipment.schema.QualityManual]\n    * technical_procedures: [QualityManual][msl.equipment.schema.QualityManual]\n\n    Args:\n        pattern: A [regular-expression pattern](https://regexr.com/) to use to find equipment.\n        flags: The flags to use to compile the `pattern`. See [re.compile][] for more details.\n\n    Yields:\n        Equipment that match the `pattern`.\n    \"\"\"  # noqa: E501\n\n    def comment_search(item: Report | PerformanceCheck) -&gt; bool:\n        for cvd_equation in item.cvd_equations:\n            if regex.search(cvd_equation.comment) is not None:\n                return True\n        for equation in item.equations:\n            if regex.search(equation.comment) is not None:\n                return True\n        for file in item.files:\n            if regex.search(file.comment) is not None:\n                return True\n        for table in item.tables:\n            if regex.search(table.comment) is not None:\n                return True\n        return any(regex.search(deserialised.comment) is not None for deserialised in item.deserialisers)\n\n    def task_search(m: Maintenance) -&gt; bool:\n        for c in m.completed:\n            if regex.search(c.task) is not None:\n                return True\n            if regex.search(c.performed_by) is not None:\n                return True\n        for p in m.planned:\n            if regex.search(p.task) is not None:\n                return True\n            if regex.search(p.performed_by) is not None:\n                return True\n        return False\n\n    def alteration_search(alterations: tuple[Alteration, ...]) -&gt; bool:\n        for a in alterations:\n            if regex.search(a.details) is not None:\n                return True\n            if regex.search(a.performed_by) is not None:\n                return True\n        return False\n\n    def calibrations_search(e: Equipment) -&gt; bool:  # noqa: C901, PLR0911, PLR0912\n        for m in e.calibrations:\n            if regex.search(m.quantity) is not None:\n                return True\n            for c in m.components:\n                if regex.search(c.name) is not None:\n                    return True\n                for r in c.reports:\n                    if regex.search(r.entered_by) is not None:\n                        return True\n                    if regex.search(r.checked_by) is not None:\n                        return True\n                    if comment_search(r):\n                        return True\n                    if regex.search(r.id) is not None:\n                        return True\n                for pc in c.performance_checks:\n                    if regex.search(pc.entered_by) is not None:\n                        return True\n                    if regex.search(pc.checked_by) is not None:\n                        return True\n                    if comment_search(pc):\n                        return True\n                for a in c.adjustments:\n                    if regex.search(a.details) is not None:\n                        return True\n                for dr in c.digital_reports:\n                    if regex.search(dr.format.value) is not None:\n                        return True\n                    if regex.search(dr.id) is not None:\n                        return True\n                    if regex.search(dr.comment) is not None:\n                        return True\n        return False\n\n    def asset_number_search(f: Financial) -&gt; bool:\n        if f.capital_expenditure is None:\n            return False\n        return regex.search(f.capital_expenditure.asset_number) is not None\n\n    regex = re.compile(pattern, flags=flags)\n    for equipment in self:\n        if (\n            regex.search(\" \".join(equipment.keywords)) is not None\n            or regex.search(equipment.description) is not None\n            or regex.search(equipment.manufacturer) is not None\n            or regex.search(equipment.model) is not None\n            or regex.search(equipment.serial) is not None\n            or regex.search(equipment.id) is not None\n            or regex.search(equipment.location) is not None\n            or regex.search(equipment.entered_by) is not None\n            or regex.search(equipment.checked_by) is not None\n            or calibrations_search(equipment)\n            or alteration_search(equipment.alterations)\n            or task_search(equipment.maintenance)\n            or asset_number_search(equipment.quality_manual.financial)\n            or regex.search(equipment.quality_manual.service_agent) is not None\n            or regex.search(\" \".join(equipment.quality_manual.technical_procedures)) is not None\n        ):\n            yield equipment\n</code></pre>"},{"location":"schema/register/#msl.equipment.schema.Register.get","title":"get","text":"<pre><code>get(item: int | str) -&gt; Equipment | None\n</code></pre> <p>Get an Equipment item from the register.</p> <p>This method will ignore all errors if the register does not contain the requested Equipment item.</p> <p>Tip</p> <p>You can also treat a register instance as a sequence of Equipment items.</p> <p>Using the indexable notation on a register instance to access an Equipment item by using the alias of the equipment or the index within the register could raise an exception</p> <pre><code>&gt;&gt;&gt; register[\"unknown-alias\"]\nTraceback (most recent call last):\n...\nValueError: No equipment exists with the alias or id 'unknown-alias'\n\n&gt;&gt;&gt; register[243]\nTraceback (most recent call last):\n...\nIndexError: list index out of range\n</code></pre> <p>whereas these errors can be silenced by using the get method</p> <pre><code>&gt;&gt;&gt; assert register.get(\"unknown\") is None\n&gt;&gt;&gt; assert register.get(243) is None\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>int | str</code> <p>The index number, equipment id value or the equipment alias value in the register.</p> required <p>Returns:</p> Type Description <code>Equipment | None</code> <p>The Equipment item if <code>item</code> is valid, otherwise <code>None</code>.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def get(self, item: int | str) -&gt; Equipment | None:\n    \"\"\"Get an [Equipment][msl.equipment.schema.Equipment] item from the register.\n\n    This method will ignore all errors if the register does not contain the requested\n    [Equipment][msl.equipment.schema.Equipment] item.\n\n    !!! tip\n        You can also treat a _register_ instance as a sequence of [Equipment][msl.equipment.schema.Equipment] items.\n\n    &lt;!--\n    &gt;&gt;&gt; from msl.equipment import Register\n    &gt;&gt;&gt; register = Register(\"tests/resources/mass/register.xml\")\n\n    --&gt;\n\n    Using the _indexable_ notation on a _register_ instance to access an [Equipment][msl.equipment.schema.Equipment]\n    item by using the alias of the equipment or the index within the register could raise an exception\n\n    ```pycon\n    &gt;&gt;&gt; register[\"unknown-alias\"]\n    Traceback (most recent call last):\n    ...\n    ValueError: No equipment exists with the alias or id 'unknown-alias'\n\n    &gt;&gt;&gt; register[243]\n    Traceback (most recent call last):\n    ...\n    IndexError: list index out of range\n\n    ```\n\n    whereas these errors can be silenced by using the [get][msl.equipment.schema.Register.get] method\n\n    ```pycon\n    &gt;&gt;&gt; assert register.get(\"unknown\") is None\n    &gt;&gt;&gt; assert register.get(243) is None\n\n    ```\n\n    Args:\n        item: The index number, equipment id value or the equipment alias value in the register.\n\n    Returns:\n        The [Equipment][msl.equipment.schema.Equipment] item if `item` is valid, otherwise `None`.\n    \"\"\"\n    try:\n        return self[item]\n    except (ValueError, IndexError):\n        return None\n</code></pre>"},{"location":"schema/register/#msl.equipment.schema.Register.tree","title":"tree","text":"<pre><code>tree(\n    namespace: str | None = \"DEFAULT\", indent: int = 4\n) -&gt; ElementTree[Element[str]]\n</code></pre> <p>Convert the Register class into an XML element tree.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str | None</code> <p>The namespace to associate with the root element. If the value is <code>DEFAULT</code>, uses the value of NAMESPACE as the namespace. If <code>None</code>, or an empty string, no namespace is associated with the root element.</p> <code>'DEFAULT'</code> <code>indent</code> <code>int</code> <p>The number of spaces to indent sub elements. The value must be \u2265 0. This parameter is ignored if the version of Python is &lt; 3.9.</p> <code>4</code> <p>Returns:</p> Type Description <code>ElementTree[Element[str]]</code> <p>The Register as an ElementTree.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def tree(self, namespace: str | None = \"DEFAULT\", indent: int = 4) -&gt; ElementTree[Element[str]]:\n    \"\"\"Convert the [Register][msl.equipment.schema.Register] class into an XML element tree.\n\n    Args:\n        namespace: The namespace to associate with the root element. If the value is\n            `DEFAULT`, uses the value of [NAMESPACE][msl.equipment.schema.Register.NAMESPACE]\n            as the namespace. If `None`, or an empty string, no namespace is associated\n            with the root element.\n        indent: The number of spaces to indent sub elements. The value must be &amp;ge; 0.\n            This parameter is ignored if the version of Python is &amp;lt; 3.9.\n\n    Returns:\n        The [Register][msl.equipment.schema.Register] as an\n            [ElementTree][xml.etree.ElementTree.ElementTree].\n    \"\"\"\n    if indent &lt; 0:\n        msg = f\"Indentation must be &gt;= 0, got {indent}\"\n        raise ValueError(msg)\n\n    attrib = {\"team\": self.team}\n    if namespace:\n        if namespace == \"DEFAULT\":\n            namespace = self.NAMESPACE\n        attrib[\"xmlns\"] = namespace\n\n    # The &lt;table&gt;&lt;data&gt; element is 7 levels deep from &lt;register&gt;\n    _Indent.table_data = (7 * indent) + len(\"&lt;data&gt;\")\n\n    e = Element(\"register\", attrib=attrib)\n    e.extend(equipment.to_xml() for equipment in self)\n    tree: ElementTree[Element[str]] = ElementTree(element=e)\n\n    if indent &gt; 0 and sys.version_info &gt;= (3, 9):\n        from xml.etree.ElementTree import indent as pretty  # noqa: PLC0415\n\n        pretty(tree, space=\" \" * indent)\n\n    return tree\n</code></pre>"},{"location":"schema/report/","title":"Report","text":""},{"location":"schema/report/#msl.equipment.schema.Report","title":"Report  <code>dataclass</code>","text":"<pre><code>Report(\n    id: str,\n    report_issue_date: date,\n    measurement_start_date: date,\n    measurement_stop_date: date,\n    issuing_laboratory: IssuingLaboratory = IssuingLaboratory(),\n    technical_procedure: str = \"\",\n    entered_by: str = \"\",\n    checked_by: str = \"\",\n    checked_date: date | None = None,\n    conditions: Conditions = Conditions(),\n    acceptance_criteria: AcceptanceCriteria = AcceptanceCriteria(),\n    cvd_equations: tuple[CVDEquation, ...] = (),\n    deserialisers: tuple[Deserialised, ...] = (),\n    equations: tuple[Equation, ...] = (),\n    files: tuple[File, ...] = (),\n    tables: tuple[Table, ...] = (),\n)\n</code></pre> <p>Represents the report element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The report identification number.</p> required <code>report_issue_date</code> <code>date</code> <p>The date that the report was issued.</p> required <code>measurement_start_date</code> <code>date</code> <p>The date that the calibration measurement started.</p> required <code>measurement_stop_date</code> <code>date</code> <p>The date that the calibration measurement stopped.</p> required <code>issuing_laboratory</code> <code>IssuingLaboratory</code> <p>Information about the laboratory that issued the calibration report.</p> <code>IssuingLaboratory()</code> <code>technical_procedure</code> <code>str</code> <p>The technical procedure(s) that was(were) followed to perform the calibration.</p> <code>''</code> <code>entered_by</code> <code>str</code> <p>The name of the person who initially entered the <code>&lt;report&gt;</code> element in the register.</p> <code>''</code> <code>checked_by</code> <code>str</code> <p>The name of the person who checked the information in the <code>&lt;report&gt;</code> element.</p> <code>''</code> <code>checked_date</code> <code>date | None</code> <p>The date that the information in the <code>&lt;report&gt;</code> element was last checked.</p> <code>None</code> <code>conditions</code> <code>Conditions</code> <p>The conditions under which the report is valid.</p> <code>Conditions()</code> <code>acceptance_criteria</code> <code>AcceptanceCriteria</code> <p>Acceptance criteria for the calibration report.</p> <code>AcceptanceCriteria()</code> <code>cvd_equations</code> <code>tuple[CVDEquation, ...]</code> <p>Calibration data is expressed as Callendar-Van Dusen equations.</p> <code>()</code> <code>deserialisers</code> <code>tuple[Deserialised, ...]</code> <p>Calibration data is stored in serialised formats and deserialised.</p> <code>()</code> <code>equations</code> <code>tuple[Equation, ...]</code> <p>Calibration data is expressed as equations.</p> <code>()</code> <code>files</code> <code>tuple[File, ...]</code> <p>Calibration data is stored in other files (not in the equipment register).</p> <code>()</code> <code>tables</code> <code>tuple[Table, ...]</code> <p>Calibration data is stored as Comma Separated Values (CSV) tables.</p> <code>()</code>"},{"location":"schema/report/#msl.equipment.schema.Report.acceptance_criteria","title":"acceptance_criteria  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acceptance_criteria: AcceptanceCriteria = field(\n    default_factory=AcceptanceCriteria\n)\n</code></pre> <p>Acceptance criteria for the calibration report.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.checked_by","title":"checked_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_by: str = ''\n</code></pre> <p>The name of the person who checked the information in the <code>&lt;report&gt;</code> element.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.checked_date","title":"checked_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_date: date | None = None\n</code></pre> <p>The date that the information in the <code>&lt;report&gt;</code> element was last checked.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.conditions","title":"conditions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>conditions: Conditions = field(default_factory=Conditions)\n</code></pre> <p>The conditions under which the report is valid.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.cvd_equation","title":"cvd_equation  <code>property</code>","text":"<pre><code>cvd_equation: CVDEquation\n</code></pre> <p>Returns the first item in the cvd_equations tuple.</p> <p>Raises IndexError if the report does not contain Callendar-Van Dusen equations.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.cvd_equations","title":"cvd_equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cvd_equations: tuple[CVDEquation, ...] = ()\n</code></pre> <p>Calibration data is expressed as Callendar-Van Dusen equations.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.deserialised","title":"deserialised  <code>property</code>","text":"<pre><code>deserialised: Deserialised\n</code></pre> <p>Returns the first item in the deserialisers tuple.</p> <p>Raises IndexError if the report does not contain serialised data.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.deserialisers","title":"deserialisers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>deserialisers: tuple[Deserialised, ...] = ()\n</code></pre> <p>Calibration data is stored in serialised formats and deserialised.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.entered_by","title":"entered_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entered_by: str = ''\n</code></pre> <p>The name of the person who initially entered the <code>&lt;report&gt;</code> element in the register.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.equation","title":"equation  <code>property</code>","text":"<pre><code>equation: Equation\n</code></pre> <p>Returns the first item in the equations tuple.</p> <p>Raises IndexError if the report does not contain equations.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.equations","title":"equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>equations: tuple[Equation, ...] = ()\n</code></pre> <p>Calibration data is expressed as equations.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.file","title":"file  <code>property</code>","text":"<pre><code>file: File\n</code></pre> <p>Returns the first item in the files tuple.</p> <p>Raises IndexError if the report does not contain files.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.files","title":"files  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>files: tuple[File, ...] = ()\n</code></pre> <p>Calibration data is stored in other files (not in the equipment register).</p>"},{"location":"schema/report/#msl.equipment.schema.Report.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>The report identification number.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.issuing_laboratory","title":"issuing_laboratory  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>issuing_laboratory: IssuingLaboratory = field(\n    default_factory=IssuingLaboratory\n)\n</code></pre> <p>Information about the laboratory that issued the calibration report.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.measurement_start_date","title":"measurement_start_date  <code>instance-attribute</code>","text":"<pre><code>measurement_start_date: date\n</code></pre> <p>The date that the calibration measurement started.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.measurement_stop_date","title":"measurement_stop_date  <code>instance-attribute</code>","text":"<pre><code>measurement_stop_date: date\n</code></pre> <p>The date that the calibration measurement stopped.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.report_issue_date","title":"report_issue_date  <code>instance-attribute</code>","text":"<pre><code>report_issue_date: date\n</code></pre> <p>The date that the report was issued.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.table","title":"table  <code>property</code>","text":"<pre><code>table: Table\n</code></pre> <p>Returns the first item in the tables tuple.</p> <p>Raises IndexError if the report does not contain tables.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.tables","title":"tables  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tables: tuple[Table, ...] = ()\n</code></pre> <p>Calibration data is stored as Comma Separated Values (CSV) tables.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.technical_procedure","title":"technical_procedure  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>technical_procedure: str = ''\n</code></pre> <p>The technical procedure(s) that was(were) followed to perform the calibration.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Report\n</code></pre> <p>Convert an XML element into a Report instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A report XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Report</code> <p>The Report instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Report:\n    \"\"\"Convert an XML element into a [Report][msl.equipment.schema.Report] instance.\n\n    Args:\n        element: A [report][type_report] XML element from an equipment register.\n\n    Returns:\n        The [Report][msl.equipment.schema.Report] instance.\n    \"\"\"\n    # Schema forces order until `acceptanceCriteria` and then uses xsd:choice, which\n    # allows sub-elements to appear (or not appear) in any order, for the data elements.\n    # Using str.endswith() allows for ignoring XML namespaces that may be associated with each tag\n    cvd_equations: list[CVDEquation] = []\n    deserialisers: list[Deserialised] = []\n    equations: list[Equation] = []\n    files: list[File] = []\n    tables: list[Table] = []\n    for child in element[7:]:\n        tag = child.tag\n        if tag.endswith(\"equation\"):\n            equations.append(Equation.from_xml(child))\n        elif tag.endswith(\"table\"):\n            tables.append(Table.from_xml(child))\n        elif tag.endswith(\"cvdCoefficients\"):\n            cvd_equations.append(CVDEquation.from_xml(child))\n        elif tag.endswith(\"file\"):\n            files.append(File.from_xml(child))\n        else:\n            deserialisers.append(Deserialised.from_xml(child))\n\n    a = element.attrib\n    return cls(\n        id=a[\"id\"] or \"\",\n        entered_by=a[\"enteredBy\"] or \"\",\n        checked_by=a.get(\"checkedBy\", \"\"),\n        checked_date=None if not a.get(\"checkedDate\") else _date.fromisoformat(a[\"checkedDate\"]),\n        report_issue_date=_date.fromisoformat(element[0].text or \"\"),\n        measurement_start_date=_date.fromisoformat(element[1].text or \"\"),\n        measurement_stop_date=_date.fromisoformat(element[2].text or \"\"),\n        issuing_laboratory=IssuingLaboratory.from_xml(element[3]),\n        technical_procedure=element[4].text or \"\",\n        conditions=Conditions.from_xml(element[5]),\n        acceptance_criteria=AcceptanceCriteria.from_xml(element[6]),\n        cvd_equations=tuple(cvd_equations),\n        deserialisers=tuple(deserialisers),\n        equations=tuple(equations),\n        files=tuple(files),\n        tables=tuple(tables),\n    )\n</code></pre>"},{"location":"schema/report/#msl.equipment.schema.Report.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Report class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Report as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Report][msl.equipment.schema.Report] class into an XML element.\n\n    Returns:\n        The [Report][msl.equipment.schema.Report] as an XML element.\n    \"\"\"\n    a = {\"id\": self.id, \"enteredBy\": self.entered_by}\n    if self.checked_by:\n        a[\"checkedBy\"] = self.checked_by\n    if self.checked_date is not None:\n        a[\"checkedDate\"] = self.checked_date.isoformat()\n\n    e = Element(\"report\", attrib=a)\n\n    rid = SubElement(e, \"reportIssueDate\")\n    rid.text = self.report_issue_date.isoformat()\n\n    start = SubElement(e, \"measurementStartDate\")\n    start.text = self.measurement_start_date.isoformat()\n\n    stop = SubElement(e, \"measurementStopDate\")\n    stop.text = self.measurement_stop_date.isoformat()\n\n    e.append(self.issuing_laboratory.to_xml())\n\n    tp = SubElement(e, \"technicalProcedure\")\n    tp.text = self.technical_procedure\n\n    e.append(self.conditions)\n    e.append(self.acceptance_criteria)\n    e.extend(equation.to_xml() for equation in self.equations)\n    e.extend(table.to_xml() for table in self.tables)\n    e.extend(cvd.to_xml() for cvd in self.cvd_equations)\n    e.extend(file.to_xml() for file in self.files)\n    e.extend(deserialised.to_xml() for deserialised in self.deserialisers)\n    return e\n</code></pre>"},{"location":"schema/report/#msl.equipment.schema.IssuingLaboratory","title":"IssuingLaboratory  <code>dataclass</code>","text":"<pre><code>IssuingLaboratory(lab: str = '', person: str = '')\n</code></pre> <p>Information about the laboratory that issued a calibration report.</p> <p>Parameters:</p> Name Type Description Default <code>lab</code> <code>str</code> <p>The name of the laboratory that issued the calibration report.</p> <code>''</code> <code>person</code> <code>str</code> <p>The name of a person at the <code>laboratory</code> that authorised the report.</p> <code>''</code>"},{"location":"schema/report/#msl.equipment.schema.IssuingLaboratory.lab","title":"lab  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lab: str = ''\n</code></pre> <p>The name of the laboratory that issued the calibration report.</p>"},{"location":"schema/report/#msl.equipment.schema.IssuingLaboratory.person","title":"person  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>person: str = ''\n</code></pre> <p>The name of a person at the laboratory that authorised the report.</p>"},{"location":"schema/report/#msl.equipment.schema.IssuingLaboratory.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; IssuingLaboratory\n</code></pre> <p>Convert an XML element into a IssuingLaboratory instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An <code>&lt;issuingLaboratory&gt;</code> element from a report element in an equipment register.</p> required <p>Returns:</p> Type Description <code>IssuingLaboratory</code> <p>The IssuingLaboratory instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; IssuingLaboratory:\n    \"\"\"Convert an XML element into a [IssuingLaboratory][msl.equipment.schema.IssuingLaboratory] instance.\n\n    Args:\n        element: An `&lt;issuingLaboratory&gt;` element from a [report][type_report] element\n            in an equipment register.\n\n    Returns:\n        The [IssuingLaboratory][msl.equipment.schema.IssuingLaboratory] instance.\n    \"\"\"\n    return cls(\n        lab=element.text or \"\",\n        person=element.attrib.get(\"person\", \"\"),\n    )\n</code></pre>"},{"location":"schema/report/#msl.equipment.schema.IssuingLaboratory.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the IssuingLaboratory class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The IssuingLaboratory as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [IssuingLaboratory][msl.equipment.schema.IssuingLaboratory] class into an XML element.\n\n    Returns:\n        The [IssuingLaboratory][msl.equipment.schema.IssuingLaboratory] as an XML element.\n    \"\"\"\n    a = {\"person\": self.person} if self.person else {}\n    e = Element(\"issuingLaboratory\", attrib=a)\n    e.text = self.lab\n    return e\n</code></pre>"},{"location":"schema/specifications/","title":"Specifications","text":""},{"location":"schema/specifications/#msl.equipment.schema.Specifications","title":"Specifications","text":"<pre><code>Specifications(**attributes: str)\n</code></pre> <p>               Bases: <code>Any</code></p> <p>Specifications provided by the manufacturer of the equipment.</p> <p>Typically, the specifications are specified on the website, datasheet and/or technical notes that a manufacturer provides.</p> <p>Since this class is currently represented by the any type in the XML Schema Definition, it is simply a subclass of Element. It may be updated to be a more specific class at a later date.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any] type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/specifications/#msl.equipment.schema.Specifications.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str = 'specifications'\n</code></pre> <p>The element's name.</p>"},{"location":"schema/specifications/#msl.equipment.schema.Specifications.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/specified_requirements/","title":"SpecifiedRequirements","text":""},{"location":"schema/specified_requirements/#msl.equipment.schema.SpecifiedRequirements","title":"SpecifiedRequirements","text":"<pre><code>SpecifiedRequirements(**attributes: str)\n</code></pre> <p>               Bases: <code>Any</code></p> <p>Verification that equipment conforms with specified requirements before being placed or returned into service.</p> <p>Since this class is currently represented by the any type in the XML Schema Definition, it is simply a subclass of Element. It may be updated to be a more specific class at a later date.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any] type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/specified_requirements/#msl.equipment.schema.SpecifiedRequirements.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str = 'specifiedRequirements'\n</code></pre> <p>The element's name.</p>"},{"location":"schema/specified_requirements/#msl.equipment.schema.SpecifiedRequirements.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/status/","title":"Status","text":""},{"location":"schema/status/#msl.equipment.schema.Status","title":"Status","text":"<p>               Bases: <code>Enum</code></p> <p>Represents the status enumeration in an equipment register.</p> <p>Attributes:</p> Name Type Description <code>Active</code> <code>str</code> <p>The equipment is operable and may be used.</p> <code>Damaged</code> <code>str</code> <p>The equipment is damaged and is no longer usable.</p> <code>Disposed</code> <code>str</code> <p>The equipment has been disposed of and is no longer at available (e.g., the equipment was sent to the landfill or to be recycled).</p> <code>Dormant</code> <code>str</code> <p>The equipment is still operable, it is no longer in use but may be used again (e.g., the equipment was replaced with a newer model, and it is kept as a backup).</p> <code>Lost</code> <code>str</code> <p>The equipment is lost, but if found may be put back into service.</p> <code>Retired</code> <code>str</code> <p>The equipment is still operable, but there are no intentions of using it again (e.g., the equipment depends on other equipment that is not available or is no longer manufactured).</p>"},{"location":"schema/table/","title":"Table","text":"<p>Suppose you have a variable named <code>table</code> (which is an instance of Table) that represents the following information in an equipment register for equipment that measures spectral irradiance</p> <pre><code>&lt;table comment=\"Spectral\"&gt;\n  &lt;type&gt;   int       ,    double ,    double     &lt;/type&gt;\n  &lt;unit&gt;   nm        ,    W/m^2  ,    W/m^2      &lt;/unit&gt;\n  &lt;header&gt; Wavelength, Irradiance, u(Irradiance) &lt;/header&gt;\n  &lt;data&gt;   250       ,    0.01818,   0.02033\n           300       ,    0.18478,   0.01755\n           350       ,    0.80845,   0.01606\n           400       ,    2.21355,   0.01405\n           450       ,    4.49004,   0.01250\n           500       ,    7.45135,   0.01200\n           550       ,   10.75753,   0.01152\n           600       ,   14.03809,   0.01102\n           650       ,   16.99469,   0.01103\n           700       ,   19.44093,   0.01077\n  &lt;/data&gt;\n&lt;/table&gt;\n</code></pre> <p>The <code>table</code> instance is a numpy structured array that has the header values as the field name of each column</p> <pre><code>&gt;&gt;&gt; table.header\narray(['Wavelength', 'Irradiance', 'u(Irradiance)'], dtype='&lt;U13')\n&gt;&gt;&gt; table[\"Wavelength\"]\nTable([250, 300, 350, 400, 450, 500, 550, 600, 650, 700])\n&gt;&gt;&gt; table.types[\"Irradiance\"]\narray(dtype('float64'), dtype=object)\n&gt;&gt;&gt; assert table.units[\"u(Irradiance)\"] == \"W/m^2\"\n</code></pre> <p>Since <code>table</code> is a numpy array, you can index it</p> <pre><code>&gt;&gt;&gt; print(table[0])\n(250, 0.01818, 0.02033)\n&gt;&gt;&gt; sliced=table[:3]\n&gt;&gt;&gt; print(sliced)\n[(250, 0.01818, 0.02033) (300, 0.18478, 0.01755) (350, 0.80845, 0.01606)]\n</code></pre> <p>and since <code>sliced</code> is another Table instance, the attributes of the original <code>table</code> are available</p> <pre><code>&gt;&gt;&gt; sliced.comment\n'Spectral'\n&gt;&gt;&gt; sliced.header\narray(['Wavelength', 'Irradiance', 'u(Irradiance)'], dtype='&lt;U13')\n</code></pre> <p>You can also perform mathematical operations and call numpy functions directly with the <code>table</code> instance</p> <pre><code>&gt;&gt;&gt; np.cos(1 + table[\"Irradiance\"])\nTable([ 0.52491592,  0.37650087, -0.2354229 , -0.99741219,  0.70160756,\n       -0.56246854,  0.6903377 , -0.78390036,  0.65631968, -0.0205763 ])\n</code></pre> <p>Suppose you wanted to get all Irradiance values in the table that are for UV light (i.e., wavelengths &lt; 400 nm)</p> <pre><code>&gt;&gt;&gt; table[\"Irradiance\"][ table[\"Wavelength\"] &lt; 400 ]\nTable([0.01818, 0.18478, 0.80845])\n</code></pre> <p>If you prefer to work with unstructured data, you can convert the <code>table</code> by calling the unstructured method</p> <pre><code>&gt;&gt;&gt; unstructured = table.unstructured()\n&gt;&gt;&gt; unstructured\nTable([[2.500000e+02, 1.818000e-02, 2.033000e-02],\n       [3.000000e+02, 1.847800e-01, 1.755000e-02],\n       [3.500000e+02, 8.084500e-01, 1.606000e-02],\n       [4.000000e+02, 2.213550e+00, 1.405000e-02],\n       [4.500000e+02, 4.490040e+00, 1.250000e-02],\n       [5.000000e+02, 7.451350e+00, 1.200000e-02],\n       [5.500000e+02, 1.075753e+01, 1.152000e-02],\n       [6.000000e+02, 1.403809e+01, 1.102000e-02],\n       [6.500000e+02, 1.699469e+01, 1.103000e-02],\n       [7.000000e+02, 1.944093e+01, 1.077000e-02]])\n&gt;&gt;&gt; print(unstructured[0, 0])\n250.0\n</code></pre>"},{"location":"schema/table/#msl.equipment.schema.Table","title":"Table","text":"<p>               Bases: <code>ndarray</code></p> <p>Represents the table element in an equipment register.</p>"},{"location":"schema/table/#msl.equipment.schema.Table.comment","title":"comment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comment: str = ''\n</code></pre> <p>A comment that is associated with the table.</p>"},{"location":"schema/table/#msl.equipment.schema.Table.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header: NDArray[void] = empty(0, dtype=object)\n</code></pre> <p>The header value of each column.</p>"},{"location":"schema/table/#msl.equipment.schema.Table.types","title":"types  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>types: NDArray[void] = empty(0, dtype=object)\n</code></pre> <p>The data type of each column.</p>"},{"location":"schema/table/#msl.equipment.schema.Table.units","title":"units  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>units: NDArray[void] = empty(0, dtype=object)\n</code></pre> <p>The unit of each column.</p>"},{"location":"schema/table/#msl.equipment.schema.Table.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Table\n</code></pre> <p>Convert an XML element into a Table instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A table XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Table</code> <p>A Table is an subclass of a numpy structured array, where the <code>header</code> is used as the field names. This allows for accessing a column by the header value rather than by the index of a column. If you prefer to work with unstructured data, call unstructured on the returned object.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Table:\n    \"\"\"Convert an XML element into a [Table][msl.equipment.schema.Table] instance.\n\n    Args:\n        element: A [table][type_table] XML element from an equipment register.\n\n    Returns:\n        A [Table][msl.equipment.schema.Table] is an subclass of a numpy\n            [structured array][structured_arrays], where the `header` is used as\n            the *field names*. This allows for accessing a column by the header value rather than by\n            the index of a column. If you prefer to work with unstructured data, call\n            [unstructured][msl.equipment.schema.Table.unstructured] on the returned object.\n    \"\"\"\n    booleans = {\"True\", \"true\", \"TRUE\", \"1\", b\"True\", b\"true\", b\"TRUE\", b\"1\"}\n\n    def convert_bool(value: str | bytes) -&gt; bool:\n        # the value can be of type bytes for numpy &lt; 2.0\n        return value.strip() in booleans\n\n    def strip_string(value: str | bytes) -&gt; str:\n        # the value can be of type bytes for numpy &lt; 2.0\n        stripped = value.strip()\n        if isinstance(stripped, bytes):\n            return stripped.decode()  # pragma: no cover\n        return stripped\n\n    # Schema forces order\n    _type = [s.strip() for s in (element[0].text or \"\").split(\",\")]\n    _unit = [s.strip() for s in (element[1].text or \"\").split(\",\")]\n    _header = [s.strip() for s in (element[2].text or \"\").split(\",\")]\n    _file = StringIO((element[3].text or \"\").strip())\n\n    # must handle boolean column and string column separately\n    conv: dict[int, Callable[[str | bytes], str | bool]] = {\n        i: convert_bool for i, v in enumerate(_type) if v == \"bool\"\n    }\n    conv.update({i: strip_string for i, v in enumerate(_type) if v == \"string\"})\n\n    dtype = np.dtype([(h, schema_numpy_map[t]) for h, t in zip(_header, _type)])\n    data = np.loadtxt(_file, dtype=dtype, delimiter=\",\", converters=conv)  # type: ignore[arg-type]  # pyright: ignore[reportCallIssue, reportArgumentType, reportUnknownVariableType]\n    data.setflags(write=False)  # pyright: ignore[reportUnknownMemberType]\n\n    header = np.asarray(_header)\n    header.setflags(write=False)  # make it readonly by default\n\n    units = np.asarray(tuple(_unit), np.dtype([(h, object) for h in _header]))\n    units.setflags(write=False)  # make it readonly by default\n\n    assert data.dtype.fields is not None  # pyright: ignore[reportUnknownMemberType]  # noqa: S101\n    types = np.asarray(tuple(v[0] for v in data.dtype.fields.values()), dtype=[(h, object) for h in _header])  # pyright: ignore[reportUnknownMemberType, reportUnknownVariableType, reportUnknownArgumentType]\n    types.setflags(write=False)  # make it readonly by default\n\n    return cls(types=types, units=units, header=header, data=data, comment=element.attrib.get(\"comment\", \"\"))  # pyright: ignore[reportUnknownArgumentType]\n</code></pre>"},{"location":"schema/table/#msl.equipment.schema.Table.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Table class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Table as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Table][msl.equipment.schema.Table] class into an XML element.\n\n    Returns:\n        The [Table][msl.equipment.schema.Table] as an XML element.\n    \"\"\"\n    attrib = {\"comment\": self.comment} if self.comment else {}\n    e = Element(\"table\", attrib=attrib)\n\n    types = SubElement(e, \"type\")\n    dtypes = [numpy_schema_map[t.char] for t in self.types.tolist()]\n    types.text = \",\".join(dtypes)\n\n    units = SubElement(e, \"unit\")\n    units.text = \",\".join(self.units.tolist())\n\n    header = SubElement(e, \"header\")\n    header.text = \",\".join(self.header)\n\n    buffer = StringIO()\n    newline = \"\\n\" + \" \" * _Indent.table_data\n    np.savetxt(buffer, self, fmt=\"%s\", delimiter=\",\", newline=newline)\n    data = SubElement(e, \"data\")\n    data.text = buffer.getvalue().rstrip() + \"\\n\" + \" \" * max(0, _Indent.table_data - len(\"&lt;data&gt;\"))\n\n    return e\n</code></pre>"},{"location":"schema/table/#msl.equipment.schema.Table.unstructured","title":"unstructured","text":"<pre><code>unstructured(\n    *,\n    dtype: DTypeLike = None,\n    copy: bool = False,\n    casting: Literal[\n        \"no\", \"equiv\", \"safe\", \"same_kind\", \"unsafe\"\n    ] = \"unsafe\"\n) -&gt; NDArray[Any]\n</code></pre> <p>Converts the structured array into an unstructured array.</p> <p>See structured_to_unstructured for more details.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>DTypeLike</code> <p>The dtype of the output unstructured array.</p> <code>None</code> <code>copy</code> <code>bool</code> <p>If <code>True</code>, always return a copy. If <code>False</code>, a view is returned if possible.</p> <code>False</code> <code>casting</code> <code>Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe']</code> <p>Controls what kind of data casting may occur. See the casting argument of astype for more details.</p> <code>'unsafe'</code> <p>Returns:</p> Type Description <code>NDArray[Any]</code> <p>The unstructured array. This method may return a numpy ndarray instance instead of a Table instance if the table consists of numbers and strings and the appropriate <code>dtype</code> is not specified.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def unstructured(\n    self,\n    *,\n    dtype: DTypeLike = None,\n    copy: bool = False,\n    casting: Literal[\"no\", \"equiv\", \"safe\", \"same_kind\", \"unsafe\"] = \"unsafe\",\n) -&gt; NDArray[_Any]:\n    \"\"\"Converts the structured array into an unstructured array.\n\n    See [structured_to_unstructured][numpy.lib.recfunctions.structured_to_unstructured]\n    for more details.\n\n    Args:\n        dtype: The _dtype_ of the output unstructured array.\n        copy: If `True`, always return a copy. If `False`, a view is returned if possible.\n        casting: Controls what kind of data casting may occur. See the *casting* argument of\n            [astype][numpy.ndarray.astype] for more details.\n\n    Returns:\n        The unstructured array. This method may return a numpy [ndarray][numpy.ndarray] instance\n            instead of a [Table][msl.equipment.schema.Table] instance if the table consists of\n            numbers and strings and the appropriate `dtype` is not specified.\n    \"\"\"\n    from numpy.lib.recfunctions import structured_to_unstructured  # noqa: PLC0415\n\n    try:\n        return structured_to_unstructured(self, dtype=dtype, copy=copy, casting=casting)\n    except (TypeError, ValueError):\n        return np.array(self.tolist(), dtype=object)\n</code></pre>"}]}