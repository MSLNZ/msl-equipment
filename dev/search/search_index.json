{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Info</p> <p>The docs are being rewritten. See here for the old docs.</p> <p>The purpose of <code>msl-equipment</code> is to manage information about equipment and to interface with equipment for computer control. The information that is managed is focused on testing and calibration laboratories that are accredited for the ISO/IEC 17025 standard.</p>"},{"location":"license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2017 - 2025, Measurement Standards Laboratory of New Zealand\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#020-2025-03-28","title":"0.2.0 (2025-03-28)","text":"<p>Added:</p> <ul> <li>support for Python 3.12 and 3.13</li> <li><code>find-equipment</code> console script</li> <li><code>msl.equipment.connection_gpib.ConnectionGPIB</code> class</li> <li><code>msl.equipment.resources.greisinger.gmh3000.GMH3000</code> resource</li> <li><code>msl.equipment.resources.isotech.millik.MilliK</code> resource</li> <li><code>msl.equipment.resources.vaisala.ptu300.PTU300</code> resource</li> <li><code>msl.equipment.resources.vaisala.ptb330.PTB330</code> resource</li> </ul> <p>Fixed:</p> <ul> <li>issue #9 \u2014 Missing functions from Avantes AvaSpec DLL</li> <li>issue #8 \u2014 Invalid URL for LXI XML identification document</li> </ul> <p>Removed:</p> <ul> <li>support for Python 2.7, 3.5, 3.6 and 3.7</li> </ul>"},{"location":"release-notes/#010-2023-06-18","title":"0.1.0 (2023-06-18)","text":"<p>Initial release.</p> <p>It is also the last release to support Python 2.7, 3.5, 3.6 and 3.7</p>"},{"location":"schema/","title":"Schema Classes","text":"<p>Class representations of the XML Schema Definition for an equipment register.</p> <p>The primary class is Register which contains a sequence of Equipment classes that are each composed of the following classes:</p> <ul> <li>AcceptanceCriteria</li> <li>Accessories</li> <li>Adjustment</li> <li>Alteration</li> <li>Component</li> <li>Competency</li> <li>CompletedTask</li> <li>Conditions</li> <li>CVDEquation (Callendar-Van Dusen equation, uses the cvdCoefficients)</li> <li>Deserialised (opposite of serialised)</li> <li>DigitalReport</li> <li>Equation</li> <li>File</li> <li>Financial</li> <li>Firmware</li> <li>Maintenance</li> <li>Measurand</li> <li>PerformanceCheck</li> <li>PlannedTask</li> <li>QualityManual</li> <li>ReferenceMaterials</li> <li>Report</li> <li>Specifications</li> <li>SpecifiedRequirements</li> <li>Status</li> <li>Table</li> </ul> <p>The Any class is used as a base class for elements that are currently represented by the any type in the XML Schema Definition.</p>"},{"location":"schema/acceptance_criteria/","title":"AcceptanceCriteria","text":""},{"location":"schema/acceptance_criteria/#msl.equipment.schema.AcceptanceCriteria","title":"AcceptanceCriteria","text":"<pre><code>AcceptanceCriteria(**attributes: str)\n</code></pre> <p>               Bases: <code>Any</code></p> <p>Represents the acceptance criteria in a calibration report.</p> <p>Since this class is currently represented by the any type in the XML Schema Definition, it is simply a subclass of Element. It may be updated to be a more specific class at a later date.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any]{:target=\"_blank\"} type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/acceptance_criteria/#msl.equipment.schema.AcceptanceCriteria.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str = 'acceptanceCriteria'\n</code></pre> <p>The element's name.</p>"},{"location":"schema/acceptance_criteria/#msl.equipment.schema.AcceptanceCriteria.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/accessories/","title":"Accessories","text":""},{"location":"schema/accessories/#msl.equipment.schema.Accessories","title":"Accessories","text":"<pre><code>Accessories(**attributes: str)\n</code></pre> <p>               Bases: <code>Any</code></p> <p>Additional accessories that may be required to use the equipment.</p> <p>Since this class is currently represented by the any type in the XML Schema Definition, it is simply a subclass of Element. It may be updated to be a more specific class at a later date.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any]{:target=\"_blank\"} type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/accessories/#msl.equipment.schema.Accessories.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str = 'accessories'\n</code></pre> <p>The element's name.</p>"},{"location":"schema/accessories/#msl.equipment.schema.Accessories.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/adjustment/","title":"Adjustment","text":""},{"location":"schema/adjustment/#msl.equipment.schema.Adjustment","title":"Adjustment  <code>dataclass</code>","text":"<pre><code>Adjustment(details: str, date: date)\n</code></pre> <p>An adjustment of the equipment.</p> <p>An example of an adjustment is cleaning the equipment (e.g., a spectral filter) and then performing another calibration measurement.</p> <p>This XML element is found in component.</p> <p>Parameters:</p> Name Type Description Default <code>details</code> <code>str</code> <p>The details of the adjustment that was performed.</p> required <code>date</code> <code>date</code> <p>The date that the adjustment was performed.</p> required"},{"location":"schema/adjustment/#msl.equipment.schema.Adjustment.date","title":"date  <code>instance-attribute</code>","text":"<pre><code>date: date\n</code></pre> <p>The date that the adjustment was performed.</p>"},{"location":"schema/adjustment/#msl.equipment.schema.Adjustment.details","title":"details  <code>instance-attribute</code>","text":"<pre><code>details: str\n</code></pre> <p>The details of the adjustment that was performed.</p>"},{"location":"schema/adjustment/#msl.equipment.schema.Adjustment.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Adjustment\n</code></pre> <p>Convert an XML element into a Adjustment instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An <code>&lt;adjustment&gt;</code> XML element from an equipment register (see component).</p> required <p>Returns:</p> Type Description <code>Adjustment</code> <p>The Adjustment instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Adjustment:\n    \"\"\"Convert an XML element into a [Adjustment][msl.equipment.schema.Adjustment] instance.\n\n    Args:\n        element: An `&lt;adjustment&gt;` XML element from an equipment register\n            (see [component][type_component]{:target=\"_blank\"}).\n\n    Returns:\n        The [Adjustment][msl.equipment.schema.Adjustment] instance.\n    \"\"\"\n    return cls(details=element.text or \"\", date=_date.fromisoformat(element.attrib[\"date\"]))\n</code></pre>"},{"location":"schema/adjustment/#msl.equipment.schema.Adjustment.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Adjustment class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Adjustment as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Adjustment][msl.equipment.schema.Adjustment] class into an XML element.\n\n    Returns:\n        The [Adjustment][msl.equipment.schema.Adjustment] as an XML element.\n    \"\"\"\n    e = Element(\"adjustment\", attrib={\"date\": self.date.isoformat()})\n    e.text = self.details\n    return e\n</code></pre>"},{"location":"schema/alteration/","title":"Alteration","text":""},{"location":"schema/alteration/#msl.equipment.schema.Alteration","title":"Alteration  <code>dataclass</code>","text":"<pre><code>Alteration(date: date, details: str, performed_by: str)\n</code></pre> <p>Represents the alteration element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>date</code> <p>The date that the alteration was performed.</p> required <code>details</code> <code>str</code> <p>The details of the alteration.</p> required <code>performed_by</code> <code>str</code> <p>The person or company that performed the alteration.</p> required"},{"location":"schema/alteration/#msl.equipment.schema.Alteration.date","title":"date  <code>instance-attribute</code>","text":"<pre><code>date: date\n</code></pre> <p>The date that the alteration was performed.</p>"},{"location":"schema/alteration/#msl.equipment.schema.Alteration.details","title":"details  <code>instance-attribute</code>","text":"<pre><code>details: str\n</code></pre> <p>The details of the alteration.</p>"},{"location":"schema/alteration/#msl.equipment.schema.Alteration.performed_by","title":"performed_by  <code>instance-attribute</code>","text":"<pre><code>performed_by: str\n</code></pre> <p>The person or company that performed the alteration.</p>"},{"location":"schema/alteration/#msl.equipment.schema.Alteration.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Alteration\n</code></pre> <p>Convert an XML element into an Alteration instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An alteration XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Alteration</code> <p>The Alteration instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Alteration:\n    \"\"\"Convert an XML element into an [Alteration][msl.equipment.schema.Alteration] instance.\n\n    Args:\n        element: An [alteration][type_alteration]{:target=\"_blank\"} XML element from an equipment register.\n\n    Returns:\n        The [Alteration][msl.equipment.schema.Alteration] instance.\n    \"\"\"\n    return cls(\n        date=_date.fromisoformat(element.attrib[\"date\"]),\n        details=element.text or \"\",\n        performed_by=element.attrib[\"performedBy\"],\n    )\n</code></pre>"},{"location":"schema/alteration/#msl.equipment.schema.Alteration.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Alteration class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Alteration as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Alteration][msl.equipment.schema.Alteration] class into an XML element.\n\n    Returns:\n        The [Alteration][msl.equipment.schema.Alteration] as an XML element.\n    \"\"\"\n    e = Element(\"alteration\", attrib={\"date\": self.date.isoformat(), \"performedBy\": self.performed_by})\n    e.text = self.details\n    return e\n</code></pre>"},{"location":"schema/any/","title":"Any","text":""},{"location":"schema/any/#msl.equipment.schema.Any","title":"Any","text":"<pre><code>Any(**attributes: str)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Base class that represents the any type in the XML Schema Definition.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any]{:target=\"_blank\"} type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/any/#msl.equipment.schema.Any.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/competency/","title":"Competency","text":""},{"location":"schema/competency/#msl.equipment.schema.Competency","title":"Competency  <code>dataclass</code>","text":"<pre><code>Competency(\n    worker: str, checker: str, technical_procedure: str\n)\n</code></pre> <p>Represents the competency element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>worker</code> <code>str</code> <p>The competent person who executed the technical procedure to accomplish the performance check.</p> required <code>checker</code> <code>str</code> <p>The competent person who reviewed the work done by the <code>worker</code>.</p> required <code>technical_procedure</code> <code>str</code> <p>The technical procedure that was executed to accomplish the performance check.</p> required"},{"location":"schema/competency/#msl.equipment.schema.Competency.checker","title":"checker  <code>instance-attribute</code>","text":"<pre><code>checker: str\n</code></pre> <p>The competent person who reviewed the work done by the <code>worker</code>.</p>"},{"location":"schema/competency/#msl.equipment.schema.Competency.technical_procedure","title":"technical_procedure  <code>instance-attribute</code>","text":"<pre><code>technical_procedure: str\n</code></pre> <p>The technical procedure that was executed to accomplish the performance check.</p>"},{"location":"schema/competency/#msl.equipment.schema.Competency.worker","title":"worker  <code>instance-attribute</code>","text":"<pre><code>worker: str\n</code></pre> <p>The competent person who executed the technical procedure to accomplish the performance check.</p>"},{"location":"schema/competency/#msl.equipment.schema.Competency.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Competency\n</code></pre> <p>Convert an XML element into a Competency instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A competency XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Competency</code> <p>The Competency instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Competency:\n    \"\"\"Convert an XML element into a [Competency][msl.equipment.schema.Competency] instance.\n\n    Args:\n        element: A [competency][type_competency]{:target=\"_blank\"} XML element from an equipment register.\n\n    Returns:\n        The [Competency][msl.equipment.schema.Competency] instance.\n    \"\"\"\n    # Schema forces order\n    return cls(\n        worker=element[0].text or \"\",\n        checker=element[1].text or \"\",\n        technical_procedure=element[2].text or \"\",\n    )\n</code></pre>"},{"location":"schema/competency/#msl.equipment.schema.Competency.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Competency class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Competency as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Competency][msl.equipment.schema.Competency] class into an XML element.\n\n    Returns:\n        The [Competency][msl.equipment.schema.Competency] as an XML element.\n    \"\"\"\n    e = Element(\"competency\")\n    worker = SubElement(e, \"worker\")\n    worker.text = self.worker\n    checker = SubElement(e, \"checker\")\n    checker.text = self.checker\n    tp = SubElement(e, \"technicalProcedure\")\n    tp.text = self.technical_procedure\n    return e\n</code></pre>"},{"location":"schema/completed_task/","title":"CompletedTask","text":""},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask","title":"CompletedTask  <code>dataclass</code>","text":"<pre><code>CompletedTask(\n    task: str,\n    due_date: date,\n    performed_by: str,\n    completed_date: date,\n)\n</code></pre> <p>Represents the completedTask element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>str</code> <p>A description of the task that was completed.</p> required <code>due_date</code> <code>date</code> <p>The date that the maintenance task was due to be completed.</p> required <code>performed_by</code> <code>str</code> <p>The person or company that performed the maintenance task.</p> required <code>completed_date</code> <code>date</code> <p>The date that the maintenance task was completed.</p> required"},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask.completed_date","title":"completed_date  <code>instance-attribute</code>","text":"<pre><code>completed_date: date\n</code></pre> <p>The date that the maintenance task was completed.</p>"},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask.due_date","title":"due_date  <code>instance-attribute</code>","text":"<pre><code>due_date: date\n</code></pre> <p>The date that the maintenance task was due to be completed.</p>"},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask.performed_by","title":"performed_by  <code>instance-attribute</code>","text":"<pre><code>performed_by: str\n</code></pre> <p>The person or company that performed the maintenance task.</p>"},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask.task","title":"task  <code>instance-attribute</code>","text":"<pre><code>task: str\n</code></pre> <p>A description of the task that was completed.</p>"},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; CompletedTask\n</code></pre> <p>Convert an XML element into a CompletedTask instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A completedTask XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>CompletedTask</code> <p>The CompletedTask instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; CompletedTask:\n    \"\"\"Convert an XML element into a [CompletedTask][msl.equipment.schema.CompletedTask] instance.\n\n    Args:\n        element: A [completedTask][type_completedTask]{:target=\"_blank\"} XML element from an equipment register.\n\n    Returns:\n        The [CompletedTask][msl.equipment.schema.CompletedTask] instance.\n    \"\"\"\n    return cls(\n        task=element.text or \"\",\n        due_date=_date.fromisoformat(element.attrib[\"dueDate\"]),\n        performed_by=element.attrib[\"performedBy\"],\n        completed_date=_date.fromisoformat(element.attrib[\"completedDate\"]),\n    )\n</code></pre>"},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the CompletedTask class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The CompletedTask as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [CompletedTask][msl.equipment.schema.CompletedTask] class into an XML element.\n\n    Returns:\n        The [CompletedTask][msl.equipment.schema.CompletedTask] as an XML element.\n    \"\"\"\n    attrib = {\n        \"dueDate\": self.due_date.isoformat(),\n        \"completedDate\": self.completed_date.isoformat(),\n        \"performedBy\": self.performed_by,\n    }\n\n    e = Element(\"task\", attrib=attrib)\n    e.text = self.task\n    return e\n</code></pre>"},{"location":"schema/component/","title":"Component","text":""},{"location":"schema/component/#msl.equipment.schema.Component","title":"Component  <code>dataclass</code>","text":"<pre><code>Component(\n    name: str = \"\",\n    adjustments: tuple[Adjustment, ...] = (),\n    digital_reports: tuple[DigitalReport, ...] = (),\n    performance_checks: tuple[PerformanceCheck, ...] = (),\n    reports: tuple[Report, ...] = (),\n)\n</code></pre> <p>Represents the component element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name to associate with this component. The value must be unique amongst the other component elements within the same measurand element. An empty string is permitted.</p> <code>''</code> <code>adjustments</code> <code>tuple[Adjustment, ...]</code> <p>The history of adjustments.</p> <code>()</code> <code>digital_reports</code> <code>tuple[DigitalReport, ...]</code> <p>The history of digital calibration reports.</p> <code>()</code> <code>performance_checks</code> <code>tuple[PerformanceCheck, ...]</code> <p>The history of performance checks.</p> <code>()</code> <code>reports</code> <code>tuple[Report, ...]</code> <p>The history of calibration reports.</p> <code>()</code>"},{"location":"schema/component/#msl.equipment.schema.Component.adjustments","title":"adjustments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>adjustments: tuple[Adjustment, ...] = ()\n</code></pre> <p>The history of adjustments.</p>"},{"location":"schema/component/#msl.equipment.schema.Component.digital_reports","title":"digital_reports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>digital_reports: tuple[DigitalReport, ...] = ()\n</code></pre> <p>The history of digital calibration reports.</p>"},{"location":"schema/component/#msl.equipment.schema.Component.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = ''\n</code></pre> <p>The name associated with this component.</p>"},{"location":"schema/component/#msl.equipment.schema.Component.performance_checks","title":"performance_checks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performance_checks: tuple[PerformanceCheck, ...] = ()\n</code></pre> <p>The history of performance checks.</p>"},{"location":"schema/component/#msl.equipment.schema.Component.reports","title":"reports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reports: tuple[Report, ...] = ()\n</code></pre> <p>The history of calibration reports.</p>"},{"location":"schema/component/#msl.equipment.schema.Component.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Component\n</code></pre> <p>Convert an XML element into a Component instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A component XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Component</code> <p>The Component instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Component:\n    \"\"\"Convert an XML element into a [Component][msl.equipment.schema.Component] instance.\n\n    Args:\n        element: A [component][type_component]{:target=\"_blank\"} XML element from an equipment register.\n\n    Returns:\n        The [Component][msl.equipment.schema.Component] instance.\n    \"\"\"\n    # Schema defines &lt;component&gt; using xsd:choice, which allows sub-elements to appear (or not appear) in any order\n    # Using str.endswith() allows for ignoring XML namespaces that may be associated with each tag\n    a: list[Adjustment] = []\n    dr: list[DigitalReport] = []\n    pc: list[PerformanceCheck] = []\n    r: list[Report] = []\n    for child in element:\n        tag = child.tag\n        if tag.endswith(\"report\"):\n            r.append(Report.from_xml(child))\n        elif tag.endswith(\"performanceCheck\"):\n            pc.append(PerformanceCheck.from_xml(child))\n        elif tag.endswith(\"adjustment\"):\n            a.append(Adjustment.from_xml(child))\n        else:\n            dr.append(DigitalReport.from_xml(child))\n\n    return cls(\n        name=element.attrib[\"name\"],\n        adjustments=tuple(a),\n        digital_reports=tuple(dr),\n        performance_checks=tuple(pc),\n        reports=tuple(r),\n    )\n</code></pre>"},{"location":"schema/component/#msl.equipment.schema.Component.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Component class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Component as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Component][msl.equipment.schema.Component] class into an XML element.\n\n    Returns:\n        The [Component][msl.equipment.schema.Component] as an XML element.\n    \"\"\"\n    e = Element(\"component\", attrib={\"name\": self.name})\n\n    # the order is not important since xsd:choice is used\n    e.extend(r.to_xml() for r in self.reports)\n    e.extend(p.to_xml() for p in self.performance_checks)\n    e.extend(a.to_xml() for a in self.adjustments)\n    e.extend(d.to_xml() for d in self.digital_reports)\n    return e\n</code></pre>"},{"location":"schema/conditions/","title":"Conditions","text":""},{"location":"schema/conditions/#msl.equipment.schema.Conditions","title":"Conditions","text":"<pre><code>Conditions(**attributes: str)\n</code></pre> <p>               Bases: <code>Any</code></p> <p>Conditions under which a performance check or calibration report is valid.</p> <p>Since this class is currently represented by the any type in the XML Schema Definition, it is simply a subclass of Element. It may be updated to be a more specific class at a later date.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any]{:target=\"_blank\"} type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/conditions/#msl.equipment.schema.Conditions.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str = 'conditions'\n</code></pre> <p>The element's name.</p>"},{"location":"schema/conditions/#msl.equipment.schema.Conditions.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/cvd_equation/","title":"CVDEquation","text":"<p>The Callendar-Van Dusen (CVD) equation describes the relationship between resistance, \\(R\\), and temperature, \\(T\\), of platinum resistance thermometers (PRT). It is typically defined in two temperature ranges</p> \\[ \\frac{R(T)}{R_0} = \\begin{cases}     1 + A \\cdot T + B \\cdot T^2 &amp; 0~^{\\circ}\\text{C} \\leq T \\lt 661~^{\\circ}\\text{C} \\\\     1 + A \\cdot T + B \\cdot T^2 + C \\cdot (T-100) \\cdot T^3 &amp; -200~^{\\circ}\\text{C} \\lt T \\lt 0~^{\\circ}\\text{C} \\\\ \\end{cases} \\] <p>where, \\(R_0\\) is the resistance at \\(T=0~^{\\circ}\\text{C}\\) and \\(A\\), \\(B\\) and \\(C\\) are the Callendar-Van Dusen coefficients.</p> <p>Suppose you have a variable named <code>cvd</code> (which is an instance of CVDEquation) that represents the following information in an equipment register for a PRT</p> <pre><code>&lt;cvdCoefficients&gt;\n  &lt;R0&gt;100.0189&lt;/R0&gt;\n  &lt;A&gt;3.913e-3&lt;/A&gt;\n  &lt;B&gt;-6.056e-7&lt;/B&gt;\n  &lt;C&gt;1.372e-12&lt;/C&gt;\n  &lt;uncertainty variables=\"\"&gt;0.0056/2&lt;/uncertainty&gt;\n  &lt;range&gt;\n    &lt;minimum&gt;-10&lt;/minimum&gt;\n    &lt;maximum&gt;70&lt;/maximum&gt;\n  &lt;/range&gt;\n&lt;/cvdCoefficients&gt;\n</code></pre> <p>You can access the CVD coefficients, degrees of freedom and comment as attributes of <code>cvd</code>,</p> <pre><code>&gt;&gt;&gt; cvd.R0\n100.0189\n&gt;&gt;&gt; cvd.A\n0.003913\n&gt;&gt;&gt; cvd.B\n-6.056e-07\n&gt;&gt;&gt; cvd.C\n1.372e-12\n&gt;&gt;&gt; cvd.degree_freedom\ninf\n&gt;&gt;&gt; cvd.comment\n''\n</code></pre> <p>evaluate the uncertainty,</p> <pre><code>&gt;&gt;&gt; print(cvd.uncertainty())\n0.0026\n</code></pre> <p>calculate resistance from temperature,</p> <pre><code>&gt;&gt;&gt; print(cvd.resistance(12.4))\n104.86262358516764\n&gt;&gt;&gt; cvd.resistance([-5, 0, 5, 10, 15, 20, 25])\narray([ 98.06051774, 100.0189    , 101.97425549, 103.92658241,\n       105.87588076, 107.82215054, 109.76539174])\n</code></pre> <p>and calculate temperature from resistance</p> <pre><code>&gt;&gt;&gt; print(cvd.temperature(109.1))\n23.287055698724505\n&gt;&gt;&gt; cvd.temperature([98.7, 99.2, 100.4, 101.7, 103.8])\narray([-3.36816839, -2.09169544,  0.9738958 ,  4.29823964,  9.67558125])\n</code></pre> <p>Any sequence of numbers, i.e., a list, tuple, ndarray, etc., may be used to calculate the temperature or resistance (tip: using ndarray will improve performance since a copy of the values is not required).</p> <p>When calculating resistance or temperature, the value(s) of the inputs are checked to ensure that the value(s) are within the ranges that the CVD coefficients are valid for. The XML data above shows that the temperature must be in the range \\(-10~^\\circ\\text{C}\\) to \\(70~^\\circ\\text{C}\\), which has a corresponding resistance range of \\(96.099~\\Omega\\) to \\(127.118~\\Omega\\) from the equation above. If you calculate resistance from \\(T=-10.2~^\\circ\\text{C}\\) or temperature from \\(R=96.0~\\Omega\\) a ValueError is raised</p> <pre><code>&gt;&gt;&gt; cvd.ranges\n{'t': Range(minimum=-10, maximum=70), 'r': Range(minimum=96.099, maximum=127.118)}\n\n&gt;&gt;&gt; cvd.resistance(-10.2)\nTraceback (most recent call last):\n...\nValueError: The value -10.2 is not within the range [-10, 70]\n\n&gt;&gt;&gt; cvd.temperature(96)\nTraceback (most recent call last):\n...\nValueError: The value 96.0 is not within the range [96.099, 127.118]\n</code></pre> <p>You can bypass range checking by including a <code>check_range=False</code> keyword argument</p> <pre><code>&gt;&gt;&gt; print(cvd.resistance(-10.2, check_range=False))\n96.02059984653798\n&gt;&gt;&gt; print(cvd.temperature(96, check_range=False))\n-10.252469261526016\n</code></pre>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation","title":"CVDEquation  <code>dataclass</code>","text":"<pre><code>CVDEquation(\n    R0: float,\n    A: float,\n    B: float,\n    C: float,\n    uncertainty: Evaluable,\n    ranges: dict[str, Range] = dict(),\n    degree_freedom: float = float(\"inf\"),\n    comment: str = \"\",\n)\n</code></pre> <p>The Callendar-Van Dusen (CVD) equation based on the cvdCoefficients element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>R0</code> <code>float</code> <p>The value, in \\(\\Omega\\), of the resistance at \\(0~^\\circ\\text{C}\\), \\(R_0\\).</p> required <code>A</code> <code>float</code> <p>The value, in \\(^\\circ\\text{C}^{-1}\\), of the A coefficient, \\(A \\cdot T\\).</p> required <code>B</code> <code>float</code> <p>The value, in \\(^\\circ\\text{C}^{-2}\\), of the B coefficient, \\(B \\cdot T^2\\).</p> required <code>C</code> <code>float</code> <p>The value, in \\(^\\circ\\text{C}^{-4}\\), of the C coefficient, \\(C \\cdot (T-100) \\cdot T^3\\).</p> required <code>uncertainty</code> <code>Evaluable</code> <p>The equation to evaluate to calculate the standard uncertainty.</p> required <code>ranges</code> <code>dict[str, Range]</code> <p>The temperature range, in \\(^\\circ\\text{C}\\), and the resistance range, in \\(\\Omega\\), that the CVD coefficients are valid. The temperature key must be <code>\"t\"</code> and the resistance key <code>\"r\"</code>.</p> <code>dict()</code> <code>degree_freedom</code> <code>float</code> <p>The degrees of freedom.</p> <code>float('inf')</code> <code>comment</code> <code>str</code> <p>A comment to associate with the CVD equation.</p> <code>''</code>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.A","title":"A  <code>instance-attribute</code>","text":"<pre><code>A: float\n</code></pre> <p>The value, in \\(^\\circ\\text{C}^{-1}\\), of the A coefficient, \\(A \\cdot T\\).</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.B","title":"B  <code>instance-attribute</code>","text":"<pre><code>B: float\n</code></pre> <p>The value, in \\(^\\circ\\text{C}^{-2}\\), of the B coefficient, \\(B \\cdot T^2\\).</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.C","title":"C  <code>instance-attribute</code>","text":"<pre><code>C: float\n</code></pre> <p>The value, in \\(^\\circ\\text{C}^{-4}\\), of the C coefficient, \\(C \\cdot (T-100) \\cdot T^3\\).</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.R0","title":"R0  <code>instance-attribute</code>","text":"<pre><code>R0: float\n</code></pre> <p>The value, in \\(\\Omega\\), of the resistance at \\(0~^\\circ\\text{C}\\), \\(R_0\\).</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.comment","title":"comment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comment: str = ''\n</code></pre> <p>A comment associated with the Callendar-Van Dusen equation.</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.degree_freedom","title":"degree_freedom  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>degree_freedom: float = float('inf')\n</code></pre> <p>The degrees of freedom.</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.ranges","title":"ranges  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ranges: dict[str, Range] = field(default_factory=dict)\n</code></pre> <p>The temperature range, in \\(^\\circ\\text{C}\\), and the resistance range, in \\(\\Omega\\), that the Callendar-Van Dusen coefficients are valid.</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.uncertainty","title":"uncertainty  <code>instance-attribute</code>","text":"<pre><code>uncertainty: Evaluable\n</code></pre> <p>The equation to evaluate to calculate the standard uncertainty.</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; CVDEquation\n</code></pre> <p>Convert an XML element into a CVDEquation instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A cvdCoefficients XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>CVDEquation</code> <p>The CVDEquation instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; CVDEquation:\n    \"\"\"Convert an XML element into a [CVDEquation][msl.equipment.schema.CVDEquation] instance.\n\n    Args:\n        element: A [cvdCoefficients][type_cvdCoefficients]{:target=\"_blank\"} XML element\n            from an equipment register.\n\n    Returns:\n        The [CVDEquation][msl.equipment.schema.CVDEquation] instance.\n    \"\"\"\n    # Schema forces order\n    r0 = float(element[0].text or 0)\n    a = float(element[1].text or 0)\n    b = float(element[2].text or 0)\n    c = float(element[3].text or 0)\n\n    r = element[5]\n    _range = Range(float(r[0].text or -200), float(r[1].text or 661))\n    ranges = {\n        \"t\": _range,\n        \"r\": Range(\n            minimum=round(float(_cvd_resistance(_range.minimum, r0, a, b, c)), 3),\n            maximum=round(float(_cvd_resistance(_range.maximum, r0, a, b, c)), 3),\n        ),\n    }\n\n    u = element[4]\n    uncertainty = Evaluable(\n        equation=u.text or \"\",\n        variables=tuple(u.attrib[\"variables\"].split()),\n        ranges=ranges,\n    )\n\n    return cls(\n        R0=r0,\n        A=a,\n        B=b,\n        C=c,\n        uncertainty=uncertainty,\n        ranges=ranges,\n        degree_freedom=float(element[6].text or np.inf) if len(element) &gt; 6 else np.inf,  # noqa: PLR2004\n        comment=element.attrib.get(\"comment\", \"\"),\n    )\n</code></pre>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.resistance","title":"resistance","text":"<pre><code>resistance(\n    temperature: ArrayLike, *, check_range: bool = True\n) -&gt; NDArray[float64]\n</code></pre> <p>Calculate resistance from temperature.</p> <p>Parameters:</p> Name Type Description Default <code>temperature</code> <code>ArrayLike</code> <p>The temperature values, in \\(^\\circ\\text{C}\\).</p> required <code>check_range</code> <code>bool</code> <p>Whether to check that the temperature values are within the allowed range.</p> <code>True</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The resistance values.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def resistance(self, temperature: ArrayLike, *, check_range: bool = True) -&gt; NDArray[np.float64]:\n    r\"\"\"Calculate resistance from temperature.\n\n    Args:\n        temperature: The temperature values, in $^\\circ\\text{C}$.\n        check_range: Whether to check that the temperature values are within the allowed range.\n\n    Returns:\n        The resistance values.\n    \"\"\"\n    array = np.asarray(temperature, dtype=float)\n    if check_range and self.ranges[\"t\"].check_within_range(array):\n        pass  # check_within_range() will raise an error, if one occurred\n\n    return _cvd_resistance(array, self.R0, self.A, self.B, self.C)\n</code></pre>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.temperature","title":"temperature","text":"<pre><code>temperature(\n    resistance: ArrayLike, *, check_range: bool = True\n) -&gt; NDArray[float64]\n</code></pre> <p>Calculate temperature from resistance.</p> <p>Parameters:</p> Name Type Description Default <code>resistance</code> <code>ArrayLike</code> <p>The resistance values, in \\(\\Omega\\).</p> required <code>check_range</code> <code>bool</code> <p>Whether to check that the resistance values are within the allowed range.</p> <code>True</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The temperature values.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def temperature(self, resistance: ArrayLike, *, check_range: bool = True) -&gt; NDArray[np.float64]:\n    r\"\"\"Calculate temperature from resistance.\n\n    Args:\n        resistance: The resistance values, in $\\Omega$.\n        check_range: Whether to check that the resistance values are within the allowed range.\n\n    Returns:\n        The temperature values.\n    \"\"\"\n    array: NDArray[np.float64] = np.asarray(resistance, dtype=float)\n    if check_range and self.ranges[\"r\"].check_within_range(array):\n        pass  # check_within_range raised an error, if one occurred\n\n    def positive(r: NDArray[np.float64]) -&gt; NDArray[np.float64]:\n        # rearrange CVD equation to be: a*x^2 + b*x + c = 0\n        #   a -&gt; B, b -&gt; A, c -&gt; 1 - R/R0\n        # then use the quadratic formula\n        return (-self.A + np.sqrt(self.A**2 - 4.0 * self.B * (1.0 - r / self.R0))) / (2.0 * self.B)\n\n    def negative(r: NDArray[np.float64]) -&gt; NDArray[np.float64]:\n        # rearrange CVD equation to be: a*x^4 + b*x^3 + c*x^2 + d*x + e = 0\n        a = self.C\n        b = -100.0 * self.C\n        c = self.B\n        d = self.A\n        e = 1.0 - (r / self.R0)\n\n        # https://en.wikipedia.org/wiki/Quartic_function#Solving_a_quartic_equation]\n        # See Section \"General formula for roots\" for the definitions of these variables\n        p = (8 * a * c - 3 * b**2) / (8 * a**2)\n        q = (b**3 - 4 * a * b * c + 8 * a**2 * d) / (8 * a**3)\n        delta_0 = c**2 - 3 * b * d + 12 * a * e\n        delta_1 = 2 * c**3 - 9 * b * c * d + 27 * b**2 * e + 27 * a * d**2 - 72 * a * c * e\n        Q = np.cbrt((delta_1 + np.sqrt(delta_1**2 - 4 * delta_0**3)) / 2)  # noqa: N806\n        S = 0.5 * np.sqrt(-2 * p / 3 + 1 / (3 * a) * (Q + delta_0 / Q))  # noqa: N806\n\n        # decide which root of the quartic to use by looking at the value under the\n        # square root in the x1,2 and x3,4 equations\n        t1 = -4 * S**2 - 2 * p\n        t2 = q / S\n        t3 = t1 - t2\n        return np.piecewise(\n            t3,\n            [t3 &gt;= 0, t3 &lt; 0],\n            [\n                lambda x: -b / (4.0 * a) + S - 0.5 * np.sqrt(x),  # x4 equation\n                lambda x: -b / (4.0 * a) - S + 0.5 * np.sqrt(x + 2.0 * t2),  # x1 equation\n            ],\n        )\n\n    return np.piecewise(array, [array &lt; self.R0, array &gt;= self.R0], [negative, positive])\n</code></pre>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the CVDEquation class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The CVDEquation as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [CVDEquation][msl.equipment.schema.CVDEquation] class into an XML element.\n\n    Returns:\n        The [CVDEquation][msl.equipment.schema.CVDEquation] as an XML element.\n    \"\"\"\n    attrib = {\"comment\": self.comment} if self.comment else {}\n    e = Element(\"cvdCoefficients\", attrib=attrib)\n\n    r0 = SubElement(e, \"R0\")\n    r0.text = str(self.R0)\n\n    a = SubElement(e, \"A\")\n    a.text = str(self.A)\n\n    b = SubElement(e, \"B\")\n    b.text = str(self.B)\n\n    c = SubElement(e, \"C\")\n    c.text = str(self.C)\n\n    u = SubElement(e, \"uncertainty\", attrib={\"variables\": \" \".join(self.uncertainty.variables)})\n    u.text = str(self.uncertainty.equation)\n\n    rng = SubElement(e, \"range\")\n    mn = SubElement(rng, \"minimum\")\n    mn.text = str(self.ranges[\"t\"].minimum)\n    mx = SubElement(rng, \"maximum\")\n    mx.text = str(self.ranges[\"t\"].maximum)\n\n    if not isinf(self.degree_freedom):\n        dof = SubElement(e, \"degreeFreedom\")\n        dof.text = str(self.degree_freedom)\n\n    return e\n</code></pre>"},{"location":"schema/deserialised/","title":"Deserialised","text":""},{"location":"schema/deserialised/#msl.equipment.schema.Deserialised","title":"Deserialised  <code>dataclass</code>","text":"<pre><code>Deserialised(value: Any, comment: str = '')\n</code></pre> <p>Represents the opposite of the serialised element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value of the deserialised object.</p> required <code>comment</code> <code>str</code> <p>A comment to associate with the (de)serialised object.</p> <code>''</code>"},{"location":"schema/deserialised/#msl.equipment.schema.Deserialised.comment","title":"comment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comment: str = ''\n</code></pre> <p>A comment associated with the (de)serialised object.</p>"},{"location":"schema/deserialised/#msl.equipment.schema.Deserialised.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: Any\n</code></pre> <p>The value of the deserialised object. For example, an Archive object from GTC.</p>"},{"location":"schema/deserialised/#msl.equipment.schema.Deserialised.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Deserialised\n</code></pre> <p>Convert a serialised XML element into a Deserialised instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A serialised XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Deserialised</code> <p>The Deserialised instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Deserialised:\n    \"\"\"Convert a [serialised][type_serialised]{:target=\"_blank\"} XML element into a [Deserialised][msl.equipment.schema.Deserialised] instance.\n\n    Args:\n        element: A [serialised][type_serialised]{:target=\"_blank\"} XML element from an equipment register.\n\n    Returns:\n        The [Deserialised][msl.equipment.schema.Deserialised] instance.\n    \"\"\"  # noqa: E501\n    e = element[0]\n    comment = element.attrib.get(\"comment\", \"\")\n\n    # GTC is not required for msl-equipment, so we import it here\n    if e.tag.endswith(\"gtcArchive\"):\n        from GTC.xml_format import (  # type: ignore[import-untyped]  # pyright: ignore[reportMissingTypeStubs]  # noqa: PLC0415\n            xml_to_archive,  # pyright: ignore[reportUnknownVariableType]\n        )\n\n        return cls(value=xml_to_archive(e), comment=comment)\n\n    if e.tag.endswith(\"gtcArchiveJSON\"):\n        from GTC import (  # type: ignore[import-untyped]  # pyright: ignore[reportMissingTypeStubs]  # noqa: PLC0415\n            pr,  # pyright: ignore[reportUnknownVariableType]\n        )\n\n        return cls(value=pr.loads_json(e.text), comment=comment)  # pyright: ignore[reportUnknownMemberType]\n\n    # Use the Element object rather than raising an exception that the deserializer has not been implemented yet\n    return cls(value=e, comment=comment)\n</code></pre>"},{"location":"schema/deserialised/#msl.equipment.schema.Deserialised.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Deserialised class into a serialised XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The serialised XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Deserialised][msl.equipment.schema.Deserialised] class into a [serialised][type_serialised]{:target=\"_blank\"} XML element.\n\n    Returns:\n        The [serialised][type_serialised]{:target=\"_blank\"} XML element.\n    \"\"\"  # noqa: E501\n    attrib = {\"comment\": self.comment} if self.comment else {}\n    e = Element(\"serialised\", attrib=attrib)\n\n    if isinstance(self.value, Element):\n        e.append(self.value)  # pyright: ignore[reportUnknownMemberType, reportUnknownArgumentType]\n        return e\n\n    # Currently, only a GTC Archive is supported so we don't need to check how to serialise it\n    # GTC is not required for msl-equipment, so we import it here\n    from GTC.persistence import (  # type: ignore[import-untyped]  # pyright: ignore[reportMissingTypeStubs]  # noqa: PLC0415\n        Archive,  # pyright: ignore[reportUnknownVariableType]\n    )\n    from GTC.xml_format import (  # pyright: ignore[reportMissingTypeStubs]  # noqa: PLC0415\n        archive_to_xml,  # pyright: ignore[reportUnknownVariableType]\n    )\n\n    e.append(archive_to_xml(Archive.copy(self.value)))  # pyright: ignore[reportUnknownArgumentType, reportUnknownMemberType]\n    return e\n</code></pre>"},{"location":"schema/digital_report/","title":"DigitalReport","text":""},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport","title":"DigitalReport  <code>dataclass</code>","text":"<pre><code>DigitalReport(\n    url: str,\n    format: DigitalFormat,\n    id: str,\n    sha256: str,\n    attributes: dict[str, str] = dict(),\n    comment: str = \"\",\n)\n</code></pre> <p>Represents the digitalReport element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The location of the digital report. The syntax follows RFC 1738 <code>scheme:scheme-specific-part</code>. If <code>scheme:</code> is not specified, it is assumed to be <code>file:</code>.</p> required <code>format</code> <code>DigitalFormat</code> <p>The format of the digital calibration report.</p> required <code>id</code> <code>str</code> <p>The report identification number.</p> required <code>sha256</code> <code>str</code> <p>The SHA-256 checksum of the digital report.</p> required <code>attributes</code> <code>dict[str, str]</code> <p>XML attributes associated with the <code>&lt;url&gt;</code> element.</p> <code>dict()</code> <code>comment</code> <code>str</code> <p>A comment to associate with the digital report.</p> <code>''</code>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.attributes","title":"attributes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attributes: dict[str, str] = field(default_factory=dict)\n</code></pre> <p>XML attributes associated with the <code>&lt;url&gt;</code> element.</p>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.comment","title":"comment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comment: str = ''\n</code></pre> <p>A comment associated with the digital report.</p>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.format","title":"format  <code>instance-attribute</code>","text":"<pre><code>format: DigitalFormat\n</code></pre> <p>The format of the digital calibration report.</p>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>The report identification number.</p>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.sha256","title":"sha256  <code>instance-attribute</code>","text":"<pre><code>sha256: str\n</code></pre> <p>The SHA-256 checksum of the digital report.</p>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: str\n</code></pre> <p>The location of the digital report. The syntax follows RFC 1738 <code>scheme:scheme-specific-part</code>. If <code>scheme:</code> is not specified, it is assumed to be <code>file:</code>.</p>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; DigitalReport\n</code></pre> <p>Convert an XML element into a DigitalReport instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A digitalReport XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>DigitalReport</code> <p>The DigitalReport instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; DigitalReport:\n    \"\"\"Convert an XML element into a [DigitalReport][msl.equipment.schema.DigitalReport] instance.\n\n    Args:\n        element: A [digitalReport][type_digitalReport]{:target=\"_blank\"} XML element from an equipment register.\n\n    Returns:\n        The [DigitalReport][msl.equipment.schema.DigitalReport] instance.\n    \"\"\"\n    # Schema forces order\n    return cls(\n        url=element[0].text or \"\",\n        format=DigitalFormat(element.attrib[\"format\"]),\n        id=element.attrib[\"id\"],\n        sha256=element[1].text or \"\",\n        attributes=element[0].attrib,\n        comment=element.attrib.get(\"comment\", \"\"),\n    )\n</code></pre>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the DigitalReport class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The DigitalReport as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [DigitalReport][msl.equipment.schema.DigitalReport] class into an XML element.\n\n    Returns:\n        The [DigitalReport][msl.equipment.schema.DigitalReport] as an XML element.\n    \"\"\"\n    attrib = {\"format\": self.format.value, \"id\": self.id}\n    if self.comment:\n        attrib[\"comment\"] = self.comment\n    e = Element(\"digitalReport\", attrib=attrib)\n    url = SubElement(e, \"url\", attrib=self.attributes)\n    url.text = self.url\n    sha256 = SubElement(e, \"sha256\")\n    sha256.text = self.sha256\n    return e\n</code></pre>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalFormat","title":"DigitalFormat","text":"<p>               Bases: <code>Enum</code></p> <p>Represents the digitalFormatEnumerationString enumeration in an equipment register.</p> <p>Attributes:</p> Name Type Description <code>MSL_PDF</code> <code>str</code> <p><code>\"MSL PDF/A-3\"</code> (MSL's PDF/A-3 format).</p> <code>PTB_DCC</code> <code>str</code> <p><code>\"PTB DCC\"</code> (PTB's Digital Calibration Certificate).</p>"},{"location":"schema/equation/","title":"Equation","text":"<p>Suppose you have a variable named <code>equation</code> (which is an instance of Equation) that represents the following information in an equipment register for equipment that measures relative humidity. The corrected value depends on two variables (<code>r</code> and <code>t</code>) and the standard uncertainty is a constant.</p> <pre><code>&lt;equation&gt;\n  &lt;value variables=\"r t\"&gt;r-0.71-0.04*r+3.4e-4*pow(r,2)+2.4e-3*t+1.3e-3*r*t&lt;/value&gt;\n  &lt;uncertainty variables=\"\"&gt;0.355&lt;/uncertainty&gt;\n  &lt;unit&gt;%rh&lt;/unit&gt;\n  &lt;ranges&gt;\n    &lt;range variable=\"r\"&gt;\n      &lt;minimum&gt;30&lt;/minimum&gt;\n      &lt;maximum&gt;80&lt;/maximum&gt;\n    &lt;/range&gt;\n    &lt;range variable=\"t\"&gt;\n      &lt;minimum&gt;15&lt;/minimum&gt;\n      &lt;maximum&gt;25&lt;/maximum&gt;\n    &lt;/range&gt;\n  &lt;/ranges&gt;\n&lt;/equation&gt;\n</code></pre> <p>You can access the unit, degrees of freedom and comment as attributes of <code>equation</code></p> <pre><code>&gt;&gt;&gt; equation.unit\n'%rh'\n&gt;&gt;&gt; equation.degree_freedom\ninf\n&gt;&gt;&gt; equation.comment\n''\n</code></pre> <p>To evaluate an equation, call the appropriate attribute with the variable(s) that are required to evaluate the equation with</p> <pre><code>&gt;&gt;&gt; equation.value.variables\n('r', 't')\n&gt;&gt;&gt; equation.uncertainty.variables\n()\n&gt;&gt;&gt; assert equation.value(r=50.3, t=20.4) == 49.8211466\n&gt;&gt;&gt; assert equation.uncertainty() == 0.355\n</code></pre> <p>A variable can have multiple values. Any sequence of numbers, i.e., a list, tuple, ndarray, etc., may be used (tip: using ndarray will improve performance since a copy of the values is not required),</p> <pre><code>&gt;&gt;&gt; equation.value(r=[50.3, 52.1, 48.7], t=[20.4, 19.7, 20.0])\narray([49.8211466, 51.6104604, 48.1625746])\n</code></pre> <p>the values of the variables do not need to be 1-dimensional arrays,</p> <pre><code>&gt;&gt;&gt; equation.value(r=[(50.3, 52.1), (48.7, 47.9)], t=[(20.4, 19.7), (20.0, 19.6)])\narray([[49.8211466, 51.6104604],\n       [48.1625746, 47.3216314]])\n</code></pre> <p>and the array broadcasting rules of numpy also apply, i.e., multiple <code>r</code> values and a single <code>t</code> value</p> <pre><code>&gt;&gt;&gt; equation.value(r=(50.3, 52.1, 48.7), t=20.4)\narray([49.8211466, 51.6595514, 48.1888586])\n</code></pre> <p>If you forget to specify a variable (in the following case, <code>t</code>) a NameError will be raised,</p> <pre><code>&gt;&gt;&gt; equation.value(r=50.3)\nTraceback (most recent call last):\n...\nNameError: name 't' is not defined\n</code></pre> <p>however, if you specify more variables than are required to evaluate the equation, the additional variables are ignored <pre><code>&gt;&gt;&gt; equation.uncertainty(r=50.3, t=20.4)\narray(0.355)\n</code></pre></p> <p>Notice in the last returned value that the result was printed as <code>array(0.355)</code> even though a single <code>r</code> and <code>t</code> value was specified (although these variables were ignored in this particular example, since the standard uncertainty is a constant, the principle remains the same if they were not ignored). All evaluated returned types are an instance of a numpy ndarray even if a single value is specified. These particular returned array instances are referred to as 0-dimensional array scalars in numpy terminology.</p> <p>When evaluating an equation, the value(s) of the input variables are checked to ensure that the value(s) are within the ranges that the equation is valid for. The XML data above shows that the temperature, <code>t</code>, value must be in the range <code>15</code> to <code>25</code>. If you evaluate the corrected value at <code>t=30</code> a ValueError is raised</p> <pre><code>&gt;&gt;&gt; equation.value.ranges\n{'r': Range(minimum=30, maximum=80), 't': Range(minimum=15, maximum=25)}\n&gt;&gt;&gt; equation.value(r=50.3, t=30)\nTraceback (most recent call last):\n...\nValueError: The value 30.0 is not within the range [15, 25]\n</code></pre> <p>You can bypass range checking by including a <code>check_range=False</code> keyword argument</p> <pre><code>&gt;&gt;&gt; equation.value(r=50.3, t=30, check_range=False)\narray(50.4719306)\n</code></pre>"},{"location":"schema/equation/#msl.equipment.schema.Equation","title":"Equation  <code>dataclass</code>","text":"<pre><code>Equation(\n    value: Evaluable,\n    uncertainty: Evaluable,\n    unit: str,\n    degree_freedom: float = float(\"inf\"),\n    comment: str = \"\",\n)\n</code></pre> <p>Represents the equation element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Evaluable</code> <p>The equation to evaluate to calculate the corrected value.</p> required <code>uncertainty</code> <code>Evaluable</code> <p>The equation to evaluate to calculate the standard uncertainty.</p> required <code>unit</code> <code>str</code> <p>The unit of the measured quantity.</p> required <code>degree_freedom</code> <code>float</code> <p>The degrees of freedom.</p> <code>float('inf')</code> <code>comment</code> <code>str</code> <p>A comment to associate with the equation.</p> <code>''</code>"},{"location":"schema/equation/#msl.equipment.schema.Equation.comment","title":"comment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comment: str = ''\n</code></pre> <p>A comment associated with the equation.</p>"},{"location":"schema/equation/#msl.equipment.schema.Equation.degree_freedom","title":"degree_freedom  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>degree_freedom: float = float('inf')\n</code></pre> <p>The degrees of freedom.</p>"},{"location":"schema/equation/#msl.equipment.schema.Equation.uncertainty","title":"uncertainty  <code>instance-attribute</code>","text":"<pre><code>uncertainty: Evaluable\n</code></pre> <p>The equation to evaluate to calculate the standard uncertainty.</p>"},{"location":"schema/equation/#msl.equipment.schema.Equation.unit","title":"unit  <code>instance-attribute</code>","text":"<pre><code>unit: str\n</code></pre> <p>The unit of the measured quantity.</p>"},{"location":"schema/equation/#msl.equipment.schema.Equation.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: Evaluable\n</code></pre> <p>The equation to evaluate to calculate the corrected value.</p>"},{"location":"schema/equation/#msl.equipment.schema.Equation.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Equation\n</code></pre> <p>Convert an XML element into an Equation instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An equation XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Equation</code> <p>The Equation instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Equation:\n    \"\"\"Convert an XML element into an [Equation][msl.equipment.schema.Equation] instance.\n\n    Args:\n        element: An [equation][type_equation]{:target=\"_blank\"} XML element from an equipment register.\n\n    Returns:\n        The [Equation][msl.equipment.schema.Equation] instance.\n    \"\"\"\n    # Schema forces order\n    value = element[0]\n    uncertainty = element[1]\n    ranges = {\n        r.attrib[\"variable\"]: Range(minimum=float(r[0].text or -np.inf), maximum=float(r[1].text or np.inf))\n        for r in element[3]\n    }\n\n    return cls(\n        value=Evaluable(\n            equation=value.text or \"\", variables=tuple(value.attrib[\"variables\"].split()), ranges=ranges\n        ),\n        uncertainty=Evaluable(\n            equation=uncertainty.text or \"\", variables=tuple(uncertainty.attrib[\"variables\"].split()), ranges=ranges\n        ),\n        unit=element[2].text or \"\",\n        degree_freedom=float(element[4].text or np.inf) if len(element) &gt; 4 else np.inf,  # noqa: PLR2004\n        comment=element.attrib.get(\"comment\", \"\"),\n    )\n</code></pre>"},{"location":"schema/equation/#msl.equipment.schema.Equation.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Equation class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Equation as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Equation][msl.equipment.schema.Equation] class into an XML element.\n\n    Returns:\n        The [Equation][msl.equipment.schema.Equation] as an XML element.\n    \"\"\"\n    attrib = {\"comment\": self.comment} if self.comment else {}\n    e = Element(\"equation\", attrib=attrib)\n    value = SubElement(e, \"value\", attrib={\"variables\": \" \".join(self.value.variables)})\n    value.text = self.value.equation\n    uncertainty = SubElement(e, \"uncertainty\", attrib={\"variables\": \" \".join(self.uncertainty.variables)})\n    uncertainty.text = self.uncertainty.equation\n    unit = SubElement(e, \"unit\")\n    unit.text = self.unit\n\n    ranges = SubElement(e, \"ranges\")\n    for name, _range in self.value.ranges.items():  # self.value.ranges and self.uncertainty.ranges are the same\n        rng = SubElement(ranges, \"range\", attrib={\"variable\": name})\n        mn = SubElement(rng, \"minimum\")\n        mn.text = str(_range.minimum)\n        mx = SubElement(rng, \"maximum\")\n        mx.text = str(_range.maximum)\n\n    if not isinf(self.degree_freedom):\n        dof = SubElement(e, \"degreeFreedom\")\n        dof.text = str(self.degree_freedom)\n\n    return e\n</code></pre>"},{"location":"schema/equation/#msl.equipment.schema.Evaluable","title":"Evaluable  <code>dataclass</code>","text":"<pre><code>Evaluable(\n    equation: str,\n    variables: tuple[str, ...] = (),\n    ranges: dict[str, Range] = dict(),\n)\n</code></pre> <p>Represents the <code>&lt;value&gt;</code> and <code>&lt;uncertainty&gt;</code> XML elements in an equation.</p> <p>Parameters:</p> Name Type Description Default <code>equation</code> <code>str</code> <p>The string representation of the equation to evaluate.</p> required <code>variables</code> <code>tuple[str, ...]</code> <p>The names of the variables in the equation.</p> <code>()</code> <code>ranges</code> <code>dict[str, Range]</code> <p>The numeric range for a variable that the <code>equation</code> is valid for. The keys are the variable names. A range does not need to be defined for every variable. If a range is not defined then a range of \\([-\\infty, +\\infty]\\) is assumed.</p> <code>dict()</code>"},{"location":"schema/equation/#msl.equipment.schema.Evaluable.equation","title":"equation  <code>instance-attribute</code>","text":"<pre><code>equation: str\n</code></pre> <p>The string representation of the equation to evaluate.</p>"},{"location":"schema/equation/#msl.equipment.schema.Evaluable.ranges","title":"ranges  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ranges: dict[str, Range] = field(default_factory=dict)\n</code></pre> <p>The numeric range for each variable that the <code>equation</code> is valid for. The keys are the variable names.</p>"},{"location":"schema/equation/#msl.equipment.schema.Evaluable.variables","title":"variables  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variables: tuple[str, ...] = ()\n</code></pre> <p>The names of the variables in the equation.</p>"},{"location":"schema/equation/#msl.equipment.schema.Range","title":"Range","text":"<p>               Bases: <code>NamedTuple</code></p> <p>The numeric range of a variable that an equation is valid for.</p> <p>Parameters:</p> Name Type Description <code>minimum</code> <code>float</code> <p>Minimum value in range.</p> <code>maximum</code> <code>float</code> <p>Maximum value in range.</p>"},{"location":"schema/equation/#msl.equipment.schema.Range.maximum","title":"maximum  <code>instance-attribute</code>","text":"<pre><code>maximum: float\n</code></pre> <p>Maximum value in range.</p>"},{"location":"schema/equation/#msl.equipment.schema.Range.minimum","title":"minimum  <code>instance-attribute</code>","text":"<pre><code>minimum: float\n</code></pre> <p>Minimum value in range.</p>"},{"location":"schema/equation/#msl.equipment.schema.Range.check_within_range","title":"check_within_range","text":"<pre><code>check_within_range(\n    value: float | ArrayLike,\n) -&gt; Literal[True]\n</code></pre> <p>Check that the values are within the range.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float | ArrayLike</code> <p>The values to check, raises</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>Always returns <code>True</code>. Raises ValueError if <code>value</code> is not within the range.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def check_within_range(self, value: float | ArrayLike) -&gt; Literal[True]:\n    \"\"\"Check that the values are within the range.\n\n    Args:\n        value: The values to check, raises\n\n    Returns:\n        Always returns `True`. Raises [ValueError][]{:target=\"_blank\"} if\n            `value` is not within the range.\n    \"\"\"\n    if isinstance(value, (int, float)) or (isinstance(value, np.ndarray) and value.ndim == 0):\n        if value &lt; self.minimum or value &gt; self.maximum:\n            msg = f\"The value {value} is not within the range [{self.minimum}, {self.maximum}]\"\n            raise ValueError(msg)\n    elif np.any(np.less(value, self.minimum)) or np.any(np.greater(value, self.maximum)):  # pyright: ignore[reportUnknownArgumentType]\n        msg = f\"A value in the sequence is not within the range [{self.minimum}, {self.maximum}]\"\n        raise ValueError(msg)\n    return True\n</code></pre>"},{"location":"schema/equipment/","title":"Equipment","text":""},{"location":"schema/equipment/#msl.equipment.schema.Equipment","title":"Equipment  <code>dataclass</code>","text":"<pre><code>Equipment(\n    entered_by: str = \"\",\n    checked_by: str = \"\",\n    checked_date: date | None = None,\n    alias: str = \"\",\n    keywords: tuple[str, ...] = (),\n    id: str = \"\",\n    manufacturer: str = \"\",\n    model: str = \"\",\n    serial: str = \"\",\n    description: str = \"\",\n    specifications: Specifications = Specifications(),\n    location: str = \"\",\n    status: Status = Active,\n    loggable: bool = False,\n    traceable: bool = False,\n    calibrations: tuple[Measurand, ...] = (),\n    maintenance: Maintenance = Maintenance(),\n    alterations: tuple[Alteration, ...] = (),\n    firmware: tuple[Firmware, ...] = (),\n    specified_requirements: SpecifiedRequirements = SpecifiedRequirements(),\n    reference_materials: ReferenceMaterials = ReferenceMaterials(),\n    quality_manual: QualityManual = QualityManual(),\n)\n</code></pre> <p>Represents the equipment element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>entered_by</code> <code>str</code> <p>The name of the person who initially entered the <code>&lt;equipment&gt;</code> element in the register.</p> <code>''</code> <code>checked_by</code> <code>str</code> <p>The name of the person who checked the information in the <code>&lt;equipment&gt;</code> element.</p> <code>''</code> <code>checked_date</code> <code>date | None</code> <p>The date that the information in the <code>&lt;equipment&gt;</code> element was last checked.</p> <code>None</code> <code>alias</code> <code>str</code> <p>An alternative name to associate with the equipment.</p> <code>''</code> <code>keywords</code> <code>tuple[str, ...]</code> <p>Keywords that describe the equipment.</p> <code>()</code> <code>id</code> <code>str</code> <p>Identity in an equipment register.</p> <code>''</code> <code>manufacturer</code> <code>str</code> <p>Name of manufacturer.</p> <code>''</code> <code>model</code> <code>str</code> <p>Manufacturer's model number (or type identification).</p> <code>''</code> <code>serial</code> <code>str</code> <p>Manufacturer's serial number (or other unique identification).</p> <code>''</code> <code>description</code> <code>str</code> <p>A short description about the equipment.</p> <code>''</code> <code>specifications</code> <code>Specifications</code> <p>Specifications provided by the manufacturer of the equipment.</p> <code>Specifications()</code> <code>location</code> <code>str</code> <p>The usual location (laboratory) that the equipment is found in.</p> <code>''</code> <code>status</code> <code>Status</code> <p>The status of the equipment is an indication of whether the equipment is active (in use) or inactive (not in use).</p> <code>Active</code> <code>loggable</code> <code>bool</code> <p>Whether measurements from the equipment should be logged. Equipment that monitor (for example) pressure, temperature or humidity of a laboratory environment are considered as loggable.</p> <code>False</code> <code>traceable</code> <code>bool</code> <p>Whether the equipment is used for a traceable measurement.</p> <code>False</code> <code>calibrations</code> <code>tuple[Measurand, ...]</code> <p>The calibration history.</p> <code>()</code> <code>maintenance</code> <code>Maintenance</code> <p>The maintenance history and maintenance plan.</p> <code>Maintenance()</code> <code>alterations</code> <code>tuple[Alteration, ...]</code> <p>The alteration history.</p> <code>()</code> <code>firmware</code> <code>tuple[Firmware, ...]</code> <p>The firmware version history.</p> <code>()</code> <code>specified_requirements</code> <code>SpecifiedRequirements</code> <p>Verification that equipment conforms with specified requirements before being placed or returned into service.</p> <code>SpecifiedRequirements()</code> <code>reference_materials</code> <code>ReferenceMaterials</code> <p>Documentation of reference materials, results, acceptance criteria, relevant dates and the period of validity.</p> <code>ReferenceMaterials()</code> <code>quality_manual</code> <code>QualityManual</code> <p>Information that is specified in Section 4.3.6 of the MSL Quality Manual.</p> <code>QualityManual()</code>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.alias","title":"alias  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alias: str = ''\n</code></pre> <p>An alternative name to associate with the equipment.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.alterations","title":"alterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alterations: tuple[Alteration, ...] = ()\n</code></pre> <p>The alteration history.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.calibrations","title":"calibrations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>calibrations: tuple[Measurand, ...] = ()\n</code></pre> <p>The calibration history.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.checked_by","title":"checked_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_by: str = ''\n</code></pre> <p>The name of the person who checked the information in the <code>&lt;equipment&gt;</code> element.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.checked_date","title":"checked_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_date: date | None = None\n</code></pre> <p>The date that the information in the <code>&lt;equipment&gt;</code> element was last checked.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = ''\n</code></pre> <p>A short description about the equipment.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.entered_by","title":"entered_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entered_by: str = ''\n</code></pre> <p>The name of the person who initially entered the <code>&lt;equipment&gt;</code> element in the register.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.firmware","title":"firmware  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>firmware: tuple[Firmware, ...] = ()\n</code></pre> <p>The firmware version history.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = ''\n</code></pre> <p>Identity in an equipment register.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.keywords","title":"keywords  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keywords: tuple[str, ...] = ()\n</code></pre> <p>Keywords that describe the equipment.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.location","title":"location  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>location: str = ''\n</code></pre> <p>The usual location (laboratory) that the equipment is found in.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.loggable","title":"loggable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>loggable: bool = False\n</code></pre> <p>Whether measurements from the equipment should be logged.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.maintenance","title":"maintenance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>maintenance: Maintenance = field(\n    default_factory=Maintenance\n)\n</code></pre> <p>The maintenance history and maintenance plan.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.manufacturer","title":"manufacturer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>manufacturer: str = ''\n</code></pre> <p>Name of manufacturer.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.model","title":"model  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model: str = ''\n</code></pre> <p>Manufacturer's model number (or type identification).</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.quality_manual","title":"quality_manual  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quality_manual: QualityManual = field(\n    default_factory=QualityManual\n)\n</code></pre> <p>Information that is specified in Section 4.3.6 of the MSL Quality Manual.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.reference_materials","title":"reference_materials  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reference_materials: ReferenceMaterials = field(\n    default_factory=ReferenceMaterials\n)\n</code></pre> <p>Documentation of reference materials, results, acceptance criteria, relevant dates and the period of validity.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.serial","title":"serial  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>serial: str = ''\n</code></pre> <p>Manufacturer's serial number (or other unique identification).</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.specifications","title":"specifications  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>specifications: Specifications = field(\n    default_factory=Specifications\n)\n</code></pre> <p>Specifications provided by the manufacturer of the equipment.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.specified_requirements","title":"specified_requirements  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>specified_requirements: SpecifiedRequirements = field(\n    default_factory=SpecifiedRequirements\n)\n</code></pre> <p>Verification that equipment conforms with specified requirements before being placed or returned into service.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.status","title":"status  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>status: Status = Active\n</code></pre> <p>The status of the equipment is an indication of whether the equipment is active (in use) or inactive (not in use).</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.traceable","title":"traceable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traceable: bool = False\n</code></pre> <p>Whether the equipment is used for a traceable measurement.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Equipment\n</code></pre> <p>Convert an XML element into an Equipment instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An equipment XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Equipment</code> <p>The Equipment instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Equipment:\n    \"\"\"Convert an XML element into an [Equipment][msl.equipment.schema.Equipment] instance.\n\n    Args:\n        element: An [equipment][type_equipment]{:target=\"_blank\"} XML element from an equipment register.\n\n    Returns:\n        The [Equipment][msl.equipment.schema.Equipment] instance.\n    \"\"\"\n    # Schema forces order\n    a = element.attrib\n    return cls(\n        entered_by=a[\"enteredBy\"],\n        checked_by=a.get(\"checkedBy\", \"\"),\n        checked_date=None if not a.get(\"checkedDate\") else _date.fromisoformat(a[\"checkedDate\"]),\n        alias=a.get(\"alias\", \"\"),\n        keywords=tuple(a.get(\"keywords\", \"\").split()),\n        id=element[0].text or \"\",\n        manufacturer=element[1].text or \"\",\n        model=element[2].text or \"\",\n        serial=element[3].text or \"\",\n        description=element[4].text or \"\",\n        specifications=Specifications.from_xml(element[5]),\n        location=element[6].text or \"\",\n        status=Status(element[7].text),\n        loggable=element[8].text in {\"1\", \"true\"},\n        traceable=element[9].text in {\"1\", \"true\"},\n        calibrations=tuple(Measurand.from_xml(e) for e in element[10]),\n        maintenance=Maintenance.from_xml(element[11]),\n        alterations=tuple(Alteration.from_xml(e) for e in element[12]),\n        firmware=tuple(Firmware.from_xml(e) for e in element[13]),\n        specified_requirements=SpecifiedRequirements.from_xml(element[14]),\n        reference_materials=ReferenceMaterials.from_xml(element[15]),\n        quality_manual=QualityManual.from_xml(element[16]),\n    )\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.latest_performance_check","title":"latest_performance_check","text":"<pre><code>latest_performance_check(\n    *, quantity: str = \"\", name: str = \"\"\n) -&gt; LatestPerformanceCheck | None\n</code></pre> <p>Returns the latest performance check.</p> <p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>str</code> <p>The measurand quantity.</p> <code>''</code> <code>name</code> <code>str</code> <p>The component name.</p> <code>''</code> <p>Returns:</p> Type Description <code>LatestPerformanceCheck | None</code> <p>The LatestPerformanceCheck for the specified <code>quantity</code> and <code>name</code>. If the equipment has only one measurand and only one component then you do not need to specify a value for the <code>quantity</code> and <code>name</code>. Returns <code>None</code> if there are no performance checks that match the <code>quantity</code> and <code>name</code> criteria or if the equipment does not have performance checks entered in the register.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def latest_performance_check(self, *, quantity: str = \"\", name: str = \"\") -&gt; LatestPerformanceCheck | None:\n    \"\"\"Returns the latest performance check.\n\n    Args:\n        quantity: The measurand [quantity][msl.equipment.schema.Measurand.quantity].\n        name: The component [name][msl.equipment.schema.Component.name].\n\n    Returns:\n        The [LatestPerformanceCheck][msl.equipment.schema.LatestPerformanceCheck] for the specified\n            `quantity` and `name`. If the equipment has only one _measurand_ and only one _component_\n            then you do not need to specify a value for the `quantity` and `name`. Returns `None` if\n            there are no performance checks that match the `quantity` and `name` criteria or if\n            the equipment does not have performance checks entered in the register.\n    \"\"\"\n    return _latest(items=list(self.latest_performance_checks()), quantity=quantity, name=name)\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.latest_performance_checks","title":"latest_performance_checks","text":"<pre><code>latest_performance_checks() -&gt; (\n    Iterator[LatestPerformanceCheck]\n)\n</code></pre> <p>Yields the latest performance check for every measurand and component.</p> <p>Yields:</p> Type Description <code>LatestPerformanceCheck</code> <p>The latest performance check.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def latest_performance_checks(self) -&gt; Iterator[LatestPerformanceCheck]:\n    \"\"\"Yields the latest performance check for every _measurand_ and _component_.\n\n    Yields:\n        The latest performance check.\n    \"\"\"\n    default = _date(1875, 5, 20)\n    for m in self.calibrations:\n        for c in m.components:\n            latest = default\n            check: PerformanceCheck | None = None\n            for pc in c.performance_checks:\n                if pc.completed_date &gt; latest:\n                    check = pc\n                    latest = pc.completed_date\n\n            if check is not None:\n                yield LatestPerformanceCheck(\n                    calibration_interval=m.calibration_interval,\n                    name=c.name,\n                    next_calibration_date=_future_date(latest, m.calibration_interval),\n                    performance_check=check,\n                    quantity=m.quantity,\n                )\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.latest_report","title":"latest_report","text":"<pre><code>latest_report(\n    *,\n    quantity: str = \"\",\n    name: str = \"\",\n    date: Literal[\"issue\", \"start\", \"stop\"] = \"stop\"\n) -&gt; LatestReport | None\n</code></pre> <p>Returns the latest calibration report.</p> <p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>str</code> <p>The measurand quantity.</p> <code>''</code> <code>name</code> <code>str</code> <p>The component name.</p> <code>''</code> <code>date</code> <code>Literal['issue', 'start', 'stop']</code> <p>Which date in a report to use to determine what latest refers to:</p> <ul> <li><code>issue</code>: Report issue date</li> <li><code>start</code>: Measurement start date</li> <li><code>stop</code>: Measurement stop date</li> </ul> <code>'stop'</code> <p>Returns:</p> Type Description <code>LatestReport | None</code> <p>The LatestReport for the specified <code>quantity</code> and <code>name</code>. If the equipment has only one measurand and only one component then you do not need to specify a value for the <code>quantity</code> and <code>name</code>. Returns <code>None</code> if there are no calibration reports that match the <code>quantity</code> and <code>name</code> criteria or if the equipment does not have calibration reports entered in the register.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def latest_report(\n    self, *, quantity: str = \"\", name: str = \"\", date: Literal[\"issue\", \"start\", \"stop\"] = \"stop\"\n) -&gt; LatestReport | None:\n    \"\"\"Returns the latest calibration report.\n\n    Args:\n        quantity: The measurand [quantity][msl.equipment.schema.Measurand.quantity].\n        name: The component [name][msl.equipment.schema.Component.name].\n        date: Which date in a report to use to determine what _latest_ refers to:\n\n            * `issue`: Report issue date\n            * `start`: Measurement start date\n            * `stop`: Measurement stop date\n\n    Returns:\n        The [LatestReport][msl.equipment.schema.LatestReport] for the specified `quantity` and `name`.\n            If the equipment has only one _measurand_ and only one _component_ then you do not need\n            to specify a value for the `quantity` and `name`. Returns `None` if there are no calibration\n            reports that match the `quantity` and `name` criteria or if the equipment does not have\n            calibration reports entered in the register.\n    \"\"\"\n    return _latest(items=list(self.latest_reports(date=date)), quantity=quantity, name=name)\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.latest_reports","title":"latest_reports","text":"<pre><code>latest_reports(\n    date: Literal[\"issue\", \"start\", \"stop\"] = \"stop\",\n) -&gt; Iterator[LatestReport]\n</code></pre> <p>Yields the latest calibration report for every measurand and component.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>Literal['issue', 'start', 'stop']</code> <p>Which date in a report to use to determine what latest refers to:</p> <ul> <li><code>issue</code>: Report issue date</li> <li><code>start</code>: Measurement start date</li> <li><code>stop</code>: Measurement stop date</li> </ul> <code>'stop'</code> <p>Yields:</p> Type Description <code>LatestReport</code> <p>The latest calibration report.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def latest_reports(self, date: Literal[\"issue\", \"start\", \"stop\"] = \"stop\") -&gt; Iterator[LatestReport]:\n    \"\"\"Yields the latest calibration report for every _measurand_ and _component_.\n\n    Args:\n        date: Which date in a report to use to determine what _latest_ refers to:\n\n            * `issue`: Report issue date\n            * `start`: Measurement start date\n            * `stop`: Measurement stop date\n\n    Yields:\n        The latest calibration report.\n    \"\"\"\n    default = _date(1875, 5, 20)\n    for m in self.calibrations:\n        for c in m.components:\n            latest = default\n            report: Report | None = None\n            for r in c.reports:\n                if date == \"stop\":\n                    if r.measurement_stop_date &gt; latest:\n                        report = r\n                        latest = r.measurement_stop_date\n                elif date == \"start\":\n                    if r.measurement_start_date &gt; latest:\n                        report = r\n                        latest = r.measurement_start_date\n                elif r.report_issue_date &gt; latest:\n                    report = r\n                    latest = r.report_issue_date\n\n            if report is not None:\n                yield LatestReport(\n                    calibration_interval=m.calibration_interval,\n                    name=c.name,\n                    next_calibration_date=_future_date(latest, m.calibration_interval),\n                    report=report,\n                    quantity=m.quantity,\n                )\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Equipment class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Equipment as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Equipment][msl.equipment.schema.Equipment] class into an XML element.\n\n    Returns:\n        The [Equipment][msl.equipment.schema.Equipment] as an XML element.\n    \"\"\"\n    a = {\"enteredBy\": self.entered_by}\n    if self.checked_by:\n        a[\"checkedBy\"] = self.checked_by\n    if self.checked_date is not None:\n        a[\"checkedDate\"] = self.checked_date.isoformat()\n    if self.alias:\n        a[\"alias\"] = self.alias\n    if self.keywords:\n        a[\"keywords\"] = \" \".join(self.keywords)\n\n    e = Element(\"equipment\", attrib=a)\n\n    _id = SubElement(e, \"id\")\n    _id.text = self.id\n\n    manufacturer = SubElement(e, \"manufacturer\")\n    manufacturer.text = self.manufacturer\n\n    model = SubElement(e, \"model\")\n    model.text = self.model\n\n    serial = SubElement(e, \"serial\")\n    serial.text = self.serial\n\n    description = SubElement(e, \"description\")\n    description.text = self.description\n\n    e.append(self.specifications)\n\n    location = SubElement(e, \"location\")\n    location.text = self.location\n\n    status = SubElement(e, \"status\")\n    status.text = self.status.value\n\n    loggable = SubElement(e, \"loggable\")\n    loggable.text = \"true\" if self.loggable else \"false\"\n\n    traceable = SubElement(e, \"traceable\")\n    traceable.text = \"true\" if self.traceable else \"false\"\n\n    calibrations = SubElement(e, \"calibrations\")\n    calibrations.extend(c.to_xml() for c in self.calibrations)\n\n    e.append(self.maintenance.to_xml())\n\n    alterations = SubElement(e, \"alterations\")\n    alterations.extend(a.to_xml() for a in self.alterations)\n\n    firmware = SubElement(e, \"firmware\")\n    firmware.extend(f.to_xml() for f in self.firmware)\n\n    e.append(self.specified_requirements)\n    e.append(self.reference_materials)\n    e.append(self.quality_manual.to_xml())\n    return e\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Latest","title":"Latest  <code>dataclass</code>","text":"<pre><code>Latest(\n    calibration_interval: float,\n    name: str,\n    next_calibration_date: date,\n    quantity: str,\n)\n</code></pre> <p>Base class for LatestReport and LatestPerformanceCheck.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Latest.calibration_interval","title":"calibration_interval  <code>instance-attribute</code>","text":"<pre><code>calibration_interval: float\n</code></pre> <p>The number of years that may pass between a calibration or a performance check.</p> <p>For equipment that do not have a required and periodic interval, but are calibrated on demand, the value is <code>0</code>.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Latest.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>The Component name.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Latest.next_calibration_date","title":"next_calibration_date  <code>instance-attribute</code>","text":"<pre><code>next_calibration_date: date\n</code></pre> <p>The date that the equipment is due for a re-calibration.</p> <p>If the calibration_interval is <code>0</code>, i.e., the equipment is calibrated on demand, this date is equal to the date that the equipment was last calibrated.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Latest.quantity","title":"quantity  <code>instance-attribute</code>","text":"<pre><code>quantity: str\n</code></pre> <p>The Measurand quantity.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Latest.is_calibration_due","title":"is_calibration_due","text":"<pre><code>is_calibration_due(months: int = 0) -&gt; bool\n</code></pre> <p>Determine if the equipment needs to be re-calibrated.</p> <p>Parameters:</p> Name Type Description Default <code>months</code> <code>int</code> <p>The number of months to add to today's date to determine if the equipment needs to be re-calibrated.</p> <code>0</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether a calibration is due within the specified number of <code>months</code>.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def is_calibration_due(self, months: int = 0) -&gt; bool:\n    \"\"\"Determine if the equipment needs to be re-calibrated.\n\n    Args:\n        months: The number of months to add to today's date to determine if\n            the equipment needs to be re-calibrated.\n\n    Returns:\n        Whether a calibration is due within the specified number of `months`.\n    \"\"\"\n    if self.calibration_interval &lt;= 0:\n        return False  # calibrate on-demand\n\n    ask_date = _future_date(_date.today(), max(0.0, months / 12.0))  # noqa: DTZ011\n    return ask_date &gt;= self.next_calibration_date\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck","title":"LatestPerformanceCheck  <code>dataclass</code>","text":"<pre><code>LatestPerformanceCheck(\n    calibration_interval: float,\n    name: str,\n    next_calibration_date: date,\n    quantity: str,\n    performance_check: PerformanceCheck,\n)\n</code></pre> <p>               Bases: <code>Latest</code></p> <p>Latest performance check.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.calibration_interval","title":"calibration_interval  <code>instance-attribute</code>","text":"<pre><code>calibration_interval: float\n</code></pre> <p>The number of years that may pass between a calibration or a performance check.</p> <p>For equipment that do not have a required and periodic interval, but are calibrated on demand, the value is <code>0</code>.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>The Component name.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.next_calibration_date","title":"next_calibration_date  <code>instance-attribute</code>","text":"<pre><code>next_calibration_date: date\n</code></pre> <p>The date that the equipment is due for a re-calibration.</p> <p>If the calibration_interval is <code>0</code>, i.e., the equipment is calibrated on demand, this date is equal to the date that the equipment was last calibrated.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.performance_check","title":"performance_check  <code>instance-attribute</code>","text":"<pre><code>performance_check: PerformanceCheck\n</code></pre> <p>Latest performance check.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.quantity","title":"quantity  <code>instance-attribute</code>","text":"<pre><code>quantity: str\n</code></pre> <p>The Measurand quantity.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.is_calibration_due","title":"is_calibration_due","text":"<pre><code>is_calibration_due(months: int = 0) -&gt; bool\n</code></pre> <p>Determine if the equipment needs to be re-calibrated.</p> <p>Parameters:</p> Name Type Description Default <code>months</code> <code>int</code> <p>The number of months to add to today's date to determine if the equipment needs to be re-calibrated.</p> <code>0</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether a calibration is due within the specified number of <code>months</code>.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def is_calibration_due(self, months: int = 0) -&gt; bool:\n    \"\"\"Determine if the equipment needs to be re-calibrated.\n\n    Args:\n        months: The number of months to add to today's date to determine if\n            the equipment needs to be re-calibrated.\n\n    Returns:\n        Whether a calibration is due within the specified number of `months`.\n    \"\"\"\n    if self.calibration_interval &lt;= 0:\n        return False  # calibrate on-demand\n\n    ask_date = _future_date(_date.today(), max(0.0, months / 12.0))  # noqa: DTZ011\n    return ask_date &gt;= self.next_calibration_date\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport","title":"LatestReport  <code>dataclass</code>","text":"<pre><code>LatestReport(\n    calibration_interval: float,\n    name: str,\n    next_calibration_date: date,\n    quantity: str,\n    report: Report,\n)\n</code></pre> <p>               Bases: <code>Latest</code></p> <p>Latest calibration report.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.calibration_interval","title":"calibration_interval  <code>instance-attribute</code>","text":"<pre><code>calibration_interval: float\n</code></pre> <p>The number of years that may pass between a calibration or a performance check.</p> <p>For equipment that do not have a required and periodic interval, but are calibrated on demand, the value is <code>0</code>.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>The Component name.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.next_calibration_date","title":"next_calibration_date  <code>instance-attribute</code>","text":"<pre><code>next_calibration_date: date\n</code></pre> <p>The date that the equipment is due for a re-calibration.</p> <p>If the calibration_interval is <code>0</code>, i.e., the equipment is calibrated on demand, this date is equal to the date that the equipment was last calibrated.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.quantity","title":"quantity  <code>instance-attribute</code>","text":"<pre><code>quantity: str\n</code></pre> <p>The Measurand quantity.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.report","title":"report  <code>instance-attribute</code>","text":"<pre><code>report: Report\n</code></pre> <p>Latest calibration report.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.is_calibration_due","title":"is_calibration_due","text":"<pre><code>is_calibration_due(months: int = 0) -&gt; bool\n</code></pre> <p>Determine if the equipment needs to be re-calibrated.</p> <p>Parameters:</p> Name Type Description Default <code>months</code> <code>int</code> <p>The number of months to add to today's date to determine if the equipment needs to be re-calibrated.</p> <code>0</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether a calibration is due within the specified number of <code>months</code>.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def is_calibration_due(self, months: int = 0) -&gt; bool:\n    \"\"\"Determine if the equipment needs to be re-calibrated.\n\n    Args:\n        months: The number of months to add to today's date to determine if\n            the equipment needs to be re-calibrated.\n\n    Returns:\n        Whether a calibration is due within the specified number of `months`.\n    \"\"\"\n    if self.calibration_interval &lt;= 0:\n        return False  # calibrate on-demand\n\n    ask_date = _future_date(_date.today(), max(0.0, months / 12.0))  # noqa: DTZ011\n    return ask_date &gt;= self.next_calibration_date\n</code></pre>"},{"location":"schema/file/","title":"File","text":"<p>Suppose you have a variable named <code>file</code> (which is an instance of File) that represents the following information in an equipment register for data that is stored in a Spreadsheet</p> <pre><code>&lt;file comment=\"FEL T647\"&gt;\n  &lt;url sheet=\"2024-May\" cells=\"A1:C11\"&gt;tests\\resources\\irradiance.xlsx&lt;/url&gt;\n  &lt;sha256&gt;7a91267cfb529388a99762b891ee4b7a12463e83b5d55809f76a0c8e76c71886&lt;/sha256&gt;\n&lt;/file&gt;\n</code></pre> <p>You can access sha256 and comment as attributes of <code>file</code></p> <pre><code>&gt;&gt;&gt; file.sha256\n'7a91267cfb529388a99762b891ee4b7a12463e83b5d55809f76a0c8e76c71886'\n&gt;&gt;&gt; file.comment\n'FEL T647'\n</code></pre> <p>The url and attributes attributes of <code>file</code> can be used with the read_table function of msl-io to read the Spreadsheet data</p> <pre><code>&gt;&gt;&gt; from msl.io import read_table\n&gt;&gt;&gt; table = read_table(file.url, **file.attributes)\n&gt;&gt;&gt; print(table.metadata.header)\n['Wavelength' 'Irradiance' 'u(Irradiance)']\n&gt;&gt;&gt; table\n&lt;Dataset 'irradiance.xlsx' shape=(10, 3) dtype='&lt;f8' (1 metadata)&gt;\n&gt;&gt;&gt; print(table)\narray([[2.500000e+02, 1.818000e-02, 2.033000e-02],\n       [3.000000e+02, 1.847800e-01, 1.755000e-02],\n       [3.500000e+02, 8.084500e-01, 1.606000e-02],\n       [4.000000e+02, 2.213550e+00, 1.405000e-02],\n       [4.500000e+02, 4.490040e+00, 1.250000e-02],\n       [5.000000e+02, 7.451350e+00, 1.200000e-02],\n       [5.500000e+02, 1.075753e+01, 1.152000e-02],\n       [6.000000e+02, 1.403809e+01, 1.102000e-02],\n       [6.500000e+02, 1.699469e+01, 1.103000e-02],\n       [7.000000e+02, 1.944093e+01, 1.077000e-02]])\n</code></pre> <p>Note</p> <p>Passing <code>**file.attributes</code> to read_table works as expected provided that the XML attributes of the <code>&lt;url&gt;</code> element are valid keyword arguments to read_table. See Read a table for more examples from msl-io, in particular, specifying <code>dtype=\"header\"</code> will return a structured dataset which would behave similar to the Table example in <code>msl-equipment</code> (i.e., accessing columns by header name).</p>"},{"location":"schema/file/#msl.equipment.schema.File","title":"File  <code>dataclass</code>","text":"<pre><code>File(\n    url: str,\n    sha256: str,\n    attributes: dict[str, str] = dict(),\n    comment: str = \"\",\n)\n</code></pre> <p>Represents the file element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The location of the file. The syntax follows RFC 1738 <code>scheme:scheme-specific-part</code>. If <code>scheme:</code> is not specified, it is assumed to be <code>file:</code>.</p> required <code>sha256</code> <code>str</code> <p>The SHA-256 checksum of the file.</p> required <code>attributes</code> <code>dict[str, str]</code> <p>XML attributes associated with the <code>&lt;url&gt;</code> element.</p> <code>dict()</code> <code>comment</code> <code>str</code> <p>A comment to associate with the file.</p> <code>''</code>"},{"location":"schema/file/#msl.equipment.schema.File.attributes","title":"attributes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attributes: dict[str, str] = field(default_factory=dict)\n</code></pre> <p>XML attributes associated with the <code>&lt;url&gt;</code> element.</p>"},{"location":"schema/file/#msl.equipment.schema.File.comment","title":"comment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comment: str = ''\n</code></pre> <p>A comment associated with the file.</p>"},{"location":"schema/file/#msl.equipment.schema.File.sha256","title":"sha256  <code>instance-attribute</code>","text":"<pre><code>sha256: str\n</code></pre> <p>The SHA-256 checksum of the file.</p>"},{"location":"schema/file/#msl.equipment.schema.File.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: str\n</code></pre> <p>The location of the file. The syntax follows RFC 1738 <code>scheme:scheme-specific-part</code>. If <code>scheme:</code> is not specified, it is assumed to be <code>file:</code>.</p>"},{"location":"schema/file/#msl.equipment.schema.File.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; File\n</code></pre> <p>Convert an XML element into a File instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A file XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>File</code> <p>The File instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; File:\n    \"\"\"Convert an XML element into a [File][msl.equipment.schema.File] instance.\n\n    Args:\n        element: A [file][type_file]{:target=\"_blank\"} XML element from an equipment register.\n\n    Returns:\n        The [File][msl.equipment.schema.File] instance.\n    \"\"\"\n    # Schema forces order\n    return cls(\n        url=element[0].text or \"\",\n        sha256=element[1].text or \"\",\n        attributes=element[0].attrib,\n        comment=element.attrib.get(\"comment\", \"\"),\n    )\n</code></pre>"},{"location":"schema/file/#msl.equipment.schema.File.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the File class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The File as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [File][msl.equipment.schema.File] class into an XML element.\n\n    Returns:\n        The [File][msl.equipment.schema.File] as an XML element.\n    \"\"\"\n    attrib = {\"comment\": self.comment} if self.comment else {}\n    e = Element(\"file\", attrib=attrib)\n    url = SubElement(e, \"url\", attrib=self.attributes)\n    url.text = self.url\n    sha256 = SubElement(e, \"sha256\")\n    sha256.text = self.sha256\n    return e\n</code></pre>"},{"location":"schema/financial/","title":"Financial","text":""},{"location":"schema/financial/#msl.equipment.schema.Financial","title":"Financial  <code>dataclass</code>","text":"<pre><code>Financial(\n    asset_number: str = \"\",\n    warranty_expiration_date: date | None = None,\n    year_purchased: int = 0,\n)\n</code></pre> <p>Represents the financial element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>asset_number</code> <code>str</code> <p>The asset number in the financial system.</p> <code>''</code> <code>warranty_expiration_date</code> <code>date | None</code> <p>Approximate date that the warranty expires.</p> <code>None</code> <code>year_purchased</code> <code>int</code> <p>Approximate year that the equipment was purchased. A value of <code>0</code> represents that the year is unknown.</p> <code>0</code>"},{"location":"schema/financial/#msl.equipment.schema.Financial.asset_number","title":"asset_number  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>asset_number: str = ''\n</code></pre> <p>The asset number in the financial system.</p>"},{"location":"schema/financial/#msl.equipment.schema.Financial.warranty_expiration_date","title":"warranty_expiration_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>warranty_expiration_date: date | None = None\n</code></pre> <p>Approximate date that the warranty expires.</p>"},{"location":"schema/financial/#msl.equipment.schema.Financial.year_purchased","title":"year_purchased  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>year_purchased: int = 0\n</code></pre> <p>Approximate year that the equipment was purchased. A value of <code>0</code> represents that the year is unknown.</p>"},{"location":"schema/financial/#msl.equipment.schema.Financial.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Financial\n</code></pre> <p>Convert an XML element into a Financial instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A financial XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Financial</code> <p>The Financial instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Financial:\n    \"\"\"Convert an XML element into a [Financial][msl.equipment.schema.Financial] instance.\n\n    Args:\n        element: A [financial][type_financial]{:target=\"_blank\"} XML element from an equipment register.\n\n    Returns:\n        The [Financial][msl.equipment.schema.Financial] instance.\n    \"\"\"\n    # Schema defines &lt;financial&gt; using xsd:all, which allows sub-elements to appear (or not appear) in any order\n    # Using str.endswith() allows for ignoring XML namespaces that may be associated with each tag\n    asset, warranty, year = \"\", None, 0\n    for child in element:\n        if child.tag.endswith(\"assetNumber\"):\n            asset = child.text or \"\"\n        elif child.tag.endswith(\"warrantyExpirationDate\"):\n            warranty = _date.fromisoformat(child.text or \"\")\n        else:\n            year = int(child.text or 0)\n    return cls(asset_number=asset, warranty_expiration_date=warranty, year_purchased=year)\n</code></pre>"},{"location":"schema/financial/#msl.equipment.schema.Financial.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Financial class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Financial as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Financial][msl.equipment.schema.Financial] class into an XML element.\n\n    Returns:\n        The [Financial][msl.equipment.schema.Financial] as an XML element.\n    \"\"\"\n    e = Element(\"financial\")\n\n    if self.asset_number:\n        an = SubElement(e, \"assetNumber\")\n        an.text = self.asset_number\n\n    if self.warranty_expiration_date is not None:\n        wed = SubElement(e, \"warrantyExpirationDate\")\n        wed.text = self.warranty_expiration_date.isoformat()\n\n    if self.year_purchased &gt; 0:\n        yp = SubElement(e, \"yearPurchased\")\n        yp.text = str(self.year_purchased)\n\n    return e\n</code></pre>"},{"location":"schema/firmware/","title":"Firmware","text":""},{"location":"schema/firmware/#msl.equipment.schema.Firmware","title":"Firmware  <code>dataclass</code>","text":"<pre><code>Firmware(version: str, date: date)\n</code></pre> <p>Represents a firmware <code>&lt;version&gt;</code> sub-element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>Firmware version number.</p> required <code>date</code> <code>date</code> <p>The date that the firmware was initially at or changed to <code>version</code>.</p> required"},{"location":"schema/firmware/#msl.equipment.schema.Firmware.date","title":"date  <code>instance-attribute</code>","text":"<pre><code>date: date\n</code></pre> <p>The date that the firmware was initially at or changed to <code>version</code>.</p>"},{"location":"schema/firmware/#msl.equipment.schema.Firmware.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str\n</code></pre> <p>Firmware version number.</p>"},{"location":"schema/firmware/#msl.equipment.schema.Firmware.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Firmware\n</code></pre> <p>Convert an XML element into a Firmware instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A firmware <code>&lt;version&gt;</code> XML sub-element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Firmware</code> <p>The Firmware instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Firmware:\n    \"\"\"Convert an XML element into a [Firmware][msl.equipment.schema.Firmware] instance.\n\n    Args:\n        element: A [firmware][type_firmware]{:target=\"_blank\"} `&lt;version&gt;` XML sub-element\n            from an equipment register.\n\n    Returns:\n        The [Firmware][msl.equipment.schema.Firmware] instance.\n    \"\"\"\n    return cls(version=element.text or \"\", date=_date.fromisoformat(element.attrib[\"date\"]))\n</code></pre>"},{"location":"schema/firmware/#msl.equipment.schema.Firmware.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Firmware class into a <code>&lt;version&gt;</code> XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Firmware as a <code>&lt;version&gt;</code> XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Firmware][msl.equipment.schema.Firmware] class into a `&lt;version&gt;` XML element.\n\n    Returns:\n        The [Firmware][msl.equipment.schema.Firmware] as a `&lt;version&gt;` XML element.\n    \"\"\"\n    e = Element(\"version\", attrib={\"date\": self.date.isoformat()})\n    e.text = self.version\n    return e\n</code></pre>"},{"location":"schema/maintenance/","title":"Maintenance","text":""},{"location":"schema/maintenance/#msl.equipment.schema.Maintenance","title":"Maintenance  <code>dataclass</code>","text":"<pre><code>Maintenance(\n    planned: tuple[PlannedTask, ...] = (),\n    completed: tuple[CompletedTask, ...] = (),\n)\n</code></pre> <p>Represents the maintenance element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>planned</code> <code>tuple[PlannedTask, ...]</code> <p>Maintenance tasks that are planned to be performed.</p> <code>()</code> <code>completed</code> <code>tuple[CompletedTask, ...]</code> <p>Maintenance tasks that have been completed.</p> <code>()</code>"},{"location":"schema/maintenance/#msl.equipment.schema.Maintenance.completed","title":"completed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>completed: tuple[CompletedTask, ...] = ()\n</code></pre> <p>Maintenance tasks that have been completed.</p>"},{"location":"schema/maintenance/#msl.equipment.schema.Maintenance.planned","title":"planned  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>planned: tuple[PlannedTask, ...] = ()\n</code></pre> <p>Maintenance tasks that are planned to be performed.</p>"},{"location":"schema/maintenance/#msl.equipment.schema.Maintenance.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Maintenance\n</code></pre> <p>Convert an XML element into a Maintenance instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A maintenance XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Maintenance</code> <p>The Maintenance instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Maintenance:\n    \"\"\"Convert an XML element into a [Maintenance][msl.equipment.schema.Maintenance] instance.\n\n    Args:\n        element: A [maintenance][type_maintenance]{:target=\"_blank\"} XML element from an equipment register.\n\n    Returns:\n        The [Maintenance][msl.equipment.schema.Maintenance] instance.\n    \"\"\"\n    if len(element) == 0:\n        return cls()\n\n    # Schema forces order, planned tasks then completed tasks (and both sub-elements must exist)\n    return cls(\n        planned=tuple(PlannedTask.from_xml(e) for e in element[0]),\n        completed=tuple(CompletedTask.from_xml(e) for e in element[1]),\n    )\n</code></pre>"},{"location":"schema/maintenance/#msl.equipment.schema.Maintenance.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Maintenance class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Maintenance as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Maintenance][msl.equipment.schema.Maintenance] class into an XML element.\n\n    Returns:\n        The [Maintenance][msl.equipment.schema.Maintenance] as an XML element.\n    \"\"\"\n    e = Element(\"maintenance\")\n    if not (self.planned or self.completed):\n        return e  # no maintenance plan\n\n    # planned must come before completed\n    planned = SubElement(e, \"planned\")\n    planned.extend(p.to_xml() for p in self.planned)\n    completed = SubElement(e, \"completed\")\n    completed.extend(c.to_xml() for c in self.completed)\n    return e\n</code></pre>"},{"location":"schema/measurand/","title":"Measurand","text":""},{"location":"schema/measurand/#msl.equipment.schema.Measurand","title":"Measurand  <code>dataclass</code>","text":"<pre><code>Measurand(\n    quantity: str,\n    calibration_interval: float,\n    components: tuple[Component, ...] = (),\n)\n</code></pre> <p>Represents the measurand element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>str</code> <p>The kind of quantity that is measured.</p> required <code>calibration_interval</code> <code>float</code> <p>The number of years that may pass between a calibration or a performance check. For equipment that do not have a required and periodic interval, but are calibrated on demand, set the value to <code>0</code>.</p> required <code>components</code> <code>tuple[Component, ...]</code> <p>The components of the equipment that measure the <code>quantity</code>.</p> <code>()</code>"},{"location":"schema/measurand/#msl.equipment.schema.Measurand.calibration_interval","title":"calibration_interval  <code>instance-attribute</code>","text":"<pre><code>calibration_interval: float\n</code></pre> <p>The number of years that may pass between a calibration or a performance check.</p> <p>For equipment that do not have a required and periodic interval, but are calibrated on demand, the value is <code>0</code>.</p>"},{"location":"schema/measurand/#msl.equipment.schema.Measurand.components","title":"components  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>components: tuple[Component, ...] = ()\n</code></pre> <p>The components of the equipment that measure the <code>quantity</code>.</p>"},{"location":"schema/measurand/#msl.equipment.schema.Measurand.quantity","title":"quantity  <code>instance-attribute</code>","text":"<pre><code>quantity: str\n</code></pre> <p>The kind of quantity that is measured.</p>"},{"location":"schema/measurand/#msl.equipment.schema.Measurand.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Measurand\n</code></pre> <p>Convert an XML element into a Measurand instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A measurand XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Measurand</code> <p>The Measurand instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Measurand:\n    \"\"\"Convert an XML element into a [Measurand][msl.equipment.schema.Measurand] instance.\n\n    Args:\n        element: A [measurand][type_measurand]{:target=\"_blank\"} XML element from an equipment register.\n\n    Returns:\n        The [Measurand][msl.equipment.schema.Measurand] instance.\n    \"\"\"\n    return cls(\n        quantity=element.attrib[\"quantity\"],\n        calibration_interval=float(element.attrib[\"calibrationInterval\"]),\n        components=tuple(Component.from_xml(c) for c in element),\n    )\n</code></pre>"},{"location":"schema/measurand/#msl.equipment.schema.Measurand.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Measurand class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Measurand as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Measurand][msl.equipment.schema.Measurand] class into an XML element.\n\n    Returns:\n        The [Measurand][msl.equipment.schema.Measurand] as an XML element.\n    \"\"\"\n    attrib = {\"quantity\": self.quantity, \"calibrationInterval\": str(self.calibration_interval)}\n    e = Element(\"measurand\", attrib=attrib)\n    e.extend(c.to_xml() for c in self.components)\n    return e\n</code></pre>"},{"location":"schema/performance_check/","title":"PerformanceCheck","text":""},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck","title":"PerformanceCheck  <code>dataclass</code>","text":"<pre><code>PerformanceCheck(\n    completed_date: date,\n    competency: Competency,\n    entered_by: str,\n    checked_by: str = \"\",\n    checked_date: date | None = None,\n    conditions: Conditions = Conditions(),\n    cvd_equations: tuple[CVDEquation, ...] = (),\n    equations: tuple[Equation, ...] = (),\n    files: tuple[File, ...] = (),\n    deserialised: tuple[Deserialised, ...] = (),\n    tables: tuple[Table, ...] = (),\n)\n</code></pre> <p>Represents the performanceCheck element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>completed_date</code> <code>date</code> <p>The date that the performance check was completed.</p> required <code>competency</code> <code>Competency</code> <p>The competent people who accomplished the performance check and the technical procedure that was executed.</p> required <code>entered_by</code> <code>str</code> <p>The name of the person who initially entered the <code>&lt;performanceCheck&gt;</code> element in the register.</p> required <code>checked_by</code> <code>str</code> <p>The name of the person who checked the information in the <code>&lt;performanceCheck&gt;</code> element.</p> <code>''</code> <code>checked_date</code> <code>date | None</code> <p>The date that the information in the <code>&lt;performanceCheck&gt;</code> element was last checked.</p> <code>None</code> <code>conditions</code> <code>Conditions</code> <p>The conditions under which the performance check is valid.</p> <code>Conditions()</code> <code>cvd_equations</code> <code>tuple[CVDEquation, ...]</code> <p>Performance-check data is expressed as coefficients for the Callendar-Van Dusen equation.</p> <code>()</code> <code>equations</code> <code>tuple[Equation, ...]</code> <p>Performance-check data is expressed as an equation.</p> <code>()</code> <code>files</code> <code>tuple[File, ...]</code> <p>Performance-check data is stored in another file (not in the equipment register).</p> <code>()</code> <code>deserialised</code> <code>tuple[Deserialised, ...]</code> <p>Performance-check data is stored in a serialised format and deserialised.</p> <code>()</code> <code>tables</code> <code>tuple[Table, ...]</code> <p>Performance-check data is expressed as a CSV table in the equipment register.</p> <code>()</code>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.checked_by","title":"checked_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_by: str = ''\n</code></pre> <p>The name of the person who checked the information in the <code>&lt;performanceCheck&gt;</code> element.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.checked_date","title":"checked_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_date: date | None = None\n</code></pre> <p>The date that the information in the <code>&lt;performanceCheck&gt;</code> element was last checked.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.competency","title":"competency  <code>instance-attribute</code>","text":"<pre><code>competency: Competency\n</code></pre> <p>The competent people who accomplished the performance check and the technical procedure that was executed.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.completed_date","title":"completed_date  <code>instance-attribute</code>","text":"<pre><code>completed_date: date\n</code></pre> <p>The date that the performance check was completed.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.conditions","title":"conditions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>conditions: Conditions = field(default_factory=Conditions)\n</code></pre> <p>The conditions under which the performance check is valid.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.cvd_equations","title":"cvd_equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cvd_equations: tuple[CVDEquation, ...] = ()\n</code></pre> <p>Performance-check data is expressed as coefficients for the Callendar-Van Dusen equation.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.deserialised","title":"deserialised  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>deserialised: tuple[Deserialised, ...] = ()\n</code></pre> <p>Performance-check data is stored in a serialised format and deserialised.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.entered_by","title":"entered_by  <code>instance-attribute</code>","text":"<pre><code>entered_by: str\n</code></pre> <p>The name of the person who initially entered the <code>&lt;performanceCheck&gt;</code> element in the register.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.equations","title":"equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>equations: tuple[Equation, ...] = ()\n</code></pre> <p>Performance-check data is expressed as an equation.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.files","title":"files  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>files: tuple[File, ...] = ()\n</code></pre> <p>Performance-check data is stored in another file (not in the equipment register).</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.tables","title":"tables  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tables: tuple[Table, ...] = ()\n</code></pre> <p>Performance-check data is expressed as a CSV table in the equipment register.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; PerformanceCheck\n</code></pre> <p>Convert an XML element into a PerformanceCheck instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A performanceCheck XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>PerformanceCheck</code> <p>The PerformanceCheck instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; PerformanceCheck:\n    \"\"\"Convert an XML element into a [PerformanceCheck][msl.equipment.schema.PerformanceCheck] instance.\n\n    Args:\n        element: A [performanceCheck][type_performanceCheck]{:target=\"_blank\"} XML element from an\n            equipment register.\n\n    Returns:\n        The [PerformanceCheck][msl.equipment.schema.PerformanceCheck] instance.\n    \"\"\"\n    # Schema forces order for `competency` and `conditions` but uses xsd:choice,\n    # which allows sub-elements to appear (or not appear) in any order, for the data elements.\n    # Using str.endswith() allows for ignoring XML namespaces that may be associated with each tag\n    cvd_equations: list[CVDEquation] = []\n    equations: list[Equation] = []\n    files: list[File] = []\n    deserialised: list[Deserialised] = []\n    tables: list[Table] = []\n    for child in element[2:]:\n        tag = child.tag\n        if tag.endswith(\"equation\"):\n            equations.append(Equation.from_xml(child))\n        elif tag.endswith(\"table\"):\n            tables.append(Table.from_xml(child))\n        elif tag.endswith(\"cvdCoefficients\"):\n            cvd_equations.append(CVDEquation.from_xml(child))\n        elif tag.endswith(\"file\"):\n            files.append(File.from_xml(child))\n        else:\n            deserialised.append(Deserialised.from_xml(child))\n\n    a = element.attrib\n    return cls(\n        completed_date=_date.fromisoformat(a[\"completedDate\"] or \"\"),\n        entered_by=a[\"enteredBy\"] or \"\",\n        checked_by=a.get(\"checkedBy\", \"\"),\n        checked_date=None if not a.get(\"checkedDate\") else _date.fromisoformat(a[\"checkedDate\"]),\n        competency=Competency.from_xml(element[0]),\n        conditions=Conditions.from_xml(element[1]),\n        cvd_equations=tuple(cvd_equations),\n        equations=tuple(equations),\n        files=tuple(files),\n        deserialised=tuple(deserialised),\n        tables=tuple(tables),\n    )\n</code></pre>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the PerformanceCheck class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The PerformanceCheck as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [PerformanceCheck][msl.equipment.schema.PerformanceCheck] class into an XML element.\n\n    Returns:\n        The [PerformanceCheck][msl.equipment.schema.PerformanceCheck] as an XML element.\n    \"\"\"\n    a = {\"completedDate\": self.completed_date.isoformat(), \"enteredBy\": self.entered_by}\n    if self.checked_by:\n        a[\"checkedBy\"] = self.checked_by\n    if self.checked_date is not None:\n        a[\"checkedDate\"] = self.checked_date.isoformat()\n\n    e = Element(\"performanceCheck\", attrib=a)\n    e.append(self.competency.to_xml())\n    e.append(self.conditions)\n    e.extend(equation.to_xml() for equation in self.equations)\n    e.extend(table.to_xml() for table in self.tables)\n    e.extend(cvd.to_xml() for cvd in self.cvd_equations)\n    e.extend(file.to_xml() for file in self.files)\n    e.extend(deserialised.to_xml() for deserialised in self.deserialised)\n    return e\n</code></pre>"},{"location":"schema/planned_task/","title":"PlannedTask","text":""},{"location":"schema/planned_task/#msl.equipment.schema.PlannedTask","title":"PlannedTask  <code>dataclass</code>","text":"<pre><code>PlannedTask(\n    task: str, due_date: date, performed_by: str = \"\"\n)\n</code></pre> <p>Represents the plannedTask element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>str</code> <p>A description of the task that is planned.</p> required <code>due_date</code> <code>date</code> <p>The date that the planned maintenance task is due to be completed.</p> required <code>performed_by</code> <code>str</code> <p>The person or company that will perform the planned maintenance task.</p> <code>''</code>"},{"location":"schema/planned_task/#msl.equipment.schema.PlannedTask.due_date","title":"due_date  <code>instance-attribute</code>","text":"<pre><code>due_date: date\n</code></pre> <p>The date that the planned maintenance task is due to be completed.</p>"},{"location":"schema/planned_task/#msl.equipment.schema.PlannedTask.performed_by","title":"performed_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performed_by: str = ''\n</code></pre> <p>The person or company that will perform the planned maintenance task.</p>"},{"location":"schema/planned_task/#msl.equipment.schema.PlannedTask.task","title":"task  <code>instance-attribute</code>","text":"<pre><code>task: str\n</code></pre> <p>A description of the task that is planned.</p>"},{"location":"schema/planned_task/#msl.equipment.schema.PlannedTask.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; PlannedTask\n</code></pre> <p>Convert an XML element into a PlannedTask instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A plannedTask XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>PlannedTask</code> <p>The PlannedTask instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; PlannedTask:\n    \"\"\"Convert an XML element into a [PlannedTask][msl.equipment.schema.PlannedTask] instance.\n\n    Args:\n        element: A [plannedTask][type_plannedTask]{:target=\"_blank\"} XML element from an equipment register.\n\n    Returns:\n        The [PlannedTask][msl.equipment.schema.PlannedTask] instance.\n    \"\"\"\n    return cls(\n        task=element.text or \"\",\n        due_date=_date.fromisoformat(element.attrib[\"dueDate\"]),\n        performed_by=element.get(\"performedBy\", \"\"),\n    )\n</code></pre>"},{"location":"schema/planned_task/#msl.equipment.schema.PlannedTask.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the PlannedTask class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The PlannedTask as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [PlannedTask][msl.equipment.schema.PlannedTask] class into an XML element.\n\n    Returns:\n        The [PlannedTask][msl.equipment.schema.PlannedTask] as an XML element.\n    \"\"\"\n    attrib = {\"dueDate\": self.due_date.isoformat()}\n    if self.performed_by:\n        attrib[\"performedBy\"] = self.performed_by\n\n    e = Element(\"task\", attrib=attrib)\n    e.text = self.task\n    return e\n</code></pre>"},{"location":"schema/quality_manual/","title":"QualityManual","text":""},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual","title":"QualityManual  <code>dataclass</code>","text":"<pre><code>QualityManual(\n    accessories: Accessories = Accessories(),\n    documentation: str = \"\",\n    financial: Financial = Financial(),\n    personnel_restrictions: str = \"\",\n    service_agent: str = \"\",\n    technical_procedures: tuple[str, ...] = (),\n)\n</code></pre> <p>Represents the qualityManual element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>accessories</code> <code>Accessories</code> <p>Additional accessories that may be required to use the equipment.</p> <code>Accessories()</code> <code>documentation</code> <code>str</code> <p>Information (such as URLs) about the manuals, datasheets, etc. for the equipment.</p> <code>''</code> <code>financial</code> <code>Financial</code> <p>Financial information about the equipment.</p> <code>Financial()</code> <code>personnel_restrictions</code> <code>str</code> <p>Information about the people (or team) who are qualified to use the equipment.</p> <code>''</code> <code>service_agent</code> <code>str</code> <p>Information about the people or company that are qualified to perform alterations and/or maintenance to the equipment.</p> <code>''</code> <code>technical_procedures</code> <code>tuple[str, ...]</code> <p>The technical procedures that depend on this equipment.</p> <code>()</code>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.accessories","title":"accessories  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>accessories: Accessories = field(\n    default_factory=Accessories\n)\n</code></pre> <p>Additional accessories that may be required to use the equipment.</p>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.documentation","title":"documentation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>documentation: str = ''\n</code></pre> <p>Information (such as URLs) about the manuals, datasheets, etc. for the equipment.</p>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.financial","title":"financial  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>financial: Financial = field(default_factory=Financial)\n</code></pre> <p>Financial information about the equipment.</p>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.personnel_restrictions","title":"personnel_restrictions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>personnel_restrictions: str = ''\n</code></pre> <p>Information about the people (or team) who are qualified to use the equipment.</p>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.service_agent","title":"service_agent  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>service_agent: str = ''\n</code></pre> <p>Information about the people or company that are qualified to perform alterations and/or maintenance to the equipment.</p>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.technical_procedures","title":"technical_procedures  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>technical_procedures: tuple[str, ...] = ()\n</code></pre> <p>The technical procedures that depend on this equipment.</p>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; QualityManual\n</code></pre> <p>Convert an XML element into an QualityManual instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A qualityManual XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>QualityManual</code> <p>The QualityManual instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; QualityManual:\n    \"\"\"Convert an XML element into an [QualityManual][msl.equipment.schema.QualityManual] instance.\n\n    Args:\n        element: A [qualityManual][type_qualityManual]{:target=\"_blank\"} XML element from an equipment register.\n\n    Returns:\n        The [QualityManual][msl.equipment.schema.QualityManual] instance.\n    \"\"\"\n    # Schema defines &lt;qualityManual&gt; using xsd:all, which allows sub-elements to appear (or not appear) in any order\n    # Using str.endswith() allows for ignoring XML namespaces that may be associated with each tag\n    tp: tuple[str, ...] = ()\n    a, d, f, pr, sa = Accessories(), \"\", Financial(), \"\", \"\"\n    for child in element:\n        if child.tag.endswith(\"accessories\"):\n            a = Accessories.from_xml(child)\n        elif child.tag.endswith(\"documentation\"):\n            d = child.text or \"\"\n        elif child.tag.endswith(\"financial\"):\n            f = Financial.from_xml(child)\n        elif child.tag.endswith(\"personnelRestrictions\"):\n            pr = child.text or \"\"\n        elif child.tag.endswith(\"serviceAgent\"):\n            sa = child.text or \"\"\n        else:\n            tp = tuple(i.text for i in child if i.text)\n\n    return cls(\n        accessories=a,\n        documentation=d,\n        financial=f,\n        personnel_restrictions=pr,\n        service_agent=sa,\n        technical_procedures=tp,\n    )\n</code></pre>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the QualityManual class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The QualityManual as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [QualityManual][msl.equipment.schema.QualityManual] class into an XML element.\n\n    Returns:\n        The [QualityManual][msl.equipment.schema.QualityManual] as an XML element.\n    \"\"\"\n    e = Element(\"qualityManual\")\n\n    if len(self.accessories) or len(self.accessories.attrib):\n        e.append(self.accessories)\n\n    if self.documentation:\n        d = SubElement(e, \"documentation\")\n        d.text = self.documentation\n\n    if self.financial != Financial():\n        e.append(self.financial.to_xml())\n\n    if self.personnel_restrictions:\n        pr = SubElement(e, \"personnelRestrictions\")\n        pr.text = self.personnel_restrictions\n\n    if self.service_agent:\n        sa = SubElement(e, \"serviceAgent\")\n        sa.text = self.service_agent\n\n    if self.technical_procedures:\n        tp = SubElement(e, \"technicalProcedures\")\n        for procedure in self.technical_procedures:\n            sub = SubElement(tp, \"id\")\n            sub.text = procedure\n\n    return e\n</code></pre>"},{"location":"schema/reference_materials/","title":"ReferenceMaterials","text":""},{"location":"schema/reference_materials/#msl.equipment.schema.ReferenceMaterials","title":"ReferenceMaterials","text":"<pre><code>ReferenceMaterials(**attributes: str)\n</code></pre> <p>               Bases: <code>Any</code></p> <p>Documentation of reference materials, results, acceptance criteria, relevant dates and the period of validity.</p> <p>Since this class is currently represented by the any type in the XML Schema Definition, it is simply a subclass of Element. It may be updated to be a more specific class at a later date.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any]{:target=\"_blank\"} type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/reference_materials/#msl.equipment.schema.ReferenceMaterials.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str = 'referenceMaterials'\n</code></pre> <p>The element's name.</p>"},{"location":"schema/reference_materials/#msl.equipment.schema.ReferenceMaterials.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/register/","title":"Register","text":""},{"location":"schema/register/#msl.equipment.schema.Register","title":"Register","text":"<pre><code>Register(*sources: XMLSource)\n</code></pre> <p>Represents the register element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>XMLSource</code> <p>The path-like or file-like objects that are equipment registers. Specifying multiple sources allows for storing an equipment register across multiple files for the same team.</p> <code>()</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, *sources: XMLSource) -&gt; None:\n    \"\"\"Represents the [register][element_register]{:target=\"_blank\"} element in an equipment register.\n\n    Args:\n        sources: The [path-like][path-like object]{:target=\"_blank\"} or\n            [file-like][file-like object]{:target=\"_blank\"} objects that are equipment registers.\n            Specifying multiple sources allows for storing an equipment register across multiple\n            files for the same team.\n    \"\"\"\n    team = \"\"\n    self._elements: list[Element[str]] = []\n    for source in sources:\n        root = ElementTree().parse(source)\n        t = root.attrib.get(\"team\", \"\")\n        if not team:\n            team = t\n\n        if team != t:\n            msg = f\"Cannot merge equipment registers from different teams, {team!r} != {t!r}\"\n            raise ValueError(msg)\n\n        self._elements.extend(child for child in root)\n\n    self._team: str = team\n    self._equipment: list[Equipment | None] = [None] * len(self._elements)\n\n    # a mapping between the alias/id and the index number in the register\n    self._index_map: dict[str, int] = {\n        e.attrib[\"alias\"]: i for i, e in enumerate(self._elements) if e.attrib.get(\"alias\")\n    }\n    self._index_map.update({e[0].text or \"\": i for i, e in enumerate(self._elements)})\n</code></pre>"},{"location":"schema/register/#msl.equipment.schema.Register.NAMESPACE","title":"NAMESPACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NAMESPACE: str = (\n    \"https://measurement.govt.nz/equipment-register\"\n)\n</code></pre> <p>Default XML namespace.</p>"},{"location":"schema/register/#msl.equipment.schema.Register.team","title":"team  <code>property</code> <code>writable</code>","text":"<pre><code>team: str\n</code></pre> <p>str \u2014 The name of the team that is responsible for the equipment register.</p>"},{"location":"schema/register/#msl.equipment.schema.Register.add","title":"add","text":"<pre><code>add(equipment: Equipment) -&gt; None\n</code></pre> <p>Add equipment to the register.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>The equipment to add.</p> required Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def add(self, equipment: Equipment) -&gt; None:\n    \"\"\"Add equipment to the register.\n\n    Args:\n        equipment: The equipment to add.\n    \"\"\"\n    if equipment.id:\n        self._index_map[equipment.id] = len(self._equipment)\n    if equipment.alias:\n        self._index_map[equipment.alias] = len(self._equipment)\n    self._equipment.append(equipment)\n</code></pre>"},{"location":"schema/register/#msl.equipment.schema.Register.find","title":"find","text":"<pre><code>find(\n    pattern: str | Pattern[str], *, flags: int = 0\n) -&gt; Iterator[Equipment]\n</code></pre> <p>Find equipment in the register.</p> <p>The following attributes are used in the search:</p> <ul> <li>keywords: Equipment</li> <li>description: Equipment</li> <li>manufacturer: Equipment</li> <li>model: Equipment</li> <li>serial: Equipment</li> <li>id: Equipment, Report, DigitalReport</li> <li>location: Equipment</li> <li>quantity: Measurand</li> <li>name: Component</li> <li>entered_by: Equipment, PerformanceCheck, Report</li> <li>checked_by: Equipment, PerformanceCheck, Report</li> <li>performed_by: Alteration, CompletedTask, PlannedTask</li> <li>comment: CVDEquation, Equation, File, Table, Deserialised, DigitalReport</li> <li>format: DigitalReport</li> <li>details: Alteration, Adjustment</li> <li>task: CompletedTask, PlannedTask</li> <li>asset_number: Financial</li> <li>service_agent: QualityManual</li> <li>technical_procedures: QualityManual</li> </ul> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str | Pattern[str]</code> <p>A regular-expression pattern to use to find equipment.</p> required <code>flags</code> <code>int</code> <p>The flags to use to compile the <code>pattern</code>. See re.compile for more details.</p> <code>0</code> <p>Yields:</p> Type Description <code>Equipment</code> <p>Equipment that match the <code>pattern</code>.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def find(self, pattern: str | re.Pattern[str], *, flags: int = 0) -&gt; Iterator[Equipment]:  # noqa: C901\n    \"\"\"Find equipment in the register.\n\n    The following attributes are used in the search:\n\n    * keywords: [Equipment][msl.equipment.schema.Equipment]\n    * description: [Equipment][msl.equipment.schema.Equipment]\n    * manufacturer: [Equipment][msl.equipment.schema.Equipment]\n    * model: [Equipment][msl.equipment.schema.Equipment]\n    * serial: [Equipment][msl.equipment.schema.Equipment]\n    * id: [Equipment][msl.equipment.schema.Equipment], [Report][msl.equipment.schema.Report], [DigitalReport][msl.equipment.schema.DigitalReport]\n    * location: [Equipment][msl.equipment.schema.Equipment]\n    * quantity: [Measurand][msl.equipment.schema.Measurand]\n    * name: [Component][msl.equipment.schema.Component]\n    * entered_by: [Equipment][msl.equipment.schema.Equipment], [PerformanceCheck][msl.equipment.schema.PerformanceCheck], [Report][msl.equipment.schema.Report]\n    * checked_by: [Equipment][msl.equipment.schema.Equipment], [PerformanceCheck][msl.equipment.schema.PerformanceCheck], [Report][msl.equipment.schema.Report]\n    * performed_by: [Alteration][msl.equipment.schema.Alteration], [CompletedTask][msl.equipment.schema.CompletedTask], [PlannedTask][msl.equipment.schema.PlannedTask]\n    * comment: [CVDEquation][msl.equipment.schema.CVDEquation], [Equation][msl.equipment.schema.Equation], [File][msl.equipment.schema.File], [Table][msl.equipment.schema.Table], [Deserialised][msl.equipment.schema.Deserialised], [DigitalReport][msl.equipment.schema.DigitalReport]\n    * format: [DigitalReport][msl.equipment.schema.DigitalReport]\n    * details: [Alteration][msl.equipment.schema.Alteration], [Adjustment][msl.equipment.schema.Adjustment]\n    * task: [CompletedTask][msl.equipment.schema.CompletedTask], [PlannedTask][msl.equipment.schema.PlannedTask]\n    * asset_number: [Financial][msl.equipment.schema.Financial]\n    * service_agent: [QualityManual][msl.equipment.schema.QualityManual]\n    * technical_procedures: [QualityManual][msl.equipment.schema.QualityManual]\n\n    Args:\n        pattern: A [regular-expression pattern](https://regexr.com/){:target=\"_blank\"} to use to find equipment.\n        flags: The flags to use to compile the `pattern`. See [re.compile][]{:target=\"_blank\"} for more details.\n\n    Yields:\n        Equipment that match the `pattern`.\n    \"\"\"  # noqa: E501\n\n    def comment_search(item: Report | PerformanceCheck) -&gt; bool:\n        for cvd_equation in item.cvd_equations:\n            if regex.search(cvd_equation.comment) is not None:\n                return True\n        for equation in item.equations:\n            if regex.search(equation.comment) is not None:\n                return True\n        for file in item.files:\n            if regex.search(file.comment) is not None:\n                return True\n        for table in item.tables:\n            if regex.search(table.comment) is not None:\n                return True\n        return any(regex.search(deserialised.comment) is not None for deserialised in item.deserialised)\n\n    def task_search(m: Maintenance) -&gt; bool:\n        for c in m.completed:\n            if regex.search(c.task) is not None:\n                return True\n            if regex.search(c.performed_by) is not None:\n                return True\n        for p in m.planned:\n            if regex.search(p.task) is not None:\n                return True\n            if regex.search(p.performed_by) is not None:\n                return True\n        return False\n\n    def alteration_search(alterations: tuple[Alteration, ...]) -&gt; bool:\n        for a in alterations:\n            if regex.search(a.details) is not None:\n                return True\n            if regex.search(a.performed_by) is not None:\n                return True\n        return False\n\n    def calibrations_search(e: Equipment) -&gt; bool:  # noqa: C901, PLR0911, PLR0912\n        for m in e.calibrations:\n            if regex.search(m.quantity) is not None:\n                return True\n            for c in m.components:\n                if regex.search(c.name) is not None:\n                    return True\n                for r in c.reports:\n                    if regex.search(r.entered_by) is not None:\n                        return True\n                    if regex.search(r.checked_by) is not None:\n                        return True\n                    if comment_search(r):\n                        return True\n                    if regex.search(r.id) is not None:\n                        return True\n                for pc in c.performance_checks:\n                    if regex.search(pc.entered_by) is not None:\n                        return True\n                    if regex.search(pc.checked_by) is not None:\n                        return True\n                    if comment_search(pc):\n                        return True\n                for a in c.adjustments:\n                    if regex.search(a.details) is not None:\n                        return True\n                for dr in c.digital_reports:\n                    if regex.search(dr.format.value) is not None:\n                        return True\n                    if regex.search(dr.id) is not None:\n                        return True\n                    if regex.search(dr.comment) is not None:\n                        return True\n        return False\n\n    regex = re.compile(pattern, flags=flags)\n    for equipment in self:\n        if (\n            regex.search(\" \".join(equipment.keywords)) is not None\n            or regex.search(equipment.description) is not None\n            or regex.search(equipment.manufacturer) is not None\n            or regex.search(equipment.model) is not None\n            or regex.search(equipment.serial) is not None\n            or regex.search(equipment.id) is not None\n            or regex.search(equipment.location) is not None\n            or regex.search(equipment.entered_by) is not None\n            or regex.search(equipment.checked_by) is not None\n            or calibrations_search(equipment)\n            or alteration_search(equipment.alterations)\n            or task_search(equipment.maintenance)\n            or regex.search(equipment.quality_manual.financial.asset_number) is not None\n            or regex.search(equipment.quality_manual.service_agent) is not None\n            or regex.search(\" \".join(equipment.quality_manual.technical_procedures)) is not None\n        ):\n            yield equipment\n</code></pre>"},{"location":"schema/register/#msl.equipment.schema.Register.tree","title":"tree","text":"<pre><code>tree(\n    namespace: str | None = \"DEFAULT\", indent: int = 4\n) -&gt; ElementTree[Element[str]]\n</code></pre> <p>Convert the Register class into an XML element tree.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str | None</code> <p>The namespace to associate with the root element. If the value is <code>DEFAULT</code>, uses the value of NAMESPACE as the namespace. If <code>None</code>, or an empty string, no namespace is associated with the root element.</p> <code>'DEFAULT'</code> <code>indent</code> <code>int</code> <p>The number of spaces to indent sub elements. The value must be \u2265 0. This parameter is ignored if the version of Python is &lt; 3.9.</p> <code>4</code> <p>Returns:</p> Type Description <code>ElementTree[Element[str]]</code> <p>The Register as an ElementTree.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def tree(self, namespace: str | None = \"DEFAULT\", indent: int = 4) -&gt; ElementTree[Element[str]]:\n    \"\"\"Convert the [Register][msl.equipment.schema.Register] class into an XML element tree.\n\n    Args:\n        namespace: The namespace to associate with the root element. If the value is\n            `DEFAULT`, uses the value of [NAMESPACE][msl.equipment.schema.Register.NAMESPACE]\n            as the namespace. If `None`, or an empty string, no namespace is associated\n            with the root element.\n        indent: The number of spaces to indent sub elements. The value must be &amp;ge; 0.\n            This parameter is ignored if the version of Python is &amp;lt; 3.9.\n\n    Returns:\n        The [Register][msl.equipment.schema.Register] as an\n            [ElementTree][xml.etree.ElementTree.ElementTree]{:target=\"_blank\"}.\n    \"\"\"\n    if indent &lt; 0:\n        msg = f\"Indentation must be &gt;= 0, got {indent}\"\n        raise ValueError(msg)\n\n    attrib = {\"team\": self.team}\n    if namespace:\n        if namespace == \"DEFAULT\":\n            namespace = self.NAMESPACE\n        attrib[\"xmlns\"] = namespace\n\n    # The &lt;table&gt;&lt;data&gt; element is 7 levels deep from &lt;register&gt;\n    _Indent.table_data = (7 * indent) + len(\"&lt;data&gt;\")\n\n    e = Element(\"register\", attrib=attrib)\n    e.extend(equipment.to_xml() for equipment in self)\n    tree: ElementTree[Element[str]] = ElementTree(element=e)\n\n    if indent &gt; 0 and sys.version_info &gt;= (3, 9):\n        from xml.etree.ElementTree import indent as pretty  # noqa: PLC0415\n\n        pretty(tree, space=\" \" * indent)\n\n    return tree\n</code></pre>"},{"location":"schema/report/","title":"Report","text":""},{"location":"schema/report/#msl.equipment.schema.Report","title":"Report  <code>dataclass</code>","text":"<pre><code>Report(\n    id: str,\n    entered_by: str,\n    report_issue_date: date,\n    measurement_start_date: date,\n    measurement_stop_date: date,\n    issuing_laboratory: IssuingLaboratory = IssuingLaboratory(),\n    technical_procedure: str = \"\",\n    checked_by: str = \"\",\n    checked_date: date | None = None,\n    conditions: Conditions = Conditions(),\n    acceptance_criteria: AcceptanceCriteria = AcceptanceCriteria(),\n    cvd_equations: tuple[CVDEquation, ...] = (),\n    equations: tuple[Equation, ...] = (),\n    files: tuple[File, ...] = (),\n    deserialised: tuple[Deserialised, ...] = (),\n    tables: tuple[Table, ...] = (),\n)\n</code></pre> <p>Represents the report element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The report identification number.</p> required <code>entered_by</code> <code>str</code> <p>The name of the person who initially entered the <code>&lt;report&gt;</code> element in the register.</p> required <code>report_issue_date</code> <code>date</code> <p>The date that the report was issued.</p> required <code>measurement_start_date</code> <code>date</code> <p>The date that the calibration measurement started.</p> required <code>measurement_stop_date</code> <code>date</code> <p>The date that the calibration measurement stopped.</p> required <code>issuing_laboratory</code> <code>IssuingLaboratory</code> <p>Information about the laboratory that issued the calibration report.</p> <code>IssuingLaboratory()</code> <code>technical_procedure</code> <code>str</code> <p>The technical procedure(s) that was(were) followed to perform the calibration.</p> <code>''</code> <code>checked_by</code> <code>str</code> <p>The name of the person who checked the information in the <code>&lt;report&gt;</code> element.</p> <code>''</code> <code>checked_date</code> <code>date | None</code> <p>The date that the information in the <code>&lt;report&gt;</code> element was last checked.</p> <code>None</code> <code>conditions</code> <code>Conditions</code> <p>The conditions under which the report is valid.</p> <code>Conditions()</code> <code>acceptance_criteria</code> <code>AcceptanceCriteria</code> <p>Acceptance criteria for the calibration report.</p> <code>AcceptanceCriteria()</code> <code>cvd_equations</code> <code>tuple[CVDEquation, ...]</code> <p>Calibration data is expressed as coefficients for the Callendar-Van Dusen equation.</p> <code>()</code> <code>equations</code> <code>tuple[Equation, ...]</code> <p>Calibration data is expressed as an equation.</p> <code>()</code> <code>files</code> <code>tuple[File, ...]</code> <p>Calibration data is stored in another file (not in the equipment register).</p> <code>()</code> <code>deserialised</code> <code>tuple[Deserialised, ...]</code> <p>Calibration data is stored in a serialised format and deserialised.</p> <code>()</code> <code>tables</code> <code>tuple[Table, ...]</code> <p>Calibration data is expressed as a CSV table in the equipment register.</p> <code>()</code>"},{"location":"schema/report/#msl.equipment.schema.Report.acceptance_criteria","title":"acceptance_criteria  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acceptance_criteria: AcceptanceCriteria = field(\n    default_factory=AcceptanceCriteria\n)\n</code></pre> <p>Acceptance criteria for the calibration report.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.checked_by","title":"checked_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_by: str = ''\n</code></pre> <p>The name of the person who checked the information in the <code>&lt;report&gt;</code> element.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.checked_date","title":"checked_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_date: date | None = None\n</code></pre> <p>The date that the information in the <code>&lt;report&gt;</code> element was last checked.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.conditions","title":"conditions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>conditions: Conditions = field(default_factory=Conditions)\n</code></pre> <p>The conditions under which the report is valid.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.cvd_equations","title":"cvd_equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cvd_equations: tuple[CVDEquation, ...] = ()\n</code></pre> <p>Calibration data is expressed as coefficients for the Callendar-Van Dusen equation.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.deserialised","title":"deserialised  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>deserialised: tuple[Deserialised, ...] = ()\n</code></pre> <p>Calibration data is stored in a serialised format and deserialised.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.entered_by","title":"entered_by  <code>instance-attribute</code>","text":"<pre><code>entered_by: str\n</code></pre> <p>The name of the person who initially entered the <code>&lt;report&gt;</code> element in the register.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.equations","title":"equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>equations: tuple[Equation, ...] = ()\n</code></pre> <p>Calibration data is expressed as an equation.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.files","title":"files  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>files: tuple[File, ...] = ()\n</code></pre> <p>Calibration data is stored in another file (not in the equipment register).</p>"},{"location":"schema/report/#msl.equipment.schema.Report.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>The report identification number.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.issuing_laboratory","title":"issuing_laboratory  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>issuing_laboratory: IssuingLaboratory = field(\n    default_factory=IssuingLaboratory\n)\n</code></pre> <p>Information about the laboratory that issued the calibration report.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.measurement_start_date","title":"measurement_start_date  <code>instance-attribute</code>","text":"<pre><code>measurement_start_date: date\n</code></pre> <p>The date that the calibration measurement started.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.measurement_stop_date","title":"measurement_stop_date  <code>instance-attribute</code>","text":"<pre><code>measurement_stop_date: date\n</code></pre> <p>The date that the calibration measurement stopped.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.report_issue_date","title":"report_issue_date  <code>instance-attribute</code>","text":"<pre><code>report_issue_date: date\n</code></pre> <p>The date that the report was issued.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.tables","title":"tables  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tables: tuple[Table, ...] = ()\n</code></pre> <p>Calibration data is expressed as a CSV table in the equipment register.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.technical_procedure","title":"technical_procedure  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>technical_procedure: str = ''\n</code></pre> <p>The technical procedure(s) that was(were) followed to perform the calibration.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Report\n</code></pre> <p>Convert an XML element into a Report instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A report XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Report</code> <p>The Report instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Report:\n    \"\"\"Convert an XML element into a [Report][msl.equipment.schema.Report] instance.\n\n    Args:\n        element: A [report][type_report]{:target=\"_blank\"} XML element from an equipment register.\n\n    Returns:\n        The [Report][msl.equipment.schema.Report] instance.\n    \"\"\"\n    # Schema forces order until `acceptanceCriteria` and then uses xsd:choice, which\n    # allows sub-elements to appear (or not appear) in any order, for the data elements.\n    # Using str.endswith() allows for ignoring XML namespaces that may be associated with each tag\n    cvd_equations: list[CVDEquation] = []\n    equations: list[Equation] = []\n    files: list[File] = []\n    deserialised: list[Deserialised] = []\n    tables: list[Table] = []\n    for child in element[7:]:\n        tag = child.tag\n        if tag.endswith(\"equation\"):\n            equations.append(Equation.from_xml(child))\n        elif tag.endswith(\"table\"):\n            tables.append(Table.from_xml(child))\n        elif tag.endswith(\"cvdCoefficients\"):\n            cvd_equations.append(CVDEquation.from_xml(child))\n        elif tag.endswith(\"file\"):\n            files.append(File.from_xml(child))\n        else:\n            deserialised.append(Deserialised.from_xml(child))\n\n    a = element.attrib\n    return cls(\n        id=a[\"id\"] or \"\",\n        entered_by=a[\"enteredBy\"] or \"\",\n        checked_by=a.get(\"checkedBy\", \"\"),\n        checked_date=None if not a.get(\"checkedDate\") else _date.fromisoformat(a[\"checkedDate\"]),\n        report_issue_date=_date.fromisoformat(element[0].text or \"\"),\n        measurement_start_date=_date.fromisoformat(element[1].text or \"\"),\n        measurement_stop_date=_date.fromisoformat(element[2].text or \"\"),\n        issuing_laboratory=IssuingLaboratory.from_xml(element[3]),\n        technical_procedure=element[4].text or \"\",\n        conditions=Conditions.from_xml(element[5]),\n        acceptance_criteria=AcceptanceCriteria.from_xml(element[6]),\n        cvd_equations=tuple(cvd_equations),\n        equations=tuple(equations),\n        files=tuple(files),\n        deserialised=tuple(deserialised),\n        tables=tuple(tables),\n    )\n</code></pre>"},{"location":"schema/report/#msl.equipment.schema.Report.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Report class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Report as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Report][msl.equipment.schema.Report] class into an XML element.\n\n    Returns:\n        The [Report][msl.equipment.schema.Report] as an XML element.\n    \"\"\"\n    a = {\"id\": self.id, \"enteredBy\": self.entered_by}\n    if self.checked_by:\n        a[\"checkedBy\"] = self.checked_by\n    if self.checked_date is not None:\n        a[\"checkedDate\"] = self.checked_date.isoformat()\n\n    e = Element(\"report\", attrib=a)\n\n    rid = SubElement(e, \"reportIssueDate\")\n    rid.text = self.report_issue_date.isoformat()\n\n    start = SubElement(e, \"measurementStartDate\")\n    start.text = self.measurement_start_date.isoformat()\n\n    stop = SubElement(e, \"measurementStopDate\")\n    stop.text = self.measurement_stop_date.isoformat()\n\n    e.append(self.issuing_laboratory.to_xml())\n\n    tp = SubElement(e, \"technicalProcedure\")\n    tp.text = self.technical_procedure\n\n    e.append(self.conditions)\n    e.append(self.acceptance_criteria)\n    e.extend(equation.to_xml() for equation in self.equations)\n    e.extend(table.to_xml() for table in self.tables)\n    e.extend(cvd.to_xml() for cvd in self.cvd_equations)\n    e.extend(file.to_xml() for file in self.files)\n    e.extend(deserialised.to_xml() for deserialised in self.deserialised)\n    return e\n</code></pre>"},{"location":"schema/report/#msl.equipment.schema.IssuingLaboratory","title":"IssuingLaboratory  <code>dataclass</code>","text":"<pre><code>IssuingLaboratory(lab: str = '', person: str = '')\n</code></pre> <p>Information about the laboratory that issued a calibration report.</p> <p>Parameters:</p> Name Type Description Default <code>lab</code> <code>str</code> <p>The name of the laboratory that issued the calibration report.</p> <code>''</code> <code>person</code> <code>str</code> <p>The name of a person at the <code>laboratory</code> that authorised the report.</p> <code>''</code>"},{"location":"schema/report/#msl.equipment.schema.IssuingLaboratory.lab","title":"lab  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lab: str = ''\n</code></pre> <p>The name of the laboratory that issued the calibration report.</p>"},{"location":"schema/report/#msl.equipment.schema.IssuingLaboratory.person","title":"person  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>person: str = ''\n</code></pre> <p>The name of a person at the laboratory that authorised the report.</p>"},{"location":"schema/report/#msl.equipment.schema.IssuingLaboratory.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; IssuingLaboratory\n</code></pre> <p>Convert an XML element into a IssuingLaboratory instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An <code>&lt;issuingLaboratory&gt;</code> element from a report element in an equipment register.</p> required <p>Returns:</p> Type Description <code>IssuingLaboratory</code> <p>The IssuingLaboratory instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; IssuingLaboratory:\n    \"\"\"Convert an XML element into a [IssuingLaboratory][msl.equipment.schema.IssuingLaboratory] instance.\n\n    Args:\n        element: An `&lt;issuingLaboratory&gt;` element from a [report][type_report]{:target=\"_blank\"} element\n            in an equipment register.\n\n    Returns:\n        The [IssuingLaboratory][msl.equipment.schema.IssuingLaboratory] instance.\n    \"\"\"\n    return cls(\n        lab=element.text or \"\",\n        person=element.attrib.get(\"person\", \"\"),\n    )\n</code></pre>"},{"location":"schema/report/#msl.equipment.schema.IssuingLaboratory.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the IssuingLaboratory class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The IssuingLaboratory as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [IssuingLaboratory][msl.equipment.schema.IssuingLaboratory] class into an XML element.\n\n    Returns:\n        The [IssuingLaboratory][msl.equipment.schema.IssuingLaboratory] as an XML element.\n    \"\"\"\n    a = {\"person\": self.person} if self.person else {}\n    e = Element(\"issuingLaboratory\", attrib=a)\n    e.text = self.lab\n    return e\n</code></pre>"},{"location":"schema/specifications/","title":"Specifications","text":""},{"location":"schema/specifications/#msl.equipment.schema.Specifications","title":"Specifications","text":"<pre><code>Specifications(**attributes: str)\n</code></pre> <p>               Bases: <code>Any</code></p> <p>Specifications provided by the manufacturer of the equipment.</p> <p>Typically, the specifications are specified on the website, datasheet and/or technical notes that a manufacturer provides.</p> <p>Since this class is currently represented by the any type in the XML Schema Definition, it is simply a subclass of Element. It may be updated to be a more specific class at a later date.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any]{:target=\"_blank\"} type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/specifications/#msl.equipment.schema.Specifications.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str = 'specifications'\n</code></pre> <p>The element's name.</p>"},{"location":"schema/specifications/#msl.equipment.schema.Specifications.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/specified_requirements/","title":"SpecifiedRequirements","text":""},{"location":"schema/specified_requirements/#msl.equipment.schema.SpecifiedRequirements","title":"SpecifiedRequirements","text":"<pre><code>SpecifiedRequirements(**attributes: str)\n</code></pre> <p>               Bases: <code>Any</code></p> <p>Verification that equipment conforms with specified requirements before being placed or returned into service.</p> <p>Since this class is currently represented by the any type in the XML Schema Definition, it is simply a subclass of Element. It may be updated to be a more specific class at a later date.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any]{:target=\"_blank\"} type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/specified_requirements/#msl.equipment.schema.SpecifiedRequirements.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str = 'specifiedRequirements'\n</code></pre> <p>The element's name.</p>"},{"location":"schema/specified_requirements/#msl.equipment.schema.SpecifiedRequirements.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/status/","title":"Status","text":""},{"location":"schema/status/#msl.equipment.schema.Status","title":"Status","text":"<p>               Bases: <code>Enum</code></p> <p>Represents the status enumeration in an equipment register.</p> <p>Attributes:</p> Name Type Description <code>Active</code> <code>str</code> <p>The equipment is operable and may be used.</p> <code>Damaged</code> <code>str</code> <p>The equipment is damaged and is no longer usable.</p> <code>Disposed</code> <code>str</code> <p>The equipment has been disposed of and is no longer at available (e.g., the equipment was sent to the landfill or to be recycled).</p> <code>Dormant</code> <code>str</code> <p>The equipment is still operable, it is no longer in use but may be used again (e.g., the equipment was replaced with a newer model, and it is kept as a backup).</p> <code>Lost</code> <code>str</code> <p>The equipment is lost, but if found may be put back into service.</p> <code>Retired</code> <code>str</code> <p>The equipment is still operable, but there are no intentions of using it again (e.g., the equipment depends on other equipment that is not available or is no longer manufactured).</p>"},{"location":"schema/table/","title":"Table","text":"<p>Suppose you have a variable named <code>table</code> (which is an instance of Table) that represents the following information in an equipment register for equipment that measures spectral irradiance</p> <pre><code>&lt;table comment=\"Spectral\"&gt;\n  &lt;type&gt;   int       ,    double ,    double     &lt;/type&gt;\n  &lt;unit&gt;   nm        ,    W/m^2  ,    W/m^2      &lt;/unit&gt;\n  &lt;header&gt; Wavelength, Irradiance, u(Irradiance) &lt;/header&gt;\n  &lt;data&gt;   250       ,    0.01818,   0.02033\n           300       ,    0.18478,   0.01755\n           350       ,    0.80845,   0.01606\n           400       ,    2.21355,   0.01405\n           450       ,    4.49004,   0.01250\n           500       ,    7.45135,   0.01200\n           550       ,   10.75753,   0.01152\n           600       ,   14.03809,   0.01102\n           650       ,   16.99469,   0.01103\n           700       ,   19.44093,   0.01077\n  &lt;/data&gt;\n&lt;/table&gt;\n</code></pre> <p>The <code>table</code> instance is a numpy structured array that has the header values as the field name of each column</p> <pre><code>&gt;&gt;&gt; table.header\narray(['Wavelength', 'Irradiance', 'u(Irradiance)'], dtype='&lt;U13')\n&gt;&gt;&gt; table[\"Wavelength\"]\nTable([250, 300, 350, 400, 450, 500, 550, 600, 650, 700])\n&gt;&gt;&gt; table.types[\"Irradiance\"]\narray(dtype('float64'), dtype=object)\n&gt;&gt;&gt; assert table.units[\"u(Irradiance)\"] == \"W/m^2\"\n</code></pre> <p>Since <code>table</code> is a numpy array, you can index it</p> <pre><code>&gt;&gt;&gt; print(table[0])\n(250, 0.01818, 0.02033)\n&gt;&gt;&gt; sliced=table[:3]\n&gt;&gt;&gt; print(sliced)\n[(250, 0.01818, 0.02033) (300, 0.18478, 0.01755) (350, 0.80845, 0.01606)]\n</code></pre> <p>and notice that the returned instance fo <code>sliced</code> is another Table instance, so the attributes of Table are available</p> <pre><code>&gt;&gt;&gt; sliced.comment\n'Spectral'\n</code></pre> <p>as well as perform mathematical operations and call numpy functions directly with the <code>table</code> instance</p> <pre><code>&gt;&gt;&gt; np.cos(1 + table[\"Irradiance\"])\nTable([ 0.52491592,  0.37650087, -0.2354229 , -0.99741219,  0.70160756,\n       -0.56246854,  0.6903377 , -0.78390036,  0.65631968, -0.0205763 ])\n</code></pre> <p>Suppose you wanted to get all Irradiance values in the table that are for UV light (i.e., wavelengths &lt; 400 nm)</p> <pre><code>&gt;&gt;&gt; table[\"Irradiance\"][ table[\"Wavelength\"] &lt; 400 ]\nTable([0.01818, 0.18478, 0.80845])\n</code></pre> <p>If you prefer to work with unstructured data, you can convert the <code>table</code> by calling the unstructured method</p> <pre><code>&gt;&gt;&gt; unstructured = table.unstructured()\n&gt;&gt;&gt; unstructured\nTable([[2.500000e+02, 1.818000e-02, 2.033000e-02],\n       [3.000000e+02, 1.847800e-01, 1.755000e-02],\n       [3.500000e+02, 8.084500e-01, 1.606000e-02],\n       [4.000000e+02, 2.213550e+00, 1.405000e-02],\n       [4.500000e+02, 4.490040e+00, 1.250000e-02],\n       [5.000000e+02, 7.451350e+00, 1.200000e-02],\n       [5.500000e+02, 1.075753e+01, 1.152000e-02],\n       [6.000000e+02, 1.403809e+01, 1.102000e-02],\n       [6.500000e+02, 1.699469e+01, 1.103000e-02],\n       [7.000000e+02, 1.944093e+01, 1.077000e-02]])\n&gt;&gt;&gt; print(unstructured[0, 0])\n250.0\n</code></pre>"},{"location":"schema/table/#msl.equipment.schema.Table","title":"Table","text":"<p>               Bases: <code>ndarray</code></p> <p>Represents the table element in an equipment register.</p>"},{"location":"schema/table/#msl.equipment.schema.Table.comment","title":"comment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comment: str = ''\n</code></pre> <p>A comment that is associated with the table.</p>"},{"location":"schema/table/#msl.equipment.schema.Table.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header: NDArray[void] = empty(0, dtype=object)\n</code></pre> <p>The header value of each column.</p>"},{"location":"schema/table/#msl.equipment.schema.Table.types","title":"types  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>types: NDArray[void] = empty(0, dtype=object)\n</code></pre> <p>The data type of each column.</p>"},{"location":"schema/table/#msl.equipment.schema.Table.units","title":"units  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>units: NDArray[void] = empty(0, dtype=object)\n</code></pre> <p>The unit of each column.</p>"},{"location":"schema/table/#msl.equipment.schema.Table.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Table\n</code></pre> <p>Convert an XML element into a Table instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A table XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Table</code> <p>A Table is an subclass of a numpy structured array, where the <code>header</code> is used as the field names. This allows for accessing a column by the header value rather than by the index of a column. If you prefer to work with unstructured data, call unstructured on the returned object.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Table:\n    \"\"\"Convert an XML element into a [Table][msl.equipment.schema.Table] instance.\n\n    Args:\n        element: A [table][type_table]{:target=\"_blank\"} XML element from an equipment register.\n\n    Returns:\n        A [Table][msl.equipment.schema.Table] is an subclass of a numpy\n            [structured array][structured_arrays]{:target=\"_blank\"}, where the `header` is used as\n            the *field names*. This allows for accessing a column by the header value rather than by\n            the index of a column. If you prefer to work with unstructured data, call\n            [unstructured][msl.equipment.schema.Table.unstructured] on the returned object.\n    \"\"\"\n    booleans = {\"True\", \"true\", \"TRUE\", \"1\", b\"True\", b\"true\", b\"TRUE\", b\"1\"}\n\n    def convert_bool(value: str | bytes) -&gt; bool:\n        # the value can be of type bytes for numpy &lt; 2.0\n        return value.strip() in booleans\n\n    def strip_string(value: str | bytes) -&gt; str:\n        # the value can be of type bytes for numpy &lt; 2.0\n        stripped = value.strip()\n        if isinstance(stripped, bytes):\n            return stripped.decode()  # pragma: no cover\n        return stripped\n\n    # Schema forces order\n    _type = [s.strip() for s in (element[0].text or \"\").split(\",\")]\n    _unit = [s.strip() for s in (element[1].text or \"\").split(\",\")]\n    _header = [s.strip() for s in (element[2].text or \"\").split(\",\")]\n    _file = StringIO((element[3].text or \"\").strip())\n\n    # must handle boolean column and string column separately\n    conv: dict[int, Callable[[str | bytes], str | bool]] = {\n        i: convert_bool for i, v in enumerate(_type) if v == \"bool\"\n    }\n    conv.update({i: strip_string for i, v in enumerate(_type) if v == \"string\"})\n\n    dtype = np.dtype([(h, schema_numpy_map[t]) for h, t in zip(_header, _type)])\n    data = np.loadtxt(_file, dtype=dtype, delimiter=\",\", converters=conv)  # type: ignore[arg-type]  # pyright: ignore[reportCallIssue, reportArgumentType, reportUnknownVariableType]\n    data.setflags(write=False)  # pyright: ignore[reportUnknownMemberType]\n\n    header = np.asarray(_header)\n    header.setflags(write=False)  # make it readonly by default\n\n    units = np.asarray(tuple(_unit), np.dtype([(h, object) for h in _header]))\n    units.setflags(write=False)  # make it readonly by default\n\n    assert data.dtype.fields is not None  # pyright: ignore[reportUnknownMemberType]  # noqa: S101\n    types = np.asarray(tuple(v[0] for v in data.dtype.fields.values()), dtype=[(h, object) for h in _header])  # pyright: ignore[reportUnknownMemberType, reportUnknownVariableType, reportUnknownArgumentType]\n    types.setflags(write=False)  # make it readonly by default\n\n    return cls(types=types, units=units, header=header, data=data, comment=element.attrib.get(\"comment\", \"\"))  # pyright: ignore[reportUnknownArgumentType]\n</code></pre>"},{"location":"schema/table/#msl.equipment.schema.Table.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Table class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Table as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Table][msl.equipment.schema.Table] class into an XML element.\n\n    Returns:\n        The [Table][msl.equipment.schema.Table] as an XML element.\n    \"\"\"\n    attrib = {\"comment\": self.comment} if self.comment else {}\n    e = Element(\"table\", attrib=attrib)\n\n    types = SubElement(e, \"type\")\n    dtypes = [numpy_schema_map[t.char] for t in self.types.tolist()]\n    types.text = \",\".join(dtypes)\n\n    units = SubElement(e, \"unit\")\n    units.text = \",\".join(self.units.tolist())\n\n    header = SubElement(e, \"header\")\n    header.text = \",\".join(self.header)\n\n    buffer = StringIO()\n    newline = \"\\n\" + \" \" * _Indent.table_data\n    np.savetxt(buffer, self, fmt=\"%s\", delimiter=\",\", newline=newline)\n    data = SubElement(e, \"data\")\n    data.text = buffer.getvalue().rstrip() + \"\\n\" + \" \" * max(0, _Indent.table_data - len(\"&lt;data&gt;\"))\n\n    return e\n</code></pre>"},{"location":"schema/table/#msl.equipment.schema.Table.unstructured","title":"unstructured","text":"<pre><code>unstructured(\n    *,\n    dtype: DTypeLike = None,\n    copy: bool = False,\n    casting: Literal[\n        \"no\", \"equiv\", \"safe\", \"same_kind\", \"unsafe\"\n    ] = \"unsafe\"\n) -&gt; NDArray[Any]\n</code></pre> <p>Converts the structured array into an unstructured array.</p> <p>See structured_to_unstructured for more details.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>DTypeLike</code> <p>The dtype of the output unstructured array.</p> <code>None</code> <code>copy</code> <code>bool</code> <p>If <code>True</code>, always return a copy. If <code>False</code>, a view is returned if possible.</p> <code>False</code> <code>casting</code> <code>Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe']</code> <p>Controls what kind of data casting may occur. See the casting argument of numpy.ndarray.astype for more details.</p> <code>'unsafe'</code> <p>Returns:</p> Type Description <code>NDArray[Any]</code> <p>The unstructured array. This method may return a numpy ndarray instance instead of a Table instance if the table consists of numbers and strings and the appropriate <code>dtype</code> is not specified.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def unstructured(\n    self,\n    *,\n    dtype: DTypeLike = None,\n    copy: bool = False,\n    casting: Literal[\"no\", \"equiv\", \"safe\", \"same_kind\", \"unsafe\"] = \"unsafe\",\n) -&gt; NDArray[_Any]:\n    \"\"\"Converts the structured array into an unstructured array.\n\n    See [structured_to_unstructured][numpy.lib.recfunctions.structured_to_unstructured]{:target=\"_blank\"}\n    for more details.\n\n    Args:\n        dtype: The _dtype_ of the output unstructured array.\n        copy: If `True`, always return a copy. If `False`, a view is returned if possible.\n        casting: Controls what kind of data casting may occur. See the *casting* argument of\n            [numpy.ndarray.astype][]{:target=\"_blank\"} for more details.\n\n    Returns:\n        The unstructured array. This method may return a numpy [ndarray][numpy.ndarray]{:target=\"_blank\"}\n            instance instead of a [Table][msl.equipment.schema.Table] instance if the table consists of\n            numbers and strings and the appropriate `dtype` is not specified.\n    \"\"\"\n    from numpy.lib.recfunctions import structured_to_unstructured  # noqa: PLC0415\n\n    try:\n        return structured_to_unstructured(self, dtype=dtype, copy=copy, casting=casting)\n    except (TypeError, ValueError):\n        return np.array(self.tolist(), dtype=object)\n</code></pre>"}]}