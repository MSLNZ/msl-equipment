{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p>Info</p> <p>The docs are being rewritten. See here for the old docs.</p> <p>The purpose of <code>msl-equipment</code> is to manage information about equipment and to interface with equipment for computer control. The information that is managed is focused on testing and calibration laboratories that are accredited for the ISO/IEC 17025 standard, but the information may also be selectively specified for laboratories that are not required to meet the standard. See the Getting Started page to learn how information is managed and how equipment is controlled.</p>"},{"location":"#install","title":"Install","text":"<p>The <code>msl-equipment</code> repository is organised as a workspace project that is split across multiple packages: <code>msl-equipment</code>, msl-equipment-resources, msl-equipment-validate, and msl-equipment-webapp.</p> <p>The core package is <code>msl-equipment</code> and it is available through the Python Package Index. It can be installed using a variety of package managers</p> pipuvpoetrypdm <pre><code>pip install msl-equipment\n</code></pre> <pre><code>uv add msl-equipment\n</code></pre> <pre><code>poetry add msl-equipment\n</code></pre> <pre><code>pdm add msl-equipment\n</code></pre>"},{"location":"#dependencies","title":"Dependencies","text":"<p>The <code>msl-equipment</code> package depends on the following packages: msl-loadlib, numpy, pySerial, PyUSB, PyZMQ.</p> <p>The following packages are optional dependencies that may be installed to interface with equipment: msl-equipment-resources, NI-DAQmx, PyVISA, PyVISA-py</p>"},{"location":"license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2017 - 2025, Measurement Standards Laboratory of New Zealand\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#020-2025-03-28","title":"0.2.0 (2025-03-28)","text":"<p>Added:</p> <ul> <li>support for Python 3.12 and 3.13</li> <li><code>find-equipment</code> console script</li> <li><code>msl.equipment.connection_gpib.ConnectionGPIB</code> class</li> <li><code>msl.equipment.resources.greisinger.gmh3000.GMH3000</code> resource</li> <li><code>msl.equipment.resources.isotech.millik.MilliK</code> resource</li> <li><code>msl.equipment.resources.vaisala.ptu300.PTU300</code> resource</li> <li><code>msl.equipment.resources.vaisala.ptb330.PTB330</code> resource</li> </ul> <p>Fixed:</p> <ul> <li>issue #9 \u2014 Missing functions from Avantes AvaSpec DLL</li> <li>issue #8 \u2014 Invalid URL for LXI XML identification document</li> </ul> <p>Removed:</p> <ul> <li>support for Python 2.7, 3.5, 3.6 and 3.7</li> </ul>"},{"location":"release-notes/#010-2023-06-18","title":"0.1.0 (2023-06-18)","text":"<p>Initial release.</p> <p>It is also the last release to support Python 2.7, 3.5, 3.6 and 3.7</p>"},{"location":"validate/","title":"Validate","text":"<p>You may use any XML validating tool to validate equipment registers and connection files against the schema; however, some of the values of the XML elements are not completely validated by the schema alone. For example, the value of an element in an equipment register could be the SHA-256 checksum of a file. The schema will validate that the SHA-256 checksum value has the correct string length and that the checksum only contains the allowed alphanumeric characters, but, the schema does not validate that the checksum value is correct for the associated file. For these additional validation steps, another tool must be used. The <code>msl-equipment-validate</code> command-line tool validates the XML files against the schema and also provides the additional validation steps.</p>"},{"location":"validate/#validate-install","title":"Install","text":"<p><code>msl-equipment-validate</code> is available on PyPI and can be installed with a variety of Python package managers.</p> pippipxuv <pre><code>pip install msl-equipment-validate\n</code></pre> <pre><code>pipx install msl-equipment-validate\n</code></pre> <pre><code>uv tool install msl-equipment-validate\n</code></pre> <p>The source code is hosted on GitHub and to install the development version you can run the following.</p> pippipxuv <pre><code> pip install msl-equipment-validate@git+https://github.com/MSLNZ/msl-equipment#subdirectory=packages/validate\n</code></pre> <pre><code>pipx install msl-equipment-validate@git+https://github.com/MSLNZ/msl-equipment#subdirectory=packages/validate\n</code></pre> <pre><code>uv tool install msl-equipment-validate@git+https://github.com/MSLNZ/msl-equipment#subdirectory=packages/validate\n</code></pre> <p>This will install a command-line tool that you can use to validate the content of equipment registers and connection files.</p> <p>If you used a package manager that does not automatically add the <code>msl-equipment-validate</code> executable to your PATH environment variable (without activating a virtual environment), you may want to add the directory to where the <code>msl-equipment-validate</code> executable is located to your PATH. This will allow you to validate XML documents from any directory without having to first activate a virtual environment.</p>"},{"location":"validate/#command-alias","title":"Command alias","text":"<p>You may also want to create a command alias, since the executable name <code>msl-equipment-validate</code> is rather long. The following assigns an alias <code>check</code> for the <code>msl-equipment-validate</code> executable, but you should pick an alias that you prefer.</p> UnixWindows <p>Add the following to your <code>.bashrc</code> (or <code>.zshrc</code>) file</p> <pre><code>alias check=\"msl-equipment-validate\"\n</code></pre> <p>You can create an alias in your PowerShell profile script. To determine where this file is located, run the following command from your terminal, e.g., PowerShell or Windows Terminal (not Command Prompt)</p> <pre><code>echo $PROFILE\n</code></pre> <p>Open (or create) the <code>Microsoft.PowerShell_profile.ps1</code> file that was displayed in the previous command in a text editor and add the following line</p> <pre><code>Set-Alias check C:\\Update\\to\\be\\the\\path\\to\\msl-equipment-validate.exe\n</code></pre> <p>save it then open a new terminal (or run <code>. $PROFILE</code> in the current terminal to reload the PowerShell profile).</p> <p>Caution</p> <p>If you get an error that the profile script cannot be loaded because running scripts is disabled on this system, run the following command in an elevated (admin) terminal</p> <pre><code>Set-ExecutionPolicy -ExecutionPolicy RemoteSigned\n</code></pre> <p>then restart the terminal.</p>"},{"location":"validate/#validate-usage","title":"Usage","text":"<p>The tool first validates XML files against the schema and once there are no schema-related issues continues to process the additional validation steps (correct SHA-256 checksum values, tables are well formatted, equations contain valid syntax, etc.), therefore, it is possible that the number of issues found increases after the schema-related issues are fixed.</p> <p>To see the help for the tool run the following.</p> <pre><code>msl-equipment-validate --help\n</code></pre> <p>To recursively validate all XML files (that are used by <code>msl-equipment</code>) in the current working directory and all sub directories, run the command without arguments,</p> <pre><code>msl-equipment-validate\n</code></pre> <p>or specify specific files to validate,</p> <pre><code>msl-equipment-validate my/equipment/register.xml my/equipment/connections.xml\n</code></pre> <p>or specify a specific folder to validate.</p> <pre><code>msl-equipment-validate my/equipment\n</code></pre> <p>Including the <code>--strict</code> flag will provide the highest level of validation. It will treat warnings as errors.</p> <pre><code>msl-equipment-validate --strict\n</code></pre> <p>If the <code>msl-equipment</code> package is also installed, you can use its command-line interface to validate documents. (Note the removal of the hyphen between <code>equipment</code> and <code>validate</code>.),</p> <pre><code>msl-equipment validate\n</code></pre> <p>or to display the help.</p> <pre><code>msl-equipment help validate\n</code></pre>"},{"location":"validate/#validate-developers-guide","title":"Developer's Guide","text":"<p>When updating the equipment-register schema to an unreleased version, update the version number defined in the schema file. Run the following command from the root directory of the <code>equipment-register-schema</code> repository. A warning may be shown stating could not use pyproject.toml, using default configuration but just ignore the warning.</p> <pre><code>uvx --with setuptools-scm -- python -m setuptools_scm\n</code></pre> <p>Copy the version that is shown to the <code>version</code> attribute of the root <code>xsd:schema</code> element.</p>"},{"location":"validate/#validate-release-notes","title":"Release Notes","text":""},{"location":"validate/#unreleased","title":"unreleased","text":""},{"location":"webapp/","title":"Web Application","text":"<p>Info</p> <p>Development on the web application has not started.</p> <p>The web application provides a server for running a website that allows people to search for equipment records with equipment registers and (maybe) to add equipment records to a register.</p>"},{"location":"webapp/#install","title":"Install","text":"<p>Eventually...</p> <pre><code>pip install msl-equipment-webapp\n</code></pre>"},{"location":"api/","title":"API Overview","text":"<p>Although this package contains many classes and functions, the classes that you may typically create instances of are</p> <ul> <li>Config \u2014 if you want to load equipment registers and communicate with equipment</li> <li>Connection \u2014 if you are only interested in communicating with equipment</li> <li>Register \u2014 if you only want to load an equipment register</li> </ul> <p>and there are enumeration classes and a Readings class.</p> <p>Interfaces are available to communicate with equipment, Backends may be used to interface with equipment using external packages and possibly Resources may be available.</p> <p>Tip</p> <p>You do not need to create instances of these communication classes. Calling the Equipment.connect() or Connection.connect() method will automatically use the correct object for communication.</p> <p>If you are using type annotations and/or an editor that supports code completion, you can annotate the type of the returned object to get support for these features, for example,</p> <pre><code>from msl.equipment import GPIB, Connection\n\ndevice: GPIB = Connection(\"GPIB::22\").connect()\n</code></pre> <p>The MSLConnectionError and MSLTimeoutError classes are raised if there are issues when communicating with equipment.</p>"},{"location":"api/#command-line-interface","title":"Command Line Interface","text":"<p>A command-line interface is also available to find equipment, validate XML files against the schema or start the web application. Validation and the web application require that the <code>msl-equipment-validate</code> and <code>msl-equipment-webapp</code> packages are installed.</p> <p>To see the help, run</p> <pre><code>msl-equipment help\n</code></pre> <p>or to display the help for a specific command</p> <pre><code>msl-equipment help find\n</code></pre>"},{"location":"api/#find","title":"find","text":"<p>Run the <code>find</code> command to find equipment (and serial ports) that are available.</p> <pre><code>msl-equipment find\n</code></pre> <p>This will display a description about the type of interface, the equipment that was found for each interface and the address(es) that may be used to connect to the equipment.</p> <p>Tip</p> <p>If USB devices are attached to the computer and none are found, make sure you have followed these instructions for your operating system.</p> <pre><code>ASRL Ports\n  COM1 [Communications Port (COM1)]\n  COM2 [Communications Port (COM2)]\n  COM3 [Intel(R) Active Management Technology - SOL (COM3)]\nGPIB Devices\n  GPIB0::5::INSTR\nLXI Devices\n  315W Multi Range Triple Output PSU [webserver: http://169.254.100.2]\n    TCPIP::169.254.100.2::9221::SOCKET\n    TCPIP::169.254.100.2::inst0::INSTR\n  34465A Digital Multimeter [webserver: http://169.254.100.3]\n    TCPIP::169.254.100.3::5025::SOCKET\n    TCPIP::169.254.100.3::hislip0::INSTR\n    TCPIP::169.254.100.3::inst0::INSTR\nVXI11 Devices\n  34972A Data Acquisition / Switch Unit [webserver: http://10.12.102.15]\n    TCPIP::10.12.102.15::5025::SOCKET\n    TCPIP::10.12.102.15::inst0::INSTR\n  E5810 (00-21-B3-1F-01-CD) [webserver: http://10.12.102.31]\n    TCPIP::10.12.102.31::inst0::INSTR\n  E5810 (43:8E:5A:06:23:EE) [webserver: http://10.12.102.2]\n    TCPIP::10.12.102.2::inst0::INSTR\n</code></pre>"},{"location":"api/config/","title":"Config","text":"<p>A configuration file is useful when you want to perform a measurement.</p>"},{"location":"api/config/#msl.equipment.config.Config","title":"Config","text":"<pre><code>Config(source: XMLSource)\n</code></pre> <p>Load a configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>XMLSource</code> <p>A path-like or file-like object containing the configuration data.</p> required Source code in <code>src/msl/equipment/config.py</code> <pre><code>def __init__(self, source: XMLSource) -&gt; None:  # noqa: C901\n    \"\"\"Load a configuration file.\n\n    Args:\n        source: A [path-like][path-like object] or [file-like][file-like object]\n            object containing the configuration data.\n    \"\"\"\n    logger.debug(\"load configuration %s\", source)\n    self._source: XMLSource = source\n    self._root: Element[str] = parse(source).getroot()  # noqa: S314\n    self._registers: dict[str, Register] | None = None\n    self._config_equipment: ConfigEquipment = ConfigEquipment(self)\n\n    element = self.find(\"d2xx_library\")\n    if element is not None and element.text:\n        os.environ[\"D2XX_LIBRARY\"] = element.text\n        logger.debug(\"update D2XX_LIBRARY=%s\", element.text)\n\n    element = self.find(\"gpib_library\")\n    if element is not None and element.text:\n        os.environ[\"GPIB_LIBRARY\"] = element.text\n        logger.debug(\"update GPIB_LIBRARY=%s\", element.text)\n\n    element = self.find(\"pyvisa_library\")\n    if element is not None and element.text:\n        os.environ[\"PYVISA_LIBRARY\"] = element.text\n        logger.debug(\"update PyVISA_LIBRARY=%s\", element.text)\n\n    path_elements = self.findall(\"path\")\n    if path_elements:\n        paths: list[str] = []\n        os_paths: set[str] = set(os.environ[\"PATH\"].split(os.pathsep))\n        for element in path_elements:\n            path = element.text\n            if not path or not os.path.isdir(path):  # noqa: PTH112\n                logger.warning(\"skipped append to PATH: %r\", path)\n            elif element.attrib.get(\"recursive\", \"false\").lower() == \"true\":\n                for directory, _, _ in os.walk(path):\n                    if directory not in os_paths and directory not in paths:\n                        paths.append(directory)\n                        logger.debug(\"append to PATH: %r\", path)\n            elif path not in os_paths and path not in paths:\n                paths.append(path)\n                logger.debug(\"append to PATH: %r\", path)\n\n        os.environ[\"PATH\"] += os.pathsep + os.pathsep.join(paths)\n\n    for element in self.findall(\"connections\"):\n        connections.add(*_sources(element.text, \"connections\"))\n</code></pre>"},{"location":"api/config/#msl.equipment.config.Config.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: ConfigEquipment\n</code></pre> <p>Returns the <code>&lt;equipment/&gt;</code> elements in the configuration file like a sequence of Equipment items.</p> <p>Using the returned object you can access Equipment items by index (based on the order that <code>&lt;equipment/&gt;</code> elements are defined in the configuration file), by the <code>eid</code> attribute value or by the <code>name</code> attribute value. You can also iterate over the Equipment items in the sequence.</p> <p>See here for examples.</p>"},{"location":"api/config/#msl.equipment.config.Config.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>The path to the configuration file.</p>"},{"location":"api/config/#msl.equipment.config.Config.registers","title":"registers  <code>property</code>","text":"<pre><code>registers: dict[str, Register]\n</code></pre> <p>Returns all equipment registers that are specified in the configuration file.</p> <p>The key in the returned dict is the team value of the corresponding Register.</p>"},{"location":"api/config/#msl.equipment.config.Config.root","title":"root  <code>property</code>","text":"<pre><code>root: Element[str]\n</code></pre> <p>The root element (the first node) in the configuration file.</p>"},{"location":"api/config/#msl.equipment.config.Config.attrib","title":"attrib","text":"<pre><code>attrib(path: str) -&gt; dict[str, bool | float | str]\n</code></pre> <p>Get the attributes of the first matching element by tag name or path.</p> <p>If possible, the value is converted to a bool (<code>true</code> or <code>false</code> case-insensitive), an int or a float, otherwise the value remains a str.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Either an element tag name or an XPath.</p> required <p>Returns:</p> Type Description <code>dict[str, bool | float | str]</code> <p>The attributes of the matching <code>path</code> element.</p> Source code in <code>src/msl/equipment/config.py</code> <pre><code>def attrib(self, path: str) -&gt; dict[str, bool | float | str]:\n    \"\"\"Get the attributes of the first matching element by tag name or path.\n\n    If possible, the value is converted to a [bool][] (`true` or `false` case-insensitive),\n    an [int][] or a [float][], otherwise the value remains a [str][].\n\n    Args:\n        path: Either an element tag name or an XPath.\n\n    Returns:\n        The attributes of the matching `path` element.\n    \"\"\"\n    element = self.find(path)\n    if element is None:\n        return {}\n    return {k: to_primitive(v) for k, v in element.attrib.items()}\n</code></pre>"},{"location":"api/config/#msl.equipment.config.Config.find","title":"find","text":"<pre><code>find(path: str) -&gt; Element[str] | None\n</code></pre> <p>Find the first matching element by tag name or path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Either an element tag name or an XPath.</p> required <p>Returns:</p> Type Description <code>Element[str] | None</code> <p>The element or <code>None</code> if an element was not found at <code>path</code>.</p> Source code in <code>src/msl/equipment/config.py</code> <pre><code>def find(self, path: str) -&gt; Element[str] | None:\n    \"\"\"Find the first matching element by tag name or path.\n\n    Args:\n        path: Either an element tag name or an XPath.\n\n    Returns:\n        The element or `None` if an element was not found at `path`.\n    \"\"\"\n    return self._root.find(path)\n</code></pre>"},{"location":"api/config/#msl.equipment.config.Config.findall","title":"findall","text":"<pre><code>findall(path: str) -&gt; list[Element[str]]\n</code></pre> <p>Find all matching sub-elements by tag name or path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Either an element tag name or an XPath.</p> required <p>Returns:</p> Type Description <code>list[Element[str]]</code> <p>All matching elements in document order.</p> Source code in <code>src/msl/equipment/config.py</code> <pre><code>def findall(self, path: str) -&gt; list[Element[str]]:\n    \"\"\"Find all matching sub-elements by tag name or path.\n\n    Args:\n        path: Either an element tag name or an XPath.\n\n    Returns:\n        All matching elements in document order.\n    \"\"\"\n    return self._root.findall(path)\n</code></pre>"},{"location":"api/config/#msl.equipment.config.Config.value","title":"value","text":"<pre><code>value(\n    path: str, default: None = None\n) -&gt; bool | float | str | None\n</code></pre><pre><code>value(path: str, default: bool) -&gt; bool\n</code></pre><pre><code>value(path: str, default: int) -&gt; int\n</code></pre><pre><code>value(path: str, default: float) -&gt; float\n</code></pre><pre><code>value(path: str, default: str) -&gt; str\n</code></pre> <pre><code>value(\n    path: str, default: bool | float | str | None = None\n) -&gt; bool | float | str | None\n</code></pre> <p>Gets the value (text) associated with the first matching element.</p> <p>If possible, the value is converted to a bool (<code>true</code> or <code>false</code> case-insensitive), an int or a float, otherwise the value remains a str.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Either an element tag name or an XPath.</p> required <code>default</code> <code>bool | float | str | None</code> <p>The default value if an element cannot be found.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool | float | str | None</code> <p>The value of the element or <code>default</code> if an element was not found at <code>path</code>.</p> Source code in <code>src/msl/equipment/config.py</code> <pre><code>def value(self, path: str, default: bool | float | str | None = None) -&gt; bool | float | str | None:  # noqa: FBT001\n    \"\"\"Gets the value (text) associated with the first matching element.\n\n    If possible, the value is converted to a [bool][] (`true` or `false` case-insensitive),\n    an [int][] or a [float][], otherwise the value remains a [str][].\n\n    Args:\n        path: Either an element tag name or an XPath.\n        default: The default value if an element cannot be found.\n\n    Returns:\n        The value of the element or `default` if an element was not found at `path`.\n    \"\"\"\n    element = self.find(path)\n    if element is None:\n        return default\n    if element.text is None:\n        return None\n    return to_primitive(element.text)\n</code></pre>"},{"location":"api/config/#msl.equipment.config.ConfigEquipment","title":"ConfigEquipment","text":"<pre><code>ConfigEquipment(cfg: Config)\n</code></pre> <p>Access <code>&lt;equipment/&gt;</code> elements in a configuration file like a sequence of Equipment items.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>Config</code> <p>The configuration instance.</p> required Source code in <code>src/msl/equipment/config.py</code> <pre><code>def __init__(self, cfg: Config) -&gt; None:\n    \"\"\"Access `&lt;equipment/&gt;` elements in a configuration file like a sequence of [Equipment][] items.\n\n    Args:\n        cfg: The configuration instance.\n    \"\"\"\n    self._cfg: Config = cfg\n    self._elements: list[Element[str]] = cfg.findall(\"equipment\")\n    self._equipment: dict[str, Equipment] = {}  # key=eid\n    self._index_map: dict[int, str] = {i: e.attrib[\"eid\"] for i, e in enumerate(self._elements)}\n    self._name_map: dict[str, str] = {\n        e.attrib[\"name\"]: e.attrib[\"eid\"] for e in self._elements if e.attrib.get(\"name\")\n    }\n</code></pre>"},{"location":"api/config/#msl.equipment.config.ConfigEquipment.eids","title":"eids  <code>property</code>","text":"<pre><code>eids: tuple[str, ...]\n</code></pre> <p>Returns the value of the <code>eid</code> attribute for each <code>&lt;equipment/&gt;</code> element in a configuration file.</p>"},{"location":"api/config/#msl.equipment.config.ConfigEquipment.names","title":"names  <code>property</code>","text":"<pre><code>names: tuple[str, ...]\n</code></pre> <p>Returns the value of the <code>name</code> attribute for each <code>&lt;equipment/&gt;</code> element in a configuration file.</p>"},{"location":"api/connection/","title":"Connection","text":""},{"location":"api/connection/#msl.equipment.schema.Connection","title":"Connection","text":"<pre><code>Connection(\n    address: str,\n    *,\n    backend: (\n        Literal[\"MSL\", \"PyVISA\", \"NIDAQ\"] | Backend\n    ) = MSL,\n    eid: str = \"\",\n    manufacturer: str = \"\",\n    model: str = \"\",\n    serial: str = \"\",\n    **properties: Any\n)\n</code></pre> <p>Information about how to interface with equipment.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The VISA-style address of the connection (see here for examples).</p> required <code>backend</code> <code>Literal['MSL', 'PyVISA', 'NIDAQ'] | Backend</code> <p>The backend to use to communicate with the equipment.</p> <code>MSL</code> <code>eid</code> <code>str</code> <p>The equipment id to associate with the Connection instance.</p> <code>''</code> <code>manufacturer</code> <code>str</code> <p>The name of the manufacturer of the equipment.</p> <code>''</code> <code>model</code> <code>str</code> <p>The model number of the equipment.</p> <code>''</code> <code>serial</code> <code>str</code> <p>The serial number (or unique identifier) of the equipment.</p> <code>''</code> <code>properties</code> <code>Any</code> <p>Additional key-value pairs to use when communicating with the equipment. For example, the baud_rate and parity values for an RS-232 connection.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(\n    self,\n    address: str,\n    *,\n    backend: Literal[\"MSL\", \"PyVISA\", \"NIDAQ\"] | Backend = Backend.MSL,\n    eid: str = \"\",\n    manufacturer: str = \"\",\n    model: str = \"\",\n    serial: str = \"\",\n    **properties: _Any,  # noqa: ANN401\n) -&gt; None:\n    \"\"\"Information about how to interface with equipment.\n\n    Args:\n        address: The VISA-style address of the connection (see [here][address-syntax] for examples).\n        backend: The [backend][msl.equipment.enumerations.Backend] to use to communicate with the equipment.\n        eid: The [equipment id][msl.equipment.schema.Equipment.id] to associate with the [Connection][] instance.\n        manufacturer: The name of the manufacturer of the equipment.\n        model: The model number of the equipment.\n        serial: The serial number (or unique identifier) of the equipment.\n        properties: Additional key-value pairs to use when communicating with the equipment.\n            For example, the _baud_rate_ and _parity_ values for an _RS-232_ connection.\n    \"\"\"\n    self.address: str = address\n    \"\"\"The VISA-style address of the connection (see [here][address-syntax] for examples).\"\"\"\n\n    self.backend: Backend = Backend(backend)\n    \"\"\"The [backend][msl.equipment.enumerations.Backend] that is used to communicate with the equipment.\"\"\"\n\n    self.eid: str = eid\n    \"\"\"The [equipment id][msl.equipment.schema.Equipment.id] associated with the [Connection][] instance.\"\"\"\n\n    self.manufacturer: str = manufacturer\n    \"\"\"The name of the manufacturer of the equipment.\"\"\"\n\n    self.model: str = model\n    \"\"\"The model number of the equipment.\"\"\"\n\n    # check for a properties key being explicitly defined and the value is a dict\n    properties = (  # pyright: ignore[reportUnknownVariableType]\n        properties[\"properties\"]\n        if (\"properties\" in properties and isinstance(properties[\"properties\"], dict))\n        else properties\n    )\n\n    self.properties: dict[str, _Any] = properties\n    \"\"\"Additional key-value pairs to use when communicating with the equipment.\n\n    For example, the *baud_rate* and *parity* values for an *RS-232* connection.\n    \"\"\"\n\n    self.serial: str = serial\n    \"\"\"The serial number (or unique identifier) of the equipment.\"\"\"\n</code></pre>"},{"location":"api/connection/#msl.equipment.schema.Connection.address","title":"address  <code>instance-attribute</code>","text":"<pre><code>address: str = address\n</code></pre> <p>The VISA-style address of the connection (see here for examples).</p>"},{"location":"api/connection/#msl.equipment.schema.Connection.backend","title":"backend  <code>instance-attribute</code>","text":"<pre><code>backend: Backend = Backend(backend)\n</code></pre> <p>The backend that is used to communicate with the equipment.</p>"},{"location":"api/connection/#msl.equipment.schema.Connection.eid","title":"eid  <code>instance-attribute</code>","text":"<pre><code>eid: str = eid\n</code></pre> <p>The equipment id associated with the Connection instance.</p>"},{"location":"api/connection/#msl.equipment.schema.Connection.manufacturer","title":"manufacturer  <code>instance-attribute</code>","text":"<pre><code>manufacturer: str = manufacturer\n</code></pre> <p>The name of the manufacturer of the equipment.</p>"},{"location":"api/connection/#msl.equipment.schema.Connection.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model: str = model\n</code></pre> <p>The model number of the equipment.</p>"},{"location":"api/connection/#msl.equipment.schema.Connection.properties","title":"properties  <code>instance-attribute</code>","text":"<pre><code>properties: dict[str, Any] = properties\n</code></pre> <p>Additional key-value pairs to use when communicating with the equipment.</p> <p>For example, the baud_rate and parity values for an RS-232 connection.</p>"},{"location":"api/connection/#msl.equipment.schema.Connection.serial","title":"serial  <code>instance-attribute</code>","text":"<pre><code>serial: str = serial\n</code></pre> <p>The serial number (or unique identifier) of the equipment.</p>"},{"location":"api/connection/#msl.equipment.schema.Connection.connect","title":"connect","text":"<pre><code>connect() -&gt; Any\n</code></pre> <p>Connect to the equipment for computer control.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def connect(self) -&gt; _Any:  # noqa: ANN401\n    \"\"\"Connect to the equipment for computer control.\"\"\"\n    equipment = Equipment(\n        id=self.eid,\n        manufacturer=self.manufacturer,\n        model=self.model,\n        serial=self.serial,\n        connection=self,\n    )\n    return equipment.connect()\n</code></pre>"},{"location":"api/enumerations/","title":"enumerations","text":"<p>Enumeration constants.</p>"},{"location":"api/enumerations/#msl.equipment.enumerations.Backend","title":"Backend","text":"<p>               Bases: <code>Enum</code></p> <p>The backend library to use for communication with the equipment.</p> <p>Attributes:</p> Name Type Description <code>MSL</code> <code>str</code> <p>\"MSL\"</p> <code>PyVISA</code> <code>str</code> <p>\"PyVISA\"</p> <code>NIDAQ</code> <code>str</code> <p>\"NIDAQ\"</p>"},{"location":"api/enumerations/#msl.equipment.enumerations.DataBits","title":"DataBits","text":"<p>               Bases: <code>IntEnum</code></p> <p>The number of data bits to use for Serial communication.</p> <p>Attributes:</p> Name Type Description <code>FIVE</code> <code>int</code> <p>5</p> <code>SIX</code> <code>int</code> <p>6</p> <code>SEVEN</code> <code>int</code> <p>7</p> <code>EIGHT</code> <code>int</code> <p>8</p>"},{"location":"api/enumerations/#msl.equipment.enumerations.Parity","title":"Parity","text":"<p>               Bases: <code>Enum</code></p> <p>The parity type to use for Serial communication.</p> <p>Attributes:</p> Name Type Description <code>NONE</code> <code>str</code> <p>\"N\"</p> <code>ODD</code> <code>str</code> <p>\"O\"</p> <code>EVEN</code> <code>str</code> <p>\"E\"</p> <code>MARK</code> <code>str</code> <p>\"M\"</p> <code>SPACE</code> <code>str</code> <p>\"S\"</p>"},{"location":"api/enumerations/#msl.equipment.enumerations.StopBits","title":"StopBits","text":"<p>               Bases: <code>Enum</code></p> <p>The number of stop bits to use for Serial communication.</p> <p>Attributes:</p> Name Type Description <code>ONE</code> <code>int</code> <p>1</p> <code>ONE_POINT_FIVE</code> <code>float</code> <p>1.5</p> <code>TWO</code> <code>int</code> <p>2</p>"},{"location":"api/exceptions/","title":"exceptions","text":""},{"location":"api/exceptions/#msl.equipment.interfaces.message_based.MSLConnectionError","title":"MSLConnectionError","text":"<pre><code>MSLConnectionError(interface: Interface, message: str)\n</code></pre> <p>               Bases: <code>OSError</code></p> <p>Base class for connection-related exceptions.</p> <p>Parameters:</p> Name Type Description Default <code>interface</code> <code>Interface</code> <p>An interface subclass.</p> required <code>message</code> <code>str</code> <p>A message to append to the generic error message.</p> required Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def __init__(self, interface: Interface, message: str) -&gt; None:\n    \"\"\"Base class for connection-related exceptions.\n\n    Args:\n        interface: An interface subclass.\n        message: A message to append to the generic error message.\n    \"\"\"\n    logger.debug(\"%r %s\", interface, message)\n    super().__init__(f\"{interface!r}\\n{message}\")\n</code></pre>"},{"location":"api/exceptions/#msl.equipment.interfaces.message_based.MSLTimeoutError","title":"MSLTimeoutError","text":"<pre><code>MSLTimeoutError(interface: MessageBased, message: str = '')\n</code></pre> <p>               Bases: <code>TimeoutError</code></p> <p>A timeout exception for I/O operations.</p> <p>Parameters:</p> Name Type Description Default <code>interface</code> <code>MessageBased</code> <p>A message-based interface subclass.</p> required <code>message</code> <code>str</code> <p>An optional message to append to the generic timeout error message.</p> <code>''</code> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def __init__(self, interface: MessageBased, message: str = \"\") -&gt; None:\n    \"\"\"A timeout exception for I/O operations.\n\n    Args:\n        interface: A message-based interface subclass.\n        message: An optional message to append to the generic timeout error message.\n    \"\"\"\n    msg = f\"Timeout occurred after {interface.timeout} second(s). {message}\"\n    logger.debug(\"%r %s\", interface, msg)\n    super().__init__(f\"{interface!r}\\n{msg}\")\n</code></pre>"},{"location":"api/readings/","title":"Readings","text":"<p>The Readings class may be used after requesting measurement data from equipment. It calculates the mean, standard deviation and the standard deviation of the mean and provides a user-friendly way to display the information.</p> <p>Suppose we have a Connection to a digital multimeter, <code>dmm</code>, and we fetch some readings</p> <pre><code>&gt;&gt;&gt; data = dmm.query(\"FETCH?\")\n&gt;&gt;&gt; data\n' 8.000167847E+00, 8.000164032E+00, 8.000163241E+00, 8.000165864E+00, 8.000164893E+00\\r\\n'\n</code></pre> <p>We can create a Readings instance from the fetched data and then get statistical information about the data</p> <pre><code>&gt;&gt;&gt; from msl.equipment import Readings\n&gt;&gt;&gt; r = Readings(data)\n&gt;&gt;&gt; r.mean\n8.0001651754\n&gt;&gt;&gt; r.std\n1.784701179552952e-06\n&gt;&gt;&gt; r.std_mean\n7.981426314008917e-07\n&gt;&gt;&gt; len(r)\n5\n</code></pre> <p>We can treat the readings as a numpy ndarray and call ndarray attributes</p> <pre><code>&gt;&gt;&gt; print(r.max())\n8.000167847\n&gt;&gt;&gt; print(r.min())\n8.000163241\n</code></pre> <p>or access the numpy ndarray directly</p> <pre><code>&gt;&gt;&gt; r.data\narray([8.00016785, 8.00016403, 8.00016324, 8.00016586, 8.00016489])\n</code></pre> <p>Unpacking the Readings instance returns the mean and the standard deviation of the mean</p> <pre><code>&gt;&gt;&gt; mean, std_mean = r\n&gt;&gt;&gt; mean\n8.0001651754\n&gt;&gt;&gt; std_mean\n7.981426314008917e-07\n</code></pre> <p>When converting the Readings to a string, the custom format specification is used and it displays the value (mean) with the uncertainty (standard deviation of the mean)</p> <pre><code>&gt;&gt;&gt; f\"{r}\" # use the default options\n'8.00016518(80)'\n&gt;&gt;&gt; f\"{r:.2B}\" # equivalent to previous\n'8.00016518(80)'\n&gt;&gt;&gt; f\"{r:.3PU}\"  # retain 3 digits, +/- mode, unicode style\n'8.000165175\u00b10.000000798'\n</code></pre>"},{"location":"api/readings/#format-specification","title":"Format Specification","text":"<p>The format specification is similar to the built-in Python specification, but with additional options (mode, style and si). The number of significant digits for the value (mean) and the uncertainty (standard deviation of the mean) can be controlled, based on the uncertainty.</p> <p>The grammar for the format specification is defined as,</p> <pre><code>[[fill]align][sign][z][#][0][width][grouping][.digits][type][mode][style][si]\n</code></pre> <p>where we note the use of digits (not precision) and the additional mode, style and si options. digits refers to the number of significant digits to retain in the uncertainty. The mode option specifies how the value and the uncertainty are separated: <code>B</code> (bracket mode, default) or <code>P</code> (plus-minus sign). There are two style options: <code>L</code> (\\(\\LaTeX\\)) or <code>U</code> (unicode). The si option can only be <code>S</code> and if it is specified the appropriate SI prefix symbol replaces the Base-10 component.</p> <p>We can also create a Readings instance by specifying the mean, standard deviation and size keyword arguments</p> <pre><code>&gt;&gt;&gt; r = Readings(mean=3.4562e-6, std=4.218e-8, size=10)\n&gt;&gt;&gt; r.mean\n3.4562e-06\n&gt;&gt;&gt; r.std\n4.218e-08\n&gt;&gt;&gt; r.std_mean  # 4.218e-8 / sqrt(10)\n1.3338487170590222e-08\n</code></pre> <p>Here are some examples on how to use the custom format specification</p> <pre><code>&gt;&gt;&gt; f\"{r}\"  # default is to retain 2 digits with bracket mode\n'0.000003456(13)'\n&gt;&gt;&gt; f\"{r:P}\"  # +/- mode\n'0.000003456+/-0.000000013'\n&gt;&gt;&gt; f\"{r:PU}\"  # +/- mode, unicode style\n'0.000003456\u00b10.000000013'\n&gt;&gt;&gt; f\"{r:e}\"  # exponent form\n'3.456(13)e-06'\n&gt;&gt;&gt; f\"{r:S}\" # SI prefix\n'3.456(13) u'\n&gt;&gt;&gt; f\"{r:US}\" # unicode style, SI prefix\n'3.456(13) \u00b5'\n&gt;&gt;&gt; f\"{r:.1eU}\" # 1 digit, exponent form, unicode style\n'3.46(1)\u00d710\u207b\u2076'\n&gt;&gt;&gt; f\"{r:eL}\" # exponent form, LaTeX style\n'3.456\\\\left(13\\\\right)\\\\times10^{-6}'\n&gt;&gt;&gt; f\"{r:=^+30.4e}\"  # fill with '=', align center, include + sign, 30 characters in total, 4 digits, exponent form\n'======+3.45620(1334)e-06======'\n</code></pre> <p>If the standard deviation of the mean is zero, the uncertainty component is not included in the output and the format applies only to the mean</p> <pre><code>&gt;&gt;&gt; r = Readings(mean=3.4562e-6, std=0, size=10)\n&gt;&gt;&gt; f\"{r}\"  # default is 2 decimal places in floating-point, f, notation\n'0.00'\n&gt;&gt;&gt; f\"{r:e}\"\n'3.46e-06'\n&gt;&gt;&gt; f\"{r:.4e}\"  # 4 decimals (uses built-in specification since no custom options are used)\n'3.4562e-06'\n&gt;&gt;&gt; f\"{r:.4eUS}\"  # 4 digits (uses custom specification since custom options are included)\n'3.456 \u00b5'\n</code></pre>"},{"location":"api/readings/#msl.equipment.readings.Readings","title":"Readings","text":"<pre><code>Readings(\n    data: (\n        str | Sequence[str | float] | NDArray[number] | None\n    ) = None,\n    *,\n    mean: float | None = None,\n    std: float | None = None,\n    size: int | None = None,\n    overload: float | None = 1e30,\n    delimiter: str | None = \",\"\n)\n</code></pre> <p>A formatting-friendly convenience class for measurement data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | Sequence[str | float] | NDArray[number] | None</code> <p>The measurement data.</p> <code>None</code> <code>mean</code> <code>float | None</code> <p>If specified, then the mean is not calculated from the <code>data</code>.</p> <code>None</code> <code>std</code> <code>float | None</code> <p>If specified, then the standard deviation is not calculated from the <code>data</code>.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>If specified, then the number of items is not determined from the <code>data</code>.</p> <code>None</code> <code>overload</code> <code>float | None</code> <p>For some devices, like a digital multimeter, if the input signal is greater than the range can measure, the device returns a large value (e.g., 9.9E+37) to indicate a measurement overload. If the absolute value of the mean is greater than <code>overload</code> then the mean and standard deviation become <code>NaN</code>. Setting <code>overload</code> to <code>None</code> disables this check.</p> <code>1e+30</code> <code>delimiter</code> <code>str | None</code> <p>The character used to separate values (only used if <code>data</code> is of type str). The value <code>None</code> corresponds to whitespace.</p> <code>','</code> Source code in <code>src/msl/equipment/readings.py</code> <pre><code>def __init__(\n    self,\n    data: str | Sequence[str | float] | NDArray[np.number] | None = None,\n    *,\n    mean: float | None = None,\n    std: float | None = None,\n    size: int | None = None,\n    overload: float | None = 1e30,\n    delimiter: str | None = \",\",\n) -&gt; None:\n    \"\"\"A formatting-friendly convenience class for measurement data.\n\n    Args:\n        data: The measurement data.\n        mean: If specified, then the mean is not calculated from the `data`.\n        std: If specified, then the standard deviation is not calculated from the `data`.\n        size: If specified, then the number of items is not determined from the `data`.\n        overload: For some devices, like a digital multimeter, if the input signal is\n            greater than the range can measure, the device returns a large value\n            (e.g., 9.9E+37) to indicate a measurement overload. If the absolute value of\n            the mean is greater than `overload` then the mean and standard deviation become\n            `NaN`. Setting `overload` to `None` disables this check.\n        delimiter: The character used to separate values (only used if `data` is of type [str][]).\n            The value `None` corresponds to whitespace.\n    \"\"\"\n    if data is not None and any(a is not None for a in (mean, std, size)):\n        msg = \"Cannot specify data and the mean, std or size\"\n        raise ValueError(msg)\n\n    self._data: NDArray[np.float64]\n    if isinstance(data, str):\n        stripped = data.strip()\n        if stripped:\n            self._data = np.loadtxt(StringIO(stripped), dtype=float, delimiter=delimiter)\n        else:\n            self._data = np.empty(0)\n    elif isinstance(data, np.ndarray):\n        self._data = data.astype(np.float64)\n    elif data is None:\n        self._data = np.empty(0)\n    else:\n        self._data = np.asarray(data, dtype=float)\n\n    self._size: int = self._data.size if size is None else size\n    self._overload: float | None = None if overload is None else float(overload)\n    self._std: float | None = std\n\n    self._mean: float | None\n    if mean is not None:\n        self._mean = self._check_overload(mean)\n    else:\n        self._mean = None\n</code></pre>"},{"location":"api/readings/#msl.equipment.readings.Readings.data","title":"data  <code>property</code>","text":"<pre><code>data: NDArray[float64]\n</code></pre> <p>Returns the data.</p>"},{"location":"api/readings/#msl.equipment.readings.Readings.mean","title":"mean  <code>property</code>","text":"<pre><code>mean: float\n</code></pre> <p>Returns the mean.</p>"},{"location":"api/readings/#msl.equipment.readings.Readings.overload","title":"overload  <code>property</code>","text":"<pre><code>overload: float | None\n</code></pre> <p>Returns the overload value.</p>"},{"location":"api/readings/#msl.equipment.readings.Readings.std","title":"std  <code>property</code>","text":"<pre><code>std: float\n</code></pre> <p>Returns the sample standard deviation (uses \\(N-1\\) in the denominator).</p>"},{"location":"api/readings/#msl.equipment.readings.Readings.std_mean","title":"std_mean  <code>property</code>","text":"<pre><code>std_mean: float\n</code></pre> <p>Returns the standard deviation of the mean.</p>"},{"location":"api/types/","title":"types","text":"<p>Custom type annotations.</p>"},{"location":"api/types/#msl.equipment._types.EnumType","title":"EnumType  <code>module-attribute</code>","text":"<pre><code>EnumType = TypeVar('EnumType', bound=Enum)\n</code></pre> <p>An Enum subclass.</p>"},{"location":"api/types/#msl.equipment._types.MessageDataType","title":"MessageDataType  <code>module-attribute</code>","text":"<pre><code>MessageDataType = (\n    type[int] | type[float] | type[number] | str\n)\n</code></pre> <p>Data type to use to read(write) bytes from(to) equipment.</p> <p>The data type to use to convert each element in a Sequence1D to. If the corresponding MessageFormat is <code>ascii</code> then the data type value must be of type str and it is used as the <code>format_spec</code> argument in format to first convert each element in Sequence1D to a string, and then it is encoded (e.g., <code>'.2e'</code> converts each element to scientific notation with two digits after the decimal point). If the data type includes a byte-order character, it is ignored. For all other values of MessageFormat, the data type can be any object that numpy dtype supports (e.g., <code>'H'</code>, <code>'uint16'</code> and ushort are equivalent values to convert each element to an unsigned short). If a byte-order character is specified then it is used, otherwise the native byte order of the CPU architecture is used. See struct-format-strings for more details.</p>"},{"location":"api/types/#msl.equipment._types.MessageFormat","title":"MessageFormat  <code>module-attribute</code>","text":"<pre><code>MessageFormat = Literal['ascii', 'hp', 'ieee'] | None\n</code></pre> <p>Format to use to read(write) bytes from(to) equipment.</p> <p>Possible values are:</p> <ul> <li> <p><code>None</code> \u2014 do not use a header.</p> <p>Format</p> <p><code>&lt;byte&gt;&lt;byte&gt;&lt;byte&gt;...</code></p> </li> <li> <p><code>ascii</code> \u2014 comma-separated ASCII characters, see the         <code>&lt;PROGRAM DATA SEPARATOR&gt;</code> standard that is defined in Section 7.4.2.2 of         IEEE 488.2-1992.</p> <p>Format</p> <p><code>&lt;string&gt;,&lt;string&gt;,&lt;string&gt;,...</code></p> </li> <li> <p><code>ieee</code> \u2014 arbitrary block data for <code>SCPI</code> messages, see the         <code>&lt;DEFINITE LENGTH ARBITRARY BLOCK RESPONSE DATA&gt;</code> standard that is defined in         Section 8.7.9 of IEEE 488.2-1992.</p> <p>Format</p> <p><code>#&lt;length of num bytes value&gt;&lt;num bytes&gt;&lt;byte&gt;&lt;byte&gt;&lt;byte&gt;...</code></p> </li> <li> <p><code>hp</code> \u2014 the HP-IB data transfer standard, i.e., the <code>FORM#</code> command         option. See the programming guide for an         HP 8530A         for more details.</p> <p>Format</p> <p><code>#A&lt;num bytes as uint16&gt;&lt;byte&gt;&lt;byte&gt;&lt;byte&gt;...</code></p> </li> </ul>"},{"location":"api/types/#msl.equipment._types.NumpyArray1D","title":"NumpyArray1D  <code>module-attribute</code>","text":"<pre><code>NumpyArray1D = ndarray[tuple[int], dtype[number]]\n</code></pre> <p>A 1-dimensional numpy ndarray of numbers.</p>"},{"location":"api/types/#msl.equipment._types.PathLike","title":"PathLike  <code>module-attribute</code>","text":"<pre><code>PathLike = Union[str, bytes, PathLike[str], PathLike[bytes]]\n</code></pre> <p>A path-like object.</p>"},{"location":"api/types/#msl.equipment._types.Sequence1D","title":"Sequence1D  <code>module-attribute</code>","text":"<pre><code>Sequence1D = Sequence[float] | NumpyArray1D\n</code></pre> <p>A 1-dimensional sequence of numbers.</p>"},{"location":"api/types/#msl.equipment._types.XMLSource","title":"XMLSource  <code>module-attribute</code>","text":"<pre><code>XMLSource = Union[\n    int, PathLike, SupportsRead[bytes] | SupportsRead[str]\n]\n</code></pre> <p>A path-like object or a file-like object for parsing XML content.</p>"},{"location":"api/types/#msl.equipment._types.SupportsRead","title":"SupportsRead","text":"<p>               Bases: <code>Protocol[_T_co]</code></p> <p>A file-like object that has a <code>read</code> method.</p>"},{"location":"api/types/#msl.equipment._types.SupportsRead.read","title":"read","text":"<pre><code>read(size: int | None = -1) -&gt; _T_co\n</code></pre> <p>Read from the stream.</p> Source code in <code>src/msl/equipment/_types.py</code> <pre><code>def read(self, size: int | None = -1, /) -&gt; _T_co:\n    \"\"\"Read from the stream.\"\"\"\n    ...\n</code></pre>"},{"location":"api/backends/","title":"Backends","text":"<p>The following classes may be used to interface with equipment using external packages</p> <ul> <li>NIDAQ \u2014 Use the NIDAQmx package to establish a connection to the equipment</li> <li>PyVISA \u2014 Use the PyVISA package to establish a connection to the equipment</li> </ul>"},{"location":"api/backends/nidaq/","title":"NIDAQ","text":""},{"location":"api/backends/nidaq/#msl.equipment.interfaces.nidaq.NIDAQ","title":"NIDAQ","text":"<pre><code>NIDAQ(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Use NI-DAQmx as the backend to communicate with the equipment.</p> <p>The backend value must be equal to <code>NIDAQ</code> to use this class for the communication backend.</p> <p>The returned object from calling the connect method is equivalent to importing the NI-DAQmx package, e.g.,</p> <pre><code>from msl.equipment import Backend, Connection\n\nconnection = Connection(address=\"Dev1\", backend=Backend.NIDAQ)\nnidaqmx = connection.connect()\n\nwith nidaqmx.Task() as task:\n    task.ai_channels.add_ai_voltage_chan(f\"{nidaqmx.address}/ai0\")\n    voltage = task.read()\n</code></pre> <p>is equivalent to</p> <pre><code>import nidaqmx\n\nwith nidaqmx.Task() as task:\n    task.ai_channels.add_ai_voltage_chan(\"Dev1/ai0\")\n    voltage = task.read()\n</code></pre> <p>You can also combine the packages, use <code>msl-equipment</code> for managing information about the equipment and directly use <code>nidaqmx</code> for the connection. If you use this combination, the editor you use to develop your code may have better support for features like code completion and type checking.</p> <pre><code>import nidaqmx\nfrom msl.equipment import Config\n\n# config.xml contains &lt;equipment eid=\"MSLE.0.142\" name=\"daq\" manufacturer=\"NI\"/&gt;\n# and specifies where the equipment registers are and the connections file.\ncfg = Config(\"config.xml\")\nequipment = cfg.equipment[\"daq\"]\naddress = equipment.connection.address\n\nwith nidaqmx.Task() as task:\n    task.ai_channels.add_ai_voltage_chan(f\"{address}/ai0\")\n    voltage = task.read()\n\n    # You could now use the `equipment` instance to apply a correction to the `voltage`\n</code></pre> <p>See the examples on the NI-DAQmx repository to learn how to use the <code>nidaqmx</code> package.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>src/msl/equipment/interfaces/nidaq.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Use [NI-DAQmx] as the backend to communicate with the equipment.\n\n    The [backend][msl.equipment.schema.Connection.backend] value must be equal\n    to `NIDAQ` to use this class for the communication backend.\n\n    The returned object from calling the [connect][msl.equipment.schema.Equipment.connect]\n    method is equivalent to importing the [NI-DAQmx] package, e.g.,\n\n    ```python\n    from msl.equipment import Backend, Connection\n\n    connection = Connection(address=\"Dev1\", backend=Backend.NIDAQ)\n    nidaqmx = connection.connect()\n\n    with nidaqmx.Task() as task:\n        task.ai_channels.add_ai_voltage_chan(f\"{nidaqmx.address}/ai0\")\n        voltage = task.read()\n    ```\n\n    is equivalent to\n\n    ```python\n    import nidaqmx\n\n    with nidaqmx.Task() as task:\n        task.ai_channels.add_ai_voltage_chan(\"Dev1/ai0\")\n        voltage = task.read()\n    ```\n\n    You can also combine the packages, use `msl-equipment` for managing information\n    about the equipment and directly use `nidaqmx` for the connection. If you use this\n    combination, the editor you use to develop your code may have better support for\n    features like code completion and type checking.\n\n    ```python\n    import nidaqmx\n    from msl.equipment import Config\n\n    # config.xml contains &lt;equipment eid=\"MSLE.0.142\" name=\"daq\" manufacturer=\"NI\"/&gt;\n    # and specifies where the equipment registers are and the connections file.\n    cfg = Config(\"config.xml\")\n    equipment = cfg.equipment[\"daq\"]\n    address = equipment.connection.address\n\n    with nidaqmx.Task() as task:\n        task.ai_channels.add_ai_voltage_chan(f\"{address}/ai0\")\n        voltage = task.read()\n\n        # You could now use the `equipment` instance to apply a correction to the `voltage`\n    ```\n\n    See the [examples](https://github.com/ni/nidaqmx-python/tree/master/examples)\n    on the [NI-DAQmx repository](https://github.com/ni/nidaqmx-python) to learn\n    how to use the `nidaqmx` package.\n\n    [NI-DAQmx]: https://nidaqmx-python.readthedocs.io/en/stable/index.html\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"\n    super().__init__(equipment)\n\n    if nidaqmx is None:  # pragma: no branch\n        msg = \"nidaqmx is not installed, run: pip install nidaqmx\"\n        raise RuntimeError(msg)\n</code></pre>"},{"location":"api/backends/nidaq/#msl.equipment.interfaces.nidaq.NIDAQ.address","title":"address  <code>property</code>","text":"<pre><code>address: str\n</code></pre> <p>Returns the address of the Connection.</p>"},{"location":"api/backends/nidaq/#msl.equipment.interfaces.nidaq.NIDAQ.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/backends/nidaq/#msl.equipment.interfaces.nidaq.NIDAQ.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the equipment.</p> <p>This method can be overridden in the subclass if the subclass must implement tasks that need to be performed in order to safely disconnect from the equipment.</p> <p>For example,</p> <ul> <li>to clean up system resources from memory (e.g., if using a manufacturer's SDK)</li> <li>to configure the equipment to be in a state that is safe for people   working in the lab when the equipment is not in use</li> </ul> <p>Tip</p> <p>This method gets called automatically when the Interface instance gets garbage collected, which happens when the reference count is 0.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from the equipment.\n\n    This method can be overridden in the subclass if the subclass must implement\n    tasks that need to be performed in order to safely disconnect from the equipment.\n\n    For example,\n\n    * to clean up system resources from memory (e.g., if using a manufacturer's SDK)\n    * to configure the equipment to be in a state that is safe for people\n      working in the lab when the equipment is not in use\n\n    !!! tip\n        This method gets called automatically when the [Interface][msl.equipment.schema.Interface]\n        instance gets garbage collected, which happens when the reference count is 0.\n    \"\"\"\n    logger.debug(\"Disconnected from %r\", self)\n</code></pre>"},{"location":"api/backends/pyvisa/","title":"PyVISA","text":""},{"location":"api/backends/pyvisa/#msl.equipment.interfaces.pyvisa.PyVISA","title":"PyVISA","text":"<pre><code>PyVISA(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Use PyVISA as the backend to communicate with the equipment.</p> <p>The backend value must be equal to <code>PyVISA</code> to use this class for the communication backend.</p> <p>The <code>PYVISA_LIBRARY</code> environment variable is used (if it exists) to create the ResourceManager. This environment variable can be defined in a configuration file or by defining the environment variable in your code before connecting to the equipment using PyVISA for the first time. The default value is <code>@ivi</code> if this environment variable is not defined.</p> <p>The returned object using <code>msl-equipment</code> to connect to the equipment is equivalent to calling open_resource, e.g.,</p> <pre><code>from msl.equipment import Backend, Connection\n\nconnection = Connection(\"GPIB::12\", backend=Backend.PyVISA)\ninst = connection.connect()\nprint(inst.query(\"*IDN?\"))\n</code></pre> <p>is equivalent to</p> <pre><code>import pyvisa\n\nrm = pyvisa.ResourceManager()\ninst = rm.open_resource(\"GPIB::12\")\nprint(inst.query(\"*IDN?\"))\n</code></pre> <p>You can also combine the packages, use <code>msl-equipment</code> for managing information about the equipment and directly use <code>pyvisa</code> for the connection. If you use this combination, the editor you use to develop your code may have better support for features like code completion and type checking.</p> <pre><code>import pyvisa\nfrom msl.equipment import Config\n\n# config.xml contains &lt;equipment eid=\"MSLE.0.063\" name=\"dmm\"/&gt;\n# and specifies where the equipment registers are and the connections file.\ncfg = Config(\"config.xml\")\nequipment = cfg.equipment[\"dmm\"]\n\nrm = pyvisa.ResourceManager()\ninst = rm.open_resource(equipment.connection.address)\ndata = inst.query(\"READ?\")\n\n# You could now use the `equipment` instance to apply a correction to the `data`\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>src/msl/equipment/interfaces/pyvisa.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Use [PyVISA] as the backend to communicate with the equipment.\n\n    The [backend][msl.equipment.schema.Connection.backend] value must be equal to\n    `PyVISA` to use this class for the communication backend.\n\n    The `PYVISA_LIBRARY` environment variable is used (if it exists) to create the\n    [ResourceManager][pyvisa.highlevel.ResourceManager]. This environment variable\n    can be defined in a [configuration file][config-xml-example] or by defining the\n    environment variable in your code before connecting to the equipment using\n    [PyVISA][msl.equipment.interfaces.pyvisa.PyVISA] for the first time. The default\n    value is `@ivi` if this environment variable is not defined.\n\n    The returned object using `msl-equipment` to connect to the equipment is equivalent\n    to calling [open_resource][pyvisa.highlevel.ResourceManager.open_resource], e.g.,\n\n    ```python\n    from msl.equipment import Backend, Connection\n\n    connection = Connection(\"GPIB::12\", backend=Backend.PyVISA)\n    inst = connection.connect()\n    print(inst.query(\"*IDN?\"))\n    ```\n\n    is equivalent to\n\n    ```python\n    import pyvisa\n\n    rm = pyvisa.ResourceManager()\n    inst = rm.open_resource(\"GPIB::12\")\n    print(inst.query(\"*IDN?\"))\n    ```\n\n    You can also combine the packages, use `msl-equipment` for managing information\n    about the equipment and directly use `pyvisa` for the connection. If you use this\n    combination, the editor you use to develop your code may have better support for\n    features like code completion and type checking.\n\n    ```python\n    import pyvisa\n    from msl.equipment import Config\n\n    # config.xml contains &lt;equipment eid=\"MSLE.0.063\" name=\"dmm\"/&gt;\n    # and specifies where the equipment registers are and the connections file.\n    cfg = Config(\"config.xml\")\n    equipment = cfg.equipment[\"dmm\"]\n\n    rm = pyvisa.ResourceManager()\n    inst = rm.open_resource(equipment.connection.address)\n    data = inst.query(\"READ?\")\n\n    # You could now use the `equipment` instance to apply a correction to the `data`\n    ```\n\n    [PyVISA]: https://pyvisa.readthedocs.io/en/stable/\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"\n    self._resource: Resource | None = None\n    super().__init__(equipment)\n\n    if pyvisa is None:  # pragma: no branch\n        msg = \"pyvisa is not installed, run: pip install pyvisa\"  # type: ignore[unreachable]\n        raise RuntimeError(msg)\n\n    assert equipment.connection is not None  # noqa: S101\n    kwargs = _prepare_kwargs(equipment.connection.properties)\n\n    if PyVISA.rm is None:\n        PyVISA.rm = pyvisa.ResourceManager()\n\n    self._resource = PyVISA.rm.open_resource(equipment.connection.address, **kwargs)\n</code></pre>"},{"location":"api/backends/pyvisa/#msl.equipment.interfaces.pyvisa.PyVISA.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/backends/pyvisa/#msl.equipment.interfaces.pyvisa.PyVISA.rm","title":"rm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rm: ResourceManager | None = None\n</code></pre> <p>PyVISA Resource Manager.</p>"},{"location":"api/backends/pyvisa/#msl.equipment.interfaces.pyvisa.PyVISA.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Calls pyvisa.resources.Resource.close.</p> Source code in <code>src/msl/equipment/interfaces/pyvisa.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Calls [pyvisa.resources.Resource.close][].\"\"\"\n    if self._resource is not None:\n        self._resource.close()\n        logger.debug(\"Disconnected from %s\", self)\n        self._resource = None\n    super().disconnect()\n</code></pre>"},{"location":"api/interfaces/","title":"Interfaces","text":"<p>Generic interface classes for computer control</p> <ul> <li>Interface \u2014 Base class for all interfaces</li> <li>MessageBased \u2014 Base class for all message-based interfaces</li> </ul>"},{"location":"api/interfaces/#msl.equipment.schema.Interface","title":"Interface","text":"<pre><code>Interface(equipment: Equipment)\n</code></pre> <p>Base class for all interfaces.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Base class for all interfaces.\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"\n    # __str__ and __repr__ can be called often for logging message, cache the values\n    self._str: str = f\"{self.__class__.__name__}&lt;{equipment.manufacturer}|{equipment.model}|{equipment.serial}&gt;\"\n    self._repr: str = self._str  # updated later\n\n    self._equipment: Equipment = equipment\n\n    if equipment.connection is None:\n        msg = f\"A Connection is not associated with {equipment}\"\n        raise TypeError(msg)\n\n    self._repr = self._repr[:-1] + f\" at {equipment.connection.address}&gt;\"\n    logger.debug(\"Connecting to %r\", self)\n</code></pre>"},{"location":"api/interfaces/#msl.equipment.schema.Interface.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/#msl.equipment.schema.Interface.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the equipment.</p> <p>This method can be overridden in the subclass if the subclass must implement tasks that need to be performed in order to safely disconnect from the equipment.</p> <p>For example,</p> <ul> <li>to clean up system resources from memory (e.g., if using a manufacturer's SDK)</li> <li>to configure the equipment to be in a state that is safe for people   working in the lab when the equipment is not in use</li> </ul> <p>Tip</p> <p>This method gets called automatically when the Interface instance gets garbage collected, which happens when the reference count is 0.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from the equipment.\n\n    This method can be overridden in the subclass if the subclass must implement\n    tasks that need to be performed in order to safely disconnect from the equipment.\n\n    For example,\n\n    * to clean up system resources from memory (e.g., if using a manufacturer's SDK)\n    * to configure the equipment to be in a state that is safe for people\n      working in the lab when the equipment is not in use\n\n    !!! tip\n        This method gets called automatically when the [Interface][msl.equipment.schema.Interface]\n        instance gets garbage collected, which happens when the reference count is 0.\n    \"\"\"\n    logger.debug(\"Disconnected from %r\", self)\n</code></pre>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased","title":"MessageBased","text":"<pre><code>MessageBased(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Base class for equipment that use message-based communication.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for message-based communication.</p> <p>Connection Properties:</p> Name Type Description <code>encoding</code> <code>str</code> <p>Encoding to used for read and write operations. Default: <code>utf-8</code></p> <code>max_read_size</code> <code>int</code> <p>Maximum number of bytes that can be read. Default: <code>1048576</code> (1 MB)</p> <code>read_termination</code> <code>bytes | str</code> <p>Termination character(s) to use for read messages. Default: <code>\\n</code></p> <code>rstrip</code> <code>bool</code> <p>Whether to remove trailing whitespace from read messages. Default: <code>False</code></p> <code>termination</code> <code>bytes | str</code> <p>Sets both <code>read_termination</code> and <code>write_termination</code> to the same termination character(s).</p> <code>timeout</code> <code>float | None</code> <p>Timeout, in seconds, for read and write operations. Default: <code>None</code></p> <code>write_termination</code> <code>bytes | str</code> <p>Termination character(s) to use for write messages. Default: <code>\\r\\n</code></p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    r\"\"\"Base class for equipment that use message-based communication.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following\n    _properties_ for message-based communication.\n\n    Attributes: Connection Properties:\n        encoding (str): Encoding to used for\n            [read][msl.equipment.interfaces.message_based.MessageBased.read] and\n            [write][msl.equipment.interfaces.message_based.MessageBased.write] operations.\n            _Default: `utf-8`_\n        max_read_size (int): Maximum number of bytes that can be\n            [read][msl.equipment.interfaces.message_based.MessageBased.read].\n            _Default: `1048576` (1 MB)_\n        read_termination (bytes | str): Termination character(s) to use for\n            [read][msl.equipment.interfaces.message_based.MessageBased.read] messages.\n            _Default: `\\n`_\n        rstrip (bool): Whether to remove trailing whitespace from\n            [read][msl.equipment.interfaces.message_based.MessageBased.read] messages.\n            _Default: `False`_\n        termination (bytes | str): Sets both `read_termination` and `write_termination`\n            to the same termination character(s).\n        timeout (float | None): Timeout, in seconds, for\n            [read][msl.equipment.interfaces.message_based.MessageBased.read] and\n            [write][msl.equipment.interfaces.message_based.MessageBased.write] operations.\n            _Default: `None`_\n        write_termination (bytes | str): Termination character(s) to use for\n            [write][msl.equipment.interfaces.message_based.MessageBased.write] messages.\n            _Default: `\\r\\n`_\n    \"\"\"\n    super().__init__(equipment)\n    assert equipment.connection is not None  # noqa: S101\n\n    self._encoding: str = \"utf-8\"\n    self._read_termination: bytes | None = None\n    self._write_termination: bytes | None = None\n    self._max_read_size: int = 1048576  # 1 &lt;&lt; 20 (1 MB)\n    self._timeout: float | None = None\n    self._rstrip: bool = False\n\n    p = equipment.connection.properties\n\n    self.max_read_size = p.get(\"max_read_size\", self._max_read_size)\n    self.timeout = p.get(\"timeout\", self._timeout)\n    self.encoding = p.get(\"encoding\", self._encoding)\n    self.rstrip = p.get(\"rstrip\", self._rstrip)\n\n    if \"termination\" in p:\n        self.read_termination = p[\"termination\"]\n        self.write_termination = p[\"termination\"]\n    else:\n        self.read_termination = p.get(\"read_termination\", b\"\\n\")\n        self.write_termination = p.get(\"write_termination\", b\"\\r\\n\")\n</code></pre>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.read_termination","title":"read_termination  <code>property</code> <code>writable</code>","text":"<pre><code>read_termination: bytes | None\n</code></pre> <p>The termination character sequence that is used for a read operation.</p> <p>Reading stops when the equipment stops sending data or the <code>read_termination</code> character sequence is detected. If you set the <code>read_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.write_termination","title":"write_termination  <code>property</code> <code>writable</code>","text":"<pre><code>write_termination: bytes | None\n</code></pre> <p>The termination character sequence that is appended to write messages.</p> <p>If you set the <code>write_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the equipment.</p> <p>This method can be overridden in the subclass if the subclass must implement tasks that need to be performed in order to safely disconnect from the equipment.</p> <p>For example,</p> <ul> <li>to clean up system resources from memory (e.g., if using a manufacturer's SDK)</li> <li>to configure the equipment to be in a state that is safe for people   working in the lab when the equipment is not in use</li> </ul> <p>Tip</p> <p>This method gets called automatically when the Interface instance gets garbage collected, which happens when the reference count is 0.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from the equipment.\n\n    This method can be overridden in the subclass if the subclass must implement\n    tasks that need to be performed in order to safely disconnect from the equipment.\n\n    For example,\n\n    * to clean up system resources from memory (e.g., if using a manufacturer's SDK)\n    * to configure the equipment to be in a state that is safe for people\n      working in the lab when the equipment is not in use\n\n    !!! tip\n        This method gets called automatically when the [Interface][msl.equipment.schema.Interface]\n        instance gets garbage collected, which happens when the reference count is 0.\n    \"\"\"\n    logger.debug(\"Disconnected from %r\", self)\n</code></pre>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError, USBTimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"api/interfaces/#msl.equipment.interfaces.message_based.MessageBased.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError, USBTimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"api/interfaces/ftdi/","title":"FTDI","text":""},{"location":"api/interfaces/ftdi/#ftdi-prerequisites","title":"Prerequisites","text":"<p>Before communicating with equipment that use a Future Technology Devices International (FTDI) chip for the interface, either a libusb-compatible driver or the d2xx driver must be installed and the directory to the appropriate library file (<code>libusb</code> or <code>ftd2xx</code>) must be available on the <code>PATH</code> environment variable.</p> <p>The following instructions are intended to be a starting point if you are having issues communicating with an FTDI chip.</p>"},{"location":"api/interfaces/ftdi/#ftdi-prerequisites-windows","title":"Windows","text":"<p>The choice of using a <code>libusb</code> or <code>d2xx</code> driver depends on whether the manufacturer of the equipment provides software that you also want to use to control the equipment and what driver their software uses. On Windows, this is typically the <code>d2xx</code> driver. If you don't want to use the manufacturer's software (or they don't provide software) then the choice of which driver to use does not matter.</p> <p>If you want to use a <code>libusb</code> driver, follow these instructions.</p> <p>If you want to use the d2xx driver, follow the installation guide (skip this step if the Windows Device Manager shows that the driver for the equipment has already been successfully installed), download the zip file that contains the <code>ftd2xx</code> library file then extract the zip file and copy the appropriate library file (i.e., <code>amd64\\ftd2xx64.dll</code> if using 64-bit Python, <code>i386\\ftd2xx.dll</code> if using 32-bit Python) to a directory that is on your <code>PATH</code> environment variable.</p>"},{"location":"api/interfaces/ftdi/#ftdi-prerequisites-linux","title":"Debian/Ubuntu","text":"<p>If you want to use the <code>libusb</code> driver (recommended), follow these instructions.</p> <p>If you want to use the d2xx driver, follow the installation guide, download the compressed-archive file that contains the <code>libftd2xx.so</code> library file then extract the archive and copy the library file (i.e., <code>linux-x86_64\\libftd2xx.so</code>) to a directory that is on your <code>PATH</code> environment variable, and, finally create a udev rule to be able to access the equipment as a non-root user (follow the udev instructions from here).</p>"},{"location":"api/interfaces/ftdi/#ftdi-prerequisites-macos","title":"macOS","text":"<p>If you want to use the <code>libusb</code> driver (recommended), follow these instructions.</p> <p>If you want to use the d2xx driver, follow the installation guide, download the virtual-disk file that contains the <code>libftd2xx.dylib</code> library file then extract the file and copy the library file (i.e., <code>release\\build\\libftd2xx.1.4.30.dylib</code>) to a directory that is on your <code>PATH</code> environment variable, and, finally rename the library file to be <code>libftd2xx.dylib</code> (i.e., remove the version information).</p>"},{"location":"api/interfaces/ftdi/#msl.equipment.interfaces.ftdi.FTDI","title":"FTDI","text":"<pre><code>FTDI(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MessageBased</code></p> <p>Base class for equipment that use a Future Technology Devices International (FTDI) chip for communication.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for the FTDI communication protocol, as well as the properties defined in MessageBased. The DataBits, Parity and StopBits enumeration names or values may also be used. For properties that specify an alias, you may also use the alternative name as the property name. The read_termination and write_termination values are automatically set to <code>None</code> (termination characters are not used in the FTDI protocol).</p> <p>Connection Properties:</p> Name Type Description <code>baud_rate</code> <code>int</code> <p>The baud rate (alias: baudrate). Default: <code>9600</code></p> <code>data_bits</code> <code>DataBits | str | int</code> <p>The number of data bits: 7 or 8 (alias: bytesize). Default: <code>8</code></p> <code>dsr_dtr</code> <code>bool</code> <p>Whether to enable hardware (DSR/DTR) flow control (alias: dsrdtr). Default: <code>False</code></p> <code>latency</code> <code>int | None</code> <p>The latency-timer value in milliseconds, between 1 and 255. If <code>None</code>, the latency timer is not set and the chip default is used, typically 16 ms. Default: <code>None</code></p> <code>parity</code> <code>Parity | str</code> <p>Parity checking: NONE, ODD, EVEN, MARK or SPACE. Default: <code>NONE</code></p> <code>rts_cts</code> <code>bool</code> <p>Whether to enable hardware (RTS/CTS) flow control (alias: rtscts). Default: <code>False</code></p> <code>stop_bits</code> <code>StopBits | str | float</code> <p>The number of stop bits: 1, 1.5 or 2 (alias: stopbits). Default: <code>1</code></p> <code>xon_xoff</code> <code>bool</code> <p>Whether to enable software flow control (alias: xonxoff). Default: <code>False</code></p> Source code in <code>src/msl/equipment/interfaces/ftdi.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Base class for equipment that use a Future Technology Devices International (FTDI) chip for communication.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for the FTDI communication protocol, as well as the _properties_ defined in\n    [MessageBased][msl.equipment.interfaces.message_based.MessageBased]. The\n    [DataBits][msl.equipment.enumerations.DataBits],\n    [Parity][msl.equipment.enumerations.Parity] and [StopBits][msl.equipment.enumerations.StopBits]\n    enumeration names or values may also be used. For properties that specify an _alias_, you\n    may also use the alternative name as the property name. The\n    [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination] and\n    [write_termination][msl.equipment.interfaces.message_based.MessageBased.write_termination] values\n    are automatically set to `None` (termination characters are not used in the FTDI protocol).\n\n    Attributes: Connection Properties:\n        baud_rate (int): The baud rate (_alias:_ baudrate).\n            _Default: `9600`_\n        data_bits (DataBits | str | int): The number of data bits: 7 or 8 (_alias:_ bytesize).\n            _Default: `8`_\n        dsr_dtr (bool): Whether to enable hardware (DSR/DTR) flow control (_alias:_ dsrdtr).\n            _Default: `False`_\n        latency (int | None): The latency-timer value in milliseconds, between 1 and 255.\n            If `None`, the latency timer is not set and the chip default is used, typically 16 ms.\n            _Default: `None`_\n        parity (Parity | str): Parity checking: NONE, ODD, EVEN, MARK or SPACE.\n            _Default: `NONE`_\n        rts_cts (bool): Whether to enable hardware (RTS/CTS) flow control (_alias:_ rtscts).\n            _Default: `False`_\n        stop_bits (StopBits | str | float): The number of stop bits: 1, 1.5 or 2 (_alias:_ stopbits).\n            _Default: `1`_\n        xon_xoff (bool): Whether to enable software flow control (_alias:_ xonxoff).\n            _Default: `False`_\n    \"\"\"\n    self._d2xx: _D2XX | None = None\n    self._libusb: USB | None = None\n    super().__init__(equipment)\n\n    self.check_packet_for_errors: bool = True\n    \"\"\"Whether to check the bit mask of the `line` byte in a read packet for errors.\n\n    This attribute is only used if *libusb* is used as the communication library.\n    See [poll_status][msl.equipment.interfaces.ftdi.FTDI.poll_status] for more details\n    about the `line` bit mask.\n    \"\"\"\n\n    self._read_termination: bytes | None = None\n    self._write_termination: bytes | None = None\n\n    assert equipment.connection is not None  # noqa: S101\n    parsed = parse_ftdi_address(equipment.connection.address)\n    if parsed is None:\n        msg = f\"Invalid FTDI address {equipment.connection.address!r}\"\n        raise ValueError(msg)\n\n    self._out_req_type: int = -1\n    self._in_req_type: int = -1\n    self._index: int = -1\n    self._characteristics: int = 0\n\n    if parsed.driver == 0:\n        # http://developer.intra2net.com/git/?p=libftdi;a=tree;f=src;hb=HEAD\n        self._libusb = USB(equipment)\n        self._libusb._str = self._str  # noqa: SLF001\n        self._index = self._libusb.bulk_in_endpoint.interface_number + 1\n        self._out_req_type = self._libusb.build_request_type(\n            direction=self._libusb.CtrlDirection.OUT,\n            type=self._libusb.CtrlType.VENDOR,\n            recipient=self._libusb.CtrlRecipient.DEVICE,\n        )\n        self._in_req_type = self._libusb.build_request_type(\n            direction=self._libusb.CtrlDirection.IN,\n            type=self._libusb.CtrlType.VENDOR,\n            recipient=self._libusb.CtrlRecipient.DEVICE,\n        )\n    elif parsed.driver == 2:  # noqa: PLR2004\n        self._d2xx = _D2XX(errcheck=self._error_check)\n        if not IS_WINDOWS:\n            self._d2xx.set_vid_pid(parsed.vid, parsed.pid)\n\n        if parsed.index is None:\n            self._d2xx.open_ex(parsed.serial)\n        else:\n            self._d2xx.open(parsed.index)\n    else:\n        msg = f\"Invalid FTDI driver number {parsed.driver}, must be either 0 or 2\"\n        raise ValueError(msg)\n\n    self._set_interface_timeout()\n\n    p = equipment.connection.properties\n\n    self.set_baud_rate(p.get(\"baud_rate\", p.get(\"baudrate\", 9600)))\n\n    self.set_data_characteristics(\n        data_bits=p.get(\"data_bits\", p.get(\"bytesize\", DataBits.EIGHT)),\n        parity=p.get(\"parity\", Parity.NONE),\n        stop_bits=p.get(\"stop_bits\", p.get(\"stopbits\", StopBits.ONE)),\n    )\n\n    latency: int | None = p.get(\"latency\")\n    if latency:\n        self.set_latency_timer(latency)\n\n    self.set_flow_control()  # set to None as default, the following may overwrite\n\n    if p.get(\"xon_xoff\", p.get(\"xonxoff\", False)):\n        self.set_flow_control(\"XON_XOFF\", xon=17, xoff=19)  # pySerial uses 17 and 19\n\n    if p.get(\"dsr_dtr\", p.get(\"dsrdtr\", False)):\n        self.set_flow_control(\"DTR_DSR\")\n\n    if p.get(\"rts_cts\", p.get(\"rtscts\", False)):\n        self.set_flow_control(\"RTS_CTS\")\n</code></pre>"},{"location":"api/interfaces/ftdi/#msl.equipment.interfaces.ftdi.FTDI.check_packet_for_errors","title":"check_packet_for_errors  <code>instance-attribute</code>","text":"<pre><code>check_packet_for_errors: bool = True\n</code></pre> <p>Whether to check the bit mask of the <code>line</code> byte in a read packet for errors.</p> <p>This attribute is only used if libusb is used as the communication library. See poll_status for more details about the <code>line</code> bit mask.</p>"},{"location":"api/interfaces/ftdi/#msl.equipment.interfaces.ftdi.FTDI.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"api/interfaces/ftdi/#msl.equipment.interfaces.ftdi.FTDI.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/ftdi/#msl.equipment.interfaces.ftdi.FTDI.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"api/interfaces/ftdi/#msl.equipment.interfaces.ftdi.FTDI.read_termination","title":"read_termination  <code>property</code> <code>writable</code>","text":"<pre><code>read_termination: bytes | None\n</code></pre> <p>The termination character sequence that is used for a read operation.</p> <p>Reading stops when the equipment stops sending data or the <code>read_termination</code> character sequence is detected. If you set the <code>read_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/ftdi/#msl.equipment.interfaces.ftdi.FTDI.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"api/interfaces/ftdi/#msl.equipment.interfaces.ftdi.FTDI.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"api/interfaces/ftdi/#msl.equipment.interfaces.ftdi.FTDI.write_termination","title":"write_termination  <code>property</code> <code>writable</code>","text":"<pre><code>write_termination: bytes | None\n</code></pre> <p>The termination character sequence that is appended to write messages.</p> <p>If you set the <code>write_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/ftdi/#msl.equipment.interfaces.ftdi.FTDI.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the equipment.</p> Source code in <code>src/msl/equipment/interfaces/ftdi.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Disconnect from the equipment.\"\"\"\n    if self._d2xx is not None:\n        self._d2xx.close()\n        self._d2xx = None\n        super().disconnect()\n    elif self._libusb is not None:\n        self._libusb.disconnect()\n        self._libusb = None\n        super().disconnect()\n</code></pre>"},{"location":"api/interfaces/ftdi/#msl.equipment.interfaces.ftdi.FTDI.get_latency_timer","title":"get_latency_timer","text":"<pre><code>get_latency_timer() -&gt; int\n</code></pre> <p>Get the latency-timer value from the FTDI chip.</p> <p>Returns:</p> Type Description <code>int</code> <p>The latency-timer value, in milliseconds.</p> Source code in <code>src/msl/equipment/interfaces/ftdi.py</code> <pre><code>def get_latency_timer(self) -&gt; int:\n    \"\"\"Get the latency-timer value from the FTDI chip.\n\n    Returns:\n        The latency-timer value, in milliseconds.\n    \"\"\"\n    if self._d2xx is not None:\n        return self._d2xx.get_latency_timer()\n\n    assert self._libusb is not None  # noqa: S101\n\n    # https://github.com/torvalds/linux/blob/5572ad8fddecd4a0db19801262072ff5916b7589/drivers/usb/serial/ftdi_sio.c#L1408\n    if self._libusb.device_version &lt;= FT232A:\n        # The linux code returns an error, but FT_GetLatencyTimer in the D2xx programming manual states:\n        #  \"In the FT8U232AM and FT8U245AM devices, the receive buffer timeout that is used\n        #   to flush remaining data from the receive buffer was fixed at 16 ms.\"\n        return 16\n\n    data = self._libusb.ctrl_transfer(\n        request_type=self._in_req_type,\n        request=0x0A,  # FTDI_SIO_GET_LATENCY_TIMER\n        value=0,\n        index=self._index,\n        data_or_length=1,\n    )\n    assert not isinstance(data, int)  # noqa: S101\n    return data[0]\n</code></pre>"},{"location":"api/interfaces/ftdi/#msl.equipment.interfaces.ftdi.FTDI.poll_status","title":"poll_status","text":"<pre><code>poll_status() -&gt; tuple[int, int]\n</code></pre> <p>Polls the modem and line status bytes from the FTDI chip.</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>The <code>(modem, line)</code> status bytes.</p> <p>Bit mask of the <code>modem</code> byte:</p> <ul> <li>B0..3: Should be 0 (reserved)</li> <li>B4: Clear To Send (CTS) = 0x10</li> <li>B5: Data Set Ready (DSR) = 0x20</li> <li>B6: Ring Indicator (RI) = 0x40</li> <li>B7: Data Carrier Detect (DCD) = 0x80</li> </ul> <p>Bit mask of the <code>line</code> byte:</p> <ul> <li>B0: Data Ready (DR) = 0x01</li> <li>B1: Overrun Error (OE) = 0x02</li> <li>B2: Parity Error (PE) = 0x04</li> <li>B3: Framing Error (FE) = 0x08</li> <li>B4: Break Interrupt (BI) = 0x10</li> <li>B5: Transmitter Holding Register Empty (THRE) = 0x20</li> <li>B6: Transmitter Empty (TEMT) = 0x40</li> <li>B7: Receiver FIFO Error (RCVE) = 0x80</li> </ul> Source code in <code>src/msl/equipment/interfaces/ftdi.py</code> <pre><code>def poll_status(self) -&gt; tuple[int, int]:\n    \"\"\"Polls the modem and line status bytes from the FTDI chip.\n\n    Returns:\n        The `(modem, line)` status bytes.\n\n            Bit mask of the `modem` byte:\n\n            - B0..3: Should be 0 (reserved)\n            - B4: Clear To Send (CTS) = 0x10\n            - B5: Data Set Ready (DSR) = 0x20\n            - B6: Ring Indicator (RI) = 0x40\n            - B7: Data Carrier Detect (DCD) = 0x80\n\n            Bit mask of the `line` byte:\n\n            - B0: Data Ready (DR) = 0x01\n            - B1: Overrun Error (OE) = 0x02\n            - B2: Parity Error (PE) = 0x04\n            - B3: Framing Error (FE) = 0x08\n            - B4: Break Interrupt (BI) = 0x10\n            - B5: Transmitter Holding Register Empty (THRE) = 0x20\n            - B6: Transmitter Empty (TEMT) = 0x40\n            - B7: Receiver FIFO Error (RCVE) = 0x80\n\n    \"\"\"\n    status: int\n    if self._d2xx is not None:\n        status = self._d2xx.get_line_modem_status()\n    else:\n        assert self._libusb is not None  # noqa: S101\n\n        # https://github.com/torvalds/linux/blob/5572ad8fddecd4a0db19801262072ff5916b7589/drivers/usb/serial/ftdi_sio.c#L2744\n        length, fmt = (1, \"B\") if self._libusb.device_version &lt; FT232A else (2, \"&lt;H\")\n        data = self._libusb.ctrl_transfer(\n            request_type=self._in_req_type,\n            request=5,  # FTDI_SIO_GET_MODEM_STATUS\n            value=0,\n            index=self._index,\n            data_or_length=length,\n        )\n        assert not isinstance(data, int)  # noqa: S101\n        (status,) = unpack(fmt, data)\n\n    line = (status &gt;&gt; 8) &amp; 0xFF\n    modem = status &amp; 0xFF\n    return modem, line\n</code></pre>"},{"location":"api/interfaces/ftdi/#msl.equipment.interfaces.ftdi.FTDI.purge_buffers","title":"purge_buffers","text":"<pre><code>purge_buffers() -&gt; None\n</code></pre> <p>Purge the receive (Rx) and transmit (Tx) buffers of the FTDI chip.</p> Source code in <code>src/msl/equipment/interfaces/ftdi.py</code> <pre><code>def purge_buffers(self) -&gt; None:\n    \"\"\"Purge the receive (Rx) and transmit (Tx) buffers of the FTDI chip.\"\"\"\n    if self._d2xx is not None:\n        return self._d2xx.purge_buffers()\n\n    assert self._libusb is not None  # noqa: S101\n    # http://developer.intra2net.com/git/?p=libftdi;a=blob;f=src/ftdi.c;h=811f801feab8a04a62526c68ff2a93aae11feb2b;hb=HEAD#l1032\n    # 0=SIO_RESET_REQUEST, 1=SIO_TCOFLUSH (host-to-ftdi), 2=SIO_TCIFLUSH (ftdi-to-host)\n    _ = self._libusb.ctrl_transfer(request_type=self._out_req_type, request=0, value=1, index=self._index)\n    _ = self._libusb.ctrl_transfer(request_type=self._out_req_type, request=0, value=2, index=self._index)\n    return None\n</code></pre>"},{"location":"api/interfaces/ftdi/#msl.equipment.interfaces.ftdi.FTDI.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"api/interfaces/ftdi/#msl.equipment.interfaces.ftdi.FTDI.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError, USBTimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"api/interfaces/ftdi/#msl.equipment.interfaces.ftdi.FTDI.reset_device","title":"reset_device","text":"<pre><code>reset_device() -&gt; None\n</code></pre> <p>Sends a reset command to the FTDI chip.</p> Source code in <code>src/msl/equipment/interfaces/ftdi.py</code> <pre><code>def reset_device(self) -&gt; None:\n    \"\"\"Sends a reset command to the FTDI chip.\"\"\"\n    if self._d2xx is not None:\n        return self._d2xx.reset_device()\n\n    # http://developer.intra2net.com/git/?p=libftdi;a=blob;f=src/ftdi.c;h=811f801feab8a04a62526c68ff2a93aae11feb2b;hb=HEAD#l1006\n    assert self._libusb is not None  # noqa: S101\n    # SIO_RESET=0, SIO_RESET_SIO=0\n    _ = self._libusb.ctrl_transfer(request_type=self._out_req_type, request=0, value=0, index=self._index)\n    return None\n</code></pre>"},{"location":"api/interfaces/ftdi/#msl.equipment.interfaces.ftdi.FTDI.set_baud_rate","title":"set_baud_rate","text":"<pre><code>set_baud_rate(rate: int) -&gt; None\n</code></pre> <p>Set the baud rate for the FTDI chip.</p> <p>Parameters:</p> Name Type Description Default <code>rate</code> <code>int</code> <p>The baud rate.</p> required Source code in <code>src/msl/equipment/interfaces/ftdi.py</code> <pre><code>def set_baud_rate(self, rate: int) -&gt; None:\n    \"\"\"Set the baud rate for the FTDI chip.\n\n    Args:\n        rate: The baud rate.\n    \"\"\"\n    if self._d2xx is not None:\n        return self._d2xx.set_baud_rate(rate)\n\n    # https://github.com/torvalds/linux/blob/5572ad8fddecd4a0db19801262072ff5916b7589/drivers/usb/serial/ftdi_sio.c#L1342\n    assert self._libusb is not None  # noqa: S101\n    dv = self._libusb.device_version\n    divisor = _get_ftdi_divisor(baudrate=rate, device_version=dv)\n    value = divisor &amp; 0xFFFF\n    index = (divisor &gt;&gt; 16) &amp; 0xFFFF\n    if dv &gt;= FT2232H or dv == FT2232C:\n        index &lt;&lt;= 8\n        index |= self._index\n\n    _ = self._libusb.ctrl_transfer(\n        request_type=self._out_req_type,\n        request=3,  # FTDI_SIO_SET_BAUDRATE_REQUEST\n        value=value,\n        index=index,\n    )\n    return None\n</code></pre>"},{"location":"api/interfaces/ftdi/#msl.equipment.interfaces.ftdi.FTDI.set_break","title":"set_break","text":"<pre><code>set_break(state: bool) -&gt; None\n</code></pre> <p>Set the BREAK condition for the FTDI chip.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>The state of the BREAK condition. If <code>True</code>, the transmit (Tx) line is driven low until this method is called with <code>False</code>, which resets or de-asserts the BREAK condition returning the transmit line to its normal operating state.</p> required Source code in <code>src/msl/equipment/interfaces/ftdi.py</code> <pre><code>def set_break(self, state: bool) -&gt; None:  # noqa: FBT001\n    \"\"\"Set the BREAK condition for the FTDI chip.\n\n    Args:\n        state: The state of the BREAK condition. If `True`, the transmit (Tx) line is driven\n            low until this method is called with `False`, which resets or de-asserts the\n            BREAK condition returning the transmit line to its normal operating state.\n    \"\"\"\n    if self._d2xx is not None:\n        return self._d2xx.set_break_on() if state else self._d2xx.set_break_off()\n\n    # http://developer.intra2net.com/git/?p=libftdi;a=blob;f=src/ftdi.c;h=811f801feab8a04a62526c68ff2a93aae11feb2b;hb=HEAD#l1512\n    assert self._libusb is not None  # noqa: S101\n    _ = self._libusb.ctrl_transfer(\n        request_type=self._out_req_type,\n        request=4,  # SIO_SET_DATA\n        value=self._characteristics | (0x1 &lt;&lt; 14) if state else self._characteristics,\n        index=self._index,\n    )\n    return None\n</code></pre>"},{"location":"api/interfaces/ftdi/#msl.equipment.interfaces.ftdi.FTDI.set_data_characteristics","title":"set_data_characteristics","text":"<pre><code>set_data_characteristics(\n    *,\n    data_bits: DataBits | str | int = EIGHT,\n    parity: Parity | str = NONE,\n    stop_bits: StopBits | str | float = ONE\n) -&gt; None\n</code></pre> <p>Set the RS-232 data characteristics for the FTDI chip.</p> <p>Parameters:</p> Name Type Description Default <code>data_bits</code> <code>DataBits | str | int</code> <p>The number of data bits (7 or 8). Can be an enum member name (case insensitive) or value.</p> <code>EIGHT</code> <code>parity</code> <code>Parity | str</code> <p>The parity. Can be an enum member name (case insensitive) or value.</p> <code>NONE</code> <code>stop_bits</code> <code>StopBits | str | float</code> <p>The number of stop bits. Can be an enum member name (case insensitive) or value.</p> <code>ONE</code> Source code in <code>src/msl/equipment/interfaces/ftdi.py</code> <pre><code>def set_data_characteristics(\n    self,\n    *,\n    data_bits: DataBits | str | int = DataBits.EIGHT,\n    parity: Parity | str = Parity.NONE,\n    stop_bits: StopBits | str | float = StopBits.ONE,\n) -&gt; None:\n    \"\"\"Set the RS-232 data characteristics for the FTDI chip.\n\n    Args:\n        data_bits: The number of data bits (7 or 8). Can be an enum member name (case insensitive) or value.\n        parity: The parity. Can be an enum member name (case insensitive) or value.\n        stop_bits: The number of stop bits. Can be an enum member name (case insensitive) or value.\n    \"\"\"\n    data_bits = to_enum(data_bits, DataBits, to_upper=True)\n    parity = to_enum(parity, Parity, to_upper=True)\n    stop_bits = to_enum(stop_bits, StopBits, to_upper=True)\n\n    if data_bits not in {7, 8}:\n        msg = f\"Unsupported data_bits value {data_bits!r}, must be either 7 or 8\"\n        raise ValueError(msg)\n\n    if self._d2xx is not None:\n        return self._d2xx.set_data_characteristics(data_bits=data_bits, parity=parity, stop_bits=stop_bits)\n\n    # http://developer.intra2net.com/git/?p=libftdi;a=blob;f=src/ftdi.c;h=811f801feab8a04a62526c68ff2a93aae11feb2b;hb=HEAD#l1512\n    assert self._libusb is not None  # noqa: S101\n    value = data_bits.value\n    value |= {Parity.NONE: 0, Parity.ODD: 256, Parity.EVEN: 512, Parity.MARK: 768, Parity.SPACE: 1024}[parity]\n    value |= {StopBits.ONE: 0, StopBits.ONE_POINT_FIVE: 2048, StopBits.TWO: 4096}[stop_bits]\n\n    self._characteristics = value\n    _ = self._libusb.ctrl_transfer(\n        request_type=self._out_req_type,\n        request=4,  # SIO_SET_DATA\n        value=value,\n        index=self._index,\n    )\n    return None\n</code></pre>"},{"location":"api/interfaces/ftdi/#msl.equipment.interfaces.ftdi.FTDI.set_dtr","title":"set_dtr","text":"<pre><code>set_dtr(state: bool) -&gt; None\n</code></pre> <p>Set the Data Terminal Ready (DTR) control signal.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>New state of the DTR logical level: HIGH (<code>True</code>) or LOW (<code>False</code>).</p> required Source code in <code>src/msl/equipment/interfaces/ftdi.py</code> <pre><code>def set_dtr(self, state: bool) -&gt; None:  # noqa: FBT001\n    \"\"\"Set the Data Terminal Ready (DTR) control signal.\n\n    Args:\n        state: New state of the DTR logical level: HIGH (`True`) or LOW (`False`).\n    \"\"\"\n    if self._d2xx is not None:\n        return self._d2xx.set_dtr() if state else self._d2xx.clr_dtr()\n\n    # https://github.com/torvalds/linux/blob/5572ad8fddecd4a0db19801262072ff5916b7589/drivers/usb/serial/ftdi_sio.c#L1199\n    assert self._libusb is not None  # noqa: S101\n    # FTDI_SIO_SET_DTR_HIGH=((0x01 &lt;&lt; 8) | 1), FTDI_SIO_SET_DTR_LOW=((0x01 &lt;&lt; 8) | 0)\n    _ = self._libusb.ctrl_transfer(\n        request_type=self._out_req_type,\n        request=1,  # FTDI_SIO_MODEM_CTRL\n        value=257 if state else 256,\n        index=self._index,\n    )\n    return None\n</code></pre>"},{"location":"api/interfaces/ftdi/#msl.equipment.interfaces.ftdi.FTDI.set_flow_control","title":"set_flow_control","text":"<pre><code>set_flow_control(\n    flow: (\n        Literal[\"RTS_CTS\", \"DTR_DSR\", \"XON_XOFF\"] | None\n    ) = None,\n    *,\n    xon: int = 0,\n    xoff: int = 0\n) -&gt; None\n</code></pre> <p>Sets the flow control for the FTDI chip.</p> <p>Parameters:</p> Name Type Description Default <code>flow</code> <code>Literal['RTS_CTS', 'DTR_DSR', 'XON_XOFF'] | None</code> <p>The type of flow control to use, <code>None</code> disables flow control.</p> <code>None</code> <code>xon</code> <code>int</code> <p>The character (between 0 and 255) to signal Xon. Only used if <code>flow</code> is <code>XON_XOFF</code>.</p> <code>0</code> <code>xoff</code> <code>int</code> <p>The character (between 0 and 255) to signal Xoff. Only used if <code>flow</code> is <code>XON_XOFF</code>.</p> <code>0</code> Source code in <code>src/msl/equipment/interfaces/ftdi.py</code> <pre><code>def set_flow_control(\n    self, flow: Literal[\"RTS_CTS\", \"DTR_DSR\", \"XON_XOFF\"] | None = None, *, xon: int = 0, xoff: int = 0\n) -&gt; None:\n    \"\"\"Sets the flow control for the FTDI chip.\n\n    Args:\n        flow: The type of flow control to use, `None` disables flow control.\n        xon: The character (between 0 and 255) to signal Xon. Only used if `flow` is `XON_XOFF`.\n        xoff: The character (between 0 and 255) to signal Xoff. Only used if `flow` is `XON_XOFF`.\n    \"\"\"\n    if self._d2xx is not None:\n        return self._d2xx.set_flow_control(flow, xon=xon, xoff=xoff)\n\n    # https://github.com/torvalds/linux/blob/5572ad8fddecd4a0db19801262072ff5916b7589/drivers/usb/serial/ftdi_sio.c#L2716\n    assert self._libusb is not None  # noqa: S101\n    value, index = 0, 0\n    if flow == \"RTS_CTS\":\n        index = 0x1 &lt;&lt; 8  # FTDI_SIO_RTS_CTS_HS\n    elif flow == \"DTR_DSR\":\n        index = 0x2 &lt;&lt; 8  # FTDI_SIO_DTR_DSR_HS\n    elif flow == \"XON_XOFF\":\n        value = (xoff &lt;&lt; 8) | xon\n        index = 0x4 &lt;&lt; 8  # FTDI_SIO_XON_XOFF_HS\n\n    _ = self._libusb.ctrl_transfer(\n        request_type=self._out_req_type,\n        request=2,  # FTDI_SIO_SET_FLOW_CTRL\n        value=value,\n        index=index | self._index,\n    )\n    return None\n</code></pre>"},{"location":"api/interfaces/ftdi/#msl.equipment.interfaces.ftdi.FTDI.set_latency_timer","title":"set_latency_timer","text":"<pre><code>set_latency_timer(value: int) -&gt; None\n</code></pre> <p>Set the latency-timer value for the FTDI chip.</p> <p>The latency timer is a form of timeout mechanism for the read buffer of FTDI chip.</p> <p>The latency timer counts from the last time data was sent back to the computer. If the latency timer expires, the chip will send what data it has available to the computer regardless of how many bytes it is waiting on. The latency timer will then reset and begin counting again.</p> <p>The timer allows the chip to be better optimized for protocols requiring faster response times from shorter data packets.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>Required value, in milliseconds, of the latency timer. Valid range is [1, 255].</p> required Source code in <code>src/msl/equipment/interfaces/ftdi.py</code> <pre><code>def set_latency_timer(self, value: int) -&gt; None:\n    \"\"\"Set the latency-timer value for the FTDI chip.\n\n    The latency timer is a form of timeout mechanism for the read buffer of FTDI chip.\n\n    The latency timer counts from the last time data was sent back to the computer. If\n    the latency timer expires, the chip will send what data it has available to the\n    computer regardless of how many bytes it is waiting on. The latency timer will then\n    reset and begin counting again.\n\n    The timer allows the chip to be better optimized for protocols requiring faster\n    response times from shorter data packets.\n\n    Args:\n        value: Required value, in milliseconds, of the latency timer. Valid range is [1, 255].\n    \"\"\"\n    v = int(value)\n    if v &lt; 1 or v &gt; 255:  # noqa: PLR2004\n        msg = f\"Invalid latency timer value {value}, must be an integer in the range [1, 255]\"\n        raise ValueError(msg)\n\n    if self._d2xx is not None:\n        return self._d2xx.set_latency_timer(v)\n\n    # https://github.com/torvalds/linux/blob/5572ad8fddecd4a0db19801262072ff5916b7589/drivers/usb/serial/ftdi_sio.c#L1365\n    assert self._libusb is not None  # noqa: S101\n    if self._libusb.device_version &lt;= FT232A:\n        # The linux code returns an error, but FT_SetLatencyTimer in the D2xx programming manual states:\n        #  \"In the FT8U232AM and FT8U245AM devices, the receive buffer timeout that is used\n        #   to flush remaining data from the receive buffer was fixed at 16 ms.\"\n        if v == 16:  # noqa: PLR2004\n            return None\n        msg = \"Cannot set the latency timer for the FTDI chip. The value is fixed at 16 ms.\"\n        raise MSLConnectionError(self, msg)\n\n    _ = self._libusb.ctrl_transfer(\n        request_type=self._out_req_type,\n        request=9,  # FTDI_SIO_SET_LATENCY_TIMER\n        value=v,\n        index=self._index,\n    )\n    return None\n</code></pre>"},{"location":"api/interfaces/ftdi/#msl.equipment.interfaces.ftdi.FTDI.set_rts","title":"set_rts","text":"<pre><code>set_rts(state: bool) -&gt; None\n</code></pre> <p>Set the Request To Send (RTS) control signal.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>New state of the RTS logical level: HIGH (<code>True</code>) or LOW (<code>False</code>).</p> required Source code in <code>src/msl/equipment/interfaces/ftdi.py</code> <pre><code>def set_rts(self, state: bool) -&gt; None:  # noqa: FBT001\n    \"\"\"Set the Request To Send (RTS) control signal.\n\n    Args:\n        state: New state of the RTS logical level: HIGH (`True`) or LOW (`False`).\n    \"\"\"\n    if self._d2xx is not None:\n        return self._d2xx.set_rts() if state else self._d2xx.clr_rts()\n\n    # https://github.com/torvalds/linux/blob/5572ad8fddecd4a0db19801262072ff5916b7589/drivers/usb/serial/ftdi_sio.c#L1199\n    assert self._libusb is not None  # noqa: S101\n    # FTDI_SIO_SET_RTS_HIGH=((0x2 &lt;&lt; 8) | 2), FTDI_SIO_SET_RTS_LOW=((0x2 &lt;&lt; 8) | 0)\n    _ = self._libusb.ctrl_transfer(\n        request_type=self._out_req_type,\n        request=1,  # FTDI_SIO_MODEM_CTRL\n        value=514 if state else 512,\n        index=self._index,\n    )\n    return None\n</code></pre>"},{"location":"api/interfaces/ftdi/#msl.equipment.interfaces.ftdi.FTDI.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError, USBTimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"api/interfaces/gpib/","title":"GPIB","text":""},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB","title":"GPIB","text":"<pre><code>GPIB(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MessageBased</code></p> <p>Base class for GPIB communication.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for the GPIB communication protocol, as well as the properties defined in MessageBased.</p> <p>Connection Properties:</p> Name Type Description <code>eos_mode</code> <code>int</code> <p>Specifies the end-of-string character and mode (see eos for details). Default: <code>0</code></p> <code>send_eoi</code> <code>bool</code> <p>Whether to enable (<code>True</code>) or disable (<code>False</code>) the assertion of the EOI signal. Default: <code>True</code></p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Base class for GPIB communication.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for the GPIB communication protocol, as well as the _properties_ defined in\n    [MessageBased][msl.equipment.interfaces.message_based.MessageBased].\n\n    Attributes: Connection Properties:\n        eos_mode (int): Specifies the end-of-string character and mode\n            (see [eos](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibeos.html) for details).\n            _Default: `0`_\n        send_eoi (bool): Whether to enable (`True`) or disable (`False`) the assertion of the EOI signal.\n            _Default: `True`_\n    \"\"\"\n    self._own: bool = True\n    self._handle: int = -1\n    super().__init__(equipment)\n\n    assert equipment.connection is not None  # noqa: S101\n    info = parse_gpib_address(equipment.connection.address)\n    if not info:\n        msg = f\"Invalid GPIB address {equipment.connection.address!r}\"\n        raise ValueError(msg)\n\n    props = equipment.connection.properties\n    _ = props.setdefault(\"read_termination\", None)\n\n    _load_library(self._error_check)\n    assert GPIB.gpib_library is not None  # noqa: S101\n    self._lib: Any = GPIB.gpib_library.lib\n\n    if info.name:\n        # a board or device object from a name in a gpib.conf file\n        self._handle = self._get_ibfind_handle(info.name)\n    elif info.pad is None:\n        # a board object with the given board number\n        self._handle = info.board\n        self._own = False\n    else:\n        # a device object\n        send_eoi = int(props.get(\"send_eoi\", 1))\n        eos_mode = int(props.get(\"eos_mode\", 0))\n        sad = 0 if info.sad is None else info.sad\n        if sad != 0 and sad &lt; 0x60:  # noqa: PLR2004\n            sad += 0x60\n        info.sad = sad\n        timeout = _convert_timeout(props.get(\"timeout\", None))\n        self._handle = self._get_ibdev_handle(info.board, info.pad, sad, timeout, send_eoi, eos_mode)\n\n    # keep this reference assignment after the if/else condition since the\n    # value of the secondary address may have been updated\n    self._address_info: ParsedGPIBAddress = info\n\n    # check if the handle corresponds to a system controller (INTFC)\n    self._is_board: bool\n    try:\n        self._is_board = bool(self.ask(0xA))  # IbaSC = 0xa\n    except MSLConnectionError:\n        # asking IbaSC for a GPIB device raises EHDL error\n        self._is_board = False\n\n    if not self._is_board:\n        self._set_interface_timeout()\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.board","title":"board  <code>property</code>","text":"<pre><code>board: int\n</code></pre> <p>Returns the board descriptor.</p>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.handle","title":"handle  <code>property</code>","text":"<pre><code>handle: int\n</code></pre> <p>Returns the handle of the instantiated board or device.</p>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.read_termination","title":"read_termination  <code>property</code> <code>writable</code>","text":"<pre><code>read_termination: bytes | None\n</code></pre> <p>The termination character sequence that is used for the read method.</p> <p>By default, reading stops when the EOI line is asserted.</p>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.write_termination","title":"write_termination  <code>property</code> <code>writable</code>","text":"<pre><code>write_termination: bytes | None\n</code></pre> <p>The termination character sequence that is appended to write messages.</p> <p>If you set the <code>write_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.ask","title":"ask","text":"<pre><code>ask(option: int, *, handle: int | None = None) -&gt; int\n</code></pre> <p>Get a configuration setting (board or device).</p> <p>This method is the ibask function, it should not be confused with the query method.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>int</code> <p>A configuration setting to get the value of.</p> required <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The value of the configuration setting.</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def ask(self, option: int, *, handle: int | None = None) -&gt; int:\n    \"\"\"Get a configuration setting (board or device).\n\n    This method is the [ibask](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibask.html)\n    function, it should not be confused with the [query][msl.equipment.interfaces.message_based.MessageBased.query]\n    method.\n\n    Args:\n        option: A configuration setting to get the value of.\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The value of the configuration setting.\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    setting = c_int()\n    self._lib.ibask(handle, option, byref(setting))\n    return setting.value\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.clear","title":"clear","text":"<pre><code>clear(*, handle: int | None = None) -&gt; int\n</code></pre> <p>Send the clear command (device).</p> <p>This method is the ibclr function.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def clear(self, *, handle: int | None = None) -&gt; int:\n    \"\"\"Send the clear command (device).\n\n    This method is the [ibclr](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibclr.html) function.\n\n    Args:\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibclr(handle)\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.command","title":"command","text":"<pre><code>command(data: bytes, *, handle: int | None = None) -&gt; int\n</code></pre> <p>Write command bytes (board).</p> <p>This method is the ibcmd function.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The commands to write to the bus.</p> required <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def command(self, data: bytes, *, handle: int | None = None) -&gt; int:\n    \"\"\"Write command bytes (board).\n\n    This method is the [ibcmd](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibcmd.html) function.\n\n    Args:\n        data: The [commands](https://linux-gpib.sourceforge.io/doc_html/gpib-protocol.html#REFERENCE-COMMAND-BYTES)\n            to write to the bus.\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibcmd(handle, data, len(data))\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.config","title":"config","text":"<pre><code>config(\n    option: int, value: int, *, handle: int | None = None\n) -&gt; int\n</code></pre> <p>Change configuration settings (board or device).</p> <p>This method is the ibconfig function.</p> <p>Parameters:</p> Name Type Description Default <code>option</code> <code>int</code> <p>A configuration setting to change the value of.</p> required <code>value</code> <code>int</code> <p>The new configuration setting value.</p> required <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def config(self, option: int, value: int, *, handle: int | None = None) -&gt; int:\n    \"\"\"Change configuration settings (board or device).\n\n    This method is the [ibconfig](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibconfig.html)\n    function.\n\n    Args:\n        option: A configuration setting to change the value of.\n        value: The new configuration setting value.\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibconfig(handle, option, value)\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.control_atn","title":"control_atn","text":"<pre><code>control_atn(\n    state: int, *, handle: int | None = None\n) -&gt; int\n</code></pre> <p>Set the state of the ATN line (board).</p> <p>This method mimics the PyVISA-py implementation.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>The state of the ATN line or the active controller. Allowed values are:</p> <ul> <li>0: ATN_DEASSERT</li> <li>1: ATN_ASSERT</li> <li>2: ATN_DEASSERT_HANDSHAKE</li> <li>3: ATN_ASSERT_IMMEDIATE</li> </ul> required <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def control_atn(self, state: int, *, handle: int | None = None) -&gt; int:\n    \"\"\"Set the state of the ATN line (board).\n\n    This method mimics the PyVISA-py implementation.\n\n    Args:\n        state: The state of the ATN line or the active controller. Allowed values are:\n\n            * 0: ATN_DEASSERT\n            * 1: ATN_ASSERT\n            * 2: ATN_DEASSERT_HANDSHAKE\n            * 3: ATN_ASSERT_IMMEDIATE\n\n    Args:\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    ibsta: int\n    if handle is None:\n        handle = self._handle\n    if state == ATN_DEASSERT:\n        ibsta = self._lib.ibgts(handle, 0)\n        return ibsta\n    if state == ATN_ASSERT:\n        ibsta = self._lib.ibcac(handle, 0)\n        return ibsta\n    if state == ATN_DEASSERT_HANDSHAKE:\n        ibsta = self._lib.ibgts(handle, 1)\n        return ibsta\n    if state == ATN_ASSERT_IMMEDIATE:\n        ibsta = self._lib.ibcac(handle, 1)\n        return ibsta\n\n    msg = f\"Invalid ATN {state=}\"\n    raise MSLConnectionError(self, message=msg)\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.control_ren","title":"control_ren","text":"<pre><code>control_ren(\n    state: int, *, handle: int | None = None\n) -&gt; int\n</code></pre> <p>Controls the state of the GPIB Remote Enable (REN) interface line.</p> <p>Optionally the remote/local state of the device is also controlled.</p> <p>This method mimics the PyVISA-py implementation.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>Specifies the state of the REN line and optionally the device remote/local state. Allowed values are:</p> <ul> <li>0: REN_DEASSERT</li> <li>1: REN_ASSERT</li> <li>2: REN_DEASSERT_GTL</li> <li>3: REN_ASSERT_ADDRESS</li> <li>4: REN_ASSERT_LLO</li> <li>5: REN_ASSERT_ADDRESS_LLO</li> <li>6: REN_ADDRESS_GTL</li> </ul> required <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def control_ren(self, state: int, *, handle: int | None = None) -&gt; int:\n    \"\"\"Controls the state of the GPIB Remote Enable (REN) interface line.\n\n    Optionally the remote/local state of the device is also controlled.\n\n    This method mimics the PyVISA-py implementation.\n\n    Args:\n        state: Specifies the state of the REN line and optionally the device remote/local state.\n            Allowed values are:\n\n            * 0: REN_DEASSERT\n            * 1: REN_ASSERT\n            * 2: REN_DEASSERT_GTL\n            * 3: REN_ASSERT_ADDRESS\n            * 4: REN_ASSERT_LLO\n            * 5: REN_ASSERT_ADDRESS_LLO\n            * 6: REN_ADDRESS_GTL\n\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n\n    ibsta = 0\n    if self._is_board and state not in (REN_ASSERT, REN_DEASSERT, REN_ASSERT_LLO):\n        msg = f\"Invalid REN {state=} for INTFC\"\n        raise MSLConnectionError(self, message=msg)\n\n    if state == REN_DEASSERT_GTL:\n        ibsta = self.command(b\"\\x01\", handle=handle)  # GTL = 0x1\n\n    if state in (REN_DEASSERT, REN_DEASSERT_GTL):\n        ibsta = self.remote_enable(state=False, handle=handle)\n\n    if state == REN_ASSERT_LLO:\n        ibsta = self.command(b\"\\x11\", handle=handle)  # LLO = 0x11\n    elif state == REN_ADDRESS_GTL:\n        ibsta = self.command(b\"\\x01\", handle=handle)  # GTL = 0x1\n    elif state == REN_ASSERT_ADDRESS_LLO:\n        pass\n    elif state in (REN_ASSERT, REN_ASSERT_ADDRESS):\n        ibsta = self.remote_enable(state=True, handle=handle)\n        if not self._is_board and state == REN_ASSERT_ADDRESS:\n            assert self._address_info.pad is not None  # noqa: S101\n            ibsta = int(self.listener(self._address_info.pad, sad=self._address_info.sad or 0, handle=handle))\n\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.count","title":"count","text":"<pre><code>count() -&gt; int\n</code></pre> <p>Get the number of bytes sent or received.</p> <p>This method is the ibcntl function.</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def count(self) -&gt; int:\n    \"\"\"Get the number of bytes sent or received.\n\n    This method is the [ibcntl](https://linux-gpib.sourceforge.io/doc_html/reference-globals-ibcnt.html) function.\n    \"\"\"\n    return int(self._lib.ibcntl())\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Close the GPIB connection.</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Close the GPIB connection.\"\"\"\n    if self._own and self._handle &gt; 0:\n        with contextlib.suppress(MSLConnectionError):\n            _ = self.online(state=False, handle=self._handle)\n        self._handle = -1\n        super().disconnect()\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.interface_clear","title":"interface_clear","text":"<pre><code>interface_clear(*, handle: int | None = None) -&gt; int\n</code></pre> <p>Perform interface clear (board).</p> <p>Resets the GPIB bus by asserting the interface clear (IFC) bus line for a duration of at least 100 microseconds.</p> <p>This method is the ibsic function.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def interface_clear(self, *, handle: int | None = None) -&gt; int:\n    \"\"\"Perform interface clear (board).\n\n    Resets the GPIB bus by asserting the *interface clear* (IFC) bus line for a duration of at\n    least 100 microseconds.\n\n    This method is the [ibsic](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibsic.html)\n    function.\n\n    Args:\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibsic(handle)\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.lines","title":"lines","text":"<pre><code>lines(*, handle: int | None = None) -&gt; int\n</code></pre> <p>Returns the status of the control and handshaking bus lines (board).</p> <p>This method is the iblines function.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def lines(self, *, handle: int | None = None) -&gt; int:\n    \"\"\"Returns the status of the control and handshaking bus lines (board).\n\n    This method is the [iblines](https://linux-gpib.sourceforge.io/doc_html/reference-function-iblines.html)\n    function.\n\n    Args:\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    status = c_short()\n    self._lib.iblines(handle, byref(status))\n    return status.value\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.listener","title":"listener","text":"<pre><code>listener(\n    pad: int, sad: int = 0, *, handle: int | None = None\n) -&gt; bool\n</code></pre> <p>Check if a listener is present (board or device).</p> <p>This method is the ibln function.</p> <p>Parameters:</p> Name Type Description Default <code>pad</code> <code>int</code> <p>Primary address of the GPIB device.</p> required <code>sad</code> <code>int</code> <p>Secondary address of the GPIB device.</p> <code>0</code> <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether a listener is present.</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def listener(self, pad: int, sad: int = 0, *, handle: int | None = None) -&gt; bool:\n    \"\"\"Check if a listener is present (board or device).\n\n    This method is the [ibln](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibln.html)\n    function.\n\n    Args:\n        pad: Primary address of the GPIB device.\n        sad: Secondary address of the GPIB device.\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        Whether a listener is present.\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    listener = c_short()\n    self._lib.ibln(handle, pad, sad, byref(listener))\n    return bool(listener.value)\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.local","title":"local","text":"<pre><code>local(*, handle: int | None = None) -&gt; int\n</code></pre> <p>Go to local mode (board or device).</p> <p>This method is the ibloc function.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> Return <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def local(self, *, handle: int | None = None) -&gt; int:\n    \"\"\"Go to local mode (board or device).\n\n    This method is the [ibloc](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibloc.html)\n    function.\n\n    Args:\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Return:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibloc(handle)\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.online","title":"online","text":"<pre><code>online(*, state: bool, handle: int | None = None) -&gt; int\n</code></pre> <p>Close or reinitialize descriptor (board or device).</p> <p>This method is the ibonl function.</p> <p>If you want to close the connection for the GPIB board or device that was instantiated, use disconnect.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>If <code>False</code>, closes the connection. If <code>True</code>, then all settings associated with the descriptor (GPIB address, end-of-string mode, timeout, etc.) are reset to their default values. The default values are the settings the descriptor had when it was first obtained.</p> required <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def online(self, *, state: bool, handle: int | None = None) -&gt; int:\n    \"\"\"Close or reinitialize descriptor (board or device).\n\n    This method is the [ibonl](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibonl.html)\n    function.\n\n    If you want to close the connection for the GPIB board or device that was instantiated,\n    use [disconnect][msl.equipment.interfaces.gpib.GPIB.disconnect].\n\n    Args:\n        state: If `False`, closes the connection. If `True`, then all settings associated with the\n            descriptor (GPIB address, end-of-string mode, timeout, etc.) are reset to their *default*\n            values. The *default* values are the settings the descriptor had when it was first obtained.\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibonl(handle, int(state))\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.pass_control","title":"pass_control","text":"<pre><code>pass_control(\n    *,\n    handle: int | None = None,\n    name: str | None = None,\n    board: int | None = None,\n    pad: int = 0,\n    sad: int = NO_SEC_ADDR\n) -&gt; int\n</code></pre> <p>Set a GPIB board or device to become the controller-in-charge (CIC).</p> <p>This method is the ibpct function.</p> <p>If no arguments are specified, the instantiated class becomes the CIC.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. If specified, <code>name</code>, <code>board</code>, <code>pad</code> and <code>sad</code> are ignored.</p> <code>None</code> <code>name</code> <code>str | None</code> <p>The name of a GPIB board or device. If specified, <code>board</code>, <code>pad</code> and <code>sad</code> are ignored.</p> <code>None</code> <code>board</code> <code>int | None</code> <p>Index of the GPIB interface board.</p> <code>None</code> <code>pad</code> <code>int</code> <p>Primary address of the GPIB device.</p> <code>0</code> <code>sad</code> <code>int</code> <p>Secondary address of the GPIB device.</p> <code>NO_SEC_ADDR</code> <p>Returns:</p> Type Description <code>int</code> <p>The handle of the board or device that became CIC.</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def pass_control(\n    self,\n    *,\n    handle: int | None = None,\n    name: str | None = None,\n    board: int | None = None,\n    pad: int = 0,\n    sad: int = NO_SEC_ADDR,\n) -&gt; int:\n    \"\"\"Set a GPIB board or device to become the controller-in-charge (CIC).\n\n    This method is the [ibpct](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibpct.html)\n    function.\n\n    If no arguments are specified, the instantiated class becomes the CIC.\n\n    Args:\n        handle: Board or device descriptor. If specified, `name`, `board`, `pad` and `sad` are ignored.\n        name: The name of a GPIB board or device. If specified, `board`, `pad` and `sad` are ignored.\n        board: Index of the GPIB interface board.\n        pad: Primary address of the GPIB device.\n        sad: Secondary address of the GPIB device.\n\n    Returns:\n        The handle of the board or device that became CIC.\n    \"\"\"\n    if handle is not None:\n        pass\n    elif name is not None:\n        handle = self._get_ibfind_handle(name)\n    elif board is not None:\n        handle = self._get_ibdev_handle(board, pad, sad, 13, 1, 0)  # T10s = 13\n    else:\n        handle = self._handle\n\n    self._lib.ibpct(handle)\n    return handle\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError, USBTimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.remote_enable","title":"remote_enable","text":"<pre><code>remote_enable(\n    state: bool, *, handle: int | None = None\n) -&gt; int\n</code></pre> <p>Set remote enable (board).</p> <p>This method is the ibsre function.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>If <code>True</code>, the board asserts the REN line. Otherwise, the REN line is not asserted. The board must be the system controller.</p> required <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def remote_enable(self, state: bool, *, handle: int | None = None) -&gt; int:  # noqa: FBT001\n    \"\"\"Set remote enable (board).\n\n    This method is the [ibsre](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibsre.html)\n    function.\n\n    Args:\n        state: If `True`, the board asserts the REN line. Otherwise, the REN line is not asserted.\n            The board must be the system controller.\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    # ibsre was removed from ni4882.dll, use ibconfig instead (IbcSRE = 0xb)\n    ibsta: int = self.config(0xB, int(state), handle=handle)\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.serial_poll","title":"serial_poll","text":"<pre><code>serial_poll(*, handle: int | None = None) -&gt; int\n</code></pre> <p>Read status byte / serial poll (device).</p> <p>This method is the ibrsp function.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value.</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def serial_poll(self, *, handle: int | None = None) -&gt; int:\n    \"\"\"Read status byte / serial poll (device).\n\n    This method is the [ibrsp](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibrsp.html)\n    function.\n\n    Args:\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The [status value](https://linux-gpib.sourceforge.io/doc_html/reference-globals-ibsta.html).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    status = create_string_buffer(1)\n    self._lib.ibrsp(handle, status)\n    return ord(status.value)\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.spoll_bytes","title":"spoll_bytes","text":"<pre><code>spoll_bytes(*, handle: int | None = None) -&gt; int\n</code></pre> <p>Get the length of the serial poll bytes queue (device).</p> <p>This method is the ibspb function.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def spoll_bytes(self, *, handle: int | None = None) -&gt; int:\n    \"\"\"Get the length of the serial poll bytes queue (device).\n\n    This method is the [ibspb](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibspb.html)\n    function.\n\n    Args:\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    length = c_short()\n    self._lib.ibspb(handle, byref(length))\n    return length.value\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.status","title":"status","text":"<pre><code>status() -&gt; int\n</code></pre> <p>Returns the status value ibsta.</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def status(self) -&gt; int:\n    \"\"\"Returns the status value [ibsta](https://linux-gpib.sourceforge.io/doc_html/reference-globals-ibsta.html).\"\"\"\n    return int(self._lib.ThreadIbsta())\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.trigger","title":"trigger","text":"<pre><code>trigger(*, handle: int | None = None) -&gt; int\n</code></pre> <p>Trigger device.</p> <p>This method is the ibtrg function.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def trigger(self, *, handle: int | None = None) -&gt; int:\n    \"\"\"Trigger device.\n\n    This method is the [ibtrg](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibtrg.html)\n    function.\n\n    Args:\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibtrg(handle)\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.version","title":"version","text":"<pre><code>version() -&gt; str\n</code></pre> <p>Returns the version of the GPIB library (linux only).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def version(self) -&gt; str:\n    \"\"\"Returns the version of the GPIB library (linux only).\"\"\"\n    try:\n        version = c_char_p()\n        self._lib.ibvers(byref(version))\n        assert version.value is not None  # noqa: S101\n        return version.value.decode()\n    except AttributeError:\n        return \"\"\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.wait","title":"wait","text":"<pre><code>wait(mask: int, *, handle: int | None = None) -&gt; int\n</code></pre> <p>Wait for an event (board or device).</p> <p>This method is the ibwait function.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>int</code> <p>Wait until one of the conditions specified in <code>mask</code> is true.</p> required <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def wait(self, mask: int, *, handle: int | None = None) -&gt; int:\n    \"\"\"Wait for an event (board or device).\n\n    This method is the [ibwait](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibwait.html)\n    function.\n\n    Args:\n        mask: Wait until one of the conditions specified in `mask` is true.\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibwait(handle, mask)\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.wait_for_srq","title":"wait_for_srq","text":"<pre><code>wait_for_srq(*, board: int | None = None) -&gt; int\n</code></pre> <p>Wait for the SRQ interrupt (SRQI, 0x1000) line to be asserted (board).</p> <p>This method will return when the board receives a service request from any device. If there are multiple devices connected to the board, you must determine which device asserted the service request.</p> <p>Parameters:</p> Name Type Description Default <code>board</code> <code>int | None</code> <p>Board descriptor. Default is the board descriptor of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def wait_for_srq(self, *, board: int | None = None) -&gt; int:\n    \"\"\"Wait for the SRQ interrupt (SRQI, 0x1000) line to be asserted (board).\n\n    This method will return when the board receives a service request from *any* device.\n    If there are multiple devices connected to the board, you must determine which\n    device asserted the service request.\n\n    Args:\n        board: Board descriptor. Default is the board descriptor of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if board is None:\n        board = self._address_info.board\n    return self.wait(0x1000, handle=board)  # SRQI = 0x1000\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError, USBTimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"api/interfaces/gpib/#msl.equipment.interfaces.gpib.GPIB.write_async","title":"write_async","text":"<pre><code>write_async(\n    message: bytes, *, handle: int | None = None\n) -&gt; int\n</code></pre> <p>Write a message asynchronously (board or device).</p> <p>This method is the ibwrta function.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes</code> <p>The data to send.</p> required <code>handle</code> <code>int | None</code> <p>Board or device descriptor. Default is the handle of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value (<code>ibsta</code>).</p> Source code in <code>src/msl/equipment/interfaces/gpib.py</code> <pre><code>def write_async(self, message: bytes, *, handle: int | None = None) -&gt; int:\n    \"\"\"Write a message asynchronously (board or device).\n\n    This method is the [ibwrta](https://linux-gpib.sourceforge.io/doc_html/reference-function-ibwrta.html) function.\n\n    Args:\n        message: The data to send.\n        handle: Board or device descriptor. Default is the handle of the instantiated class.\n\n    Returns:\n        The status value (`ibsta`).\n    \"\"\"\n    if handle is None:\n        handle = self._handle\n    ibsta: int = self._lib.ibwrta(handle, message, len(message))\n    return ibsta\n</code></pre>"},{"location":"api/interfaces/hislip/","title":"HiSLIP","text":""},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP","title":"HiSLIP","text":"<pre><code>HiSLIP(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MessageBased</code></p> <p>Base class for the HiSLIP communication protocol.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for the HiSLIP communication protocol, as well as the properties defined in MessageBased.</p> <p>Connection Properties:</p> Name Type Description <code>buffer_size</code> <code>int</code> <p>The maximum number of bytes to read at a time. Default: <code>4096</code></p> <code>lock_timeout</code> <code>float</code> <p>The timeout (in seconds) to wait for a lock (0 means wait forever). Default: <code>0</code></p> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Base class for the [HiSLIP] communication protocol.\n\n    [HiSLIP]: https://www.ivifoundation.org/downloads/Protocol%20Specifications/IVI-6.1_HiSLIP-2.0-2020-04-23.pdf\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for the HiSLIP communication protocol, as well as the _properties_ defined in\n    [MessageBased][msl.equipment.interfaces.message_based.MessageBased].\n\n    Attributes: Connection Properties:\n        buffer_size (int): The maximum number of bytes to read at a time. _Default: `4096`_\n        lock_timeout (float): The timeout (in seconds) to wait for a lock (0 means wait forever). _Default: `0`_\n    \"\"\"\n    super().__init__(equipment)\n\n    assert equipment.connection is not None  # noqa: S101\n\n    info = parse_hislip_address(equipment.connection.address)\n    if info is None:\n        msg = f\"Invalid HiSLIP address {equipment.connection.address!r}\"\n        raise ValueError(msg)\n\n    self._info: ParsedHiSLIPAddress = info\n\n    # HiSLIP does not support termination characters\n    self.write_termination = None  # pyright: ignore[reportUnannotatedClassAttribute]\n    self.read_termination = None  # pyright: ignore[reportUnannotatedClassAttribute]\n\n    props = equipment.connection.properties\n    self._buffer_size: int = props.get(\"buffer_size\", 4096)\n    self._lock_timeout: float = props.get(\"lock_timeout\", 0)\n    self.lock_timeout = self._lock_timeout\n\n    self._sync: SyncClient\n    self._async: AsyncClient\n    self._connect()\n    self._set_interface_max_read_size()\n    self._set_interface_timeout()\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.asynchronous","title":"asynchronous  <code>property</code>","text":"<pre><code>asynchronous: AsyncClient\n</code></pre> <p>The reference to the asynchronous client.</p>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.lock_timeout","title":"lock_timeout  <code>property</code> <code>writable</code>","text":"<pre><code>lock_timeout: float\n</code></pre> <p>The time, in seconds, to wait to acquire a lock.</p> <p>Setting the value to \u22640 (or <code>None</code>) means wait forever.</p>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.synchronous","title":"synchronous  <code>property</code>","text":"<pre><code>synchronous: SyncClient\n</code></pre> <p>The reference to the synchronous client.</p>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Send the <code>clear</code> command to the device.</p> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Send the `clear` command to the device.\"\"\"\n    # IVI-6.1: IVI High-Speed LAN Instrument Protocol (HiSLIP)\n    # 23 April 2020 (Revision 2.0)\n    # Section 6.12: Device Clear Transaction\n    #\n    # This Connection class does not use the asynchronous client in an\n    # asynchronous manner, therefore there should not be any pending\n    # requests that need to be waited on to finish\n    acknowledged = self._async.async_device_clear()\n    _ = self._sync.device_clear_complete(acknowledged.feature_bitmap)\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Close the connection to the HiSLIP server.</p> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Close the connection to the HiSLIP server.\"\"\"\n    if not hasattr(self, \"_async\"):\n        return\n\n    if self._async.socket is None and self._sync.socket is None:\n        return\n\n    self._async.close()\n    self._sync.close()\n    super().disconnect()\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.lock","title":"lock","text":"<pre><code>lock(lock_string: str = '') -&gt; bool\n</code></pre> <p>Acquire the device's lock.</p> <p>Parameters:</p> Name Type Description Default <code>lock_string</code> <code>str</code> <p>An ASCII string that identifies this lock. If not specified, then an exclusive lock is requested, otherwise the string indicates an identification of a shared-lock request.</p> <code>''</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether acquiring the lock was successful.</p> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def lock(self, lock_string: str = \"\") -&gt; bool:\n    \"\"\"Acquire the device's lock.\n\n    Args:\n        lock_string: An ASCII string that identifies this lock. If not specified, then\n            an exclusive lock is requested, otherwise the string indicates an\n            identification of a shared-lock request.\n\n    Returns:\n        Whether acquiring the lock was successful.\n    \"\"\"\n    status = self._async.async_lock_request(timeout=self._lock_timeout, lock_string=lock_string)\n    return status.success\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.lock_status","title":"lock_status","text":"<pre><code>lock_status() -&gt; tuple[bool, int]\n</code></pre> <p>Request the lock status from the HiSLIP server.</p> <p>Returns:</p> Type Description <code>tuple[bool, int]</code> <p>Whether the HiSLIP server has an exclusive lock with a client and the number of HiSLIP clients that have a lock with the HiSLIP server.</p> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def lock_status(self) -&gt; tuple[bool, int]:\n    \"\"\"Request the lock status from the HiSLIP server.\n\n    Returns:\n        Whether the HiSLIP server has an exclusive lock with a client and\n            the number of HiSLIP clients that have a lock with the HiSLIP server.\n    \"\"\"\n    reply = self._async.async_lock_info()\n    return reply.exclusive, reply.num_locks\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError, USBTimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.read_stb","title":"read_stb","text":"<pre><code>read_stb() -&gt; int\n</code></pre> <p>Read the status byte from the device.</p> <p>Returns:</p> Type Description <code>int</code> <p>The status byte.</p> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def read_stb(self) -&gt; int:\n    \"\"\"Read the status byte from the device.\n\n    Returns:\n        The status byte.\n    \"\"\"\n    reply = self._async.async_status_query(self._sync)\n    return reply.status\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.reconnect","title":"reconnect","text":"<pre><code>reconnect(max_attempts: int = 1) -&gt; None\n</code></pre> <p>Reconnect to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>max_attempts</code> <code>int</code> <p>The maximum number of attempts to try to reconnect with the equipment. If &lt;1, keep trying until a connection is successful. If the maximum number of attempts has been reached then an exception is raise.</p> <code>1</code> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def reconnect(self, max_attempts: int = 1) -&gt; None:\n    \"\"\"Reconnect to the equipment.\n\n    Args:\n        max_attempts: The maximum number of attempts to try to reconnect with the equipment.\n            If &amp;lt;1, keep trying until a connection is successful. If the maximum number\n            of attempts has been reached then an exception is raise.\n    \"\"\"\n    attempt = 0\n    while True:\n        attempt += 1\n        try:\n            return self._connect()\n        except (MSLConnectionError, MSLTimeoutError):\n            if 0 &lt; max_attempts &lt;= attempt:\n                raise\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.remote_local_control","title":"remote_local_control","text":"<pre><code>remote_local_control(request: int) -&gt; None\n</code></pre> <p>Send a GPIB-like remote/local control request.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>int</code> <p>The request to perform.</p> <ul> <li>0 \u2014 Disable remote, <code>VI_GPIB_REN_DEASSERT</code></li> <li>1 \u2014 Enable remote, <code>VI_GPIB_REN_ASSERT</code></li> <li>2 \u2014 Disable remote and go to local, <code>VI_GPIB_REN_DEASSERT_GTL</code></li> <li>3 \u2014 Enable Remote and go to remote, <code>VI_GPIB_REN_ASSERT_ADDRESS</code></li> <li>4 \u2014 Enable remote and lock out local, <code>VI_GPIB_REN_ASSERT_LLO</code></li> <li>5 \u2014 Enable remote, go to remote, and set local lockout, <code>VI_GPIB_REN_ASSERT_ADDRESS_LLO</code></li> <li>6 \u2014 Go to local without changing REN or lockout state, <code>VI_GPIB_REN_ADDRESS_GTL</code></li> </ul> required Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def remote_local_control(self, request: int) -&gt; None:\n    \"\"\"Send a GPIB-like remote/local control request.\n\n    Args:\n        request: The request to perform.\n\n            * 0 &amp;mdash; Disable remote, `VI_GPIB_REN_DEASSERT`\n            * 1 &amp;mdash; Enable remote, `VI_GPIB_REN_ASSERT`\n            * 2 &amp;mdash; Disable remote and go to local, `VI_GPIB_REN_DEASSERT_GTL`\n            * 3 &amp;mdash; Enable Remote and go to remote, `VI_GPIB_REN_ASSERT_ADDRESS`\n            * 4 &amp;mdash; Enable remote and lock out local, `VI_GPIB_REN_ASSERT_LLO`\n            * 5 &amp;mdash; Enable remote, go to remote, and set local lockout, `VI_GPIB_REN_ASSERT_ADDRESS_LLO`\n            * 6 &amp;mdash; Go to local without changing REN or lockout state, `VI_GPIB_REN_ADDRESS_GTL`\n    \"\"\"\n    _ = self._async.async_remote_local_control(request, self._sync.message_id)\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.trigger","title":"trigger","text":"<pre><code>trigger() -&gt; None\n</code></pre> <p>Send the trigger message (emulates a GPIB Group Execute Trigger event).</p> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def trigger(self) -&gt; None:\n    \"\"\"Send the trigger message (emulates a GPIB Group Execute Trigger event).\"\"\"\n    self._sync.trigger()\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.unlock","title":"unlock","text":"<pre><code>unlock() -&gt; bool\n</code></pre> <p>Release the lock acquired by lock.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether releasing the lock was successful.</p> Source code in <code>src/msl/equipment/interfaces/hislip.py</code> <pre><code>def unlock(self) -&gt; bool:\n    \"\"\"Release the lock acquired by [lock][msl.equipment.interfaces.hislip.HiSLIP.lock].\n\n    Returns:\n        Whether releasing the lock was successful.\n    \"\"\"\n    status = self._async.async_lock_release(self._sync.message_id)\n    return status.success\n</code></pre>"},{"location":"api/interfaces/hislip/#msl.equipment.interfaces.hislip.HiSLIP.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError, USBTimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"api/interfaces/prologix/","title":"Prologix","text":""},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix","title":"Prologix","text":"<pre><code>Prologix(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Use Prologix hardware to establish a connection.</p> <p>For the GPIB-ETHERNET Controller, the format of the address string is <code>Prologix::HOST::1234::PAD[::SAD]</code>, where <code>HOST</code> is the hostname or IP address of the Prologix hardware, <code>1234</code> is the ethernet port that is open on the Prologix hardware, PAD (Primary GPIB Address) is an integer value between 0 and 30, and SAD (Secondary GPIB Address) is an integer value between 96 and 126 (SAD is optional). For example,</p> <ul> <li><code>Prologix::192.168.1.110::1234::6</code></li> <li><code>Prologix::192.168.1.110::1234::6::96</code></li> <li><code>Prologix::prologix-00-21-69-01-31-04::1234::6</code>     (typically, the hostname is <code>prologix-&lt;MAC Address&gt;</code>)</li> </ul> <p>For the GPIB-USB Controller, the format of the address string is <code>Prologix::PORT::PAD[::SAD]</code>, where <code>PORT</code> is the name of the serial port of the Prologix hardware, <code>PAD</code> (Primary GPIB Address) is an integer value between 0 and 30, and SAD (Secondary GPIB Address) is an integer value between 96 and 126 (SAD is optional). For example,</p> <ul> <li><code>Prologix::COM3::6</code></li> <li><code>Prologix::/dev/ttyUSB0::6::112</code></li> </ul> <p>Alternatively, to clearly separate the Prologix hardware address from the GPIB address you may include <code>GPIB::</code> in the address, for example,</p> <ul> <li><code>Prologix::192.168.1.110::1234::GPIB::6</code></li> <li><code>Prologix::COM3::GPIB::22::96</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for using Prologix hardware, as well as the properties defined in Serial (for a GPIB-USB Controller) and in Socket (for a GPIB-ETHERNET Controller).</p> <p>Connection Properties:</p> Name Type Description <code>eoi</code> <code>bool</code> <p>Whether to assert the End or Identify (EOI) hardware line. Default: <code>True</code></p> <code>eos</code> <code>int</code> <p>GPIB termination character(s) to append to the message that is sent to the equipment. Default: <code>3</code></p> <ul> <li><code>0</code>: CR+LF</li> <li><code>1</code>: CR</li> <li><code>2</code>: LF</li> <li><code>3</code>: no termination</li> </ul> <code>eot_char</code> <code>int | str</code> <p>A user-specified character to append to the reply that the Prologix hardware sends back to the computer when <code>eot_enable</code> is <code>True</code> and EOI is detected. Must have an ASCII value &lt;256, e.g., <code>eot_char=42</code> appends <code>*</code> (ASCII 42) when EOI is detected. Default: <code>0</code></p> <code>eot_enable</code> <code>bool</code> <p>Enable or disable the appending of a user-specified character, <code>eot_char</code>, when the Prologix hardware sends a reply back to the computer. Default: <code>False</code></p> <code>escape_characters</code> <code>bool</code> <p>Whether to escape the <code>LF</code>, <code>CR</code>, <code>ESC</code> and <code>+</code> characters when writing a message to the Prologix hardware. Default: <code>True</code></p> <code>read_tmo_ms</code> <code>int</code> <p>The inter-character timeout value, in milliseconds, to be used in the read command and the serial_poll command, i.e., the delay since the last character was read. The <code>read_tmo_ms</code> timeout value is not to be confused with the total time for which data is read. The <code>read_tmo_ms</code> value must be between 1 and 3000 milliseconds. Default: <code>1000</code></p> <p>Important</p> <p>The Prologix Connection Properties are the same for all equipment that are attached to the Prologix hardware. If different equipment require different properties you must manage the settings appropriately, such as by writing <code>++eoi 0</code> to disable the use of the End or Identify line before reading from the equipment and then perhaps writing <code>++eoi 1</code> to re-enable it afterwards. Only the <code>escape_characters</code> property is associated with the Prologix instance.</p> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Use [Prologix](https://prologix.biz/) hardware to establish a connection.\n\n    For the GPIB-ETHERNET Controller, the format of the [address][msl.equipment.schema.Connection.address]\n    string is `Prologix::HOST::1234::PAD[::SAD]`, where `HOST` is the hostname or IP address of the Prologix\n    hardware, `1234` is the ethernet port that is open on the Prologix hardware, PAD (Primary GPIB Address)\n    is an integer value between 0 and 30, and SAD (Secondary GPIB Address) is an integer value between\n    96 and 126 (SAD is optional). For example,\n\n    * `Prologix::192.168.1.110::1234::6`\n    * `Prologix::192.168.1.110::1234::6::96`\n    * `Prologix::prologix-00-21-69-01-31-04::1234::6` &lt;br/&gt;\n       (typically, the hostname is `prologix-&lt;MAC Address&gt;`)\n\n    For the GPIB-USB Controller, the format of the [address][msl.equipment.schema.Connection.address]\n    string is `Prologix::PORT::PAD[::SAD]`, where `PORT` is the name of the serial port of the Prologix\n    hardware, `PAD` (Primary GPIB Address) is an integer value between 0 and 30, and SAD (Secondary\n    GPIB Address) is an integer value between 96 and 126 (SAD is optional). For example,\n\n    * `Prologix::COM3::6`\n    * `Prologix::/dev/ttyUSB0::6::112`\n\n    Alternatively, to clearly separate the Prologix hardware address from the GPIB address you may include\n    `GPIB::` in the address, for example,\n\n    * `Prologix::192.168.1.110::1234::GPIB::6`\n    * `Prologix::COM3::GPIB::22::96`\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for using Prologix hardware, as well as the _properties_ defined in\n    [Serial][msl.equipment.interfaces.serial.Serial] (for a GPIB-USB Controller) and in\n    [Socket][msl.equipment.interfaces.socket.Socket] (for a GPIB-ETHERNET Controller).\n\n    Attributes: Connection Properties:\n        eoi (bool): Whether to assert the End or Identify (EOI) hardware line. _Default: `True`_\n        eos (int): GPIB termination character(s) to append to the message that is sent\n            to the equipment. _Default: `3`_\n\n            * `0`: CR+LF\n            * `1`: CR\n            * `2`: LF\n            * `3`: no termination\n\n        eot_char (int | str): A user-specified character to append to the reply that the Prologix hardware\n            sends back to the computer when `eot_enable` is `True` and EOI is detected. Must have an ASCII\n            value &amp;lt;256, e.g., `eot_char=42` appends `*` (ASCII 42) when EOI is detected. _Default: `0`_\n        eot_enable (bool): Enable or disable the appending of a user-specified character, `eot_char`,\n            when the Prologix hardware sends a reply back to the computer. _Default: `False`_\n        escape_characters (bool): Whether to escape the `LF`, `CR`, `ESC` and `+` characters when writing\n            a message to the Prologix hardware. _Default: `True`_\n        read_tmo_ms (int): The inter-character timeout value, in milliseconds, to be used in the *read*\n            command and the *serial_poll* command, i.e., the delay since the last character was read. The\n            `read_tmo_ms` timeout value is not to be confused with the total time for which data is\n            read. The `read_tmo_ms` value must be between 1 and 3000 milliseconds. _Default: `1000`_\n\n    !!! important\n        The Prologix Connection Properties are the same for _all_ equipment that are attached to the\n        Prologix hardware. If different equipment require different properties you must manage the\n        settings appropriately, such as by writing `++eoi 0` to disable the use of the End or\n        Identify line before reading from the equipment and then perhaps writing `++eoi 1`\n        to re-enable it afterwards. Only the `escape_characters` property is associated with the\n        [Prologix][] instance.\n    \"\"\"\n    self._addr: bytes = b\"\"\n    super().__init__(equipment)\n\n    assert equipment.connection is not None  # noqa: S101\n    info = parse_prologix_address(equipment.connection.address)\n    if info is None:\n        msg = f\"Invalid Prologix address {equipment.connection.address!r}\"\n        raise ValueError(msg)\n\n    pad = info.pad\n    if pad &lt; MIN_PAD_ADDRESS or pad &gt; MAX_PAD_ADDRESS:\n        msg = f\"Invalid primary GPIB address {pad}, must be in the range [{MIN_PAD_ADDRESS}, {MAX_PAD_ADDRESS}]\"\n        raise ValueError(msg)\n\n    sad = info.sad\n    if sad is not None and (sad &lt; MIN_SAD_ADDRESS or sad &gt; MAX_SAD_ADDRESS):\n        msg = f\"Invalid secondary GPIB address {sad}, must be in the range [{MIN_SAD_ADDRESS}, {MAX_SAD_ADDRESS}]\"\n        raise ValueError(msg)\n\n    self._addr = f\"++addr {pad}\\n\".encode() if sad is None else f\"++addr {pad} {sad}\\n\".encode()\n    self._pad: int = pad\n    self._sad: int | None = sad\n    self._plus_plus_read_char: int | str = \"eoi\"\n    self._hw_address: str = info.hw_address\n\n    props = equipment.connection.properties\n\n    try:\n        self._controller: PrologixUSB | PrologixEthernet = Prologix._controllers[self._hw_address]\n    except KeyError:\n        address = f\"TCP::{self._hw_address}::{info.enet_port}\" if info.enet_port else f\"ASRL{self._hw_address}\"\n        e = Equipment(connection=Connection(address, **props))\n        self._controller = PrologixEthernet(e) if info.enet_port else PrologixUSB(e)\n        self._controller._str = f\"Prologix&lt;{info.hw_address}&gt;\"  # noqa: SLF001\n        Prologix._controllers[self._hw_address] = self._controller\n        Prologix._selected_addresses[self._hw_address] = b\"\"\n\n    # There are two steps involved when writing a message to the equipment\n    # 1) Computer -&gt; Prologix\n    # 2) Prologix -&gt; Equipment\n    # Prologix needs to know when a message has been received in full, but cannot consume\n    # any characters that are meant to be passed on to the Equipment. The LF, CR, ESC and +\n    # characters are consumed by Prologix. If any of these characters are destined for the\n    # Equipment, then it must be preceded by the escape character, ESC (ASCII 27).\n    # All un-escaped LF, CR, ESC and + characters in Step 1 are consumed by Prologix (according to the manual).\n\n    self._write_termination: bytes | None = self._controller.write_termination  # termination for Equipment (Step 2)\n    self._controller.write_termination = b\"\\n\"  # termination for Prologix (Step 1)\n\n    self._escape_characters: bool = bool(props.get(\"escape_characters\", True))\n\n    _ = self._controller.write(\"++mode 1\\n\")  # CONTROLLER mode\n    _ = self._controller.write(\"++auto 0\\n\")  # write \"++read eoi|&lt;char&gt;\" before reading\n\n    eoi = 1 if props.get(\"eoi\", True) else 0\n    _ = self._controller.write(f\"++eoi {eoi}\\n\")\n\n    eos = props.get(\"eos\", 3)\n    _ = self._controller.write(f\"++eos {eos}\\n\")\n\n    self.set_eot_char(props.get(\"eot_char\", 0))\n    self.set_eot_enable(props.get(\"eot_enable\", False))\n\n    read_tmo_ms = props.get(\"read_tmo_ms\", 1000)\n    _ = self._controller.write(f\"++read_tmo_ms {read_tmo_ms}\\n\")\n\n    self._ensure_gpib_address_selected()\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.controller","title":"controller  <code>property</code>","text":"<pre><code>controller: Serial | Socket\n</code></pre> <p>The connection to the Prologix Controller for this equipment.</p> <p>The returned type depends on whether a GPIB-USB or a GPIB-ETHERNET Controller is used to communicate with the equipment.</p> <p>Use this property if you want more direct access to the Prologix Controller.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.escape_characters","title":"escape_characters  <code>property</code> <code>writable</code>","text":"<pre><code>escape_characters: bool\n</code></pre> <p>Whether to escape the <code>\\n</code> (ASCII 10), <code>\\r</code> (ASCII 13), <code>ESC</code> (ASCII 27) and <code>+</code> (ASCII 43) characters before a write operation.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.pad","title":"pad  <code>property</code>","text":"<pre><code>pad: int\n</code></pre> <p>Returns the primary GPIB address.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.read_termination","title":"read_termination  <code>property</code> <code>writable</code>","text":"<pre><code>read_termination: bytes | None\n</code></pre> <p>The termination character sequence that is used for a read operation.</p> <p>Reading stops when the equipment stops sending data or the <code>read_termination</code> character sequence is detected. If you set the <code>read_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.sad","title":"sad  <code>property</code>","text":"<pre><code>sad: int | None\n</code></pre> <p>Returns the secondary GPIB address.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, to use for the connection to the Prologix hardware.</p> <p>This timeout value is not to be confused with the <code>read_tmo_ms</code> command that Prologix Controllers accept. To set the inter-character delay, i.e., the delay since the last character was read or for the serial_poll command, write the <code>++read_tmo_ms &lt;time&gt;</code> message to the Controller (or define it in the Connection properties).</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.write_termination","title":"write_termination  <code>property</code> <code>writable</code>","text":"<pre><code>write_termination: bytes | None\n</code></pre> <p>The termination character sequence that is appended to write messages.</p> <p>If you set the <code>write_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Send the Selected Device Clear (SDC) command.</p> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Send the Selected Device Clear (SDC) command.\"\"\"\n    with self._controller.lock:\n        self._ensure_gpib_address_selected()\n        _ = self._controller.write(b\"++clr\\n\")\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the equipment.</p> <p>Calling this method does not close the underlying Serial or Socket connection to the Prologix Controller since the connection to the Prologix Controller may still be required to send messages to other GPIB devices that are attached to the Controller.</p> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Disconnect from the equipment.\n\n    Calling this method does not close the underlying [Serial][msl.equipment.interfaces.serial.Serial]\n    or [Socket][msl.equipment.interfaces.socket.Socket] connection to the Prologix Controller since\n    the connection to the Prologix Controller may still be required to send messages to other GPIB\n    devices that are attached to the Controller.\n    \"\"\"\n    if self._addr:\n        self._addr = b\"\"\n        super().disconnect()\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.group_execute_trigger","title":"group_execute_trigger","text":"<pre><code>group_execute_trigger(*addresses: int) -&gt; None\n</code></pre> <p>Send the Group Execute Trigger command to equipment at the specified addresses.</p> <p>Up to 15 addresses may be specified. If no address is specified then the Group Execute Trigger command is issued to the currently-addressed equipment.</p> <p>Parameters:</p> Name Type Description Default <code>addresses</code> <code>int</code> <p>The primary (and optional secondary) GPIB addresses. If a secondary address is specified then it must follow its corresponding primary address, for example,</p> <ul> <li><code>group_execute_trigger(1, 11, 17)</code> \u2192 primary, primary, primary</li> <li><code>group_execute_trigger(3, 96, 12, 21)</code> \u2192 primary, secondary, primary, primary</li> </ul> <code>()</code> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def group_execute_trigger(self, *addresses: int) -&gt; None:\n    \"\"\"Send the Group Execute Trigger command to equipment at the specified addresses.\n\n    Up to 15 addresses may be specified. If no address is specified then the\n    Group Execute Trigger command is issued to the currently-addressed equipment.\n\n    Args:\n        addresses: The primary (and optional secondary) GPIB addresses. If a secondary address is\n            specified then it must follow its corresponding primary address, for example,\n\n            * `group_execute_trigger(1, 11, 17)` &amp;#8594; primary, primary, primary\n            * `group_execute_trigger(3, 96, 12, 21)` &amp;#8594; primary, secondary, primary, primary\n    \"\"\"\n    command = \"++trg\"\n    if addresses:\n        command += \" \" + \" \".join(str(a) for a in addresses)\n    _ = self._controller.write(command)\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.interface_clear","title":"interface_clear","text":"<pre><code>interface_clear() -&gt; None\n</code></pre> <p>Perform interface clear.</p> <p>Resets the GPIB bus by asserting the interface clear (IFC) bus line for a duration of at least 150 microseconds.</p> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def interface_clear(self) -&gt; None:\n    \"\"\"Perform interface clear.\n\n    Resets the GPIB bus by asserting the *interface clear* (IFC) bus line for a duration of at\n    least 150 microseconds.\n    \"\"\"\n    _ = self._controller.write(b\"++ifc\\n\")\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.local","title":"local","text":"<pre><code>local() -&gt; None\n</code></pre> <p>Enables front panel operation of the device, <code>GTL</code> GPIB command.</p> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def local(self) -&gt; None:\n    \"\"\"Enables front panel operation of the device, `GTL` GPIB command.\"\"\"\n    with self._controller.lock:\n        self._ensure_gpib_address_selected()\n        _ = self._controller.write(b\"++loc\\n\")\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.prologix_help","title":"prologix_help","text":"<pre><code>prologix_help() -&gt; list[tuple[str, str]]\n</code></pre> <p>Get the command-syntax help for the Prologix hardware.</p> <p>Returns:</p> Type Description <code>list[tuple[str, str]]</code> <p>The help as a list of <code>(command, description)</code> tuples.</p> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def prologix_help(self) -&gt; list[tuple[str, str]]:\n    \"\"\"Get the command-syntax help for the Prologix hardware.\n\n    Returns:\n        The help as a [list][] of `(command, description)` [tuple][]s.\n    \"\"\"\n    h: list[tuple[str, str]] = []\n    # ignore the first line in the reply, \"The following commands are available:\"\n    _ = self._controller.query(b\"++help\\n\")\n    while True:\n        cmd, msg = map(str.strip, self._controller.read().split(\"--\"))\n        h.append((cmd, msg))\n        if cmd == \"++help\":  # pragma: no branch\n            return h\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as an numpy.ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def query(\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.prologix.Prologix.write]\n    followed by a [read][msl.equipment.interfaces.prologix.Prologix.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as an [numpy.ndarray][], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._controller.encoding)\n\n    if message.startswith(b\"++\"):  # message is (probably) for the Prologix hardware\n        if not message.endswith(b\"\\n\"):\n            message += b\"\\n\"\n        with self._controller.lock:\n            self._ensure_gpib_address_selected()\n            return self._controller.query(message, delay=delay, decode=decode, size=size)\n\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>See MessageBased.read() for more details about when this method returns.</p> <p>See Also</p> <p>set_plus_plus_read_char</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    r\"\"\"Read a message from the equipment.\n\n    See [MessageBased.read()][msl.equipment.interfaces.message_based.MessageBased.read] for more\n    details about when this method returns.\n\n    !!! note \"See Also\"\n        [set_plus_plus_read_char][msl.equipment.interfaces.prologix.Prologix.set_plus_plus_read_char]\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    with self._controller.lock:\n        self._ensure_gpib_address_selected()\n        _ = self._controller.write(f\"++read {self._plus_plus_read_char}\\n\")\n        return self._controller.read(decode=decode, dtype=dtype, fmt=fmt, size=size)  # type: ignore[arg-type]\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.remote_enable","title":"remote_enable","text":"<pre><code>remote_enable(state: bool) -&gt; None\n</code></pre> <p>Whether to enable or disable front panel operation of the device.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>If <code>True</code>, the device goes to remote mode (local lockout), <code>False</code> for local mode.</p> required Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def remote_enable(self, state: bool) -&gt; None:  # noqa: FBT001\n    \"\"\"Whether to enable or disable front panel operation of the device.\n\n    Args:\n        state: If `True`, the device goes to remote mode (local lockout), `False` for local mode.\n    \"\"\"\n    if state:\n        with self._controller.lock:\n            self._ensure_gpib_address_selected()\n            _ = self._controller.write(b\"++llo\\n\")\n    else:\n        self.local()\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.reset_controller","title":"reset_controller","text":"<pre><code>reset_controller() -&gt; None\n</code></pre> <p>Performs a power-on reset of the Prologix Controller.</p> <p>It takes about five seconds for the Controller to reboot.</p> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def reset_controller(self) -&gt; None:\n    \"\"\"Performs a power-on reset of the Prologix Controller.\n\n    It takes about five seconds for the Controller to reboot.\n    \"\"\"\n    _ = self._controller.write(b\"++rst\\n\")\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.serial_poll","title":"serial_poll","text":"<pre><code>serial_poll(\n    pad: int | None = None, sad: int | None = None\n) -&gt; int\n</code></pre> <p>Read status byte / serial poll.</p> <p>Parameters:</p> Name Type Description Default <code>pad</code> <code>int | None</code> <p>The primary GPIB address to poll. If not specified, uses the primary address of the instantiated class.</p> <code>None</code> <code>sad</code> <code>int | None</code> <p>The secondary GPIB address to poll. If not specified, uses the secondary address of the instantiated class.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value.</p> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def serial_poll(self, pad: int | None = None, sad: int | None = None) -&gt; int:\n    \"\"\"Read status byte / serial poll.\n\n    Args:\n        pad: The primary GPIB address to poll. If not specified, uses the\n            primary address of the instantiated class.\n        sad: The secondary GPIB address to poll. If not specified, uses the\n            secondary address of the instantiated class.\n\n    Returns:\n        The [status value](https://linux-gpib.sourceforge.io/doc_html/reference-globals-ibsta.html).\n    \"\"\"\n    p = self._pad if pad is None else pad\n    s = self._sad if sad is None else sad\n    cmd = f\"++spoll {p} {s}\" if s is not None else f\"++spoll {p}\"\n    try:\n        return int(self._controller.query(cmd, decode=False))\n    except ValueError:  # pragma: no cover\n        return 0\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.set_eot_char","title":"set_eot_char","text":"<pre><code>set_eot_char(char: bytes | str | int) -&gt; None\n</code></pre> <p>Set a user-specified character to append to the reply from the Prologix Controller back to the computer.</p> <p>This character is appended only if <code>eot_enable</code> is <code>True</code> and EOI is detected.</p> <p>See Also</p> <p>set_eot_enable</p> <p>Parameters:</p> Name Type Description Default <code>char</code> <code>bytes | str | int</code> <p>Must be an ASCII value &lt;256, e.g., <code>42</code> appends <code>*</code> (ASCII 42) when EOI is detected.</p> required Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def set_eot_char(self, char: bytes | str | int) -&gt; None:\n    \"\"\"Set a user-specified character to append to the reply from the Prologix Controller back to the computer.\n\n    This character is appended only if `eot_enable` is `True` and EOI is detected.\n\n    !!! note \"See Also\"\n        [set_eot_enable][msl.equipment.interfaces.prologix.Prologix.set_eot_enable]\n\n    Args:\n        char: Must be an ASCII value &amp;lt;256, e.g., `42` appends `*` (ASCII 42) when EOI is detected.\n    \"\"\"\n    _ = self._controller.write(f\"++eot_char {_char_to_int(char)}\\n\")\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.set_eot_enable","title":"set_eot_enable","text":"<pre><code>set_eot_enable(enable: bool | int) -&gt; None\n</code></pre> <p>Enables or disables the appending of a user-specified character.</p> <p>See Also</p> <p>set_eot_char</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool | int</code> <p>Whether to enable or disable the appending of a user-specified character.</p> required Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def set_eot_enable(self, enable: bool | int) -&gt; None:  # noqa: FBT001\n    \"\"\"Enables or disables the appending of a user-specified character.\n\n    !!! note \"See Also\"\n        [set_eot_char][msl.equipment.interfaces.prologix.Prologix.set_eot_char]\n\n    Args:\n        enable: Whether to enable or disable the appending of a user-specified character.\n    \"\"\"\n    state = 1 if enable else 0\n    _ = self._controller.write(f\"++eot_enable {state}\\n\")\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.set_plus_plus_read_char","title":"set_plus_plus_read_char","text":"<pre><code>set_plus_plus_read_char(\n    char: bytes | str | int | None = None,\n) -&gt; None\n</code></pre> <p>Set the character to send when the <code>++read eoi|&lt;char&gt;</code> message is written in read.</p> <p>Parameters:</p> Name Type Description Default <code>char</code> <code>bytes | str | int | None</code> <p>If <code>None</code> then use the EOI hardware line (the <code>++read eoi</code> message is sent), otherwise <code>++read &lt;char&gt;</code>. The decimal value of <code>char</code> must be in the range [0..255].</p> <code>None</code> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def set_plus_plus_read_char(self, char: bytes | str | int | None = None) -&gt; None:\n    \"\"\"Set the character to send when the `++read eoi|&lt;char&gt;` message is written in [read][msl.equipment.interfaces.prologix.Prologix.read].\n\n    Args:\n        char: If `None` then use the EOI hardware line (the `++read eoi` message is sent),\n            otherwise `++read &lt;char&gt;`. The decimal value of `char` must be in the range [0..255].\n    \"\"\"  # noqa: E501\n    self._plus_plus_read_char = \"eoi\" if char is None else _char_to_int(char)\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.trigger","title":"trigger","text":"<pre><code>trigger() -&gt; None\n</code></pre> <p>Trigger device.</p> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def trigger(self) -&gt; None:\n    \"\"\"Trigger device.\"\"\"\n    cmd = f\"++trg {self._pad}\\n\" if self._sad is None else f\"++trg {self._pad} {self._sad}\\n\"\n    _ = self._controller.write(cmd)\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.wait","title":"wait","text":"<pre><code>wait(\n    mask: int,\n    *,\n    delay: float = 0.05,\n    pad: int | None = None,\n    sad: int | None = None,\n    timeout: float | None = None\n) -&gt; int\n</code></pre> <p>Wait for an event.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>int</code> <p>Wait until one of the conditions specified in <code>mask</code> is true. See here for the bit values that the <code>mask</code> supports. If <code>mask=0</code>, then this method will return immediately.</p> required <code>delay</code> <code>float</code> <p>The number of seconds to wait between checking for an event.</p> <code>0.05</code> <code>pad</code> <code>int | None</code> <p>The primary GPIB address to poll. If not specified, uses the primary address of the instantiated class.</p> <code>None</code> <code>sad</code> <code>int | None</code> <p>The secondary GPIB address to poll. If not specified, uses the secondary address of the instantiated class.</p> <code>None</code> <code>timeout</code> <code>float | None</code> <p>The maximum number of seconds to wait before raising TimeoutError if an event has not occurred. A value of <code>None</code> means wait forever.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value.</p> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def wait(\n    self,\n    mask: int,\n    *,\n    delay: float = 0.05,\n    pad: int | None = None,\n    sad: int | None = None,\n    timeout: float | None = None,\n) -&gt; int:\n    \"\"\"Wait for an event.\n\n    Args:\n        mask: Wait until one of the conditions specified in `mask` is true.\n            See [here](https://linux-gpib.sourceforge.io/doc_html/reference-globals-ibsta.html)\n            for the bit values that the `mask` supports. If `mask=0`,\n            then this method will return immediately.\n        delay: The number of seconds to wait between checking for an event.\n        pad: The primary GPIB address to poll. If not specified, uses the\n            primary address of the instantiated class.\n        sad: The secondary GPIB address to poll. If not specified, uses the\n            secondary address of the instantiated class.\n        timeout: The maximum number of seconds to wait before raising [TimeoutError][]\n            if an event has not occurred. A value of `None` means wait forever.\n\n    Returns:\n        The [status value](https://linux-gpib.sourceforge.io/doc_html/reference-globals-ibsta.html).\n    \"\"\"\n    p = self._pad if pad is None else pad\n    s = self._sad if sad is None else sad\n    t0 = time.time()\n    while True:\n        status = self.serial_poll(pad=p, sad=s)\n        if (status &amp; mask) or (mask == 0):\n            return status\n\n        if timeout and time.time() &gt; t0 + timeout:\n            msg = f\"An event has not occurred after {timeout} seconds\"\n            raise TimeoutError(msg)\n\n        time.sleep(delay)\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.wait_for_srq","title":"wait_for_srq","text":"<pre><code>wait_for_srq(\n    *, delay: float = 0.05, timeout: float | None = None\n) -&gt; int\n</code></pre> <p>Wait for the SRQ interrupt line to be asserted.</p> <p>This method will return when the Prologix Controller receives a service request from any device. If there are multiple devices connected to the Prologix Controller, you must determine which device asserted the service request.</p> <p>Parameters:</p> Name Type Description Default <code>delay</code> <code>float</code> <p>The number of seconds to wait between checking if SRQ has been asserted.</p> <code>0.05</code> <code>timeout</code> <code>float | None</code> <p>The maximum number of seconds to wait before raising TimeoutError if the SRQ line is not asserted. A value of <code>None</code> means wait forever.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status value.</p> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def wait_for_srq(self, *, delay: float = 0.05, timeout: float | None = None) -&gt; int:\n    \"\"\"Wait for the SRQ interrupt line to be asserted.\n\n    This method will return when the Prologix Controller receives a service request\n    from *any* device. If there are multiple devices connected to the Prologix Controller,\n    you must determine which device asserted the service request.\n\n    Args:\n        delay: The number of seconds to wait between checking if SRQ has been asserted.\n        timeout: The maximum number of seconds to wait before raising [TimeoutError][]\n            if the SRQ line is not asserted. A value of `None` means wait forever.\n\n    Returns:\n        The [status value](https://linux-gpib.sourceforge.io/doc_html/reference-globals-ibsta.html).\n    \"\"\"\n    t0 = time.time()\n    while True:\n        if int(self._controller.query(b\"++srq\\n\")) == 1:\n            return self.serial_poll()\n\n        if timeout and time.time() &gt; t0 + timeout:\n            msg = f\"SRQ line has not been asserted after {timeout} seconds\"\n            raise TimeoutError(msg)\n\n        time.sleep(delay)\n</code></pre>"},{"location":"api/interfaces/prologix/#msl.equipment.interfaces.prologix.Prologix.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>See Also</p> <p>escape_characters</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/prologix.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    !!! note \"See Also\"\n        [escape_characters][msl.equipment.interfaces.prologix.Prologix.escape_characters]\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._controller.encoding)\n\n    if message.startswith(b\"++\"):\n        # The message is (probably) for the Prologix hardware\n        # Prologix termination is b\"\\n\" not self._write_termination (which is for the Equipment)\n        if not message.endswith(b\"\\n\"):\n            message += b\"\\n\"\n        return self._controller.write(message, data=data, dtype=dtype, fmt=fmt)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    if self._escape_characters:\n        # Escape \\n \\r ESC + characters so that Prologix does not consume them but passes them on to the Equipment\n        # ASCII code ESC is decimal 27 (octal 033, hexadecimal 0x1B)\n        message = message.replace(b\"\\033\", b\"\\033\\033\")  # must be first\n        message = message.replace(b\"\\n\", b\"\\033\\n\")\n        message = message.replace(b\"\\r\", b\"\\033\\r\")\n        message = message.replace(b\"+\", b\"\\033+\")\n\n    with self._controller.lock:\n        self._ensure_gpib_address_selected()\n        # Add an un-escaped \\n for Prologix to know it has received the full message from the Computer\n        return self._controller.write(message + b\"\\n\")\n</code></pre>"},{"location":"api/interfaces/sdk/","title":"SDK","text":""},{"location":"api/interfaces/sdk/#msl.equipment.interfaces.sdk.SDK","title":"SDK","text":"<pre><code>SDK(\n    equipment: Equipment,\n    *,\n    libtype: LibType | None = None,\n    path: PathLike | None = None,\n    **kwargs: Any\n)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Base class for equipment that use the manufacturer's Software Development Kit (SDK).</p> <p>You can use the configuration file to add the directory that the SDK is located at to the <code>PATH</code> environment variable.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <code>libtype</code> <code>LibType | None</code> <p>The library type. See LoadLibrary for more details.</p> <code>None</code> <code>path</code> <code>PathLike | None</code> <p>The path to the SDK. Specifying this value will take precedence over the address value.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>All additional keyword arguments are passed to LoadLibrary.</p> <code>{}</code> Source code in <code>src/msl/equipment/interfaces/sdk.py</code> <pre><code>def __init__(\n    self,\n    equipment: Equipment,\n    *,\n    libtype: LibType | None = None,\n    path: PathLike | None = None,\n    **kwargs: Any,  # noqa: ANN401\n) -&gt; None:\n    \"\"\"Base class for equipment that use the manufacturer's Software Development Kit (SDK).\n\n    You can use the [configuration file][config-xml-example] to add the directory that the SDK\n    is located at to the `PATH` environment variable.\n\n    Args:\n        equipment: An [Equipment][] instance.\n        libtype: The library type. See [LoadLibrary][msl.loadlib.load_library.LoadLibrary] for more details.\n        path: The path to the SDK. Specifying this value will take precedence over the\n            [address][msl.equipment.schema.Connection.address] value.\n        kwargs: All additional keyword arguments are passed to [LoadLibrary][msl.loadlib.load_library.LoadLibrary].\n    \"\"\"\n    super().__init__(equipment)\n\n    if path is None:\n        assert equipment.connection is not None  # noqa: S101\n        info = parse_sdk_address(equipment.connection.address)\n        if info is None:\n            msg = f\"Invalid SDK interface address {equipment.connection.address!r}\"\n            raise ValueError(msg)\n        path = info.path\n\n    self._load_library: LoadLibrary = LoadLibrary(path, libtype=libtype, **kwargs)\n    self._sdk: Any = self._load_library.lib\n</code></pre>"},{"location":"api/interfaces/sdk/#msl.equipment.interfaces.sdk.SDK.application","title":"application  <code>property</code>","text":"<pre><code>application: Application | None\n</code></pre> <p>Application | <code>None</code> \u2014 Reference to the ActiveX application window.</p> <p>If the loaded library is not an ActiveX library, returns <code>None</code>.</p>"},{"location":"api/interfaces/sdk/#msl.equipment.interfaces.sdk.SDK.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/sdk/#msl.equipment.interfaces.sdk.SDK.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>str \u2014 The path to the library file.</p>"},{"location":"api/interfaces/sdk/#msl.equipment.interfaces.sdk.SDK.sdk","title":"sdk  <code>property</code>","text":"<pre><code>sdk: Any\n</code></pre> <p>lib \u2014 The reference to the SDK object.</p>"},{"location":"api/interfaces/sdk/#msl.equipment.interfaces.sdk.SDK.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Cleanup references to the SDK library.</p> Source code in <code>src/msl/equipment/interfaces/sdk.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Cleanup references to the SDK library.\"\"\"\n    if hasattr(self, \"_sdk\") and self._sdk is not None:\n        self._load_library.cleanup()\n        self._sdk = None\n        super().disconnect()\n</code></pre>"},{"location":"api/interfaces/serial/","title":"Serial","text":""},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial","title":"Serial","text":"<pre><code>Serial(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MessageBased</code></p> <p>Base class for equipment that is connected through a serial port.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for the serial communication protocol, as well as the properties defined in MessageBased. The DataBits, Parity and StopBits enumeration names and values may also be used. For properties that specify an alias, you may also use the alternative name as the property name. See serial.Serial for more details.</p> <p>Connection Properties:</p> Name Type Description <code>baud_rate</code> <code>int</code> <p>The baud rate (alias: baudrate). Default: <code>9600</code></p> <code>data_bits</code> <code>int</code> <p>The number of data bits, e.g. 5, 6, 7, 8 (alias: bytesize). Default: <code>8</code></p> <code>dsr_dtr</code> <code>bool</code> <p>Whether to enable hardware (DSR/DTR) flow control (alias: dsrdtr). Default: <code>False</code></p> <code>inter_byte_timeout</code> <code>float | None</code> <p>The inter-character timeout. Default: <code>None</code></p> <code>parity</code> <code>str</code> <p>Parity checking, e.g. 'even', 'odd'. Default: <code>none</code></p> <code>rts_cts</code> <code>bool</code> <p>Whether to enable hardware (RTS/CTS) flow control (alias: rtscts). Default: <code>False</code></p> <code>stop_bits</code> <code>int | float</code> <p>The number of stop bits, e.g. 1, 1.5, 2 (alias: stopbits). Default: <code>1</code></p> <code>xon_xoff</code> <code>bool</code> <p>Whether to enable software flow control (alias: xonxoff). Default: <code>False</code></p> Source code in <code>src/msl/equipment/interfaces/serial.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Base class for equipment that is connected through a serial port.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for the serial communication protocol, as well as the _properties_ defined in\n    [MessageBased][msl.equipment.interfaces.message_based.MessageBased]. The\n    [DataBits][msl.equipment.enumerations.DataBits], [Parity][msl.equipment.enumerations.Parity]\n    and [StopBits][msl.equipment.enumerations.StopBits] enumeration names and values may also\n    be used. For properties that specify an _alias_, you may also use the alternative name as\n    the property name. See [serial.Serial][] for more details.\n\n    Attributes: Connection Properties:\n        baud_rate (int): The baud rate (_alias:_ baudrate). _Default: `9600`_\n        data_bits (int): The number of data bits, e.g. 5, 6, 7, 8 (_alias:_ bytesize). _Default: `8`_\n        dsr_dtr (bool): Whether to enable hardware (DSR/DTR) flow control (_alias:_ dsrdtr). _Default: `False`_\n        inter_byte_timeout (float | None): The inter-character timeout. _Default: `None`_\n        parity (str): Parity checking, e.g. 'even', 'odd'. _Default: `none`_\n        rts_cts (bool): Whether to enable hardware (RTS/CTS) flow control (_alias:_ rtscts). _Default: `False`_\n        stop_bits (int | float): The number of stop bits, e.g. 1, 1.5, 2 (_alias:_ stopbits). _Default: `1`_\n        xon_xoff (bool): Whether to enable software flow control (_alias:_ xonxoff). _Default: `False`_\n    \"\"\"\n    super().__init__(equipment)\n\n    assert equipment.connection is not None  # noqa: S101\n    info = parse_serial_address(equipment.connection.address)\n    if info is None:\n        msg = f\"Invalid serial address {equipment.connection.address!r}\"\n        raise ValueError(msg)\n\n    self._serial: serial.Serial = _init_serial(info.port, equipment.connection.properties)\n    self._set_interface_timeout()\n\n    try:\n        self._serial.open()\n    except serial.SerialException as e:\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.read_termination","title":"read_termination  <code>property</code> <code>writable</code>","text":"<pre><code>read_termination: bytes | None\n</code></pre> <p>The termination character sequence that is used for a read operation.</p> <p>Reading stops when the equipment stops sending data or the <code>read_termination</code> character sequence is detected. If you set the <code>read_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.serial","title":"serial  <code>property</code>","text":"<pre><code>serial: Serial\n</code></pre> <p>Returns the reference to the serial instance.</p>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.write_termination","title":"write_termination  <code>property</code> <code>writable</code>","text":"<pre><code>write_termination: bytes | None\n</code></pre> <p>The termination character sequence that is appended to write messages.</p> <p>If you set the <code>write_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Close the serial port.</p> Source code in <code>src/msl/equipment/interfaces/serial.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Close the serial port.\"\"\"\n    if hasattr(self, \"_serial\") and self._serial.is_open:\n        self._serial.close()\n        super().disconnect()\n</code></pre>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError, USBTimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"api/interfaces/serial/#msl.equipment.interfaces.serial.Serial.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError, USBTimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"api/interfaces/socket/","title":"Socket","text":""},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket","title":"Socket","text":"<pre><code>Socket(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MessageBased</code></p> <p>Base class for equipment that is connected through a socket.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for the socket communication protocol, as well as the properties defined in MessageBased.</p> <p>Connection Properties:</p> Name Type Description <code>buffer_size</code> <code>int</code> <p>The maximum number of bytes to read at a time. Default: <code>4096</code></p> Source code in <code>src/msl/equipment/interfaces/socket.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Base class for equipment that is connected through a socket.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for the socket communication protocol, as well as the _properties_ defined in\n    [MessageBased][msl.equipment.interfaces.message_based.MessageBased].\n\n    Attributes: Connection Properties:\n        buffer_size (int): The maximum number of bytes to read at a time. _Default: `4096`_\n    \"\"\"\n    super().__init__(equipment)\n\n    assert equipment.connection is not None  # noqa: S101\n\n    info = parse_socket_address(equipment.connection.address)\n    if info is None:\n        msg = f\"Invalid socket address {equipment.connection.address!r}\"\n        raise ValueError(msg)\n\n    self._info: ParsedSocketAddress = info\n\n    props = equipment.connection.properties\n    self._buffer_size: int = props.get(\"buffer_size\", 4096)\n    self._byte_buffer: bytearray = bytearray()\n\n    typ: int = socket.SOCK_DGRAM if equipment.connection.address.startswith(\"UDP\") else socket.SOCK_STREAM\n    self._is_stream: bool = typ == socket.SOCK_STREAM\n    self._socket: socket.socket = socket.socket(family=socket.AF_INET, type=typ)\n    self._connect()\n</code></pre>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.read_termination","title":"read_termination  <code>property</code> <code>writable</code>","text":"<pre><code>read_termination: bytes | None\n</code></pre> <p>The termination character sequence that is used for a read operation.</p> <p>Reading stops when the equipment stops sending data or the <code>read_termination</code> character sequence is detected. If you set the <code>read_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.socket","title":"socket  <code>property</code>","text":"<pre><code>socket: socket\n</code></pre> <p>Returns a reference to the underlying socket.</p>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.write_termination","title":"write_termination  <code>property</code> <code>writable</code>","text":"<pre><code>write_termination: bytes | None\n</code></pre> <p>The termination character sequence that is appended to write messages.</p> <p>If you set the <code>write_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Close the socket.</p> Source code in <code>src/msl/equipment/interfaces/socket.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Close the socket.\"\"\"\n    if hasattr(self, \"_socket\") and self._socket.fileno() != -1:\n        self._socket.close()\n        super().disconnect()\n</code></pre>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError, USBTimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.reconnect","title":"reconnect","text":"<pre><code>reconnect(max_attempts: int = 1) -&gt; None\n</code></pre> <p>Reconnect to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>max_attempts</code> <code>int</code> <p>The maximum number of attempts to try to reconnect with the equipment. If &lt;1, keep trying until a connection is successful. If the maximum number of attempts has been reached then an exception is raise.</p> <code>1</code> Source code in <code>src/msl/equipment/interfaces/socket.py</code> <pre><code>def reconnect(self, max_attempts: int = 1) -&gt; None:\n    \"\"\"Reconnect to the equipment.\n\n    Args:\n        max_attempts: The maximum number of attempts to try to reconnect with the equipment.\n            If &amp;lt;1, keep trying until a connection is successful. If the maximum number\n            of attempts has been reached then an exception is raise.\n    \"\"\"\n    self._socket.close()\n    self._socket = socket.socket(family=self._socket.family, type=self._socket.type)\n\n    attempt = 0\n    while True:\n        attempt += 1\n        try:\n            return self._connect()\n        except (MSLConnectionError, MSLTimeoutError):\n            if 0 &lt; max_attempts &lt;= attempt:\n                raise\n</code></pre>"},{"location":"api/interfaces/socket/#msl.equipment.interfaces.socket.Socket.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError, USBTimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"api/interfaces/usb/","title":"USB","text":""},{"location":"api/interfaces/usb/#usb-prerequisites","title":"Prerequisites","text":"<p>Before communicating with a USB device, a libusb-compatible driver must be installed and the directory to the <code>libusb</code> library must be available on the <code>PATH</code> environment variable.</p> <p>The following instructions are intended to be a starting point if you are having issues communicating with a USB device.</p>"},{"location":"api/interfaces/usb/#usb-prerequisites-windows","title":"Windows","text":"<p>Download the latest <code>libusb</code> library from the repository.</p> <p>Tip</p> <p>Here, version 1.0.29 is downloaded. Update this value in the following command if there is a new release.</p> <pre><code>Invoke-WebRequest -Uri https://github.com/libusb/libusb/releases/download/v1.0.29/libusb-1.0.29.7z -OutFile libusb.7z\n</code></pre> <p>Use 7zip to extract the zip file. First, install 7zip if it's not already.</p> <pre><code>winget install 7zip.7zip\n</code></pre> <p>Then extract the library file and copy the appropriate (i.e., x86 or x64, VS or MinGW) <code>libusb-1.0.dll</code> file to a directory that is on your <code>PATH</code> environment variable. The following command extracts the 64-bit library file that was built with Visual Studio 2022 to the C:\\Windows\\System32 directory, but you may choose to extract a different DLL file to a different directory.</p> <pre><code>&amp; 'C:\\Program Files\\7-Zip\\7z' e libusb.7z -oC:\\Windows\\System32 VS2022\\MS64\\dll\\libusb-1.0.dll\n</code></pre> <p>Finally, install the Zadig application</p> <pre><code>winget install akeo.ie.Zadig\n</code></pre> <p>then run Zadig (you must open a new administrative terminal to run the following command)</p> <pre><code>zadig\n</code></pre> <p>to install a driver (<code>WinUSB</code> is recommended) for the USB device \u2014 follow the Zadig User Guide.</p> <p>See How to use libusb on Windows for additional information.</p>"},{"location":"api/interfaces/usb/#usb-prerequisites-linux","title":"Debian/Ubuntu","text":"<p>Install the <code>libusb-1.0-0</code> package.</p> <pre><code>sudo apt install libusb-1.0-0\n</code></pre> <p>To access a USB device without root privilege you should create a udev configuration file. There are many ways to configure udev, here is a typical setup.</p> <pre><code># /etc/udev/rules.d/10-custom.rules\n\nSUBSYSTEM==\"usb\", ATTR{idVendor}==\"03eb\", ATTR{idProduct}==\"2107\", GROUP=\"plugdev\", MODE=\"0664\"\nSUBSYSTEM==\"usb\", ATTR{idVendor}==\"0403\", ATTR{idProduct}==\"6001\", GROUP=\"plugdev\", MODE=\"0664\"\nSUBSYSTEM==\"usb\", ATTR{idVendor}==\"0403\", ATTR{idProduct}==\"faf0\", GROUP=\"plugdev\", MODE=\"0664\"\n</code></pre> <p>You need to unplug / plug back the USB device once this file has been created so that udev loads the rules for the matching device, or alternatively, inform the <code>udev</code> daemon about the changes.</p> <pre><code>sudo udevadm control --reload-rules\nsudo udevadm trigger\n</code></pre> <p>With this setup, be sure to add users that want to access the USB device(s) to the plugdev group.</p> <pre><code>sudo adduser $USER plugdev\n</code></pre> <p>Remember that you need to log out / log in to get the above command effective, or start a subshell.</p> <pre><code>newgrp plugdev\n</code></pre>"},{"location":"api/interfaces/usb/#usb-prerequisites-macos","title":"macOS","text":"<p>Install the <code>libusb</code> package.</p> <pre><code>brew install libusb\n</code></pre>"},{"location":"api/interfaces/usb/#msl.equipment.interfaces.usb.Endpoint","title":"Endpoint  <code>dataclass</code>","text":"<pre><code>Endpoint(\n    address: int,\n    interface_number: int,\n    max_packet_size: int,\n)\n</code></pre> <p>Information about a USB Endpoint.</p> <p>Attributes:</p> Name Type Description <code>address</code> <code>int</code> <p>The <code>bEndpointAddress</code> value of the USB Endpoint.</p> <code>max_packet_size</code> <code>int</code> <p>The <code>wMaxPacketSize</code> value of the USB Endpoint.</p> <code>interface_number</code> <code>int</code> <p>The <code>bInterfaceNumber</code> value of the USB Interface that the USB Endpoint is associated with.</p>"},{"location":"api/interfaces/usb/#msl.equipment.interfaces.usb.USB","title":"USB","text":"<pre><code>USB(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MessageBased</code></p> <p>Base class for (raw) USB communication.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for the USB communication protocol, as well as the properties defined in MessageBased.</p> <p>Connection Properties:</p> Name Type Description <code>bAlternateSetting</code> <code>int</code> <p>The value of <code>bAlternateSetting</code> of the USB Interface Descriptor. Default: <code>0</code></p> <code>bConfigurationValue</code> <code>int | None</code> <p>The value of <code>bConfigurationValue</code> of the USB Configuration Descriptor. If <code>None</code>, use the first Configuration found. Default: <code>None</code></p> <code>usb_backend</code> <code>Literal['libusb1', 'libusb0', 'openusb'] | None</code> <p>The PyUSB backend library to use for the connection. If <code>None</code>, selects the first backend that is available. Default: <code>None</code></p> Source code in <code>src/msl/equipment/interfaces/usb.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:  # noqa: C901, PLR0915\n    \"\"\"Base class for (raw) USB communication.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for the USB communication protocol, as well as the _properties_ defined in\n    [MessageBased][msl.equipment.interfaces.message_based.MessageBased].\n\n    Attributes: Connection Properties:\n        bAlternateSetting (int): The value of `bAlternateSetting` of the USB Interface Descriptor.\n            _Default: `0`_\n        bConfigurationValue (int | None): The value of `bConfigurationValue` of the USB Configuration\n            Descriptor. If `None`, use the first Configuration found. _Default: `None`_\n        usb_backend (Literal[\"libusb1\", \"libusb0\", \"openusb\"] | None): The PyUSB backend library to use\n            for the connection. If `None`, selects the first backend that is available. _Default: `None`_\n    \"\"\"\n    self._detached: bool = False\n    self._interface_number: int = 0\n    self._timeout_ms: int = 0\n    self._byte_buffer: bytearray = bytearray()\n    super().__init__(equipment)\n\n    assert equipment.connection is not None  # noqa: S101\n    parsed = parse_usb_address(equipment.connection.address)\n    if parsed is None:\n        msg = f\"Invalid USB address {equipment.connection.address!r}\"\n        raise ValueError(msg)\n\n    p = equipment.connection.properties\n\n    backend = p.get(\"usb_backend\")\n    if isinstance(backend, str):\n        backend = _usb_backend(backend)\n\n    try:\n        device = _find_device(parsed, backend)\n    except usb.core.NoBackendError:\n        msg = (\n            \"A PyUSB backend is not available. For tips on how to fix this issue see \"\n            \"https://mslnz.github.io/msl-equipment/dev/api/interfaces/usb/\"\n        )\n        raise MSLConnectionError(self, msg) from None\n\n    if device is None:\n        msg = \"The USB device was not found\"\n        if _is_linux_and_not_sudo():\n            msg += \" (try running as sudo or create a udev rule)\"\n        raise MSLConnectionError(self, msg)\n\n    self._device: Any = device  # usb.core.Device instance\n\n    self._interface_number = parsed.interface_number\n    configuration_value: int | None = p.get(\"bConfigurationValue\")\n    alternate_setting: int = p.get(\"bAlternateSetting\", 0)\n\n    # If a kernel driver is active, the device will be unable to perform I/O\n    # On Windows there is no kernel so NotImplementedError is raised\n    with contextlib.suppress(usb.core.USBError, NotImplementedError):\n        if device.is_kernel_driver_active(self._interface_number):\n            device.detach_kernel_driver(self._interface_number)\n            self._detached = True\n\n    # Only set the USB Configuration if one is not already set\n    # https://libusb.sourceforge.io/api-1.0/libusb_caveats.html#configsel\n    cfg = None\n    with contextlib.suppress(usb.core.USBError):\n        cfg = device.get_active_configuration()\n\n    if cfg is None or (configuration_value is not None and cfg.bConfigurationValue != configuration_value):\n        try:\n            device.set_configuration(configuration_value)\n            cfg = device.get_active_configuration()\n        except ValueError:\n            msg = f\"Invalid configuration value {configuration_value}\"\n            raise MSLConnectionError(self, msg) from None\n        except usb.core.USBError as e:\n            msg = f\"Cannot set configuration to value {configuration_value}, {e}\"\n            raise MSLConnectionError(self, msg) from None\n\n    # Get the USB Interface (and maybe set the Alternate Setting)\n    interface = cfg[(self._interface_number, alternate_setting)]\n    alternates = list(usb.util.find_descriptor(cfg, find_all=True, bInterfaceNumber=interface.bInterfaceNumber))\n    if len(alternates) &gt; 1:\n        try:\n            interface.set_altsetting()\n        except usb.core.USBError as e:\n            msg = f\"Cannot set alternate setting for {interface!r}, {e}\"\n            raise MSLConnectionError(self, msg) from None\n\n    # Get the info about some of the In/Out Endpoints for the selected USB Interface\n    ep = _endpoint(self, interface, usb.util.ENDPOINT_IN, usb.util.ENDPOINT_TYPE_BULK)\n    assert ep is not None  # noqa: S101\n    self._bulk_in: Endpoint = ep\n\n    ep = _endpoint(self, interface, usb.util.ENDPOINT_OUT, usb.util.ENDPOINT_TYPE_BULK)\n    assert ep is not None  # noqa: S101\n    self._bulk_out: Endpoint = ep\n\n    self._intr_in: Endpoint | None = _endpoint(self, interface, usb.util.ENDPOINT_IN, usb.util.ENDPOINT_TYPE_INTR)\n    self._intr_out: Endpoint | None = _endpoint(self, interface, usb.util.ENDPOINT_OUT, usb.util.ENDPOINT_TYPE_INTR)\n</code></pre>"},{"location":"api/interfaces/usb/#msl.equipment.interfaces.usb.USB.bulk_in_endpoint","title":"bulk_in_endpoint  <code>property</code>","text":"<pre><code>bulk_in_endpoint: Endpoint\n</code></pre> <p>Information about the Bulk-IN endpoint.</p>"},{"location":"api/interfaces/usb/#msl.equipment.interfaces.usb.USB.bulk_out_endpoint","title":"bulk_out_endpoint  <code>property</code>","text":"<pre><code>bulk_out_endpoint: Endpoint\n</code></pre> <p>Information about the Bulk-OUT endpoint.</p>"},{"location":"api/interfaces/usb/#msl.equipment.interfaces.usb.USB.device_version","title":"device_version  <code>property</code>","text":"<pre><code>device_version: int\n</code></pre> <p>Returns the device version (release) number.</p> <p>Corresponds to the <code>bcdDevice</code> field in the Device Descriptor.</p>"},{"location":"api/interfaces/usb/#msl.equipment.interfaces.usb.USB.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"api/interfaces/usb/#msl.equipment.interfaces.usb.USB.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/usb/#msl.equipment.interfaces.usb.USB.intr_in_endpoint","title":"intr_in_endpoint  <code>property</code>","text":"<pre><code>intr_in_endpoint: Endpoint | None\n</code></pre> <p>Information about the Interrupt-IN endpoint.</p>"},{"location":"api/interfaces/usb/#msl.equipment.interfaces.usb.USB.intr_out_endpoint","title":"intr_out_endpoint  <code>property</code>","text":"<pre><code>intr_out_endpoint: Endpoint | None\n</code></pre> <p>Information about the Interrupt-OUT endpoint.</p>"},{"location":"api/interfaces/usb/#msl.equipment.interfaces.usb.USB.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"api/interfaces/usb/#msl.equipment.interfaces.usb.USB.read_termination","title":"read_termination  <code>property</code> <code>writable</code>","text":"<pre><code>read_termination: bytes | None\n</code></pre> <p>The termination character sequence that is used for a read operation.</p> <p>Reading stops when the equipment stops sending data or the <code>read_termination</code> character sequence is detected. If you set the <code>read_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/usb/#msl.equipment.interfaces.usb.USB.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"api/interfaces/usb/#msl.equipment.interfaces.usb.USB.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"api/interfaces/usb/#msl.equipment.interfaces.usb.USB.write_termination","title":"write_termination  <code>property</code> <code>writable</code>","text":"<pre><code>write_termination: bytes | None\n</code></pre> <p>The termination character sequence that is appended to write messages.</p> <p>If you set the <code>write_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"api/interfaces/usb/#msl.equipment.interfaces.usb.USB.CtrlDirection","title":"CtrlDirection","text":"<p>               Bases: <code>IntEnum</code></p> <p>The direction of a control transfer.</p> <p>Attributes:</p> Name Type Description <code>IN</code> <code>int</code> <p>Transfer direction is from device to computer.</p> <code>OUT</code> <code>int</code> <p>Transfer direction is from computer to device.</p>"},{"location":"api/interfaces/usb/#msl.equipment.interfaces.usb.USB.CtrlRecipient","title":"CtrlRecipient","text":"<p>               Bases: <code>IntEnum</code></p> <p>The recipient of a control transfer.</p> <p>Attributes:</p> Name Type Description <code>DEVICE</code> <code>int</code> <p>Transfer is for a Device descriptor.</p> <code>INTERFACE</code> <code>int</code> <p>Transfer is for an Interface descriptor.</p> <code>ENDPOINT</code> <code>int</code> <p>Transfer is for an Endpoint descriptor.</p>"},{"location":"api/interfaces/usb/#msl.equipment.interfaces.usb.USB.CtrlType","title":"CtrlType","text":"<p>               Bases: <code>IntEnum</code></p> <p>The type of a control transfer.</p> <p>Attributes:</p> Name Type Description <code>STANDARD</code> <code>int</code> <p>Standard type.</p> <code>CLASS</code> <code>int</code> <p>Class type.</p> <code>VENDOR</code> <code>int</code> <p>Vendor type.</p>"},{"location":"api/interfaces/usb/#msl.equipment.interfaces.usb.USB.build_request_type","title":"build_request_type  <code>staticmethod</code>","text":"<pre><code>build_request_type(\n    direction: CtrlDirection,\n    type: CtrlType,\n    recipient: CtrlRecipient,\n) -&gt; int\n</code></pre> <p>Build a <code>bmRequestType</code> field for a control request.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>CtrlDirection</code> <p>Transfer direction.</p> required <code>type</code> <code>CtrlType</code> <p>Transfer type.</p> required <code>recipient</code> <code>CtrlRecipient</code> <p>Recipient of the transfer.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The <code>request_type</code> argument for a ctrl_transfer.</p> Source code in <code>src/msl/equipment/interfaces/usb.py</code> <pre><code>@staticmethod\ndef build_request_type(direction: USB.CtrlDirection, type: USB.CtrlType, recipient: USB.CtrlRecipient) -&gt; int:  # noqa: A002\n    \"\"\"Build a `bmRequestType` field for a control request.\n\n    Args:\n        direction: Transfer direction.\n        type: Transfer type.\n        recipient: Recipient of the transfer.\n\n    Returns:\n        The `request_type` argument for a [ctrl_transfer][msl.equipment.interfaces.usb.USB.ctrl_transfer].\n    \"\"\"\n    request: int = usb.util.build_request_type(direction, type, recipient)\n    return request\n</code></pre>"},{"location":"api/interfaces/usb/#msl.equipment.interfaces.usb.USB.clear_halt","title":"clear_halt","text":"<pre><code>clear_halt(endpoint: Endpoint) -&gt; None\n</code></pre> <p>Clear the halt/stall condition for an endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>Endpoint</code> <p>The endpoint to clear.</p> required Source code in <code>src/msl/equipment/interfaces/usb.py</code> <pre><code>def clear_halt(self, endpoint: Endpoint) -&gt; None:\n    \"\"\"Clear the halt/stall condition for an endpoint.\n\n    Args:\n        endpoint: The endpoint to clear.\n    \"\"\"\n    logger.debug(\"%s.clear_halt(0x%02X)\", self, endpoint.address)\n    self._device.clear_halt(endpoint.address)\n</code></pre>"},{"location":"api/interfaces/usb/#msl.equipment.interfaces.usb.USB.ctrl_transfer","title":"ctrl_transfer","text":"<pre><code>ctrl_transfer(\n    request_type: int,\n    request: int,\n    value: int = 0,\n    index: int = 0,\n    data_or_length: (\n        int | bytes | bytearray | array[int] | str | None\n    ) = None,\n) -&gt; int | array[int]\n</code></pre> <p>Perform a control transfer on Endpoint 0.</p> <p>Parameters:</p> Name Type Description Default <code>request_type</code> <code>int</code> <p>The <code>bmRequestType</code> field for the setup packet. The bit-map value defines the direction (OUT or IN) of the request, the type of request and the designated recipient. See build_request_type.</p> required <code>request</code> <code>int</code> <p>Defines the request being made.</p> required <code>value</code> <code>int</code> <p>The value field for the request.</p> <code>0</code> <code>index</code> <code>int</code> <p>The index field for the request.</p> <code>0</code> <code>data_or_length</code> <code>int | bytes | bytearray | array[int] | str | None</code> <p>Either the data payload for an OUT transfer or the number of bytes to read for an IN transfer. If there is no data payload, the parameter should be <code>None</code> for an OUT transfer or 0 for an IN transfer.</p> <code>None</code> <p>Returns:</p> Type Description <code>int | array[int]</code> <p>For an OUT transfer, the returned value is the number of bytes sent to the equipment. For an IN transfer, the returned value is the data that was read.</p> Source code in <code>src/msl/equipment/interfaces/usb.py</code> <pre><code>def ctrl_transfer(\n    self,\n    request_type: int,\n    request: int,\n    value: int = 0,\n    index: int = 0,\n    data_or_length: int | bytes | bytearray | array[int] | str | None = None,\n) -&gt; int | array[int]:\n    \"\"\"Perform a control transfer on Endpoint 0.\n\n    Args:\n        request_type: The `bmRequestType` field for the setup packet. The bit-map value\n            defines the direction (OUT or IN) of the request, the type of request\n            and the designated recipient. See\n            [build_request_type][msl.equipment.interfaces.usb.USB.build_request_type].\n        request: Defines the request being made.\n        value: The value field for the request.\n        index: The index field for the request.\n        data_or_length: Either the data payload for an OUT transfer or the number of\n            bytes to read for an IN transfer. If there is no data payload, the parameter\n            should be `None` for an OUT transfer or 0 for an IN transfer.\n\n    Returns:\n        For an OUT transfer, the returned value is the number of bytes sent to the equipment.\n            For an IN transfer, the returned value is the data that was read.\n    \"\"\"\n    # fmt: off\n    logger.debug(\n        \"%s.ctrl_transfer(0x%02X, 0x%02X, 0x%04X, 0x%04X, %s, %d)\",\n        self, request_type, request, value, index, data_or_length, self._timeout_ms\n    )\n    # fmt: on\n\n    try:\n        out: int | array[int] = self._device.ctrl_transfer(\n            bmRequestType=request_type,\n            bRequest=request,\n            wValue=value,\n            wIndex=index,\n            data_or_wLength=data_or_length,\n            timeout=self._timeout_ms,\n        )\n    except usb.core.USBTimeoutError:\n        raise MSLTimeoutError(self) from None\n    except usb.core.USBError as e:\n        raise MSLConnectionError(self, str(e)) from None\n    else:\n        return out\n</code></pre>"},{"location":"api/interfaces/usb/#msl.equipment.interfaces.usb.USB.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the USB device.</p> Source code in <code>src/msl/equipment/interfaces/usb.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Disconnect from the USB device.\"\"\"\n    if not hasattr(self, \"_device\") or self._device is None:\n        return None\n\n    if self._detached:\n        with contextlib.suppress(usb.core.USBError):\n            self._device.attach_kernel_driver(self._interface_number)\n\n    with contextlib.suppress(usb.core.USBError):\n        usb.util.dispose_resources(self._device)\n\n    self._device = None\n    return super().disconnect()\n</code></pre>"},{"location":"api/interfaces/usb/#msl.equipment.interfaces.usb.USB.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"api/interfaces/usb/#msl.equipment.interfaces.usb.USB.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError, USBTimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"api/interfaces/usb/#msl.equipment.interfaces.usb.USB.reset_device","title":"reset_device","text":"<pre><code>reset_device() -&gt; None\n</code></pre> <p>Perform a USB port reset for the device.</p> <p>If your program has to call this method, the reset will cause the device state to change (e.g., register values may be reset).</p> Source code in <code>src/msl/equipment/interfaces/usb.py</code> <pre><code>def reset_device(self) -&gt; None:\n    \"\"\"Perform a USB port reset for the device.\n\n    If your program has to call this method, the reset will cause the\n    device state to change (e.g., register values may be reset).\n    \"\"\"\n    logger.debug(\"%s.reset_device()\", self)\n    self._device.reset()\n</code></pre>"},{"location":"api/interfaces/usb/#msl.equipment.interfaces.usb.USB.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError, USBTimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"api/interfaces/vxi11/","title":"VXI11","text":""},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11","title":"VXI11","text":"<pre><code>VXI11(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MessageBased</code></p> <p>Base class for the VXI-11 communication protocol.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for the VXI-11 communication protocol, as well as the properties defined in MessageBased.</p> <p>Connection Properties:</p> Name Type Description <code>buffer_size</code> <code>int</code> <p>The maximum number of bytes to read at a time. Default: <code>4096</code></p> <code>lock_timeout</code> <code>float</code> <p>The timeout (in seconds) to wait for a lock (0 means wait forever). Default: <code>0</code></p> <code>port</code> <code>int</code> <p>The port to use instead of calling the RPC Port Mapper function.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Base class for the [VXI-11](http://www.vxibus.org/specifications.html) communication protocol.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for the [VXI-11](http://www.vxibus.org/specifications.html) communication protocol, as well\n    as the _properties_ defined in [MessageBased][msl.equipment.interfaces.message_based.MessageBased].\n\n    Attributes: Connection Properties:\n        buffer_size (int): The maximum number of bytes to read at a time. _Default: `4096`_\n        lock_timeout (float): The timeout (in seconds) to wait for a lock (0 means wait forever). _Default: `0`_\n        port (int): The port to use instead of calling the RPC Port Mapper function.\n    \"\"\"\n    # the following must be defined before calling super()\n    self._core_client: CoreClient | None = None\n    self._abort_client: AsyncClient | None = None\n    self._lock_timeout: float = 0  # updated in lock_timeout.setter\n    super().__init__(equipment)\n\n    assert equipment.connection is not None  # noqa: S101\n    info = parse_vxi_address(equipment.connection.address)\n    if info is None:\n        msg = f\"Invalid VXI-11 address {equipment.connection.address!r}\"\n        raise ValueError(msg)\n\n    self._info: ParsedVXI11Address = info\n\n    props = equipment.connection.properties\n    self._buffer_size: int = props.get(\"buffer_size\", 4096)\n    self._core_port: int = props.get(\"port\", -1)  # updated in _connect if -1\n    self._abort_port: int = -1  # updated in _connect\n    self._max_recv_size: int = -1  # updated in _connect\n    self._link_id: int = -1  # updated in _connect\n    self._io_timeout_ms: int = -1  # updated in _set_interface_timeout\n    self._lock_timeout_ms: int = -1  # updated in lock_timeout.setter\n    self.lock_timeout = props.get(\"lock_timeout\", 0)\n\n    # A non-empty read_termination value is applied by default in\n    # MessageBased if the user did not specify one. Set it back\n    # to None if a read-termination character was not explicitly specified.\n    if \"read_termination\" not in props and \"termination\" not in props:\n        self.read_termination = None  # pyright: ignore[reportUnannotatedClassAttribute]\n\n    # VXI-11 does not support write-termination characters\n    self.write_termination = None  # pyright: ignore[reportUnannotatedClassAttribute]\n\n    self._connect()\n    self._set_interface_timeout()\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.lock_timeout","title":"lock_timeout  <code>property</code> <code>writable</code>","text":"<pre><code>lock_timeout: float\n</code></pre> <p>The time, in seconds, to wait to acquire a lock.</p> <p>Setting the value to \u22640 (or <code>None</code>) means wait forever.</p>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.socket","title":"socket  <code>property</code>","text":"<pre><code>socket: socket | None\n</code></pre> <p>Returns the reference to the underlying socket.</p>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.abort","title":"abort","text":"<pre><code>abort() -&gt; None\n</code></pre> <p>Stop an in-progress request.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def abort(self) -&gt; None:\n    \"\"\"Stop an in-progress request.\"\"\"\n    if self._abort_client is None:\n        self._abort_client = AsyncClient(self._info.host)\n        self._abort_client.connect(self._abort_port, timeout=self.timeout)\n    self._abort_client.device_abort(self._link_id)\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Send the <code>clear</code> command to the device.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Send the `clear` command to the device.\"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.device_clear(\n        lid=self._link_id,\n        flags=self._init_flag(),\n        lock_timeout=self._lock_timeout_ms,\n        io_timeout=self._io_timeout_ms,\n    )\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.create_intr_chan","title":"create_intr_chan","text":"<pre><code>create_intr_chan(\n    host_addr: int,\n    host_port: int,\n    prog_num: int,\n    prog_vers: int,\n    prog_family: int,\n) -&gt; None\n</code></pre> <p>Inform the network instrument server to establish an interrupt channel.</p> <p>Parameters:</p> Name Type Description Default <code>host_addr</code> <code>int</code> <p>Address of the host servicing the interrupt.</p> required <code>host_port</code> <code>int</code> <p>Valid port number on the client.</p> required <code>prog_num</code> <code>int</code> <p>Program number.</p> required <code>prog_vers</code> <code>int</code> <p>Program version number.</p> required <code>prog_family</code> <code>int</code> <p>The underlying socket protocol family type (<code>IPPROTO_TCP</code> or <code>IPPROTO_UDP</code>).</p> required Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def create_intr_chan(self, host_addr: int, host_port: int, prog_num: int, prog_vers: int, prog_family: int) -&gt; None:\n    \"\"\"Inform the network instrument server to establish an interrupt channel.\n\n    Args:\n        host_addr: Address of the host servicing the interrupt.\n        host_port: Valid port number on the client.\n        prog_num: Program number.\n        prog_vers: Program version number.\n        prog_family: The underlying socket protocol family type (`IPPROTO_TCP` or `IPPROTO_UDP`).\n    \"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.create_intr_chan(\n        host_addr=host_addr, host_port=host_port, prog_num=prog_num, prog_vers=prog_vers, prog_family=prog_family\n    )\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.destroy_intr_chan","title":"destroy_intr_chan","text":"<pre><code>destroy_intr_chan() -&gt; None\n</code></pre> <p>Inform the network instrument server to close its interrupt channel.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def destroy_intr_chan(self) -&gt; None:\n    \"\"\"Inform the network instrument server to close its interrupt channel.\"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.destroy_intr_chan()\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.destroy_link","title":"destroy_link","text":"<pre><code>destroy_link() -&gt; None\n</code></pre> <p>Destroy the link with the device.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def destroy_link(self) -&gt; None:\n    \"\"\"Destroy the link with the device.\"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.destroy_link(self._link_id)\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Unlink and close the sockets.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Unlink and close the sockets.\"\"\"\n    if self._abort_client is None and self._core_client is None:\n        return\n\n    if self._abort_client is not None:\n        self._abort_client.close()\n        self._abort_client = None\n\n    if self._core_client is not None:\n        if self._link_id != -1:\n            with contextlib.suppress(ConnectionError):\n                self._core_client.destroy_link(self._link_id)\n            self._link_id = -1\n\n        self._core_client.close()\n        self._core_client = None\n\n    super().disconnect()\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.docmd","title":"docmd","text":"<pre><code>docmd(cmd: int, value: float, fmt: str) -&gt; bytes\n</code></pre> <p>Allows for a variety of commands to be executed.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>int</code> <p>An IEEE 488 command messages. For example, to send the Group Execute Trigger command, GET, the value of <code>cmd</code> is <code>0x08</code>.</p> required <code>value</code> <code>float</code> <p>The value to use with <code>cmd</code>. Can be of type bool, int or float.</p> required <code>fmt</code> <code>str</code> <p>How to format <code>value</code>. See format-characters for more details. Do not include the byte-order character. Network (big-endian) order is always used.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The results defined by <code>cmd</code>.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def docmd(self, cmd: int, value: float, fmt: str) -&gt; bytes:\n    \"\"\"Allows for a variety of commands to be executed.\n\n    Args:\n        cmd: An IEEE 488 command messages. For example, to send the Group Execute Trigger\n            command, _GET_, the value of `cmd` is `0x08`.\n        value: The value to use with `cmd`. Can be of type [bool][], [int][] or [float][].\n        fmt: How to format `value`. See [format-characters][] for more details. Do not\n            include the byte-order character. Network (big-endian) order is always used.\n\n    Returns:\n        The results defined by `cmd`.\n    \"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    # always use network (big-endian) byte order\n    s = Struct(\"!\" + fmt.lstrip(\"@=&lt;&gt;!\"))\n    return self._core_client.device_docmd(\n        lid=self._link_id,\n        flags=self._init_flag(),\n        io_timeout=self._io_timeout_ms,\n        lock_timeout=self._lock_timeout_ms,\n        cmd=cmd,\n        network_order=True,\n        size=s.size,\n        data=s.pack(value),\n    )\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.enable_sqr","title":"enable_sqr","text":"<pre><code>enable_sqr(*, state: bool, handle: bytes) -&gt; None\n</code></pre> <p>Enable or disable the sending of <code>device_intr_srq</code> RPCs by the network instrument server.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>Whether to enable or disable interrupts.</p> required <code>handle</code> <code>bytes</code> <p>Host specific data (maximum length is 40 characters).</p> required Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def enable_sqr(self, *, state: bool, handle: bytes) -&gt; None:\n    \"\"\"Enable or disable the sending of `device_intr_srq` RPCs by the network instrument server.\n\n    Args:\n        state: Whether to enable or disable interrupts.\n        handle: Host specific data (maximum length is 40 characters).\n    \"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.device_enable_srq(lid=self._link_id, state=state, handle=handle)\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.local","title":"local","text":"<pre><code>local() -&gt; None\n</code></pre> <p>Place the device in a local state wherein all programmable local controls are enabled.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def local(self) -&gt; None:\n    \"\"\"Place the device in a local state wherein all programmable local controls are enabled.\"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.device_local(\n        lid=self._link_id,\n        flags=self._init_flag(),\n        lock_timeout=self._lock_timeout_ms,\n        io_timeout=self._io_timeout_ms,\n    )\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.lock","title":"lock","text":"<pre><code>lock() -&gt; None\n</code></pre> <p>Acquire the device's lock.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def lock(self) -&gt; None:\n    \"\"\"Acquire the device's lock.\"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.device_lock(lid=self._link_id, flags=self._init_flag(), lock_timeout=self._lock_timeout_ms)\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError, USBTimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.read_stb","title":"read_stb","text":"<pre><code>read_stb() -&gt; int\n</code></pre> <p>Read the status byte from the device.</p> <p>Returns:</p> Type Description <code>int</code> <p>The status byte.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def read_stb(self) -&gt; int:\n    \"\"\"Read the status byte from the device.\n\n    Returns:\n        The status byte.\n    \"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    return self._core_client.device_readstb(\n        lid=self._link_id,\n        flags=self._init_flag(),\n        lock_timeout=self._lock_timeout_ms,\n        io_timeout=self._io_timeout_ms,\n    )\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.reconnect","title":"reconnect","text":"<pre><code>reconnect(max_attempts: int = 1) -&gt; None\n</code></pre> <p>Reconnect to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>max_attempts</code> <code>int</code> <p>The maximum number of attempts to try to reconnect with the equipment. If &lt;1, keep trying until a connection is successful. If the maximum number of attempts has been reached then an exception is raise.</p> <code>1</code> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def reconnect(self, max_attempts: int = 1) -&gt; None:\n    \"\"\"Reconnect to the equipment.\n\n    Args:\n        max_attempts: The maximum number of attempts to try to reconnect with the equipment.\n            If &amp;lt;1, keep trying until a connection is successful. If the maximum number\n            of attempts has been reached then an exception is raise.\n    \"\"\"\n    attempt = 0\n    while True:\n        attempt += 1\n        try:\n            return self._connect()\n        except (MSLConnectionError, MSLTimeoutError):\n            if 0 &lt; max_attempts &lt;= attempt:\n                raise\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.remote","title":"remote","text":"<pre><code>remote() -&gt; None\n</code></pre> <p>Place the device in a remote state wherein all programmable local controls are disabled.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def remote(self) -&gt; None:\n    \"\"\"Place the device in a remote state wherein all programmable local controls are disabled.\"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.device_remote(\n        lid=self._link_id,\n        flags=self._init_flag(),\n        lock_timeout=self._lock_timeout_ms,\n        io_timeout=self._io_timeout_ms,\n    )\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.trigger","title":"trigger","text":"<pre><code>trigger() -&gt; None\n</code></pre> <p>Send a trigger to the device.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def trigger(self) -&gt; None:\n    \"\"\"Send a trigger to the device.\"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.device_trigger(\n        lid=self._link_id,\n        flags=self._init_flag(),\n        lock_timeout=self._lock_timeout_ms,\n        io_timeout=self._io_timeout_ms,\n    )\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.unlock","title":"unlock","text":"<pre><code>unlock() -&gt; None\n</code></pre> <p>Release the lock acquired by lock.</p> Source code in <code>src/msl/equipment/interfaces/vxi11.py</code> <pre><code>def unlock(self) -&gt; None:\n    \"\"\"Release the lock acquired by [lock][msl.equipment.interfaces.vxi11.VXI11.lock].\"\"\"\n    if self._core_client is None:\n        raise MSLConnectionError(self, \"not connected to VXI-11 device\")\n\n    self._core_client.device_unlock(self._link_id)\n</code></pre>"},{"location":"api/interfaces/vxi11/#msl.equipment.interfaces.vxi11.VXI11.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError, USBTimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"api/interfaces/zeromq/","title":"ZeroMQ","text":""},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ","title":"ZeroMQ","text":"<pre><code>ZeroMQ(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MessageBased</code></p> <p>Base class for equipment that use the ZeroMQ communication protocol.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for the ZeroMQ communication protocol, as well as the properties defined in MessageBased. The ZeroMQ protocol does not use termination characters, so if termination characters are specified the value is ignored and is set to <code>None</code>.</p> <p>Connection Properties:</p> Name Type Description <code>protocol</code> <code>str</code> <p>ZeroMQ protocol (<code>tcp</code>, <code>udp</code>, <code>pgm</code>, <code>inproc</code>, <code>ipc</code>) Default: <code>tcp</code></p> <code>socket_type</code> <code>int | str</code> <p>ZeroMQ socket type. Default: <code>REQ</code></p> Source code in <code>src/msl/equipment/interfaces/zeromq.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Base class for equipment that use the [ZeroMQ](https://zeromq.org/) communication protocol.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for the [ZeroMQ](https://zeromq.org/) communication protocol, as well as the _properties_\n    defined in [MessageBased][msl.equipment.interfaces.message_based.MessageBased].\n    The [ZeroMQ](https://zeromq.org/) protocol does not use termination characters, so if\n    termination characters are specified the value is ignored and is set to `None`.\n\n    Attributes: Connection Properties:\n        protocol (str): ZeroMQ protocol (`tcp`, `udp`, `pgm`, `inproc`, `ipc`) _Default: `tcp`_\n        socket_type (int | str): ZeroMQ [socket type][zmq.SocketType]. _Default: `REQ`_\n    \"\"\"\n    super().__init__(equipment)\n\n    assert equipment.connection is not None  # noqa: S101\n\n    address = parse_zmq_address(equipment.connection.address)\n    if address is None:\n        msg = f\"Invalid ZeroMQ address {equipment.connection.address!r}\"\n        raise ValueError(msg)\n\n    p = equipment.connection.properties\n    socket_type = to_enum(p.get(\"socket_type\", \"REQ\"), SocketType, to_upper=True)\n    protocol: str = p.get(\"protocol\", \"tcp\")\n\n    # ZeroMQ does not use termination characters\n    self.read_termination = None  # pyright: ignore[reportUnannotatedClassAttribute]\n    self.write_termination = None  # pyright: ignore[reportUnannotatedClassAttribute]\n\n    self._context: Context[SyncSocket] = zmq.Context()\n    self._socket: SyncSocket = self._context.socket(socket_type)\n    self._set_interface_timeout()\n    self._set_interface_max_read_size()\n\n    # Calling zmq.Socket.connect() does not verify that the host:port value until the\n    # socket is used to write/read bytes. An error raised here would be for an an invalid\n    # ZeroMQ addr value\n    try:\n        _ = self._socket.connect(f\"{protocol}://{address.host}:{address.port}\")\n    except zmq.ZMQError as e:\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n</code></pre>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.socket","title":"socket  <code>property</code>","text":"<pre><code>socket: SyncSocket\n</code></pre> <p>Returns a reference to the underlying socket.</p>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Close the socket connection and terminate the context.</p> Source code in <code>src/msl/equipment/interfaces/zeromq.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Close the socket connection and terminate the context.\"\"\"\n    if hasattr(self, \"_socket\") and not self._socket.closed:\n        self._context.set(zmq.BLOCKY, 0)\n        self._socket.setsockopt(zmq.LINGER, 0)\n        self._socket.close()\n        self._context.term()\n        super().disconnect()\n</code></pre>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError, USBTimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"api/interfaces/zeromq/#msl.equipment.interfaces.zeromq.ZeroMQ.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError, USBTimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Three concepts are used by <code>msl-equipment</code></p> <ol> <li>Equipment registers \u2014 to comply with the ISO/IEC 17025 standard</li> <li>Connections \u2014 to interface with equipment for computer control</li> <li>Configuration files \u2014 define requirements for a measurement (links items 1 and 2 together)</li> </ol> <p>You do not need to use all three concepts for your application. You can choose to only use the equipment-register classes to help manage information about the equipment in your laboratory and use a different Python package to communicate with equipment. Similarly, you can choose to use one of the supported backends for communication. You can choose to ignore the equipment registers concept and solely use the package to communicate with equipment. You can also choose to not use <code>msl-equipment</code> at all, but just use the Schema to create equipment registers that comply with ISO/IEC 17025. Since an equipment register is written in the eXtensible Markup Language (XML) file format, it may be parsed by many programming languages. This allows people to share a common equipment register but use different programming languages to read information from the same equipment register.</p>"},{"location":"getting-started/configuration-files/","title":"Configuration Files","text":"<p>A configuration file is useful when you want to perform a measurement. You can use it to specify</p> <ul> <li>equipment that is required to perform the measurement</li> <li>locations of the equipment registers and connections that the equipment can be found in</li> <li>user-specific information that the measurement procedure requires for data acquisition.</li> </ul> <p>A configuration file uses the eXtensible Markup Language (XML) file format to specify this information.</p>"},{"location":"getting-started/configuration-files/#config-xml-example","title":"XML Example","text":"<p>The following illustrates an example configuration file.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;config&gt; &lt;!-- The name of the root tag can be anything you want. --&gt;\n\n  &lt;!-- OPTIONAL: Set the path to the D2XX library file (for FTDI communication).\n\n    This creates/overwrites the value of the D2XX_LIBRARY environment variable.\n    Specifying this element is only necessary if the D2XX library is not\n    automatically found. You could also include the directory to the D2XX\n    library file as a &lt;path&gt; element in the configuration file (see below).\n  --&gt;\n  &lt;d2xx_library&gt;C:\\Users\\username\\ftd2xx64.dll&lt;/d2xx_library&gt;\n\n  &lt;!-- OPTIONAL: Set the path to a GPIB library file (for GPIB communication).\n\n    This creates/overwrites the value of the GPIB_LIBRARY environment variable.\n    Specifying this element is only necessary if the default file location is\n    not automatically found or if you want to use a different GPIB library\n    instead of the default library.\n  --&gt;\n  &lt;gpib_library&gt;/opt/gpib/libgpib.so.0&lt;/gpib_library&gt;\n\n  &lt;!-- OPTIONAL: Set the PyVISA backend library to use for PyVISA communication.\n\n    This creates/overwrites the value of the PYVISA_LIBRARY environment\n    variable. Possible values are:\n      @ivi (PyVISA &gt;=1.11, default)\n      @ni  (PyVISA &lt; 1.11)\n      @py  (PyVISA-py)\n      @sim (PyVISA-sim)\n  --&gt;\n  &lt;pyvisa_library&gt;@py&lt;/pyvisa_library&gt;\n\n  &lt;!-- OPTIONAL: Add paths to where library files are located.\n\n    The paths are appended to the PATH environment variable. If a\n    recursive=\"true\" attribute is included, then recursively adds the\n    specified directory and all sub-directories to PATH. Adding &lt;path&gt;\n    elements is useful if communication to equipment requires the\n    manufacturer's Software Development Kit (SDK). The &lt;path&gt; element\n    may be specified multiple times.\n  --&gt;\n  &lt;path&gt;C:\\Program Files\\Manufacturer\\lib&lt;/path&gt;\n  &lt;path recursive=\"true\"&gt;D:\\code\\SDKs&lt;/path&gt;\n\n  &lt;!-- Specify the equipment that is required to perform the measurement.\n\n    The `eid` attribute (equipment ID from an equipment register) is mandatory,\n    and the `name` attribute is optional. If you define a `name`, you can access\n    the equipment by its name instead of the index number based on the order\n    that &lt;equipment/&gt; elements are defined in the configuration file. You can\n    also access the equipment by its `eid` value. All other attributes are\n    ignored by msl-equipment. Additional attributes may be helpful for a person\n    to know what the equipment is when they read the configuration file.\n\n    Not all &lt;equipment/&gt; elements that are defined need to be for communication\n    purposes. Cables, amplifiers, filters and adaptors can all be important\n    equipment that may be required to perform a measurement. Defining this kind\n    of equipment is useful to have access to during data acquisition since you\n    can save the &lt;equipment/&gt; information (or just the equipment IDs) to the\n    output file.\n   --&gt;\n  &lt;equipment eid=\"MSLE.M.092\" name=\"dmm\" comment=\"borrowed from Kibble lab\"/&gt;\n  &lt;equipment eid=\"MSLE.O.103\" name=\"photodiode\" manufacturer=\"MSL\" std=\"B03\"/&gt;\n  &lt;equipment eid=\"MSLE.O.061\" name=\"monochromator\"/&gt;\n\n  &lt;!-- Equipment registers that the equipment above can be found in.\n\n    The value can be a single XML file or a directory that contains multiple\n    XML files (if your register spans multiple files). If a directory, the\n    specified directory and all sub-directories will be searched for equipment\n    registers.\n\n    The value supports the ~ character to represent the users HOME directory.\n    The &lt;register&gt; element can be specified multiple times.\n  --&gt;\n  &lt;register&gt;~\\Equipment\\register.xml&lt;/register&gt;\n  &lt;register&gt;M:\\Mass\\Register&lt;/register&gt;\n\n  &lt;!-- Connection files for equipment that require computer control.\n\n    The value can be a single XML file or a directory that contains multiple\n    XML files. If a directory, the specified directory and all sub-directories\n    will be searched for connection files.\n\n    The value supports the ~ character to represent the users HOME directory.\n    The &lt;connections&gt; element can be specified multiple times.\n  --&gt;\n  &lt;connections&gt;C:\\DATA\\Connections\\transmittance.xml&lt;/connections&gt;\n\n  &lt;!-- USER SPECIFIC: You may define your own elements. --&gt;\n  &lt;max_temperature unit=\"\u00b0C\"&gt;30&lt;/max_temperature&gt;\n  &lt;auto_zero&gt;true&lt;/auto_zero&gt;\n  &lt;nd_filter&gt;OD: 2.0&lt;/nd_filter&gt;\n  &lt;smtp&gt;\n    &lt;host&gt;smtp.server.nz&lt;/host&gt;\n    &lt;port&gt;25&lt;/port&gt;\n    &lt;recipient&gt;me@measurement.govt.nz&lt;/recipient&gt;\n    &lt;recipient&gt;you@measurement.govt.nz&lt;/recipient&gt;\n  &lt;/smtp&gt;\n\n&lt;/config&gt;\n</code></pre>"},{"location":"getting-started/configuration-files/#config-python-example","title":"Python Example","text":"<p>The Config class is used to load a configuration file</p> <pre><code>&gt;&gt;&gt; from msl.equipment import Config\n&gt;&gt;&gt; cfg = Config(\"tests/resources/config.xml\")\n</code></pre> <p>You can then access the equipment registers,</p> <pre><code>&gt;&gt;&gt; for team, register in cfg.registers.items():\n...    print(f\"{team}:\", register)\nMass: Register(team='Mass' (3 equipment))\nLight: Register(team='Light' (4 equipment))\n</code></pre> <p>iterate over and access <code>&lt;equipment/&gt;</code> elements that have been defined in the configuration file to access the Equipment instances,</p> <pre><code>&gt;&gt;&gt; for equipment in cfg.equipment:\n...     print(equipment.id)\nMSLE.M.092\nMSLE.O.103\nMSLE.O.061\n&gt;&gt;&gt; cfg.equipment[0].id  # use the index\n'MSLE.M.092'\n&gt;&gt;&gt; cfg.equipment[\"MSLE.M.092\"].id  # use the equipment id\n'MSLE.M.092'\n&gt;&gt;&gt; cfg.equipment[\"dmm\"].id  # use the name attribute\n'MSLE.M.092'\n</code></pre> <p>access XML elements defined in the configuration file by using the tag name or the path to the element,</p> <pre><code>&gt;&gt;&gt; cfg.attrib(\"max_temperature\")\n{'unit': '\u00b0C'}\n&gt;&gt;&gt; cfg.find(\"max_temperature\")\n&lt;Element 'max_temperature' at ...&gt;\n&gt;&gt;&gt; cfg.findall(\"smtp/recipient\")\n[&lt;Element 'recipient' at ...&gt;, &lt;Element 'recipient' at ...&gt;]\n</code></pre> <p>and if the value of an XML element is a boolean (<code>true</code>, <code>false</code> case-insensitive) an integer or a floating-point number, you can use the value method to convert the text value to the appropriate Python data type (otherwise the text value will remain as a string).</p> <pre><code>&gt;&gt;&gt; cfg.value(\"auto_zero\")\nTrue\n&gt;&gt;&gt; cfg.value(\"max_temperature\") / 2\n15.0\n&gt;&gt;&gt; cfg.value(\"nd_filter\")\n'OD: 2.0'\n</code></pre> <p>If the equipment supports computer control, you can call the connect method of the Equipment instance to establish communication.</p> <pre><code>dmm = cfg.equipment[\"dmm\"].connect()\nprint(dmm.query(\"*IDN?\"))\ndmm.disconnect()\n</code></pre> <p>See this section for more details about communicating with equipment.</p>"},{"location":"getting-started/connections/","title":"Connections","text":"<p>The information about how to interface with equipment for computer control is based on the definitions in the Schema and may either be saved in the eXtensible Markup Language (XML) file format or in a Python module. When using the XML format, you would specify the XML file that contains the connection information as a <code>&lt;connections&gt;</code> element in your configuration file. When the configuration file is loaded (via Config), it links a Connection instance with the corresponding Equipment instance based on the equipment id.</p>"},{"location":"getting-started/connections/#connections-xml","title":"XML Schema","text":"<p>Schema definition for connection information. See this section for details on how to validate the contents of a connections XML file against the schema.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;xsd:schema version=\"1.0.0\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"&gt;\n    &lt;xsd:element name=\"connections\"&gt;\n        &lt;xsd:complexType&gt;\n            &lt;xsd:sequence minOccurs=\"0\" maxOccurs=\"unbounded\"&gt;\n                &lt;xsd:element name=\"connection\"&gt;\n                    &lt;xsd:complexType&gt;\n                        &lt;xsd:all&gt;\n                            &lt;xsd:element name=\"eid\" type=\"xsd:string\"&gt;\n                                &lt;xsd:annotation&gt;\n                                    &lt;xsd:documentation&gt;\n                                        The equipment ID from an equipment register.\n                                    &lt;/xsd:documentation&gt;\n                                &lt;/xsd:annotation&gt;\n                            &lt;/xsd:element&gt;\n                            &lt;xsd:element name=\"address\" type=\"xsd:string\"&gt;\n                                &lt;xsd:annotation&gt;\n                                    &lt;xsd:documentation&gt;\n                                        The VISA-style address to use for the connection.\n                                    &lt;/xsd:documentation&gt;\n                                &lt;/xsd:annotation&gt;\n                            &lt;/xsd:element&gt;\n                            &lt;xsd:element name=\"backend\" minOccurs=\"0\"&gt;\n                                &lt;xsd:annotation&gt;\n                                    &lt;xsd:documentation&gt;\n                                        The backend package to use to communicate with the equipment.\n                                        Default is MSL if not defined.\n                                    &lt;/xsd:documentation&gt;\n                                &lt;/xsd:annotation&gt;\n                                &lt;xsd:simpleType&gt;\n                                    &lt;xsd:restriction base=\"xsd:string\"&gt;\n                                        &lt;xsd:enumeration value=\"MSL\"/&gt;\n                                        &lt;xsd:enumeration value=\"PyVISA\"/&gt;\n                                        &lt;xsd:enumeration value=\"NIDAQ\"/&gt;\n                                    &lt;/xsd:restriction&gt;\n                                &lt;/xsd:simpleType&gt;\n                            &lt;/xsd:element&gt;\n                            &lt;xsd:element name=\"manufacturer\" type=\"xsd:string\" minOccurs=\"0\"&gt;\n                                &lt;xsd:annotation&gt;\n                                    &lt;xsd:documentation&gt;\n                                        The name of the manufacturer of the equipment.\n                                    &lt;/xsd:documentation&gt;\n                                &lt;/xsd:annotation&gt;\n                            &lt;/xsd:element&gt;\n                            &lt;xsd:element name=\"model\" type=\"xsd:string\" minOccurs=\"0\"&gt;\n                                &lt;xsd:annotation&gt;\n                                    &lt;xsd:documentation&gt;\n                                        The model number of the equipment.\n                                    &lt;/xsd:documentation&gt;\n                                &lt;/xsd:annotation&gt;\n                            &lt;/xsd:element&gt;\n                            &lt;xsd:element name=\"serial\" type=\"xsd:string\" minOccurs=\"0\"&gt;\n                                &lt;xsd:annotation&gt;\n                                    &lt;xsd:documentation&gt;\n                                        The serial number (or unique identifier) of the equipment.\n                                    &lt;/xsd:documentation&gt;\n                                &lt;/xsd:annotation&gt;\n                            &lt;/xsd:element&gt;\n                            &lt;xsd:element name=\"properties\" minOccurs=\"0\"&gt;\n                                &lt;xsd:annotation&gt;\n                                    &lt;xsd:documentation&gt;\n                                        Additional name-value pairs that are required to communicate with the equipment.\n                                    &lt;/xsd:documentation&gt;\n                                &lt;/xsd:annotation&gt;\n                                &lt;xsd:complexType&gt;\n                                    &lt;xsd:sequence&gt;\n                                        &lt;xsd:any processContents=\"skip\" minOccurs=\"0\" maxOccurs=\"unbounded\"/&gt;\n                                    &lt;/xsd:sequence&gt;\n                                &lt;/xsd:complexType&gt;\n                            &lt;/xsd:element&gt;\n                        &lt;/xsd:all&gt;\n                    &lt;/xsd:complexType&gt;\n                &lt;/xsd:element&gt;\n            &lt;/xsd:sequence&gt;\n        &lt;/xsd:complexType&gt;\n    &lt;/xsd:element&gt;\n&lt;/xsd:schema&gt;\n</code></pre>"},{"location":"getting-started/connections/#connections-xml-example","title":"Example","text":"<p>Example XML file to specify connection information. Only the <code>&lt;eid&gt;</code> and <code>&lt;address&gt;</code> elements are required, all other elements are optional.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;connections&gt;\n    &lt;connection&gt;\n        &lt;eid&gt;MSLE.M.041&lt;/eid&gt;\n        &lt;address&gt;TCPIP::192.168.1.10::hislip0&lt;/address&gt;\n    &lt;/connection&gt;\n    &lt;connection&gt;\n        &lt;eid&gt;MSLE.M.023&lt;/eid&gt;\n        &lt;address&gt;ASRL/dev/ttyS1&lt;/address&gt;\n        &lt;backend&gt;PyVISA&lt;/backend&gt;\n        &lt;manufacturer&gt;Manufacturer&lt;/manufacturer&gt;\n        &lt;model&gt;Model&lt;/model&gt;\n        &lt;serial&gt;Serial&lt;/serial&gt;\n        &lt;properties&gt;\n            &lt;baud_rate&gt;19200&lt;/baud_rate&gt;\n            &lt;read_termination&gt;\\r&lt;/read_termination&gt;\n            &lt;write_termination&gt;\\r&lt;/write_termination&gt;\n            &lt;timeout&gt;10&lt;/timeout&gt;\n        &lt;/properties&gt;\n    &lt;/connection&gt;\n&lt;/connections&gt;\n</code></pre>"},{"location":"getting-started/connections/#address-syntax","title":"Address Syntax","text":"<p>The following are examples of VISA-style addresses that may be used to connect to equipment.</p> Interface Address Description FTDI FTDI::0x0403::0x6001::abc FTDI device using driver=0 (default, libusb), idVendor=0x0403, idProduct=0x6001 (hexadecimal notation), serial number=abc, USB Interface Number=0 (default) FTDI FTDI0::1027::24577::032165::1 FTDI device using driver=0 (libusb), idVendor=1027, idProduct=24577 (decimal notation), serial number=032165, USB Interface Number=1 FTDI FTDI2::0x0403::0xfaf0::A825192 FTDI device using driver=2 (d2xx), idVendor=0x0403, idProduct=0xfaf0 (hexadecimal notation), serial number=A825192,     the USB Interface Number is ignored when using the d2xx driver GPIB GPIB::10 GPIB device at board=0 (default), primary address=10, no secondary address GPIB GPIB0::voltmeter GPIB device at board=0, interface name=\"voltmeter\" (see gpib.conf for more details about the \"name\" option) GPIB GPIB1::6::97::INSTR GPIB device at board=1, primary address=6, secondary address=97 GPIB GPIB2::INTFC GPIB interface at board=2 HiSLIP TCPIP::dev.company.com::hislip0 A HiSLIP LAN instrument, host=dev.company.com HiSLIP TCPIP::10.12.114.50::hislip0,5000::INSTR A HiSLIP LAN instrument, host=10.12.114.50, port=5000 PROLOGIX Prologix::192.168.1.110::1234::6 The GPIB-ETHERNET Controller, host=192.168.1.110, port=1234, primary GPIB address=6 PROLOGIX Prologix::192.168.1.70::1234::6::112 The GPIB-ETHERNET Controller, host=192.168.1.70, port=1234, primary GPIB address=6, secondary GPIB address=112 PROLOGIX Prologix::192.168.1.70::1234::GPIB::6::112 The GPIB-ETHERNET Controller, host=192.168.1.70, port=1234, primary GPIB address=6, secondary GPIB address=112 PROLOGIX Prologix::COM3::6 The GPIB-USB Controller, port=COM3, primary GPIB address=6 PROLOGIX Prologix::COM3::GPIB::6 The GPIB-USB Controller, port=COM3, primary GPIB address=6 PROLOGIX Prologix::/dev/ttyS0::4::96 The GPIB-USB Controller, port=/dev/ttyS0, primary GPIB address=4, secondary GPIB address=96 SDK SDK::C:/Manufacturer/library.dll Specify the full path to the SDK SDK SDK::library.dll Specify only the filename if the path to where the SDK file is located has been added to the <code>PATH</code> environment variable SERIAL COM2 A serial port on Windows SERIAL ASRL/dev/ttyS1 A serial port on Linux SERIAL ASRL2::INSTR Compatible with National Instruments syntax SERIAL ASRLCOM2 Compatible with PyVISA-py syntax SOCKET TCP::192.168.1.100::5000 Use the TCP protocol, host=192.168.1.100, port=5000 SOCKET UDP::192.168.1.100::5000 Use the UDP protocol, host=192.168.1.100, port=5000 SOCKET TCPIP::192.168.1.100::5000::SOCKET Compatible with National Instruments syntax USB USB::0x2a67::0x0408::abc::RAW A (raw) USB device with board=0 (default), idVendor=0x2a67, idProduct=0x0408 (hexadecimal notation), serial number=abc, USB Interface Number=0 (default) USB USB0::1027::24577::032165::1::RAW A (raw) USB device with board=0, idVendor=1027, idProduct=24577 (decimal notation), serial number=032165, USB Interface Number=1 USB USB::0x0381::0x06a2::IGNORE::RAW A (raw) USB device with board=0 (default), idVendor=0x0381, idProduct=0x06a2 (hexadecimal notation), serial number=IGNORE (means that the serial number is not used when finding the USB device and the first USB device found that matches idVendor and idProduct is used), USB Interface Number=0 (default) VXI-11 TCPIP::dev.company.com::INSTR A VXI-11.3 LAN instrument, host=dev.company.com (uses the default LAN Device Name inst0) VXI-11 TCPIP::10.6.56.21::gpib0,2::INSTR A VXI-11.2 GPIB device, host=10.6.56.21, gpib address=2 VXI-11 TCPIP::192.168.1.100 A VXI-11.3 LAN instrument, host=192.168.1.100 (default values for board 0 and LAN device name inst0 are used) ZMQ ZMQ::192.168.20.90::5555 Use the ZeroMQ messaging library to connect to a device, host=192.168.20.90, port=5555 <p>National Instruments also provides examples if you are using PyVISA as the backend.</p>"},{"location":"getting-started/connections/#connections-interfaces","title":"Interfaces","text":"<p>The following interface classes are available</p> <ul> <li>FTDI \u2014 For equipment that use a Future Technology Devices International (FTDI) chip</li> <li>GPIB \u2014 For equipment that use the GPIB (IEEE 488) protocol</li> <li>HiSLIP \u2014 For equipment that use the HiSLIP protocol</li> <li>Prologix \u2014 Use Prologix hardware to establish a connection to GPIB-compatible equipment</li> <li>SDK \u2014 For equipment that use a Software Development Kit (SDK) for communication</li> <li>Serial \u2014 For equipment that is connected through a serial port (or a USB-to-Serial adaptor)</li> <li>Socket \u2014 For equipment that is connected through a network socket</li> <li>USB \u2014 For equipment that use the USB protocol</li> <li>VXI11 \u2014 For equipment that use the VXI-11 protocol</li> <li>ZeroMQ \u2014 For equipment that use the ZeroMQ protocol</li> </ul>"},{"location":"getting-started/connections/#connections-backend","title":"Backends","text":"<p>When a Connection instance is created, the <code>backend</code> keyword argument decides which backend to use when interfacing with the equipment. There are different Backends to choose from: <code>MSL</code> (default), <code>PyVISA</code> or <code>NIDAQ</code>.</p> <p>The interface class can be used if the <code>backend</code> is <code>MSL</code>. The corresponding interface classes for the external backends are PyVISA and NIDAQ.</p>"},{"location":"getting-started/connections/#connections-python-examples","title":"Python Examples","text":"<p>If you are primarily interested in using <code>msl-equipment</code> to interface with equipment (and not the Equipment Registers aspect), the simplest approach is to create Connection instances in a module and call the connect method (which is equivalent to calling Equipment.connect() if you are using Equipment Registers).</p> <pre><code>from msl.equipment import Connection\n\ndevice = Connection(\"COM3\").connect()\nprint(device.query(\"*IDN?\"))\ndevice.disconnect()\n</code></pre> <p>All interfaces can be used as a context manager, where the disconnect method is called when exiting the code block. The previous example is equivalent to the following.</p> <pre><code>from msl.equipment import Connection\n\nwith Connection(\"COM3\").connect() as device:\n  print(device.query(\"*IDN?\"))\n</code></pre> <p>If you have multiple equipment that you want to interface with and you also want to include some additional metadata so that you can keep track of which device is associated with the corresponding address, you could do something like the following. Also, for some interfaces, such as when using a manufacturer's SDK, the serial number must be passed to the SDK when opening the connection and therefore the serial number must be specified as a keyword argument (or as an element in a connections XML file).</p> <pre><code>from msl.equipment import Connection\n\n# Assign custom names to associate with each equipment\nconnections = {\n    \"alice\": Connection(\"GPIB::22\", model=\"3458A\"),\n    \"bob\": Connection(\"COM3\", manufacturer=\"HP\", model=\"34401A\"),\n\n    # not used below but is available to use for another day\n    \"eve\": Connection(\"SDK::company.dll\", manufacturer=\"ABC\", serial=\"4621\"),\n}\n\n# Connect to the equipment using the names that were assigned\nalice = connections[\"alice\"].connect()\nbob = connections[\"bob\"].connect()\n\n# Query the identity\nprint(alice.query(\"ID?\"))\nprint(bob.query(\"*IDN?\"))\n\n# Disconnect when finished\nalice.disconnect()\nbob.disconnect()\n</code></pre> <p>The logging module may be used to help debug communication issues, especially when interfacing with multiple equipment. By enabling the <code>DEBUG</code> level you will be able to capture the bytes that are written to and read from the equipment.</p> <pre><code>import logging\nfrom msl.equipment import Connection\n\nlogging.basicConfig(level=logging.DEBUG, format=\"%(levelname)s %(message)s\")\n\nc = Connection(\"COM3\", manufacturer=\"HP\", model=\"34401A\", serial=\"3146A\")\nwith c.connect() as dmm:\n    identity = dmm.query(\"*IDN?\")\n</code></pre> <p>Running the previous example would display something similar to the following.</p> <pre><code>DEBUG Connecting to Serial&lt;HP|34401A|3146A at COM3&gt;\nDEBUG Serial&lt;HP|34401A|3146A&gt;.write(b'*IDN?\\r\\n')\nDEBUG Serial&lt;HP|34401A|3146A&gt;.read() -&gt; b'Hewlett Packard,34401A,3146A,A03-02\\n'\nDEBUG Disconnected from Serial&lt;HP|34401A|3146A at COM3&gt;\n</code></pre>"},{"location":"getting-started/equipment-registers/","title":"Equipment Registers","text":"<p>Laboratories that use equipment for traceable calibration measurements are required to manage information about the equipment by following the ISO/IEC 17025 standard. This information is saved in files that are referred to as equipment registers.</p> <p>An equipment register is based on the definitions in the Schema and may either be saved in the eXtensible Markup Language (XML) file format or in a Python module. Using the XML format is the preferred way to save the information since XML files can be easily validated against the Schema to ensure data integrity and it allows for equipment registers to be parsed by many programming languages. An equipment register can be saved in a single XML file or distributed across multiple XML files.</p> <p>The Schema Classes section of the documentation shows how an equipment register can be used in a Python program. The Register class loads an equipment register, or when using a configuration file the registers attribute provides access to multiple equipment registers.</p>"},{"location":"getting-started/equipment-registers/#er-schema","title":"XML Schema","text":"<p>The documentation for the equipment-register schema is available here and development of the schema is performed in the repository.</p> <p>Currently, the schema is targeting equipment that is located at the Measurement Standards Laboratory of New Zealand (in particular, enumeration values and pattern-string matches). If you work at a calibration laboratory and are interested in using the schema within your Quality Management System, please contact us or open an issue.</p> <p>See this section for details on how to validate the contents of an equipment register against the schema.</p>"},{"location":"getting-started/equipment-registers/#er-python-module","title":"Python Module","text":"<p>You may save the information about the equipment you are using in Python modules instead of in XML files.</p> <pre><code>from datetime import date\n\nfrom msl.equipment import (\n    CompletedTask,\n    Component,\n    Connection,\n    Equation,\n    Equipment,\n    Evaluable,\n    Maintenance,\n    Measurand,\n    Range,\n    Report,\n)\n\nequipment = Equipment(\n    manufacturer=\"HP\",\n    model=\"3458A\",\n    connection=Connection(\"GPIB::22\"),\n    maintenance=Maintenance(\n        completed=(\n            CompletedTask(\n                task=\"Clean fan\",\n                due_date=date(2025, 3, 4),\n                completed_date=date(2025, 3, 5),\n                performed_by=\"John\",\n            ),\n        )\n    ),\n    calibrations=(\n        Measurand(\n            quantity=\"Voltage DC\",\n            calibration_interval=1,\n            components=(\n                Component(\n                    reports=(\n                        Report(\n                            id=\"Report No.\",\n                            report_issue_date=date(2024, 8, 13),\n                            measurement_start_date=date(2024, 8, 5),\n                            measurement_stop_date=date(2024, 8, 6),\n                            equations=(\n                                Equation(\n                                    value=Evaluable(\n                                        equation=\"0.9999862*v + 1.024e-5\",\n                                        variables=(\"v\",),\n                                        ranges={\"v\": Range(1, 10)}\n                                    ),\n                                    uncertainty=Evaluable(equation=\"3.2e-6\"),\n                                    unit=\"V\",\n                                ),\n                            ),\n                        ),\n                    )\n                ),\n            ),\n        ),\n    ),\n)\n\n# Connect to the digital multimeter and query its identity\ndmm = equipment.connect()\nprint(dmm.query(\"ID?\"))\n\n# Configure the multimeter, fetch voltage readings, convert to float(s)\nvoltages = ...\n\n# Apply the calibration equation to correct the voltage readings\ncorrection = equipment.latest_report().equation\nprint(correction.value(v=voltages))\nprint(correction.uncertainty(v=voltages))\n</code></pre>"},{"location":"resources/","title":"Resources","text":"<p>Resources are custom classes for interfacing with specific equipment. In previous releases of <code>msl-equipment</code> (versions &lt; 1.0), the resources were automatically bundled with <code>msl-equipment</code>. As of v1.0, the resources are maintained in another package, <code>msl-equipment-resources</code>, that must be installed separately.</p> <p>Some of the resources might not work in your application because the resource might depend on an external dependency, e.g., the Software Development Kit (SDK) provided by a manufacturer, and this external dependency might not be available for your operating system.</p> <p>Examples</p> <p>There are examples on how to use the resources in the repository.</p> <p>Attention</p> <p>Companies that sell equipment that are used for scientific research are identified in this guide in order to illustrate how to adequately use <code>msl-equipment-resources</code> in your application. Such identification is not intended to imply recommendation or endorsement by the Measurement Standards Laboratory of New Zealand, nor is it intended to imply that the companies identified are necessarily the best for the purpose.</p>"},{"location":"resources/#install","title":"Install","text":"<p>Installing <code>msl-equipment-resources</code> will also install <code>msl-equipment</code></p> <pre><code>pip install msl-equipment-resources\n</code></pre>"},{"location":"resources/#create-a-new-resource","title":"Create a new resource","text":"<p>TODO...</p>"},{"location":"resources/#multiple-interfaces","title":"Multiple interfaces","text":"<p>If the equipment supports multiple interfaces for message-based protocols (e.g., Socket, Serial, GPIB, ...) you can create a resource that inherits from the MultiMessageBased class. Upon calling super in the subclass, the connection is established with the appropriate protocol class.</p>"},{"location":"resources/multi_message_based/","title":"MultiMessageBased","text":"<p>A resource that supports multiple interfaces for message-based communication.</p>"},{"location":"resources/multi_message_based/#msl.equipment_resources.multi_message_based.MultiMessageBased","title":"MultiMessageBased","text":"<pre><code>MultiMessageBased(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MessageBased</code></p> <p>A resource that supports multiple interfaces for message-based communication.</p> <p>A Connection instance supports the same properties as MessageBased.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/multi_message_based.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"A resource that supports multiple interfaces for message-based communication.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the same _properties_ as\n    [MessageBased][msl.equipment.interfaces.message_based.MessageBased].\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"\n    self._connected: bool = False\n    super().__init__(equipment)\n\n    c = equipment.connection\n    assert c is not None  # noqa: S101\n\n    try:\n        # Let the address (not the manufacturer/model) decide which interface to use\n        self._interface: MessageBased = Connection(c.address, **c.properties).connect()\n    except MSLConnectionError as e:\n        lines = str(e).splitlines()\n        raise MSLConnectionError(self, message=\"\\n\".join(lines[1:])) from None\n\n    self._connected = True\n    self._set_interface_max_read_size()\n    self._set_interface_timeout()\n</code></pre>"},{"location":"resources/multi_message_based/#msl.equipment_resources.multi_message_based.MultiMessageBased.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"resources/multi_message_based/#msl.equipment_resources.multi_message_based.MultiMessageBased.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"resources/multi_message_based/#msl.equipment_resources.multi_message_based.MultiMessageBased.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"resources/multi_message_based/#msl.equipment_resources.multi_message_based.MultiMessageBased.read_termination","title":"read_termination  <code>property</code> <code>writable</code>","text":"<pre><code>read_termination: bytes | None\n</code></pre> <p>The termination character sequence that is used for a read operation.</p> <p>Reading stops when the equipment stops sending data or the <code>read_termination</code> character sequence is detected. If you set the <code>read_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"resources/multi_message_based/#msl.equipment_resources.multi_message_based.MultiMessageBased.rstrip","title":"rstrip  <code>property</code> <code>writable</code>","text":"<pre><code>rstrip: bool\n</code></pre> <p>Whether to remove trailing whitespace from read messages.</p>"},{"location":"resources/multi_message_based/#msl.equipment_resources.multi_message_based.MultiMessageBased.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"resources/multi_message_based/#msl.equipment_resources.multi_message_based.MultiMessageBased.write_termination","title":"write_termination  <code>property</code> <code>writable</code>","text":"<pre><code>write_termination: bytes | None\n</code></pre> <p>The termination character sequence that is appended to write messages.</p> <p>If you set the <code>write_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"resources/multi_message_based/#msl.equipment_resources.multi_message_based.MultiMessageBased.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the equipment.</p> Source code in <code>packages/resources/src/msl/equipment_resources/multi_message_based.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Disconnect from the equipment.\"\"\"\n    if self._connected:\n        self._interface.disconnect()\n        super().disconnect()\n        self._connected = False\n</code></pre>"},{"location":"resources/multi_message_based/#msl.equipment_resources.multi_message_based.MultiMessageBased.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"resources/multi_message_based/#msl.equipment_resources.multi_message_based.MultiMessageBased.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError, USBTimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"resources/multi_message_based/#msl.equipment_resources.multi_message_based.MultiMessageBased.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError, USBTimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"resources/types/","title":"types","text":"<p>Custom type annotations.</p>"},{"location":"resources/types/#msl.equipment_resources.types.AvaSpecCallback","title":"AvaSpecCallback  <code>module-attribute</code>","text":"<pre><code>AvaSpecCallback = Callable[\n    [_Pointer[c_int32], _Pointer[c_int32]], None\n]\n</code></pre> <p>Callback handler for the AvaSpec SDK.</p>"},{"location":"resources/types/#msl.equipment_resources.types.NKTDeviceStatusCallback","title":"NKTDeviceStatusCallback  <code>module-attribute</code>","text":"<pre><code>NKTDeviceStatusCallback = Callable[\n    [str, int, int, int, int], None\n]\n</code></pre> <p>Callback handler for the NKT SDK when the status of a device changes.</p>"},{"location":"resources/types/#msl.equipment_resources.types.NKTPortStatusCallback","title":"NKTPortStatusCallback  <code>module-attribute</code>","text":"<pre><code>NKTPortStatusCallback = Callable[\n    [str, int, int, int, int], None\n]\n</code></pre> <p>Callback handler for the NKT SDK when the status of a port changes.</p>"},{"location":"resources/types/#msl.equipment_resources.types.NKTRegisterStatusCallback","title":"NKTRegisterStatusCallback  <code>module-attribute</code>","text":"<pre><code>NKTRegisterStatusCallback = Callable[\n    [str, int, int, int, int, int, int], None\n]\n</code></pre> <p>Callback handler for the NKT SDK when the status of a register changes.</p>"},{"location":"resources/types/#msl.equipment_resources.types.PicoTechBlockReadyCallback","title":"PicoTechBlockReadyCallback  <code>module-attribute</code>","text":"<pre><code>PicoTechBlockReadyCallback = Callable[\n    [int, int, None], None\n]\n</code></pre> <p>Block-ready callback handler for the PicoScope SDK.</p>"},{"location":"resources/types/#msl.equipment_resources.types.PicoTechDataReadyCallback","title":"PicoTechDataReadyCallback  <code>module-attribute</code>","text":"<pre><code>PicoTechDataReadyCallback = Callable[\n    [int, int, int, int, None], None\n]\n</code></pre> <p>Data-ready callback handler for the PicoScope SDK.</p>"},{"location":"resources/types/#msl.equipment_resources.types.PicoTechStreamingReadyCallback","title":"PicoTechStreamingReadyCallback  <code>module-attribute</code>","text":"<pre><code>PicoTechStreamingReadyCallback = Callable[\n    [int, int, int, int, int, int, int, None], None\n]\n</code></pre> <p>Streaming-ready callback handler for the PicoScope SDK.</p>"},{"location":"resources/aim-tti/mx_series/","title":"MX Series DC Power Supply","text":"<p>Connect to an MX100QP, MX100TP, MX103QP or MX180TP DC power supply from Aim and Thurlby Thandar Instruments.</p>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries","title":"MXSeries","text":"<pre><code>MXSeries(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MultiMessageBased</code></p> <p>Connect to an MX100QP, MX100TP, MX103QP or MX180TP DC power supply.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Connect to an MX100QP, MX100TP, MX103QP or MX180TP DC power supply from [Aim and Thurlby Thandar Instruments].\n\n    [Aim and Thurlby Thandar Instruments]: https://www.aimtti.com/\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"  # noqa: E501\n    super().__init__(equipment)\n    self.rstrip: bool = True\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.encoding","title":"encoding  <code>property</code> <code>writable</code>","text":"<pre><code>encoding: str\n</code></pre> <p>The encoding that is used for read and write operations.</p>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.max_read_size","title":"max_read_size  <code>property</code> <code>writable</code>","text":"<pre><code>max_read_size: int\n</code></pre> <p>The maximum number of bytes that can be read.</p>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.read_termination","title":"read_termination  <code>property</code> <code>writable</code>","text":"<pre><code>read_termination: bytes | None\n</code></pre> <p>The termination character sequence that is used for a read operation.</p> <p>Reading stops when the equipment stops sending data or the <code>read_termination</code> character sequence is detected. If you set the <code>read_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.timeout","title":"timeout  <code>property</code> <code>writable</code>","text":"<pre><code>timeout: float | None\n</code></pre> <p>The timeout, in seconds, for read and write operations.</p> <p>A value &lt;0 will set the timeout to be <code>None</code> (blocking mode).</p>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.write_termination","title":"write_termination  <code>property</code> <code>writable</code>","text":"<pre><code>write_termination: bytes | None\n</code></pre> <p>The termination character sequence that is appended to write messages.</p> <p>If you set the <code>write_termination</code> to be equal to a variable of type str, it will be encoded as bytes.</p>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Send the clear command, <code>*CLS</code>.</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Send the clear command, `*CLS`.\"\"\"\n    _ = self.write(\"*CLS\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.decrement_current","title":"decrement_current","text":"<pre><code>decrement_current(channel: int) -&gt; None\n</code></pre> <p>Decrement the current limit by step size of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def decrement_current(self, channel: int) -&gt; None:\n    \"\"\"Decrement the current limit by step size of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n    \"\"\"\n    self._write_and_check(f\"DECI{channel}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.decrement_voltage","title":"decrement_voltage","text":"<pre><code>decrement_voltage(\n    channel: int, *, verify: bool = True\n) -&gt; None\n</code></pre> <p>Decrement the voltage by step size of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>verify</code> <code>bool</code> <p>Whether to verify that the output voltage has stabilized at the decremented voltage before returning to the calling program.</p> <code>True</code> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def decrement_voltage(self, channel: int, *, verify: bool = True) -&gt; None:\n    \"\"\"Decrement the voltage by step size of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        verify: Whether to verify that the output voltage has stabilized at\n            the decremented voltage before returning to the calling program.\n    \"\"\"\n    v = \"V\" if verify else \"\"\n    self._write_and_check(f\"DECV{channel}{v}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the equipment.</p> Source code in <code>packages/resources/src/msl/equipment_resources/multi_message_based.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Disconnect from the equipment.\"\"\"\n    if self._connected:\n        self._interface.disconnect()\n        super().disconnect()\n        self._connected = False\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.event_status_register","title":"event_status_register","text":"<pre><code>event_status_register() -&gt; int\n</code></pre> <p>Read and clear the standard event status register.</p> <p>Returns:</p> Type Description <code>int</code> <p>The event status register value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def event_status_register(self) -&gt; int:\n    \"\"\"Read and clear the standard event status register.\n\n    Returns:\n        The event status register value.\n    \"\"\"\n    return int(self.query(\"*ESR?\"))\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.get_current","title":"get_current","text":"<pre><code>get_current(channel: int) -&gt; float\n</code></pre> <p>Get the output current of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The output current (in Amps).</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def get_current(self, channel: int) -&gt; float:\n    \"\"\"Get the output current of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n\n    Returns:\n        The output current (in Amps).\n    \"\"\"\n    reply = self._query_and_check(f\"I{channel}O?\")\n    return float(reply[:-1])  # the reply ends with 'A'\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.get_current_limit","title":"get_current_limit","text":"<pre><code>get_current_limit(channel: int) -&gt; float\n</code></pre> <p>Get the current limit of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The current limit (in Amps).</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def get_current_limit(self, channel: int) -&gt; float:\n    \"\"\"Get the current limit of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n\n    Returns:\n        The current limit (in Amps).\n    \"\"\"\n    reply = self._query_and_check(f\"I{channel}?\")\n    return float(reply[2:])\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.get_current_step_size","title":"get_current_step_size","text":"<pre><code>get_current_step_size(channel: int) -&gt; float\n</code></pre> <p>Get the current limit step size of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The current limit step size (in Amps).</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def get_current_step_size(self, channel: int) -&gt; float:\n    \"\"\"Get the current limit step size of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n\n    Returns:\n        The current limit step size (in Amps).\n    \"\"\"\n    reply = self._query_and_check(f\"DELTAI{channel}?\")\n    return float(reply[7:])\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.get_over_current_protection","title":"get_over_current_protection","text":"<pre><code>get_over_current_protection(channel: int) -&gt; float | None\n</code></pre> <p>Get the over-current protection trip point of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>If the trip point is enabled then returns the trip point value in Amps.</p> <code>float | None</code> <p>Otherwise, returns <code>None</code> if the over-current protection is disabled.</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def get_over_current_protection(self, channel: int) -&gt; float | None:\n    \"\"\"Get the over-current protection trip point of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n\n    Returns:\n        If the trip point is enabled then returns the trip point value in Amps.\n        Otherwise, returns `None` if the over-current protection is disabled.\n    \"\"\"\n    reply = self._query_and_check(f\"OCP{channel}?\")\n    if reply.endswith(\"OFF\"):\n        return None\n    return float(reply[3:])\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.get_over_voltage_protection","title":"get_over_voltage_protection","text":"<pre><code>get_over_voltage_protection(channel: int) -&gt; float | None\n</code></pre> <p>Get the over-voltage protection trip point of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>If the trip point is enabled then returns the trip point value in Volts.</p> <code>float | None</code> <p>Otherwise, returns <code>None</code> if the over-voltage protection is disabled.</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def get_over_voltage_protection(self, channel: int) -&gt; float | None:\n    \"\"\"Get the over-voltage protection trip point of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n\n    Returns:\n        If the trip point is enabled then returns the trip point value in Volts.\n        Otherwise, returns `None` if the over-voltage protection is disabled.\n    \"\"\"\n    reply = self._query_and_check(f\"OVP{channel}?\")\n    if reply.endswith(\"OFF\"):\n        return None\n    return float(reply[3:])\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.get_voltage","title":"get_voltage","text":"<pre><code>get_voltage(channel: int) -&gt; float\n</code></pre> <p>Get the output voltage of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The output voltage (in Volts).</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def get_voltage(self, channel: int) -&gt; float:\n    \"\"\"Get the output voltage of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n\n    Returns:\n        The output voltage (in Volts).\n    \"\"\"\n    reply = self._query_and_check(f\"V{channel}O?\")\n    return float(reply[:-1])  # the reply ends with 'V'\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.get_voltage_range","title":"get_voltage_range","text":"<pre><code>get_voltage_range(channel: int) -&gt; int\n</code></pre> <p>Get the output voltage range index of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The output voltage range index. See the manual for more details.</p> <code>int</code> <p>For example, 2 \u2192 35V/3A.</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def get_voltage_range(self, channel: int) -&gt; int:\n    \"\"\"Get the output voltage range index of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n\n    Returns:\n        The output voltage range index. See the manual for more details.\n        For example, 2 &amp;#8594; 35V/3A.\n    \"\"\"\n    return int(self._query_and_check(f\"VRANGE{channel}?\"))\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.get_voltage_setpoint","title":"get_voltage_setpoint","text":"<pre><code>get_voltage_setpoint(channel: int) -&gt; float\n</code></pre> <p>Get the set-point voltage of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The set-point voltage (in Volts).</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def get_voltage_setpoint(self, channel: int) -&gt; float:\n    \"\"\"Get the set-point voltage of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n\n    Returns:\n        The set-point voltage (in Volts).\n    \"\"\"\n    reply = self._query_and_check(f\"V{channel}?\")\n    return float(reply[2:])\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.get_voltage_step_size","title":"get_voltage_step_size","text":"<pre><code>get_voltage_step_size(channel: int) -&gt; float\n</code></pre> <p>Get the voltage step size of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The voltage step size (in Volts).</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def get_voltage_step_size(self, channel: int) -&gt; float:\n    \"\"\"Get the voltage step size of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n\n    Returns:\n        The voltage step size (in Volts).\n    \"\"\"\n    reply = self._query_and_check(f\"DELTAV{channel}?\")\n    return float(reply[7:])\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.get_voltage_tracking_mode","title":"get_voltage_tracking_mode","text":"<pre><code>get_voltage_tracking_mode() -&gt; int\n</code></pre> <p>Get the voltage tracking mode of the unit.</p> <p>Returns:</p> Type Description <code>int</code> <p>The voltage tracking mode. See the manual for more details.</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def get_voltage_tracking_mode(self) -&gt; int:\n    \"\"\"Get the voltage tracking mode of the unit.\n\n    Returns:\n        The voltage tracking mode. See the manual for more details.\n    \"\"\"\n    return int(self._query_and_check(\"CONFIG?\"))\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.increment_current","title":"increment_current","text":"<pre><code>increment_current(channel: int) -&gt; None\n</code></pre> <p>Increment the current limit by the step size of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def increment_current(self, channel: int) -&gt; None:\n    \"\"\"Increment the current limit by the step size of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n    \"\"\"\n    self._write_and_check(f\"INCI{channel}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.increment_voltage","title":"increment_voltage","text":"<pre><code>increment_voltage(\n    channel: int, *, verify: bool = True\n) -&gt; None\n</code></pre> <p>Increment the voltage by the step size of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>verify</code> <code>bool</code> <p>Whether to verify that the output voltage has stabilized at the incremented voltage before returning to the calling program.</p> <code>True</code> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def increment_voltage(self, channel: int, *, verify: bool = True) -&gt; None:\n    \"\"\"Increment the voltage by the step size of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        verify: Whether to verify that the output voltage has stabilized at\n            the incremented voltage before returning to the calling program.\n    \"\"\"\n    v = \"V\" if verify else \"\"\n    self._write_and_check(f\"INCV{channel}{v}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.is_output_on","title":"is_output_on","text":"<pre><code>is_output_on(channel: int) -&gt; bool\n</code></pre> <p>Check if the output channel is on or off.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the output channel is on or off.</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def is_output_on(self, channel: int) -&gt; bool:\n    \"\"\"Check if the output channel is on or off.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n\n    Returns:\n        Whether the output channel is on or off.\n    \"\"\"\n    reply = self._query_and_check(f\"OP{channel}?\")\n    return reply == \"1\"\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.query","title":"query","text":"<pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>query(\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Convenience method for performing a write followed by a read.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>delay</code> <code>float</code> <p>Time delay, in seconds, to wait between the write and read operations.</p> <code>0.0</code> <code>decode</code> <code>bool</code> <p>Whether to decode the returned message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def query(\n    self,\n    message: bytes | str,\n    *,\n    delay: float = 0.0,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Convenience method for performing a [write][msl.equipment.interfaces.message_based.MessageBased.write]\n    followed by a [read][msl.equipment.interfaces.message_based.MessageBased.read].\n\n    Args:\n        message: The message to write to the equipment.\n        delay: Time delay, in seconds, to wait between the _write_ and _read_ operations.\n        decode: Whether to decode the returned message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is\n            returned as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"  # noqa: D205\n    _ = self.write(message)\n    if delay &gt; 0:\n        time.sleep(delay)\n    if dtype:\n        return self.read(dtype=dtype, fmt=fmt, size=size)\n    return self.read(decode=decode, size=size)\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.read","title":"read","text":"<pre><code>read(\n    *,\n    decode: Literal[True] = True,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; str\n</code></pre><pre><code>read(\n    *,\n    decode: Literal[False] = False,\n    dtype: None = None,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; bytes\n</code></pre><pre><code>read(\n    *,\n    decode: bool = ...,\n    dtype: MessageDataType = ...,\n    fmt: MessageFormat = ...,\n    size: int | None = ...\n) -&gt; NumpyArray1D\n</code></pre> <pre><code>read(\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None\n) -&gt; bytes | str | NumpyArray1D\n</code></pre> <p>Read a message from the equipment.</p> <p>This method will block until one of the following conditions is fulfilled:</p> <ol> <li><code>size</code> bytes have been received \u2014 only if <code>size</code> is not <code>None</code>.</li> <li>the read_termination    byte(s) is(are) received \u2014 only if    read_termination    is not <code>None</code>.</li> <li>a timeout occurs \u2014 only if timeout    is not <code>None</code>. If a timeout occurs, an    MSLTimeoutError is raised.</li> <li>max_read_size    bytes have been received. If the maximum number of bytes have been read, an    MSLConnectionError is raised.</li> </ol> <p>Tip</p> <p>You may also want to set the rstrip value for the class instance.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>Whether to decode the message (i.e., convert the message to a str) or keep the message as bytes. Ignored if <code>dtype</code> is not <code>None</code>.</p> <code>True</code> <code>dtype</code> <code>MessageDataType | None</code> <p>The data type of the elements in the returned message. Can be any object that numpy dtype supports. For messages that are of scalar type (i.e., a single number) it is more efficient to not specify <code>dtype</code> but to pass the returned message to the int or float class to convert the message to the appropriate numeric type. See MessageDataType for more details.</p> <code>None</code> <code>fmt</code> <code>MessageFormat</code> <p>The format that the returned message data is in. Ignored if <code>dtype</code> is <code>None</code>. See MessageFormat for more details.</p> <code>None</code> <code>size</code> <code>int | None</code> <p>The number of bytes to read. Ignored if the value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes | str | NumpyArray1D</code> <p>The message from the equipment. If <code>dtype</code> is specified, then the message is returned as a numpy ndarray, if <code>decode</code> is <code>True</code> then the message is returned as a str, otherwise the message is returned as bytes.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def read(\n    self,\n    *,\n    decode: bool = True,\n    dtype: MessageDataType | None = None,\n    fmt: MessageFormat = None,\n    size: int | None = None,\n) -&gt; bytes | str | NumpyArray1D:\n    \"\"\"Read a message from the equipment.\n\n    This method will block until one of the following conditions is fulfilled:\n\n    1. `size` bytes have been received &amp;mdash; only if `size` is not `None`.\n    2. the [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       byte(s) is(are) received &amp;mdash; only if\n       [read_termination][msl.equipment.interfaces.message_based.MessageBased.read_termination]\n       is not `None`.\n    3. a timeout occurs &amp;mdash; only if [timeout][msl.equipment.interfaces.message_based.MessageBased.timeout]\n       is not `None`. If a timeout occurs, an\n       [MSLTimeoutError][msl.equipment.interfaces.message_based.MSLTimeoutError] is raised.\n    4. [max_read_size][msl.equipment.interfaces.message_based.MessageBased.max_read_size]\n       bytes have been received. If the maximum number of bytes have been read, an\n       [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError] is raised.\n\n    !!! tip\n        You may also want to set the [rstrip][msl.equipment.interfaces.message_based.MessageBased.rstrip]\n        value for the class instance.\n\n    Args:\n        decode: Whether to decode the message (i.e., convert the message to a [str][])\n            or keep the message as [bytes][]. Ignored if `dtype` is not `None`.\n        dtype: The data type of the elements in the returned message. Can be any object that numpy\n            [dtype][numpy.dtype] supports. For messages that are of scalar type (i.e., a single number)\n            it is more efficient to not specify `dtype` but to pass the returned message to the\n            [int][] or [float][] class to convert the message to the appropriate numeric type.\n            See [MessageDataType][msl.equipment._types.MessageDataType] for more details.\n        fmt: The format that the returned message data is in. Ignored if `dtype` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n        size: The number of bytes to read. Ignored if the value is `None`.\n\n    Returns:\n        The message from the equipment. If `dtype` is specified, then the message is returned\n            as a numpy [ndarray][numpy.ndarray], if `decode` is `True` then the message\n            is returned as a [str][], otherwise the message is returned as [bytes][].\n    \"\"\"\n    if size is not None and size &gt; self._max_read_size:\n        msg = f\"max_read_size is {self._max_read_size} bytes, requesting {size} bytes\"\n        raise MSLConnectionError(self, msg)\n\n    try:\n        message = self._read(size)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError, USBTimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        msg = f\"{e.__class__.__name__}: {e}\"\n        raise MSLConnectionError(self, msg) from None\n\n    if size is None:\n        if dtype:\n            logger.debug(\"%s.read(dtype=%r, fmt=%r) -&gt; %r\", self, dtype, fmt, message)\n        else:\n            logger.debug(\"%s.read() -&gt; %r\", self, message)\n    else:\n        if len(message) != size:\n            msg = f\"received {len(message)} bytes, requested {size} bytes\"\n            raise MSLConnectionError(self, msg)\n        logger.debug(\"%s.read(size=%s) -&gt; %r\", self, size, message)\n\n    if self._rstrip:\n        message = message.rstrip()\n\n    if dtype:\n        return from_bytes(message, fmt=fmt, dtype=dtype)\n\n    if decode:\n        return message.decode(encoding=self._encoding)\n\n    return message\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.recall","title":"recall","text":"<pre><code>recall(channel: int, index: int) -&gt; None\n</code></pre> <p>Recall the settings of the output channel from the store.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>index</code> <code>int</code> <p>The store index number, can be 0-49.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def recall(self, channel: int, index: int) -&gt; None:\n    \"\"\"Recall the settings of the output channel from the store.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        index: The store index number, can be 0-49.\n    \"\"\"\n    self._write_and_check(f\"RCL{channel} {index}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.recall_all","title":"recall_all","text":"<pre><code>recall_all(index: int) -&gt; None\n</code></pre> <p>Recall the settings for all output channels from the store.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The store index number, can be 0-49.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def recall_all(self, index: int) -&gt; None:\n    \"\"\"Recall the settings for all output channels from the store.\n\n    Args:\n        index: The store index number, can be 0-49.\n    \"\"\"\n    self._write_and_check(f\"*SAV {index}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Send the reset command, <code>*RST</code>.</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Send the reset command, `*RST`.\"\"\"\n    _ = self.write(\"*RST\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.reset_trip","title":"reset_trip","text":"<pre><code>reset_trip() -&gt; None\n</code></pre> <p>Attempt to clear all trip conditions.</p> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def reset_trip(self) -&gt; None:\n    \"\"\"Attempt to clear all trip conditions.\"\"\"\n    _ = self.write(\"TRIPRST\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.save","title":"save","text":"<pre><code>save(channel: int, index: int) -&gt; None\n</code></pre> <p>Save the present settings of the output channel to the store.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>index</code> <code>int</code> <p>The store index number, can be 0-49.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def save(self, channel: int, index: int) -&gt; None:\n    \"\"\"Save the present settings of the output channel to the store.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        index: The store index number, can be 0-49.\n    \"\"\"\n    self._write_and_check(f\"SAV{channel} {index}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.save_all","title":"save_all","text":"<pre><code>save_all(index: int) -&gt; None\n</code></pre> <p>Save the settings of all output channels to the store.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The store index number, can be 0-49.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def save_all(self, index: int) -&gt; None:\n    \"\"\"Save the settings of all output channels to the store.\n\n    Args:\n        index: The store index number, can be 0-49.\n    \"\"\"\n    self._write_and_check(f\"*RCL {index}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.set_current_limit","title":"set_current_limit","text":"<pre><code>set_current_limit(channel: int, value: float) -&gt; None\n</code></pre> <p>Set the current limit of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>value</code> <code>float</code> <p>The current limit (in Amps).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def set_current_limit(self, channel: int, value: float) -&gt; None:\n    \"\"\"Set the current limit of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        value: The current limit (in Amps).\n    \"\"\"\n    self._write_and_check(f\"I{channel} {value}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.set_current_meter_averaging","title":"set_current_meter_averaging","text":"<pre><code>set_current_meter_averaging(\n    channel: int,\n    mode: Literal[\"ON\", \"OFF\", \"LOW\", \"MED\", \"HIGH\"],\n) -&gt; None\n</code></pre> <p>Set the current meter measurement averaging of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>mode</code> <code>Literal['ON', 'OFF', 'LOW', 'MED', 'HIGH']</code> <p>Averaging mode.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def set_current_meter_averaging(self, channel: int, mode: Literal[\"ON\", \"OFF\", \"LOW\", \"MED\", \"HIGH\"]) -&gt; None:\n    \"\"\"Set the current meter measurement averaging of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        mode: Averaging mode.\n    \"\"\"\n    self._write_and_check(f\"DAMPING{channel} {mode}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.set_current_step_size","title":"set_current_step_size","text":"<pre><code>set_current_step_size(channel: int, size: float) -&gt; None\n</code></pre> <p>Set the current limit step size of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>size</code> <code>float</code> <p>The current limit step size, in Amps.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def set_current_step_size(self, channel: int, size: float) -&gt; None:\n    \"\"\"Set the current limit step size of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        size: The current limit step size, in Amps.\n    \"\"\"\n    self._write_and_check(f\"DELTAI{channel} {size}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.set_multi_off_action","title":"set_multi_off_action","text":"<pre><code>set_multi_off_action(\n    channel: int, action: Literal[\"QUICK\", \"NEVER\", \"DELAY\"]\n) -&gt; None\n</code></pre> <p>Set the Multi-Off action of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>action</code> <code>Literal['QUICK', 'NEVER', 'DELAY']</code> <p>The Multi-Off action.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def set_multi_off_action(self, channel: int, action: Literal[\"QUICK\", \"NEVER\", \"DELAY\"]) -&gt; None:\n    \"\"\"Set the Multi-Off action of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        action: The Multi-Off action.\n    \"\"\"\n    self._write_and_check(f\"OFFACTION{channel} {action}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.set_multi_off_delay","title":"set_multi_off_delay","text":"<pre><code>set_multi_off_delay(channel: int, delay: int) -&gt; None\n</code></pre> <p>Set the Multi-Off delay, in milliseconds, of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>delay</code> <code>int</code> <p>The turn-off delay (in milliseconds).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def set_multi_off_delay(self, channel: int, delay: int) -&gt; None:\n    \"\"\"Set the Multi-Off delay, in milliseconds, of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        delay: The turn-off delay (in milliseconds).\n    \"\"\"\n    self._write_and_check(f\"OFFDELAY{channel} {delay}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.set_multi_on_action","title":"set_multi_on_action","text":"<pre><code>set_multi_on_action(\n    channel: int, action: Literal[\"QUICK\", \"NEVER\", \"DELAY\"]\n) -&gt; None\n</code></pre> <p>Set the Multi-On action of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>action</code> <code>Literal['QUICK', 'NEVER', 'DELAY']</code> <p>The Multi-On action.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def set_multi_on_action(self, channel: int, action: Literal[\"QUICK\", \"NEVER\", \"DELAY\"]) -&gt; None:\n    \"\"\"Set the Multi-On action of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        action: The Multi-On action.\n    \"\"\"\n    self._write_and_check(f\"ONACTION{channel} {action}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.set_multi_on_delay","title":"set_multi_on_delay","text":"<pre><code>set_multi_on_delay(channel: int, delay: int) -&gt; None\n</code></pre> <p>Set the Multi-On delay, in milliseconds, of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>delay</code> <code>int</code> <p>The turn-on delay (in milliseconds).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def set_multi_on_delay(self, channel: int, delay: int) -&gt; None:\n    \"\"\"Set the Multi-On delay, in milliseconds, of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        delay: The turn-on delay (in milliseconds).\n    \"\"\"\n    self._write_and_check(f\"ONDELAY{channel} {delay}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.set_over_current_protection","title":"set_over_current_protection","text":"<pre><code>set_over_current_protection(\n    channel: int,\n    *,\n    enable: bool,\n    value: float | None = None\n) -&gt; None\n</code></pre> <p>Set the over-current protection trip point of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>enable</code> <code>bool</code> <p>Whether to enable or disable the over-current protection trip point.</p> required <code>value</code> <code>float | None</code> <p>If the trip point is enabled then you must specify a value (in Amps).</p> <code>None</code> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def set_over_current_protection(self, channel: int, *, enable: bool, value: float | None = None) -&gt; None:\n    \"\"\"Set the over-current protection trip point of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        enable: Whether to enable or disable the over-current protection trip point.\n        value: If the trip point is enabled then you must specify a value (in Amps).\n    \"\"\"\n    if enable:\n        if value is None:\n            msg = \"Must specify the trip point value if the trip point is enabled\"\n            raise ValueError(msg)\n        command = f\"OCP{channel} ON;OCP{channel} {value}\"\n    else:\n        command = f\"OCP{channel} OFF\"\n    self._write_and_check(command)\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.set_over_voltage_protection","title":"set_over_voltage_protection","text":"<pre><code>set_over_voltage_protection(\n    channel: int,\n    *,\n    enable: bool,\n    value: float | None = None\n) -&gt; None\n</code></pre> <p>Set the over-voltage protection trip point of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>enable</code> <code>bool</code> <p>Whether to enable or disable the over-voltage protection trip point.</p> required <code>value</code> <code>float | None</code> <p>If the trip point is enabled then you must specify a value (in Volts).</p> <code>None</code> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def set_over_voltage_protection(self, channel: int, *, enable: bool, value: float | None = None) -&gt; None:\n    \"\"\"Set the over-voltage protection trip point of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        enable: Whether to enable or disable the over-voltage protection trip point.\n        value: If the trip point is enabled then you must specify a value (in Volts).\n    \"\"\"\n    if enable:\n        if value is None:\n            msg = \"Must specify the trip point value if the trip point is enabled\"\n            raise ValueError(msg)\n        command = f\"OVP{channel} ON;OVP{channel} {value}\"\n    else:\n        command = f\"OVP{channel} OFF\"\n    self._write_and_check(command)\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.set_voltage","title":"set_voltage","text":"<pre><code>set_voltage(\n    channel: int, value: float, *, verify: bool = True\n) -&gt; None\n</code></pre> <p>Set the output voltage of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>value</code> <code>float</code> <p>The value (in Volts).</p> required <code>verify</code> <code>bool</code> <p>Whether to verify that the output voltage has stabilized at <code>value</code> before returning to the calling program.</p> <code>True</code> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def set_voltage(self, channel: int, value: float, *, verify: bool = True) -&gt; None:\n    \"\"\"Set the output voltage of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        value: The value (in Volts).\n        verify: Whether to verify that the output voltage has stabilized at `value`\n            before returning to the calling program.\n    \"\"\"\n    command = f\"V{channel}V {value}\" if verify else f\"V{channel} {value}\"\n    self._write_and_check(command)\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.set_voltage_range","title":"set_voltage_range","text":"<pre><code>set_voltage_range(channel: int, index: int) -&gt; None\n</code></pre> <p>Set the output voltage range of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>index</code> <code>int</code> <p>The output voltage range index. See the manual for more details. For example, 2 \u2192 35V/3A.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def set_voltage_range(self, channel: int, index: int) -&gt; None:\n    \"\"\"Set the output voltage range of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        index: The output voltage range index. See the manual for more details.\n            For example, 2 &amp;#8594; 35V/3A.\n    \"\"\"\n    self._write_and_check(f\"VRANGE{channel} {index}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.set_voltage_step_size","title":"set_voltage_step_size","text":"<pre><code>set_voltage_step_size(channel: int, size: float) -&gt; None\n</code></pre> <p>Set the voltage step size of the output channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required <code>size</code> <code>float</code> <p>The voltage step size (in Volts).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def set_voltage_step_size(self, channel: int, size: float) -&gt; None:\n    \"\"\"Set the voltage step size of the output channel.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n        size: The voltage step size (in Volts).\n    \"\"\"\n    self._write_and_check(f\"DELTAV{channel} {size}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.set_voltage_tracking_mode","title":"set_voltage_tracking_mode","text":"<pre><code>set_voltage_tracking_mode(mode: int) -&gt; None\n</code></pre> <p>Set the voltage tracking mode of the unit.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>int</code> <p>The voltage tracking mode. See the manual for more details.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def set_voltage_tracking_mode(self, mode: int) -&gt; None:\n    \"\"\"Set the voltage tracking mode of the unit.\n\n    Args:\n        mode: The voltage tracking mode. See the manual for more details.\n    \"\"\"\n    self._write_and_check(f\"CONFIG {mode}\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.turn_off","title":"turn_off","text":"<pre><code>turn_off(channel: int) -&gt; None\n</code></pre> <p>Turn the output channel off.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def turn_off(self, channel: int) -&gt; None:\n    \"\"\"Turn the output channel off.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n    \"\"\"\n    self._write_and_check(f\"OP{channel} 0\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.turn_off_multi","title":"turn_off_multi","text":"<pre><code>turn_off_multi(\n    options: dict[int, bool | int] | None = None,\n) -&gt; None\n</code></pre> <p>Turn multiple output channels off (the Multi-Off feature).</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>dict[int, bool | int] | None</code> <p>Set the Multi-Off option for each output channel before setting Multi-Off. If not specified then uses the pre-programmed options. If a particular output channel is not included in <code>options</code> then uses the pre-programmed option for that channel. The keys are the output channel number and the value can be <code>False</code> (set the channel to <code>NEVER</code>, see the manual for more details), <code>True</code> (set the channel to <code>QUICK</code>, see the manual for more details) or a delay in milliseconds (as an int). Examples,</p> <ul> <li><code>{1: False}</code> \u2192 channel 1 does not turn off</li> <li><code>{2: 100}</code> \u2192 channel 2 has a 100-ms delay</li> <li><code>{1: 100, 3: True}</code> \u2192 channel 1 has a 100-ms delay and channel 3 turns off immediately</li> <li><code>{1: 100, 2: 200, 3: 300}</code> \u2192 channel 1 has a 100-ms delay, channel 2 has a 200-ms delay     and channel 3 has a 300-ms delay</li> </ul> <code>None</code> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def turn_off_multi(self, options: dict[int, bool | int] | None = None) -&gt; None:\n    \"\"\"Turn multiple output channels off (the Multi-Off feature).\n\n    Args:\n        options: Set the Multi-Off option for each output channel before setting Multi-Off.\n            If not specified then uses the pre-programmed options. If a particular output\n            channel is not included in `options` then uses the pre-programmed option for\n            that channel. The keys are the output channel number and the value can be\n            `False` (set the channel to `NEVER`, see the manual for more details),\n            `True` (set the channel to `QUICK`, see the manual for more details) or a\n            delay in milliseconds (as an [int][]). Examples,\n\n            * `{1: False}` &amp;#8594; channel 1 does not turn off\n            * `{2: 100}` &amp;#8594; channel 2 has a 100-ms delay\n            * `{1: 100, 3: True}` &amp;#8594; channel 1 has a 100-ms delay and channel 3 turns off immediately\n            * `{1: 100, 2: 200, 3: 300}` &amp;#8594; channel 1 has a 100-ms delay, channel 2 has a 200-ms delay\n                and channel 3 has a 300-ms delay\n    \"\"\"\n    if options:\n        for channel, value in options.items():\n            if isinstance(value, bool):\n                self.set_multi_off_action(channel, \"QUICK\" if value else \"NEVER\")\n            else:\n                self.set_multi_off_action(channel, \"DELAY\")\n                self.set_multi_off_delay(channel, value)\n                time.sleep(0.1)  # otherwise the power supply may not set the delay properly\n    self._write_and_check(\"OPALL 0\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.turn_on","title":"turn_on","text":"<pre><code>turn_on(channel: int) -&gt; None\n</code></pre> <p>Turn the output channel on.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The output channel. The first output channel is 1 (not 0).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def turn_on(self, channel: int) -&gt; None:\n    \"\"\"Turn the output channel on.\n\n    Args:\n        channel: The output channel. The first output channel is 1 (not 0).\n    \"\"\"\n    self._write_and_check(f\"OP{channel} 1\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.turn_on_multi","title":"turn_on_multi","text":"<pre><code>turn_on_multi(\n    options: dict[int, bool | int] | None = None,\n) -&gt; None\n</code></pre> <p>Turn multiple output channels on (the Multi-On feature).</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>dict[int, bool | int] | None</code> <p>Set the Multi-On option for each output channel before setting Multi-On. If not specified then uses the pre-programmed options. If a particular output channel is not included in <code>options</code> then uses the pre-programmed option for that channel. The keys are the output channel number and the value can be <code>False</code> (set the channel to <code>NEVER</code>, see the manual for more details), <code>True</code> (set the channel to <code>QUICK</code>, see the manual for more details) or a delay in milliseconds (as an int). Examples,</p> <ul> <li><code>{1: False}</code> \u2192 channel 1 does not turn on</li> <li><code>{2: 100}</code> \u2192 channel 2 has a 100-ms delay</li> <li><code>{1: 100, 3: True}</code> \u2192` channel 1 has a 100-ms delay and channel 3 turns on immediately</li> <li><code>{1: 100, 2: 200, 3: 300}</code> \u2192 channel 1 has a 100-ms delay, channel 2 has a 200-ms delay     and channel 3 has a 300-ms delay</li> </ul> <code>None</code> Source code in <code>packages/resources/src/msl/equipment_resources/aim_tti/mx_series.py</code> <pre><code>def turn_on_multi(self, options: dict[int, bool | int] | None = None) -&gt; None:\n    \"\"\"Turn multiple output channels on (the Multi-On feature).\n\n    Args:\n        options: Set the Multi-On option for each output channel before setting Multi-On.\n            If not specified then uses the pre-programmed options. If a particular output\n            channel is not included in `options` then uses the pre-programmed option for\n            that channel. The keys are the output channel number and the value can be\n            `False` (set the channel to `NEVER`, see the manual for more details),\n            `True` (set the channel to `QUICK`, see the manual for more details) or a\n            delay in milliseconds (as an [int][]). Examples,\n\n            * `{1: False}` &amp;#8594; channel 1 does not turn on\n            * `{2: 100}` &amp;#8594; channel 2 has a 100-ms delay\n            * `{1: 100, 3: True}` &amp;#8594;` channel 1 has a 100-ms delay and channel 3 turns on immediately\n            * `{1: 100, 2: 200, 3: 300}` &amp;#8594; channel 1 has a 100-ms delay, channel 2 has a 200-ms delay\n                and channel 3 has a 300-ms delay\n    \"\"\"\n    if options:\n        for channel, value in options.items():\n            if isinstance(value, bool):\n                self.set_multi_on_action(channel, \"QUICK\" if value else \"NEVER\")\n            else:\n                self.set_multi_on_action(channel, \"DELAY\")\n                self.set_multi_on_delay(channel, value)\n                time.sleep(0.1)  # otherwise the power supply may not set the delay properly\n    self._write_and_check(\"OPALL 1\")\n</code></pre>"},{"location":"resources/aim-tti/mx_series/#msl.equipment_resources.aim_tti.mx_series.MXSeries.write","title":"write","text":"<pre><code>write(\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\"\n) -&gt; int\n</code></pre> <p>Write a message to the equipment.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes | str</code> <p>The message to write to the equipment.</p> required <code>data</code> <code>Sequence1D | None</code> <p>The data to append to <code>message</code>.</p> <code>None</code> <code>dtype</code> <code>MessageDataType</code> <p>The data type to use to convert each element in <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageDataType for more details.</p> <code>'&lt;f'</code> <code>fmt</code> <code>MessageFormat</code> <p>The format to use to convert <code>data</code> to bytes. Ignored if <code>data</code> is <code>None</code>. See MessageFormat for more details.</p> <code>'ieee'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of bytes written.</p> Source code in <code>src/msl/equipment/interfaces/message_based.py</code> <pre><code>def write(\n    self,\n    message: bytes | str,\n    *,\n    data: Sequence1D | None = None,\n    dtype: MessageDataType = \"&lt;f\",\n    fmt: MessageFormat = \"ieee\",\n) -&gt; int:\n    \"\"\"Write a message to the equipment.\n\n    Args:\n        message: The message to write to the equipment.\n        data: The data to append to `message`.\n        dtype: The data type to use to convert each element in `data` to bytes. Ignored\n            if `data` is `None`. See [MessageDataType][msl.equipment._types.MessageDataType]\n            for more details.\n        fmt: The format to use to convert `data` to bytes. Ignored if `data` is `None`.\n            See [MessageFormat][msl.equipment._types.MessageFormat] for more details.\n\n    Returns:\n        The number of bytes written.\n    \"\"\"\n    if not isinstance(message, bytes):\n        message = message.encode(encoding=self._encoding)\n\n    if data is not None:\n        message += to_bytes(data, fmt=fmt, dtype=dtype)\n\n    if self._write_termination and not message.endswith(self._write_termination):\n        message += self._write_termination\n\n    logger.debug(\"%s.write(%r)\", self, message)\n\n    try:\n        return self._write(message)\n    except (serial.SerialTimeoutException, socket.timeout, TimeoutError, USBTimeoutError):\n        raise MSLTimeoutError(self) from None\n    except Exception as e:  # noqa: BLE001\n        raise MSLConnectionError(self, str(e)) from None\n</code></pre>"},{"location":"resources/avantes/avaspec/","title":"AvaSpec SDK","text":"<p>Wrapper around the <code>avaspec</code> SDK from Avantes.</p> <p>The wrapper was written using v9.7.0.0 of the SDK. The <code>avaspec</code> SDK may require a Visual C++ Redistributable Package to be installed (on Windows).</p> <p>The main class is AvaSpec and the Enums and Structs are available once the <code>avantes</code> module is imported, for example,</p> <pre><code>from msl.equipment.resources import avantes\n\ncfg = avantes.MeasConfigType()\ncfg.m_IntegrationTime = 5  # in milliseconds\ncfg.m_NrAverages = 1  # number of averages\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec","title":"AvaSpec","text":"<pre><code>AvaSpec(equipment: Equipment)\n</code></pre> <p>               Bases: <code>SDK</code></p> <p>Wrapper around the <code>avaspec</code> SDK from Avantes.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for the AvaSpec wrapper.</p> <p>Connection Properties:</p> Name Type Description <code>port_id</code> <code>int</code> <p>One of <code>-1</code> (Ethernet+USB), <code>0</code> (USB) or <code>256</code> (Ethernet). Default: <code>-1</code></p> <code>activate</code> <code>bool</code> <p>Whether to automatically activate the connection. Default: <code>True</code></p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Wrapper around the `avaspec` SDK from Avantes.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for the AvaSpec wrapper.\n\n    Attributes: Connection Properties:\n        port_id (int): One of `-1` (Ethernet+USB), `0` (USB) or `256` (Ethernet). _Default: `-1`_\n        activate (bool): Whether to automatically activate the connection. _Default: `True`_\n    \"\"\"\n    self._handle: int | None = None\n    super().__init__(equipment, libtype=\"windll\" if IS_WINDOWS else \"cdll\")\n\n    functions: dict[\n        str, tuple[type[c_int32 | c_bool], Callable[..., int | None], list[tuple[str, type[_CDataType]]]]\n    ] = {\n        \"AVS_Init\": (c_int32, self._err_check, [(\"a_Port\", c_int16)]),\n        \"AVS_Done\": (c_int32, self._err_check, []),\n        \"AVS_GetNrOfDevices\": (c_int32, self._log_errcheck, []),\n        \"AVS_UpdateUSBDevices\": (c_int32, self._log_errcheck, []),\n        \"AVS_UpdateETHDevices\": (\n            c_int32,\n            self._err_check,\n            [\n                (\"a_ListSize\", c_uint32),\n                (\"a_pRequiredSize\", POINTER(c_uint32)),\n                (\"a_pList\", POINTER(BroadcastAnswerType)),\n            ],\n        ),\n        \"AVS_GetList\": (\n            c_int32,\n            self._err_check,\n            [\n                (\"a_ListSize\", c_uint32),\n                (\"a_pRequiredSize\", POINTER(c_uint32)),\n                (\"a_pList\", POINTER(AvsIdentityType)),\n            ],\n        ),\n        \"AVS_Activate\": (c_int32, self._err_check, [(\"a_pDeviceId\", POINTER(AvsIdentityType))]),\n        \"AVS_ActivateConn\": (c_int32, self._err_check, [(\"a_pDeviceId\", POINTER(AvsIdentityType))]),\n        \"AVS_ActivateConnCb\": (c_int32, self._err_check, [(\"a_pDeviceId\", POINTER(AvsIdentityType))]),\n        \"AVS_Deactivate\": (c_bool, self._check_bool, [(\"a_hDevice\", c_int32)]),\n        \"AVS_GetHandleFromSerial\": (c_int32, self._err_check, [(\"a_pSerial\", c_char_p)]),\n        \"AVS_GetStatusBySerial\": (\n            c_int32,\n            self._err_check,\n            [(\"a_pSerial\", c_char_p), (\"a_status\", POINTER(c_int32))],\n        ),\n        \"AVS_Register\": (c_bool, self._check_bool, [(\"a_Hwnd\", c_void_p)]),\n        \"AVS_Measure\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_hWnd\", c_void_p), (\"a_Nmsr\", c_int16)],\n        ),\n        \"AVS_MeasureCallback\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"__Done\", MeasureCallback), (\"a_Nmsr\", c_int16)],\n        ),\n        \"AVS_PrepareMeasure\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_pMeasConfig\", POINTER(MeasConfigType))],\n        ),\n        \"AVS_StopMeasure\": (c_int32, self._err_check, [(\"a_hDevice\", c_int32)]),\n        \"AVS_PollScan\": (c_int32, self._err_check, [(\"a_hDevice\", c_int32)]),\n        \"AVS_GetScopeData\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_pTimeLabel\", POINTER(c_uint32)), (\"a_pSpectrum\", POINTER(c_double))],\n        ),\n        \"AVS_GetSaturatedPixels\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_pSaturated\", POINTER(c_ubyte))],\n        ),\n        \"AVS_GetLambda\": (c_int32, self._err_check, [(\"a_hDevice\", c_int32), (\"a_pWaveLength\", POINTER(c_double))]),\n        \"AVS_GetNumPixels\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_pNumPixels\", POINTER(c_uint16))],\n        ),\n        \"AVS_GetParameter\": (\n            c_int32,\n            self._err_check,\n            [\n                (\"a_hDevice\", c_int32),\n                (\"a_Size\", c_uint32),\n                (\"a_pRequiredSize\", POINTER(c_uint32)),\n                (\"a_pDeviceParm\", POINTER(DeviceConfigType)),\n            ],\n        ),\n        \"AVS_SetParameter\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_pDeviceParm\", POINTER(DeviceConfigType))],\n        ),\n        \"AVS_GetVersionInfo\": (\n            c_int32,\n            self._err_check,\n            [\n                (\"a_hDevice\", c_int32),\n                (\"a_pFPGAVersion\", c_char_p),\n                (\"a_pFirmwareVersion\", c_char_p),\n                (\"a_pDLLVersion\", c_char_p),\n            ],\n        ),\n        \"AVS_GetDLLVersion\": (c_int32, self._err_check, [(\"a_pVersionString\", c_char_p)]),\n        \"AVS_SetSyncMode\": (c_int32, self._err_check, [(\"a_hDevice\", c_int32), (\"a_Enable\", c_ubyte)]),\n        \"AVS_SetPrescanMode\": (c_int32, self._err_check, [(\"a_hDevice\", c_int32), (\"a_Prescan\", c_bool)]),\n        \"AVS_UseHighResAdc\": (c_int32, self._err_check, [(\"a_hDevice\", c_int32), (\"a_Enable\", c_bool)]),\n        \"AVS_GetAnalogIn\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_AnalogInId\", c_ubyte), (\"a_pAnalogIn\", POINTER(c_float))],\n        ),\n        \"AVS_GetDigIn\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_DigInId\", c_ubyte), (\"a_pDigIn\", POINTER(c_ubyte))],\n        ),\n        \"AVS_SetAnalogOut\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_PortId\", c_ubyte), (\"a_Value\", c_float)],\n        ),\n        \"AVS_SetDigOut\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_PortId\", c_ubyte), (\"a_Status\", c_ubyte)],\n        ),\n        \"AVS_SetPwmOut\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_PortId\", c_ubyte), (\"a_Freq\", c_ulong), (\"a_Duty\", c_ubyte)],\n        ),\n        \"AVS_GetDarkPixelData\": (\n            c_int32,\n            self._check_bool,\n            [(\"a_hDevice\", c_int32), (\"a_pDarkData\", POINTER(c_double))],\n        ),\n        \"AVS_GetComPortName\": (\n            c_int32,\n            self._check_bool,\n            [(\"a_pDeviceId\", POINTER(AvsIdentityType)), (\"a_pIp\", c_char_p), (\"a_size\", POINTER(c_int32))],\n        ),\n        \"AVS_GetComType\": (\n            c_int32,\n            self._err_check,\n            [(\"a_pDeviceId\", POINTER(AvsIdentityType)), (\"a_type\", POINTER(c_int32))],\n        ),\n        \"AVS_SetSensitivityMode\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_SensitivityMode\", c_uint32)],\n        ),\n        \"AVS_GetIpConfig\": (\n            c_int32,\n            self._check_bool,\n            [(\"a_hDevice\", c_int32), (\"a_Data\", POINTER(EthernetSettingsType))],\n        ),\n        \"AVS_SuppressStrayLight\": (\n            c_int32,\n            self._err_check,\n            [\n                (\"a_hDevice\", c_int32),\n                (\"a_Multifactor\", c_float),\n                (\"a_pSrcSpectrum\", POINTER(c_double)),\n                (\"a_pDestSpectrum\", POINTER(c_double)),\n            ],\n        ),\n        \"AVS_Heartbeat\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_pHbReq\", POINTER(c_uint32)), (\"a_pHbResp\", POINTER(HeartbeatRespType))],\n        ),\n        \"AVS_ResetDevice\": (c_int32, self._err_check, [(\"a_hDevice\", c_int32)]),\n        \"AVS_GetOemParameter\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_pOemData\", POINTER(OemDataType))],\n        ),\n        \"AVS_SetOemParameter\": (\n            c_int32,\n            self._err_check,\n            [(\"a_hDevice\", c_int32), (\"a_pOemData\", POINTER(OemDataType))],\n        ),\n    }\n\n    for key, value in functions.items():\n        try:\n            attr = getattr(self.sdk, key)\n        except AttributeError as e:  # noqa: PERF203\n            logger.debug(\"%s: %s\", self.__class__.__name__, e)\n        else:\n            attr.restype, attr.errcheck = value[:2]\n            attr.argtypes = [typ for _, typ in value[2]]\n\n    assert equipment.connection  # noqa: S101\n    props = equipment.connection.properties\n    _ = self.init(props.get(\"port_id\", -1))\n    if props.get(\"activate\", True):\n        self.activate()\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.application","title":"application  <code>property</code>","text":"<pre><code>application: Application | None\n</code></pre> <p>Application | <code>None</code> \u2014 Reference to the ActiveX application window.</p> <p>If the loaded library is not an ActiveX library, returns <code>None</code>.</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.equipment","title":"equipment  <code>property</code>","text":"<pre><code>equipment: Equipment\n</code></pre> <p>The Equipment associated with the interface.</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>str \u2014 The path to the library file.</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.sdk","title":"sdk  <code>property</code>","text":"<pre><code>sdk: Any\n</code></pre> <p>lib \u2014 The reference to the SDK object.</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.activate","title":"activate","text":"<pre><code>activate() -&gt; None\n</code></pre> <p>Activates the spectrometer for communication.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def activate(self) -&gt; None:\n    \"\"\"Activates the spectrometer for communication.\"\"\"\n    out = AvaSpec.find(path=self.path)\n    if not out:\n        raise MSLConnectionError(self, \"Cannot activate. No devices found.\")\n\n    for item in out:\n        if item.SerialNumber.decode() == self.equipment.serial:\n            self._handle = int(self.sdk.AVS_Activate(item))\n            if self._handle == INVALID_AVS_HANDLE_VALUE:\n                raise MSLConnectionError(self, \"Invalid handle\")\n            _handles.append(self._handle)\n            return\n\n    msg = f\"Did not find the Avantes serial number {self.equipment.serial!r} in the list of devices.\"\n    raise MSLConnectionError(self, msg)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.deactivate","title":"deactivate","text":"<pre><code>deactivate() -&gt; None\n</code></pre> <p>Closes communication with the spectrometer.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def deactivate(self) -&gt; None:\n    \"\"\"Closes communication with the spectrometer.\"\"\"\n    if self._handle in _handles:\n        self.sdk.AVS_Deactivate(self._handle)\n        _handles.remove(self._handle)\n        self._handle = None\n        super().disconnect()\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Calls deactivate.</p> <p>Also calls done (if there are no additional connections open to other spectrometers).</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Calls [deactivate][msl.equipment_resources.avantes.avaspec.AvaSpec.deactivate].\n\n    Also calls [done][msl.equipment_resources.avantes.avaspec.AvaSpec.done] (if there\n    are no additional connections open to other spectrometers).\n    \"\"\"\n    self.deactivate()\n    if not _handles:\n        self.done()\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.done","title":"done","text":"<pre><code>done() -&gt; None\n</code></pre> <p>Closes communication with all spectrometers and releases internal storage.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def done(self) -&gt; None:\n    \"\"\"Closes communication with all spectrometers and releases internal storage.\"\"\"\n    if hasattr(self, \"_sdk\") and self._sdk is not None:\n        self.sdk.AVS_Done()\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.find","title":"find  <code>staticmethod</code>","text":"<pre><code>find(\n    path: str = \"avaspecx64\",\n    port_id: int = -1,\n    nmax: int = 16,\n) -&gt; list[AvsIdentityType]\n</code></pre> <p>Returns device information for each spectrometer that is connected.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the AvaSpec SDK.</p> <code>'avaspecx64'</code> <code>port_id</code> <code>int</code> <p>ID of port to be used. One of:</p> <ul> <li><code>-1</code>: Use both Ethernet (AS7010) and USB ports</li> <li><code>0</code>: Use USB port</li> <li><code>1..255</code>: Not supported in v9.7 of the SDK</li> <li><code>256</code>: Use Ethernet port (AS7010)</li> </ul> <code>-1</code> <code>nmax</code> <code>int</code> <p>The maximum number of devices that can be in the list.</p> <code>16</code> <p>Returns:</p> Type Description <code>list[AvsIdentityType]</code> <p>The information about the devices.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>@staticmethod\ndef find(path: str = \"avaspecx64\", port_id: int = -1, nmax: int = 16) -&gt; list[AvsIdentityType]:\n    \"\"\"Returns device information for each spectrometer that is connected.\n\n    Args:\n        path: The path to the AvaSpec SDK.\n        port_id: ID of port to be used. One of:\n\n            * `-1`: Use both Ethernet (AS7010) and USB ports\n            * `0`: Use USB port\n            * `1..255`: Not supported in v9.7 of the SDK\n            * `256`: Use Ethernet port (AS7010)\n\n        nmax: The maximum number of devices that can be in the list.\n\n    Returns:\n        The information about the devices.\n    \"\"\"\n    lib = LoadLibrary(path, libtype=\"windll\" if IS_WINDOWS else \"cdll\").lib\n\n    ret = lib.AVS_Init(port_id)\n    if ret == 0:\n        return []\n\n    size = nmax * sizeof(AvsIdentityType)\n    required_size = c_uint32()\n    types = (AvsIdentityType * nmax)()\n\n    lib.AVS_GetList.argtypes = [c_uint32, POINTER(c_uint32), POINTER(AvsIdentityType)]\n    n = lib.AVS_GetList(size, required_size, types)\n    if n &gt;= 0:\n        return [types[i] for i in range(n)]\n\n    error_name, msg = ERROR_CODES.get(n, (\"UNKNOWN_ERROR\", f\"Unknown error [code={n}]\"))\n    msg = f\"{error_name}: {msg}\"\n    raise RuntimeError(msg)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_analog_in","title":"get_analog_in","text":"<pre><code>get_analog_in(analog_id: int) -&gt; float\n</code></pre> <p>Get the status of the specified analog input.</p> <p>Parameters:</p> Name Type Description Default <code>analog_id</code> <code>int</code> <p>The identifier of the analog input to get.</p> <ul> <li> <p>AS5216:</p> <ul> <li>0 = thermistor on optical bench (NIR 2.0 / NIR2.2 / NIR 2.5 / TEC)</li> <li>1 = 1V2</li> <li>2 = 5VIO</li> <li>3 = 5VUSB</li> <li>4 = AI2 = pin 18 at 26-pin connector</li> <li>5 = AI1 = pin 9 at 26-pin connector</li> <li>6 = NTC1 onboard thermistor</li> <li>7 = Not used</li> </ul> </li> <li> <p>Mini:</p> <ul> <li>0 = NTC1 onboard thermistor</li> <li>1 = Not used</li> <li>2 = Not used</li> <li>3 = Not used</li> <li>4 = AI2 = pin 13 on micro HDMI = pin 11 on HDMI Terminal</li> <li>5 = AI1 = pin 16 on micro HDMI = pin 17 on HDMI Terminal</li> <li>6 = Not used</li> <li>7 = Not used</li> </ul> </li> <li> <p>AS7010:</p> <ul> <li>0 = thermistor on optical bench (NIR 2.0 / NIR2.2 / NIR 2.5 / TEC)</li> <li>1 = Not used</li> <li>2 = Not used</li> <li>3 = Not used</li> <li>4 = AI2 = pin 18 at 26-pin connector</li> <li>5 = AI1 = pin 9 at 26-pin connector</li> <li>6 = digital temperature sensor, returns degrees Celsius, not Volts</li> <li>7 = Not used</li> </ul> </li> </ul> required <p>Returns:</p> Type Description <code>float</code> <p>The analog input value [Volts or degrees Celsius].</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_analog_in(self, analog_id: int) -&gt; float:\n    \"\"\"Get the status of the specified analog input.\n\n    Args:\n        analog_id: The identifier of the analog input to get.\n\n            * AS5216:\n\n                * 0 = thermistor on optical bench (NIR 2.0 / NIR2.2 / NIR 2.5 / TEC)\n                * 1 = 1V2\n                * 2 = 5VIO\n                * 3 = 5VUSB\n                * 4 = AI2 = pin 18 at 26-pin connector\n                * 5 = AI1 = pin 9 at 26-pin connector\n                * 6 = NTC1 onboard thermistor\n                * 7 = Not used\n\n            * Mini:\n\n                * 0 = NTC1 onboard thermistor\n                * 1 = Not used\n                * 2 = Not used\n                * 3 = Not used\n                * 4 = AI2 = pin 13 on micro HDMI = pin 11 on HDMI Terminal\n                * 5 = AI1 = pin 16 on micro HDMI = pin 17 on HDMI Terminal\n                * 6 = Not used\n                * 7 = Not used\n\n            * AS7010:\n\n                * 0 = thermistor on optical bench (NIR 2.0 / NIR2.2 / NIR 2.5 / TEC)\n                * 1 = Not used\n                * 2 = Not used\n                * 3 = Not used\n                * 4 = AI2 = pin 18 at 26-pin connector\n                * 5 = AI1 = pin 9 at 26-pin connector\n                * 6 = digital temperature sensor, returns degrees Celsius, not Volts\n                * 7 = Not used\n\n    Returns:\n        The analog input value [Volts or degrees Celsius].\n    \"\"\"\n    ain = c_float()\n    self.sdk.AVS_GetAnalogIn(self._handle, analog_id, ain)\n    return ain.value\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_com_port_name","title":"get_com_port_name","text":"<pre><code>get_com_port_name() -&gt; str\n</code></pre> <p>Get the IP address of the device.</p> <p>Returns:</p> Type Description <code>str</code> <p>The IP address of the device.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_com_port_name(self) -&gt; str:\n    \"\"\"Get the IP address of the device.\n\n    Returns:\n        The IP address of the device.\n    \"\"\"\n    device_id = AvsIdentityType()\n    device_id.SerialNumber = self.equipment.serial.encode()\n    name = create_string_buffer(255)\n    self.sdk.AVS_GetComPortName(device_id, name, len(name))\n    return name.value.decode()\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_com_type","title":"get_com_type","text":"<pre><code>get_com_type() -&gt; int\n</code></pre> <p>Get the communication protocol.</p> <p>Returns:</p> Type Description <code>int</code> <p>The communication type as defined below: * 0 = RS232 * 1 = USB5216 * 2 = USBMINI * 3 = USB7010 * 4 = ETH7010 * -1 = UNKNOWN</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_com_type(self) -&gt; int:\n    \"\"\"Get the communication protocol.\n\n    Returns:\n        The communication type as defined below:\n            * 0 = RS232\n            * 1 = USB5216\n            * 2 = USBMINI\n            * 3 = USB7010\n            * 4 = ETH7010\n            * -1 = UNKNOWN\n    \"\"\"\n    device_id = AvsIdentityType()\n    device_id.SerialNumber = self.equipment.serial.encode()\n    typ = c_int32(-1)\n    self.sdk.AVS_GetComType(device_id, typ)\n    return typ.value\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_dark_pixel_data","title":"get_dark_pixel_data","text":"<pre><code>get_dark_pixel_data() -&gt; NDArray[double]\n</code></pre> <p>Get the optically black pixel values of the last performed measurement.</p> <p>You must call get_data before you call this method.</p> <p>Returns:</p> Type Description <code>NDArray[double]</code> <p>The dark pixels.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_dark_pixel_data(self) -&gt; NDArray[np.double]:\n    \"\"\"Get the optically black pixel values of the last performed measurement.\n\n    You must call [get_data][msl.equipment_resources.avantes.avaspec.AvaSpec.get_data] before you call this method.\n\n    Returns:\n        The dark pixels.\n    \"\"\"\n    # from the docs the maximum size is size=18 for the AvaSpec-2048-USB2 and AvaSpec-2048L-USB2\n    values = np.zeros(32, dtype=np.double)  # make it bigger than 18\n    self.sdk.AVS_GetDarkPixelData(self._handle, values.ctypes.data_as(POINTER(c_double)))\n    return values[values &gt; 0]\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_data","title":"get_data","text":"<pre><code>get_data() -&gt; tuple[int, NDArray[double]]\n</code></pre> <p>Returns the timestamp and the spectral data of the last measurement.</p> <p>Returns:</p> Type Description <code>tuple[int, NDArray[double]]</code> <p>The timestamp and the spectral data.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_data(self) -&gt; tuple[int, NDArray[np.double]]:\n    \"\"\"Returns the timestamp and the spectral data of the last measurement.\n\n    Returns:\n        The timestamp and the spectral data.\n    \"\"\"\n    ticks = c_uint32()\n    values = np.ones(MAX_NR_PIXELS, dtype=np.double) * -1.0\n    self.sdk.AVS_GetScopeData(self._handle, ticks, values.ctypes.data_as(POINTER(c_double)))\n    return ticks.value, values[values &gt; -1.0]\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_digital_in","title":"get_digital_in","text":"<pre><code>get_digital_in(digital_id: int) -&gt; int\n</code></pre> <p>Get the status of the specified digital input.</p> <p>Parameters:</p> Name Type Description Default <code>digital_id</code> <code>int</code> <p>The identifier of the digital input to get.</p> <ul> <li> <p>AS5216:</p> <ul> <li><code>0</code>: DI1 = Pin 24 at 26-pin connector</li> <li><code>1</code>: DI2 = Pin 7 at 26-pin connector</li> <li><code>2</code>: DI3 = Pin 16 at 26-pin connector</li> </ul> </li> <li> <p>Mini:</p> <ul> <li><code>0</code>: DI1 = Pin 7 on Micro HDMI = Pin 5 on HDMI terminal</li> <li><code>1</code>: DI2 = Pin 5 on Micro HDMI = Pin 3 on HDMI Terminal</li> <li><code>2</code>: DI3 = Pin 3 on Micro HDMI = Pin 1 on HDMI Terminal</li> <li><code>3</code>: DI4 = Pin 1 on Micro HDMI = Pin 19 on HDMI Terminal</li> <li><code>4</code>: DI5 = Pin 4 on Micro HDMI = Pin 2 on HDMI Terminal</li> <li><code>5</code>: DI6 = Pin 2 on Micro HDMI = Pin 14 on HDMI Terminal</li> </ul> </li> <li> <p>AS7010:</p> <ul> <li><code>0</code>: DI1 = Pin 24 at 26-pin connector</li> <li><code>1</code>: DI2 = Pin 7 at 26-pin connector</li> <li><code>2</code>: DI3 = Pin 16 at 26-pin</li> </ul> </li> </ul> required <p>Returns:</p> Type Description <code>int</code> <p>The digital input value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_digital_in(self, digital_id: int) -&gt; int:\n    \"\"\"Get the status of the specified digital input.\n\n    Args:\n        digital_id: The identifier of the digital input to get.\n\n            * AS5216:\n\n                * `0`: DI1 = Pin 24 at 26-pin connector\n                * `1`: DI2 = Pin 7 at 26-pin connector\n                * `2`: DI3 = Pin 16 at 26-pin connector\n\n            * Mini:\n\n                * `0`: DI1 = Pin 7 on Micro HDMI = Pin 5 on HDMI terminal\n                * `1`: DI2 = Pin 5 on Micro HDMI = Pin 3 on HDMI Terminal\n                * `2`: DI3 = Pin 3 on Micro HDMI = Pin 1 on HDMI Terminal\n                * `3`: DI4 = Pin 1 on Micro HDMI = Pin 19 on HDMI Terminal\n                * `4`: DI5 = Pin 4 on Micro HDMI = Pin 2 on HDMI Terminal\n                * `5`: DI6 = Pin 2 on Micro HDMI = Pin 14 on HDMI Terminal\n\n            * AS7010:\n\n                * `0`: DI1 = Pin 24 at 26-pin connector\n                * `1`: DI2 = Pin 7 at 26-pin connector\n                * `2`: DI3 = Pin 16 at 26-pin\n\n    Returns:\n        The digital input value.\n    \"\"\"\n    din = c_ubyte()\n    self.sdk.AVS_GetDigIn(self._handle, digital_id, din)\n    return din.value\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_dll_version","title":"get_dll_version","text":"<pre><code>get_dll_version() -&gt; str\n</code></pre> <p>Get the DLL version number.</p> <p>Returns:</p> Type Description <code>str</code> <p>The DLL version number</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_dll_version(self) -&gt; str:\n    \"\"\"Get the DLL version number.\n\n    Returns:\n        The DLL version number\n    \"\"\"\n    version = create_string_buffer(255)\n    self.sdk.AVS_GetDLLVersion(version)\n    return version.value.decode()\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_handle_from_serial","title":"get_handle_from_serial","text":"<pre><code>get_handle_from_serial(serial: str | None = None) -&gt; int\n</code></pre> <p>Get the handle ID for the specified serial number.</p> <p>Parameters:</p> Name Type Description Default <code>serial</code> <code>str | None</code> <p>The serial number. Default is to get the handle for this class instance.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The handle.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_handle_from_serial(self, serial: str | None = None) -&gt; int:\n    \"\"\"Get the handle ID for the specified serial number.\n\n    Args:\n        serial: The serial number. Default is to get the handle for this class instance.\n\n    Returns:\n        The handle.\n    \"\"\"\n    serial = serial or self.equipment.serial\n    return int(self.sdk.AVS_GetHandleFromSerial(serial.encode()))\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_ip_config","title":"get_ip_config","text":"<pre><code>get_ip_config() -&gt; EthernetSettingsType\n</code></pre> <p>Retrieve IP settings from the spectrometer.</p> <p>Use this function to read the Ethernet settings of the spectrometer, without having to read the complete device configuration structure.</p> <p>Returns:</p> Type Description <code>EthernetSettingsType</code> <p>The Ethernet settings of the spectrometer.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_ip_config(self) -&gt; EthernetSettingsType:\n    \"\"\"Retrieve IP settings from the spectrometer.\n\n    Use this function to read the Ethernet settings of the spectrometer, without\n    having to read the complete device configuration structure.\n\n    Returns:\n        The Ethernet settings of the spectrometer.\n    \"\"\"\n    eth = EthernetSettingsType()\n    self.sdk.AVS_GetIpConfig(self._handle, eth)\n    return eth\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_lambda","title":"get_lambda","text":"<pre><code>get_lambda() -&gt; NDArray[double]\n</code></pre> <p>Returns the wavelength values corresponding to the pixels if available.</p> <p>Returns:</p> Type Description <code>NDArray[double]</code> <p>The wavelength value of each pixel.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_lambda(self) -&gt; NDArray[np.double]:\n    \"\"\"Returns the wavelength values corresponding to the pixels if available.\n\n    Returns:\n        The wavelength value of each pixel.\n    \"\"\"\n    values = np.zeros(MAX_NR_PIXELS, dtype=np.double)\n    self.sdk.AVS_GetLambda(self._handle, values.ctypes.data_as(POINTER(c_double)))\n    return values[values &gt; 0]\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_num_devices","title":"get_num_devices","text":"<pre><code>get_num_devices() -&gt; int\n</code></pre> <p>Scans for attached devices and returns the number of devices detected.</p> <p>Deprecated function, replaced by :meth:<code>.update_usb_devices</code>. The functionality is identical.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of devices found.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_num_devices(self) -&gt; int:\n    \"\"\"Scans for attached devices and returns the number of devices detected.\n\n    Deprecated function, replaced by :meth:`.update_usb_devices`. The\n    functionality is identical.\n\n    Returns:\n        The number of devices found.\n    \"\"\"\n    num: int = self.sdk.AVS_GetNrOfDevices()\n    return num\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_num_pixels","title":"get_num_pixels","text":"<pre><code>get_num_pixels() -&gt; int\n</code></pre> <p>Returns the number of pixels of a spectrometer.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_num_pixels(self) -&gt; int:\n    \"\"\"Returns the number of pixels of a spectrometer.\"\"\"\n    n = c_uint16()\n    self.sdk.AVS_GetNumPixels(self._handle, n)\n    return n.value\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_oem_parameter","title":"get_oem_parameter","text":"<pre><code>get_oem_parameter() -&gt; OemDataType\n</code></pre> <p>Returns the OEM data structure available on the spectrometer.</p> <p>Returns:</p> Type Description <code>OemDataType</code> <p>The OEM parameters.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_oem_parameter(self) -&gt; OemDataType:\n    \"\"\"Returns the OEM data structure available on the spectrometer.\n\n    Returns:\n        The OEM parameters.\n    \"\"\"\n    odt = OemDataType()\n    self.sdk.AVS_GetOemParameter(self._handle, odt)\n    return odt\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_parameter","title":"get_parameter","text":"<pre><code>get_parameter() -&gt; DeviceConfigType\n</code></pre> <p>Returns the device information of the spectrometer.</p> <p>Returns:</p> Type Description <code>DeviceConfigType</code> <p>The device parameters.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_parameter(self) -&gt; DeviceConfigType:\n    \"\"\"Returns the device information of the spectrometer.\n\n    Returns:\n        The device parameters.\n    \"\"\"\n    dct = DeviceConfigType()\n    required_size = c_uint32()\n    self.sdk.AVS_GetParameter(self._handle, sizeof(dct), required_size, dct)\n    return dct\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_saturated_pixels","title":"get_saturated_pixels","text":"<pre><code>get_saturated_pixels() -&gt; NDArray[uint8]\n</code></pre> <p>Returns, for each pixel, if a pixel was saturated (1) or not (0).</p> <p>Returns:</p> Type Description <code>NDArray[uint8]</code> <p>The saturation state of each pixel.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_saturated_pixels(self) -&gt; NDArray[np.uint8]:\n    \"\"\"Returns, for each pixel, if a pixel was saturated (1) or not (0).\n\n    Returns:\n        The saturation state of each pixel.\n    \"\"\"\n    n = 9\n    values = np.full(MAX_NR_PIXELS, n, dtype=np.uint8)\n    self.sdk.AVS_GetSaturatedPixels(self._handle, values.ctypes.data_as(POINTER(c_ubyte)))\n    return values[values &lt; n]\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_status_by_serial","title":"get_status_by_serial","text":"<pre><code>get_status_by_serial(serial: str | None = None) -&gt; int\n</code></pre> <p>Get the handle ID for the specified serial number.</p> <p>Parameters:</p> Name Type Description Default <code>serial</code> <code>str | None</code> <p>The serial number. Default is to get the status for this class instance.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The status.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_status_by_serial(self, serial: str | None = None) -&gt; int:\n    \"\"\"Get the handle ID for the specified serial number.\n\n    Args:\n        serial: The serial number. Default is to get the status for this class instance.\n\n    Returns:\n        The status.\n    \"\"\"\n    serial = serial or self.equipment.serial\n    status = c_int32()\n    self.sdk.AVS_GetStatusBySerial(serial.encode(), status)\n    return status.value\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.get_version_info","title":"get_version_info","text":"<pre><code>get_version_info() -&gt; tuple[str, str, str]\n</code></pre> <p>Returns software version information.</p> <p>Returns:</p> Type Description <code>tuple[str, str, str]</code> <p>FPGA software version, firmware version, DLL version.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def get_version_info(self) -&gt; tuple[str, str, str]:\n    \"\"\"Returns software version information.\n\n    Returns:\n        FPGA software version, firmware version, DLL version.\n    \"\"\"\n    fpga = create_string_buffer(16)\n    fm = create_string_buffer(16)\n    dll = create_string_buffer(16)\n    self.sdk.AVS_GetVersionInfo(self._handle, fpga, fm, dll)\n    return fpga.value.decode(), fm.value.decode(), dll.value.decode()\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.heartbeat","title":"heartbeat","text":"<pre><code>heartbeat(req_type: int) -&gt; HeartbeatRespType\n</code></pre> <p>Monitor the (heartbeat) functions of the spectrometer.</p> <p>This function applies only to the AS7010 platform. See the DLL manual for more details.</p> <p>Parameters:</p> Name Type Description Default <code>req_type</code> <code>int</code> <p>The heartbeat request values used to control heartbeat functions.</p> required <p>Returns:</p> Type Description <code>HeartbeatRespType</code> <p>The heartbeat response structure received from the spectrometer.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def heartbeat(self, req_type: int) -&gt; HeartbeatRespType:\n    \"\"\"Monitor the (heartbeat) functions of the spectrometer.\n\n    This function applies only to the AS7010 platform. See the DLL manual for more details.\n\n    Args:\n        req_type: The heartbeat request values used to control heartbeat functions.\n\n    Returns:\n        The heartbeat response structure received from the spectrometer.\n    \"\"\"\n    resp = HeartbeatRespType()\n    self.sdk.AVS_Heartbeat(self._handle, req_type, resp)\n    return resp\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.init","title":"init","text":"<pre><code>init(port_id: int) -&gt; int\n</code></pre> <p>Initializes the communication interface with the spectrometers and the internal data structures.</p> <p>For Ethernet devices this function will create a list of available Ethernet spectrometers within all the network interfaces of the host.</p> <p>Parameters:</p> Name Type Description Default <code>port_id</code> <code>int</code> <p>ID of port to be used. One of:</p> <ul> <li><code>-1</code>: Use both Ethernet (AS7010) and USB ports</li> <li><code>0</code>: Use USB port</li> <li><code>1..255</code>: Not supported in v9.7 of the SDK</li> <li><code>256</code>: Use Ethernet port (AS7010)</li> </ul> required <p>Returns:</p> Type Description <code>int</code> <p>On success, the number of connected or found devices.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def init(self, port_id: int) -&gt; int:\n    \"\"\"Initializes the communication interface with the spectrometers and the internal data structures.\n\n    For Ethernet devices this function will create a list of available Ethernet spectrometers\n    within all the network interfaces of the host.\n\n    Args:\n        port_id: ID of port to be used. One of:\n\n            * `-1`: Use both Ethernet (AS7010) and USB ports\n            * `0`: Use USB port\n            * `1..255`: Not supported in v9.7 of the SDK\n            * `256`: Use Ethernet port (AS7010)\n\n    Returns:\n        On success, the number of connected or found devices.\n    \"\"\"\n    ret = int(self.sdk.AVS_Init(port_id))\n    if ret == 0:\n        raise MSLConnectionError(self, \"No Avantes devices were found\")\n    return ret\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.measure","title":"measure","text":"<pre><code>measure(\n    num_measurements: int, window_handle: int | None = None\n) -&gt; None\n</code></pre> <p>Starts measurement on the spectrometer.</p> <p>Parameters:</p> Name Type Description Default <code>num_measurements</code> <code>int</code> <p>Number of measurements to acquire. Use -1 to measure continuously until stop_measure is called.</p> required <code>window_handle</code> <code>int | None</code> <p>Window handle to notify application measurement result data is available. The DLL sends a message to the window with command: <code>WM_MEAS_READY</code>, with <code>SUCCESS</code> (<code>0</code>), the number of scans that were saved in RAM (if <code>m_StoreToRAM</code> parameter &gt; 0, see ControlSettingsType), or <code>INVALID_MEAS_DATA</code> as <code>WPARM</code> value and <code>a_hDevice</code> as <code>LPARM</code> value. Set this value to <code>None</code> if a callback is not needed.</p> <code>None</code> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def measure(self, num_measurements: int, window_handle: int | None = None) -&gt; None:\n    \"\"\"Starts measurement on the spectrometer.\n\n    Args:\n        num_measurements: Number of measurements to acquire. Use -1 to measure continuously until\n            [stop_measure][msl.equipment_resources.avantes.avaspec.AvaSpec.stop_measure] is called.\n        window_handle: Window handle to notify application measurement result data is available.\n            The DLL sends a message to the window with command: `WM_MEAS_READY`, with `SUCCESS` (`0`),\n            the number of scans that were saved in RAM (if `m_StoreToRAM` parameter &gt; 0, see\n            [ControlSettingsType][msl.equipment_resources.avantes.avaspec.ControlSettingsType]),\n            or `INVALID_MEAS_DATA` as `WPARM` value and `a_hDevice` as `LPARM` value. Set this\n            value to `None` if a callback is not needed.\n    \"\"\"\n    self.sdk.AVS_Measure(self._handle, window_handle, num_measurements)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.measure_callback","title":"measure_callback","text":"<pre><code>measure_callback(\n    num_measurements: int,\n    callback: AvaSpecCallback | None = None,\n) -&gt; None\n</code></pre> <p>Register a measurement-available callback function for the spectrometer.</p> <p>Example</p> <p>See avaspec_callback.py for an example usage.</p> <p>Parameters:</p> Name Type Description Default <code>num_measurements</code> <code>int</code> <p>Number of measurements to acquire. Use -1 to measure continuously until stop_measure is called.</p> required <code>callback</code> <code>AvaSpecCallback | None</code> <p>A callback function to notify that application measurement result data is available. The DLL will call the given function to notify a measurement is ready and pass two parameters. The first parameter is a reference to the DLL handle. The second parameter is a reference to an integer value: <code>SUCCESS</code> (<code>0</code>) if a new scan is available, or the number of scans that were saved in RAM (if <code>m_StoreToRAM</code> parameter &gt; 0, see ControlSettingsType), or <code>INVALID_MEAS_DATA</code> (<code>-8</code>). Set this value to <code>None</code> if a callback is not needed.</p> <code>None</code> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def measure_callback(self, num_measurements: int, callback: AvaSpecCallback | None = None) -&gt; None:\n    \"\"\"Register a measurement-available callback function for the spectrometer.\n\n    !!! example\n        See [avaspec_callback.py](https://github.com/MSLNZ/msl-equipment/blob/main/packages/resources/examples/avantes/avaspec_callback.py)\n        for an example usage.\n\n    Args:\n        num_measurements: Number of measurements to acquire. Use -1 to measure continuously until\n            [stop_measure][msl.equipment_resources.avantes.avaspec.AvaSpec.stop_measure] is called.\n        callback: A callback function to notify that application measurement result data is available.\n            The DLL will call the given function to notify a measurement is ready and pass two parameters.\n            The first parameter is a reference to the DLL handle. The second parameter is a reference to\n            an integer value: `SUCCESS` (`0`) if a new scan is available, or the number of scans that were\n            saved in RAM (if `m_StoreToRAM` parameter &gt; 0, see\n            [ControlSettingsType][msl.equipment_resources.avantes.avaspec.ControlSettingsType]),\n            or `INVALID_MEAS_DATA` (`-8`). Set this value to `None` if a callback is not needed.\n    \"\"\"\n    self.sdk.AVS_MeasureCallback(self._handle, callback, num_measurements)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.poll_scan","title":"poll_scan","text":"<pre><code>poll_scan() -&gt; bool\n</code></pre> <p>Determines if new measurement results are available.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether there is a scan available.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def poll_scan(self) -&gt; bool:\n    \"\"\"Determines if new measurement results are available.\n\n    Returns:\n        Whether there is a scan available.\n    \"\"\"\n    return bool(self.sdk.AVS_PollScan(self._handle))\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.prepare_measure","title":"prepare_measure","text":"<pre><code>prepare_measure(config: MeasConfigType) -&gt; None\n</code></pre> <p>Prepares measurement on the spectrometer using the specified measurement configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>MeasConfigType</code> <p>The measurement configuration.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def prepare_measure(self, config: MeasConfigType) -&gt; None:\n    \"\"\"Prepares measurement on the spectrometer using the specified measurement configuration.\n\n    Args:\n        config: The measurement configuration.\n    \"\"\"\n    self.sdk.AVS_PrepareMeasure(self._handle, config)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.register","title":"register","text":"<pre><code>register(handle: int) -&gt; None\n</code></pre> <p>Installs an application windows handle to which device attachment/removal messages have to be sent.</p> <p>Parameters:</p> Name Type Description Default <code>handle</code> <code>int</code> <p>Application window handle.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def register(self, handle: int) -&gt; None:\n    \"\"\"Installs an application windows handle to which device attachment/removal messages have to be sent.\n\n    Args:\n        handle: Application window handle.\n    \"\"\"\n    self.sdk.AVS_Register(handle)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.reset_device","title":"reset_device","text":"<pre><code>reset_device() -&gt; None\n</code></pre> <p>Performs a hard reset on the given spectrometer.</p> <p>This function only works with the AS7010 platform.</p> <p>During reset of the spectrometer, all spectrometer HW modules (microprocessor and USB controller) will be reset at once. The spectrometer will start its reset procedure right after sending the command response back to the host.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def reset_device(self) -&gt; None:\n    \"\"\"Performs a hard reset on the given spectrometer.\n\n    This function only works with the AS7010 platform.\n\n    During reset of the spectrometer, all spectrometer HW modules (microprocessor and USB controller)\n    will be reset at once. The spectrometer will start its reset procedure right after sending the\n    command response back to the host.\n    \"\"\"\n    self.sdk.AVS_ResetDevice(self._handle)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.set_analog_out","title":"set_analog_out","text":"<pre><code>set_analog_out(port_id: int, value: float) -&gt; None\n</code></pre> <p>Sets the analog output value for the specified analog identifier.</p> <p>Parameters:</p> Name Type Description Default <code>port_id</code> <code>int</code> <p>Identifier for one of the two output signals:</p> <ul> <li> <p>AS5216:</p> <ul> <li><code>0</code>: AO1 = pin 17 at 26-pin connector</li> <li><code>1</code>: AO2 = pin 26 at 26-pin connector</li> </ul> </li> <li> <p>Mini:</p> <ul> <li><code>0</code>: AO1 = Pin 12 on Micro HDMI = Pin 10 on HDMI terminal</li> <li><code>1</code>: AO2 = Pin 14 on Micro HDMI = Pin 12 on HDMI terminal</li> </ul> </li> <li> <p>AS7010:</p> <ul> <li><code>0</code>: AO1 = pin 17 at 26-pin connector</li> <li><code>1</code>: AO2 = pin 26 at 26-pin connector</li> </ul> </li> </ul> required <code>value</code> <code>float</code> <p>DAC value to be set in Volts (internally an 8-bits DAC is used) with range 0 - 5V.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def set_analog_out(self, port_id: int, value: float) -&gt; None:\n    \"\"\"Sets the analog output value for the specified analog identifier.\n\n    Args:\n        port_id: Identifier for one of the two output signals:\n\n            * AS5216:\n\n                * `0`: AO1 = pin 17 at 26-pin connector\n                * `1`: AO2 = pin 26 at 26-pin connector\n\n            * Mini:\n\n                * `0`: AO1 = Pin 12 on Micro HDMI = Pin 10 on HDMI terminal\n                * `1`: AO2 = Pin 14 on Micro HDMI = Pin 12 on HDMI terminal\n\n            * AS7010:\n\n                * `0`: AO1 = pin 17 at 26-pin connector\n                * `1`: AO2 = pin 26 at 26-pin connector\n\n        value: DAC value to be set in Volts (internally an 8-bits DAC is used) with range 0 - 5V.\n    \"\"\"\n    self.sdk.AVS_SetAnalogOut(self._handle, port_id, value)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.set_digital_out","title":"set_digital_out","text":"<pre><code>set_digital_out(port_id: int, value: int) -&gt; None\n</code></pre> <p>Sets the digital output value for the specified digital identifier.</p> <p>Parameters:</p> Name Type Description Default <code>port_id</code> <code>int</code> <p>Identifier for one of the 10 output signals:</p> <ul> <li> <p>AS5216:</p> <ul> <li><code>0</code>: DO1 = pin 11 at 26-pin connector</li> <li><code>1</code>: DO2 = pin 2 at 26-pin connector</li> <li><code>2</code>: DO3 = pin 20 at 26-pin connector</li> <li><code>3</code>: DO4 = pin 12 at 26-pin connector</li> <li><code>4</code>: DO5 = pin 3 at 26-pin connector</li> <li><code>5</code>: DO6 = pin 21 at 26-pin connector</li> <li><code>6</code>: DO7 = pin 13 at 26-pin connector</li> <li><code>7</code>: DO8 = pin 4 at 26-pin connector</li> <li><code>8</code>: DO9 = pin 22 at 26-pin connector</li> <li><code>9</code>: DO10 = pin 25 at 26-pin connector</li> </ul> </li> <li> <p>Mini:</p> <ul> <li><code>0</code>: DO1 = Pin 7 on Micro HDMI = Pin 5 on HDMI terminal</li> <li><code>1</code>: DO2 = Pin 5 on Micro HDMI = Pin 3 on HDMI Terminal</li> <li><code>2</code>: DO3 = Pin 3 on Micro HDMI = Pin 1 on HDMI Terminal</li> <li><code>3</code>: DO4 = Pin 1 on Micro HDMI = Pin 19 on HDMI Terminal</li> <li><code>4</code>: DO5 = Pin 4 on Micro HDMI = Pin 2 on HDMI Terminal</li> <li><code>5</code>: DO6 = Pin 2 on Micro HDMI = Pin 14 on HDMI Terminal</li> <li><code>6</code>: Not used</li> <li><code>7</code>: Not used</li> <li><code>8</code>: Not used</li> <li><code>9</code>: Not used</li> </ul> </li> <li> <p>AS7010:</p> <ul> <li><code>0</code>: DO1 =pin 11 at 26-pin connector</li> <li><code>1</code>: DO2 = pin 2 at 26-pin connector</li> <li><code>2</code>: DO3 = pin 20 at 26-pin connector</li> <li><code>3</code>: DO4 = pin 12 at 26-pin connector</li> <li><code>4</code>: DO5 = pin 3 at 26-pin connector</li> <li><code>5</code>: DO6 = pin 21 at 26-pin connector</li> <li><code>6</code>: DO7 = pin 13 at 26-pin connector</li> <li><code>7</code>: DO8 = pin 4 at 26-pin connector</li> <li><code>8</code>: DO9 = pin 22 at 26-pin connector</li> <li><code>9</code>: DO10 = pin 25 at 26-pin connector</li> </ul> </li> </ul> required <code>value</code> <code>int</code> <p>The digital value to be set (0 or 1).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def set_digital_out(self, port_id: int, value: int) -&gt; None:\n    \"\"\"Sets the digital output value for the specified digital identifier.\n\n    Args:\n        port_id: Identifier for one of the 10 output signals:\n\n            * AS5216:\n\n                * `0`: DO1 = pin 11 at 26-pin connector\n                * `1`: DO2 = pin 2 at 26-pin connector\n                * `2`: DO3 = pin 20 at 26-pin connector\n                * `3`: DO4 = pin 12 at 26-pin connector\n                * `4`: DO5 = pin 3 at 26-pin connector\n                * `5`: DO6 = pin 21 at 26-pin connector\n                * `6`: DO7 = pin 13 at 26-pin connector\n                * `7`: DO8 = pin 4 at 26-pin connector\n                * `8`: DO9 = pin 22 at 26-pin connector\n                * `9`: DO10 = pin 25 at 26-pin connector\n\n            * Mini:\n\n                * `0`: DO1 = Pin 7 on Micro HDMI = Pin 5 on HDMI terminal\n                * `1`: DO2 = Pin 5 on Micro HDMI = Pin 3 on HDMI Terminal\n                * `2`: DO3 = Pin 3 on Micro HDMI = Pin 1 on HDMI Terminal\n                * `3`: DO4 = Pin 1 on Micro HDMI = Pin 19 on HDMI Terminal\n                * `4`: DO5 = Pin 4 on Micro HDMI = Pin 2 on HDMI Terminal\n                * `5`: DO6 = Pin 2 on Micro HDMI = Pin 14 on HDMI Terminal\n                * `6`: Not used\n                * `7`: Not used\n                * `8`: Not used\n                * `9`: Not used\n\n            * AS7010:\n\n                * `0`: DO1 =pin 11 at 26-pin connector\n                * `1`: DO2 = pin 2 at 26-pin connector\n                * `2`: DO3 = pin 20 at 26-pin connector\n                * `3`: DO4 = pin 12 at 26-pin connector\n                * `4`: DO5 = pin 3 at 26-pin connector\n                * `5`: DO6 = pin 21 at 26-pin connector\n                * `6`: DO7 = pin 13 at 26-pin connector\n                * `7`: DO8 = pin 4 at 26-pin connector\n                * `8`: DO9 = pin 22 at 26-pin connector\n                * `9`: DO10 = pin 25 at 26-pin connector\n\n        value: The digital value to be set (0 or 1).\n    \"\"\"\n    self.sdk.AVS_SetDigOut(self._handle, port_id, value)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.set_oem_parameter","title":"set_oem_parameter","text":"<pre><code>set_oem_parameter(parameter: OemDataType) -&gt; None\n</code></pre> <p>Sends the OEM data structure to the spectrometer.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>OemDataType</code> <p>The OEM data structure.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def set_oem_parameter(self, parameter: OemDataType) -&gt; None:\n    \"\"\"Sends the OEM data structure to the spectrometer.\n\n    Args:\n        parameter: The OEM data structure.\n    \"\"\"\n    self.sdk.AVS_SetOemParameter(self._handle, parameter)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.set_parameter","title":"set_parameter","text":"<pre><code>set_parameter(parameter: DeviceConfigType) -&gt; None\n</code></pre> <p>Overwrites the device configuration.</p> <p>Please note that OemDataType is part of the DeviceConfigType in EEPROM (see section 3.5 of DLL manual). Precautions must be taken to prevent OEM data overwrites when using this method together with set_oem_parameter.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>DeviceConfigType</code> <p>The device parameters.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def set_parameter(self, parameter: DeviceConfigType) -&gt; None:\n    \"\"\"Overwrites the device configuration.\n\n    Please note that [OemDataType][msl.equipment_resources.avantes.avaspec.OemDataType] is part\n    of the [DeviceConfigType][msl.equipment_resources.avantes.avaspec.DeviceConfigType] in EEPROM\n    (see section 3.5 of DLL manual). Precautions must be taken to prevent OEM data overwrites\n    when using this method together with\n    [set_oem_parameter][msl.equipment_resources.avantes.avaspec.AvaSpec.set_oem_parameter].\n\n    Args:\n        parameter: The device parameters.\n    \"\"\"\n    self.sdk.AVS_SetParameter(self._handle, parameter)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.set_prescan_mode","title":"set_prescan_mode","text":"<pre><code>set_prescan_mode(mode: bool) -&gt; None\n</code></pre> <p>If a prescan is set, the first measurement result will be skipped.</p> <p>This function is only useful for the AvaSpec-3648 because this detector can be operated in prescan mode, or clear-buffer mode (see DLL manual).</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>bool</code> <p>If <code>True</code>, the first measurement result will be skipped (prescan mode), else the detector will be cleared before each new scan (clear-buffer mode).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def set_prescan_mode(self, mode: bool) -&gt; None:  # noqa: FBT001\n    \"\"\"If a prescan is set, the first measurement result will be skipped.\n\n    This function is only useful for the AvaSpec-3648 because this detector\n    can be operated in prescan mode, or clear-buffer mode (see DLL manual).\n\n    Args:\n        mode: If `True`, the first measurement result will be skipped (prescan mode),\n            else the detector will be cleared before each new scan (clear-buffer mode).\n    \"\"\"\n    self.sdk.AVS_SetPrescanMode(self._handle, mode)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.set_pwm_out","title":"set_pwm_out","text":"<pre><code>set_pwm_out(\n    port_id: int, frequency: int, duty_cycle: int\n) -&gt; None\n</code></pre> <p>Selects the PWM functionality for the specified digital output.</p> <p>The PWM functionality is not supported on the Mini.</p> <p>Parameters:</p> Name Type Description Default <code>port_id</code> <code>int</code> <p>Identifier for one of the 6 PWM output signals:</p> <ul> <li><code>0</code>: DO1 = pin 11 at 26-pin connector</li> <li><code>1</code>: DO2 = pin 2 at 26-pin connector</li> <li><code>2</code>: DO3 = pin 20 at 26-pin connector</li> <li><code>4</code>: DO5 = pin 3 at 26-pin connector</li> <li><code>5</code>: DO6 = pin 21 at 26-pin connector</li> <li><code>6</code>: DO7 = pin 13 at 26-pin connector</li> </ul> required <code>frequency</code> <code>int</code> <p>Desired PWM frequency (500 - 300000) [Hz]. For the AS5216, the frequency of outputs 0, 1 and 2 is the same (the last specified frequency is used) and also the frequency of outputs 4, 5 and 6 is the same. For the AS7010, you can define six different frequencies.</p> required <code>duty_cycle</code> <code>int</code> <p>Percentage high time in one cycle (0 - 100). For the AS5216, channels 0, 1 and 2 have a synchronized rising edge, the same holds for channels 4, 5 and 6. For the AS7010, rising edges are unsynchronized.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def set_pwm_out(self, port_id: int, frequency: int, duty_cycle: int) -&gt; None:\n    \"\"\"Selects the PWM functionality for the specified digital output.\n\n    The PWM functionality is not supported on the Mini.\n\n    Args:\n        port_id: Identifier for one of the 6 PWM output signals:\n\n            * `0`: DO1 = pin 11 at 26-pin connector\n            * `1`: DO2 = pin 2 at 26-pin connector\n            * `2`: DO3 = pin 20 at 26-pin connector\n            * `4`: DO5 = pin 3 at 26-pin connector\n            * `5`: DO6 = pin 21 at 26-pin connector\n            * `6`: DO7 = pin 13 at 26-pin connector\n\n        frequency: Desired PWM frequency (500 - 300000) [Hz]. For the AS5216, the frequency of\n            outputs 0, 1 and 2 is the same (the last specified frequency is used) and\n            also the frequency of outputs 4, 5 and 6 is the same. For the AS7010, you\n            can define six different frequencies.\n        duty_cycle: Percentage high time in one cycle (0 - 100). For the AS5216, channels 0,\n            1 and 2 have a synchronized rising edge, the same holds for channels 4, 5\n            and 6. For the AS7010, rising edges are unsynchronized.\n    \"\"\"\n    self.sdk.AVS_SetPwmOut(self._handle, port_id, frequency, duty_cycle)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.set_sensitivity_mode","title":"set_sensitivity_mode","text":"<pre><code>set_sensitivity_mode(mode: int) -&gt; None\n</code></pre> <p>Set the sensitivity mode.</p> <p>This method is supported by the following detector types: HAMS9201, HAMG9208_512, SU256LSB and SU512LDB with the appropriate firmware version.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>int</code> <p>0 for low noise, &gt;0 for high sensitivity</p> required Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def set_sensitivity_mode(self, mode: int) -&gt; None:\n    \"\"\"Set the sensitivity mode.\n\n    This method is supported by the following detector types: HAMS9201,\n    HAMG9208_512, SU256LSB and SU512LDB with the appropriate firmware version.\n\n    Args:\n        mode: 0 for low noise, &gt;0 for high sensitivity\n    \"\"\"\n    self.sdk.AVS_SetSensitivityMode(self._handle, mode)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.set_sync_mode","title":"set_sync_mode","text":"<pre><code>set_sync_mode(enable: bool) -&gt; None\n</code></pre> <p>Disables/enables support for synchronous measurement.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p><code>False</code> to disable sync mode, <code>True</code> to enable sync mode.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def set_sync_mode(self, enable: bool) -&gt; None:  # noqa: FBT001\n    \"\"\"Disables/enables support for synchronous measurement.\n\n    Args:\n        enable: `False` to disable sync mode, `True` to enable sync mode.\n    \"\"\"\n    self.sdk.AVS_SetSyncMode(self._handle, int(bool(enable)))\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.stop_measure","title":"stop_measure","text":"<pre><code>stop_measure() -&gt; None\n</code></pre> <p>Stops the measurement.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def stop_measure(self) -&gt; None:\n    \"\"\"Stops the measurement.\"\"\"\n    self.sdk.AVS_StopMeasure(self._handle)\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.suppress_stray_light","title":"suppress_stray_light","text":"<pre><code>suppress_stray_light(\n    factor: float,\n) -&gt; tuple[NDArray[double], NDArray[double]]\n</code></pre> <p>Returns the stray light corrected pixel values of a dark corrected measurement.</p> <p>Parameters:</p> Name Type Description Default <code>factor</code> <code>float</code> <p>Multiplication factor for the stray light algorithm.</p> required <p>Returns:</p> Type Description <code>tuple[NDArray[double], NDArray[double]]</code> <p>Scope minus dark array, stray light suppressed array.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def suppress_stray_light(self, factor: float) -&gt; tuple[NDArray[np.double], NDArray[np.double]]:\n    \"\"\"Returns the stray light corrected pixel values of a dark corrected measurement.\n\n    Args:\n        factor: Multiplication factor for the stray light algorithm.\n\n    Returns:\n        Scope minus dark array, stray light suppressed array.\n    \"\"\"\n    x = -9e99\n    src = np.full(MAX_NR_PIXELS, x, dtype=np.double)\n    dest = np.full(MAX_NR_PIXELS, x, dtype=np.double)\n    self.sdk.AVS_SuppressStrayLight(\n        self._handle, factor, src.ctypes.data_as(POINTER(c_double)), dest.ctypes.data_as(POINTER(c_double))\n    )\n    return src[src &gt; x], dest[dest &gt; x]\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.update_eth_devices","title":"update_eth_devices","text":"<pre><code>update_eth_devices(\n    nmax: int = 16,\n) -&gt; list[BroadcastAnswerType]\n</code></pre> <p>Return the number of Ethernet devices that are connected to the computer.</p> <p>Internally checks the list of connected Ethernet devices and returns the number of devices attached.</p> <p>Parameters:</p> Name Type Description Default <code>nmax</code> <code>int</code> <p>The maximum number of devices that can be found.</p> <code>16</code> <p>Returns:</p> Type Description <code>list[BroadcastAnswerType]</code> <p>The information about the devices.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def update_eth_devices(self, nmax: int = 16) -&gt; list[BroadcastAnswerType]:\n    \"\"\"Return the number of Ethernet devices that are connected to the computer.\n\n    Internally checks the list of connected Ethernet devices and returns the number of devices attached.\n\n    Args:\n        nmax: The maximum number of devices that can be found.\n\n    Returns:\n        The information about the devices.\n    \"\"\"\n    size = nmax * sizeof(BroadcastAnswerType)\n    required_size = c_uint32()\n    types = (BroadcastAnswerType * nmax)()\n    n = self.sdk.AVS_UpdateETHDevices(size, required_size, types)\n    return [types[i] for i in range(n)]\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.update_usb_devices","title":"update_usb_devices","text":"<pre><code>update_usb_devices() -&gt; int\n</code></pre> <p>Return the number of USB devices that are connected to the computer.</p> <p>Internally checks the list of connected USB devices and returns the number of devices attached.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of devices found.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def update_usb_devices(self) -&gt; int:\n    \"\"\"Return the number of USB devices that are connected to the computer.\n\n    Internally checks the list of connected USB devices and returns the number of devices attached.\n\n    Returns:\n        The number of devices found.\n    \"\"\"\n    return int(self.sdk.AVS_UpdateUSBDevices())\n</code></pre>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvaSpec.use_high_res_adc","title":"use_high_res_adc","text":"<pre><code>use_high_res_adc(enable: bool) -&gt; None\n</code></pre> <p>Enable the 16-bit AD converter.</p> <p>When using the 16 bit ADC in full High Resolution mode (0..65535), please note that the irradiance intensity calibration, as well as the nonlinearity calibration are based on the 14bit ADC range. Therefore, if using the nonlinearity correction or irradiance calibration in your own software using the High Resolution mode, you need to apply the additional correction with ADCFactor (= 4.0), as explained in detail in section 4.6.1 and 4.6.3 of the manual.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>If <code>True</code> use a 16-bit AD converter, otherwise use a 14-bit ADC.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def use_high_res_adc(self, enable: bool) -&gt; None:  # noqa: FBT001\n    \"\"\"Enable the 16-bit AD converter.\n\n    When using the 16 bit ADC in full High Resolution mode (0..65535), please note that the\n    irradiance intensity calibration, as well as the nonlinearity calibration are based on the 14bit\n    ADC range. Therefore, if using the nonlinearity correction or irradiance calibration in your\n    own software using the High Resolution mode, you need to apply the additional correction\n    with ADCFactor (= 4.0), as explained in detail in section 4.6.1 and 4.6.3 of the manual.\n\n    Args:\n        enable: If `True` use a 16-bit AD converter, otherwise use a 14-bit ADC.\n    \"\"\"\n    self.sdk.AVS_UseHighResAdc(self._handle, bool(enable))\n</code></pre>"},{"location":"resources/avantes/avaspec/#avaspec-enums-structs","title":"Enums and Structs","text":"<p>Wrapper around the <code>avaspec</code> SDK from Avantes.</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.MeasureCallback","title":"MeasureCallback  <code>module-attribute</code>","text":"<pre><code>MeasureCallback: type[_CFunctionType] = func_type(\n    None, POINTER(c_int32), POINTER(c_int32)\n)\n</code></pre> <p>CFUNCTYPE function prototype to use when a measurement scan is available.</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.AvsIdentityType","title":"AvsIdentityType","text":"<p>               Bases: <code>Structure</code></p> <p>IdentityType Structure.</p> <p>Attributes:</p> Name Type Description <code>SerialNumber</code> <code>c_char * 10</code> <p>Serial number of device.</p> <code>UserFriendlyName</code> <code>c_char * 64</code> <p>User-friendly name.</p> <code>Status</code> <code>c_ubyte</code> <p>Device status.</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.BroadcastAnswerType","title":"BroadcastAnswerType","text":"<p>               Bases: <code>Structure</code></p> <p>BroadcastAnswerType Structure.</p> <p>Attributes:</p> Name Type Description <code>InterfaceType</code> <code>c_ubyte</code> <p>InterfaceType</p> <code>serial</code> <code>c_ubyte * 10</code> <p>serial</p> <code>port</code> <code>c_uint16</code> <p>port</p> <code>status</code> <code>c_ubyte</code> <p>status</p> <code>RemoteHostIp</code> <code>c_uint32</code> <p>RemoteHostIp</p> <code>LocalIp</code> <code>c_uint32</code> <p>LocalIp</p> <code>reserved</code> <code>c_ubyte * 4</code> <p>reserved</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.ControlSettingsType","title":"ControlSettingsType","text":"<p>               Bases: <code>Structure</code></p> <p>ControlSettingsType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_StrobeControl</code> <code>c_uint16</code> <p>m_StrobeControl</p> <code>m_LaserDelay</code> <code>c_uint32</code> <p>m_LaserDelay</p> <code>m_LaserWidth</code> <code>c_uint32</code> <p>m_LaserWidth</p> <code>m_LaserWaveLength</code> <code>c_float</code> <p>m_LaserWaveLength</p> <code>m_StoreToRam</code> <code>c_uint16</code> <p>m_StoreToRam</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.DarkCorrectionType","title":"DarkCorrectionType","text":"<p>               Bases: <code>Structure</code></p> <p>DarkCorrectionType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_Enable</code> <code>c_ubyte</code> <p>m_Enable</p> <code>m_ForgetPercentage</code> <code>c_ubyte</code> <p>m_ForgetPercentage</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.DetectorType","title":"DetectorType","text":"<p>               Bases: <code>Structure</code></p> <p>DetectorType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_SensorType</code> <code>c_ubyte</code> <p>m_SensorType</p> <code>m_NrPixels</code> <code>c_uint16</code> <p>m_NrPixels</p> <code>m_aFit</code> <code>c_float * 5</code> <p>m_aFit</p> <code>m_NLEnable</code> <code>c_bool</code> <p>m_NLEnable</p> <code>m_aNLCorrect</code> <code>c_double * 8</code> <p>m_aNLCorrect</p> <code>m_aLowNLCounts</code> <code>c_double</code> <p>m_aLowNLCounts</p> <code>m_aHighNLCounts</code> <code>c_double</code> <p>m_aHighNLCounts</p> <code>m_Gain</code> <code>c_float * 2</code> <p>m_Gain</p> <code>m_Reserved</code> <code>c_float</code> <p>m_Reserved</p> <code>m_Offset</code> <code>c_float * 2</code> <p>m_Offset</p> <code>m_ExtOffset</code> <code>c_float</code> <p>m_ExtOffset</p> <code>m_DefectivePixels</code> <code>c_uint16 * 30</code> <p>m_DefectivePixels</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.DeviceConfigType","title":"DeviceConfigType","text":"<p>               Bases: <code>Structure</code></p> <p>DeviceConfigType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_Len</code> <code>c_uint16</code> <p>m_Len</p> <code>m_ConfigVersion</code> <code>c_uint16</code> <p>m_ConfigVersion</p> <code>m_aUserFriendlyId</code> <code>c_char * 64</code> <p>m_aUserFriendlyId</p> <code>m_Detector</code> <code>DetectorType</code> <p>m_Detector</p> <code>m_Irradiance</code> <code>IrradianceType</code> <p>m_Irradiance</p> <code>m_Reflectance</code> <code>SpectrumCalibrationType</code> <p>m_Reflectance</p> <code>m_SpectrumCorrect</code> <code>SpectrumCorrectionType</code> <p>m_SpectrumCorrect</p> <code>m_StandAlone</code> <code>StandAloneType</code> <p>m_StandAlone</p> <code>m_DynamicStorage</code> <code>DynamicStorageType</code> <p>m_DynamicStorage</p> <code>m_aTemperature</code> <code>TempSensorType * 3</code> <p>m_aTemperature</p> <code>m_TecControl</code> <code>TecControlType</code> <p>m_TecControl</p> <code>m_ProcessControl</code> <code>ProcessControlType</code> <p>m_ProcessControl</p> <code>m_EthernetSettings</code> <code>EthernetSettingsType</code> <p>m_EthernetSettings</p> <code>m_aReserved</code> <code>c_ubyte * 9720</code> <p>m_aReserved</p> <code>m_OemData</code> <code>OemDataType</code> <p>m_OemData</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.DeviceStatus","title":"DeviceStatus","text":"<p>               Bases: <code>IntEnum</code></p> <p>DeviceStatus enum.</p> <p>Attributes:</p> Name Type Description <code>UNKNOWN</code> <code>int</code> <p>0</p> <code>USB_AVAILABLE</code> <code>int</code> <p>1</p> <code>USB_IN_USE_BY_APPLICATION</code> <code>int</code> <p>2</p> <code>USB_IN_USE_BY_OTHER</code> <code>int</code> <p>3</p> <code>ETH_AVAILABLE</code> <code>int</code> <p>4</p> <code>ETH_IN_USE_BY_APPLICATION</code> <code>int</code> <p>5</p> <code>ETH_IN_USE_BY_OTHER</code> <code>int</code> <p>6</p> <code>ETH_ALREADY_IN_USE_USB</code> <code>int</code> <p>7</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.DynamicStorageType","title":"DynamicStorageType","text":"<p>               Bases: <code>Structure</code></p> <p>DynamicStorageType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_Nmsr</code> <code>c_int32</code> <p>m_Nmsr</p> <code>m_Reserved</code> <code>c_ubyte * 8</code> <p>m_Reserved</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.EthernetSettingsType","title":"EthernetSettingsType","text":"<p>               Bases: <code>Structure</code></p> <p>EthernetSettingsType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_IpAddr(c_uint32)</code> <p>m_IpAddr</p> <code>m_NetMask</code> <code>c_uint32</code> <p>m_NetMask</p> <code>m_Gateway</code> <code>c_uint32</code> <p>m_Gateway</p> <code>m_DhcpEnabled</code> <code>c_ubyte</code> <p>m_DhcpEnabled</p> <code>m_TcpPort</code> <code>c_uint16</code> <p>m_TcpPort</p> <code>m_LinkStatus</code> <code>c_ubyte</code> <p>m_LinkStatus</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.HeartbeatRespType","title":"HeartbeatRespType","text":"<p>               Bases: <code>Structure</code></p> <p>HeartbeatRespType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_BitMatrix</code> <code>c_uint32</code> <p>m_BitMatrix</p> <code>m_Reserved</code> <code>c_uint32</code> <p>m_Reserved</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.InterfaceType","title":"InterfaceType","text":"<p>               Bases: <code>IntEnum</code></p> <p>InterfaceType enum.</p> <p>Attributes:</p> Name Type Description <code>RS232</code> <code>int</code> <p>0</p> <code>USB5216</code> <code>int</code> <p>1</p> <code>USBMINI</code> <code>int</code> <p>2</p> <code>USB7010</code> <code>int</code> <p>3</p> <code>ETH7010</code> <code>int</code> <p>4</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.IrradianceType","title":"IrradianceType","text":"<p>               Bases: <code>Structure</code></p> <p>IrradianceType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_IntensityCalib</code> <code>SpectrumCalibrationType</code> <p>m_IntensityCalib</p> <code>m_CalibrationType</code> <code>c_ubyte</code> <p>m_CalibrationType</p> <code>m_FiberDiameter</code> <code>c_uint32</code> <p>m_FiberDiameter</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.MeasConfigType","title":"MeasConfigType","text":"<p>               Bases: <code>Structure</code></p> <p>MeasConfigType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_StartPixel</code> <code>c_uint16</code> <p>m_StartPixel</p> <code>m_StopPixel</code> <code>c_uint16</code> <p>m_StopPixel</p> <code>m_IntegrationTime</code> <code>c_float</code> <p>m_IntegrationTime</p> <code>m_IntegrationDelay</code> <code>c_uint32</code> <p>m_IntegrationDelay</p> <code>m_NrAverages</code> <code>c_uint32</code> <p>m_NrAverages</p> <code>m_CorDynDark</code> <code>DarkCorrectionType</code> <p>m_CorDynDark</p> <code>m_Smoothing</code> <code>SmoothingType</code> <p>m_Smoothing</p> <code>m_SaturationDetection</code> <code>c_ubyte</code> <p>m_SaturationDetection</p> <code>m_Trigger</code> <code>TriggerType</code> <p>m_Trigger</p> <code>m_Control</code> <code>ControlSettingsType</code> <p>m_Control</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.OemDataType","title":"OemDataType","text":"<p>               Bases: <code>Structure</code></p> <p>OemDataType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_data</code> <code>c_ubyte * 4096</code> <p>m_data</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.ProcessControlType","title":"ProcessControlType","text":"<p>               Bases: <code>Structure</code></p> <p>ProcessControlType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_AnalogLow</code> <code>c_float * 2</code> <p>m_AnalogLow</p> <code>m_AnalogHigh</code> <code>c_float * 2</code> <p>m_AnalogHigh</p> <code>m_DigitalLow</code> <code>c_float * 10</code> <p>m_DigitalLow</p> <code>m_DigitalHigh</code> <code>c_float * 10</code> <p>m_DigitalHigh</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.SensType","title":"SensType","text":"<p>               Bases: <code>IntEnum</code></p> <p>SensType enum.</p> <p>Attributes:</p> Name Type Description <code>SENS_HAMS8378_256</code> <code>int</code> <p>1</p> <code>SENS_HAMS8378_1024</code> <code>int</code> <p>2</p> <code>SENS_ILX554</code> <code>int</code> <p>3</p> <code>SENS_HAMS9201</code> <code>int</code> <p>4</p> <code>SENS_TCD1304</code> <code>int</code> <p>5</p> <code>SENS_TSL1301</code> <code>int</code> <p>6</p> <code>SENS_TSL1401</code> <code>int</code> <p>7</p> <code>SENS_HAMS8378_512</code> <code>int</code> <p>8</p> <code>SENS_HAMS9840</code> <code>int</code> <p>9</p> <code>SENS_ILX511</code> <code>int</code> <p>10</p> <code>SENS_HAMS10420_2048X64</code> <code>int</code> <p>11</p> <code>SENS_HAMS11071_2048X64</code> <code>int</code> <p>12</p> <code>SENS_HAMS7031_1024X122</code> <code>int</code> <p>13</p> <code>SENS_HAMS7031_1024X58</code> <code>int</code> <p>14</p> <code>SENS_HAMS11071_2048X16</code> <code>int</code> <p>15</p> <code>SENS_HAMS11155_2048</code> <code>int</code> <p>16</p> <code>SENS_SU256LSB</code> <code>int</code> <p>17</p> <code>SENS_SU512LDB</code> <code>int</code> <p>18</p> <code>SENS_HAMS11638</code> <code>int</code> <p>21</p> <code>SENS_HAMS11639</code> <code>int</code> <p>22</p> <code>SENS_HAMS12443</code> <code>int</code> <p>23</p> <code>SENS_HAMG9208_512</code> <code>int</code> <p>24</p> <code>SENS_HAMG13913</code> <code>int</code> <p>25</p> <code>SENS_HAMS13496</code> <code>int</code> <p>26</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.SmoothingType","title":"SmoothingType","text":"<p>               Bases: <code>Structure</code></p> <p>SmoothingType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_SmoothPix</code> <code>c_uint16</code> <p>m_SmoothPix</p> <code>m_SmoothModel</code> <code>c_ubyte</code> <p>m_SmoothModel</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.SpectrumCalibrationType","title":"SpectrumCalibrationType","text":"<p>               Bases: <code>Structure</code></p> <p>SpectrumCalibrationType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_Smoothing</code> <code>SmoothingType</code> <p>m_Smoothing</p> <code>m_CalInttime</code> <code>c_float</code> <p>m_CalInttime</p> <code>m_aCalibConvers</code> <code>c_float * 4096</code> <p>m_aCalibConvers</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.SpectrumCorrectionType","title":"SpectrumCorrectionType","text":"<p>               Bases: <code>Structure</code></p> <p>SpectrumCorrectionType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_aSpectrumCorrect</code> <code>c_float * 4096</code> <p>m_aSpectrumCorrect</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.StandAloneType","title":"StandAloneType","text":"<p>               Bases: <code>Structure</code></p> <p>StandAloneType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_Enable</code> <code>c_bool</code> <p>m_Enable</p> <code>m_Meas</code> <code>MeasConfigType</code> <p>m_Meas</p> <code>m_Nmsr</code> <code>c_int16</code> <p>m_Nmsr</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.TecControlType","title":"TecControlType","text":"<p>               Bases: <code>Structure</code></p> <p>TecControlType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_Enable</code> <code>c_bool</code> <p>m_Enable</p> <code>m_Setpoint</code> <code>c_float</code> <p>m_Setpoint</p> <code>m_aFit</code> <code>c_float * 2</code> <p>m_aFit</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.TempSensorType","title":"TempSensorType","text":"<p>               Bases: <code>Structure</code></p> <p>TempSensorType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_aFit</code> <code>c_float * 5</code> <p>m_aFit</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.TimeStampType","title":"TimeStampType","text":"<p>               Bases: <code>Structure</code></p> <p>TimeStampType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_Date</code> <code>c_uint16</code> <p>m_Date</p> <code>m_Time</code> <code>c_uint16</code> <p>m_Time</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.TriggerType","title":"TriggerType","text":"<p>               Bases: <code>Structure</code></p> <p>TriggerType Structure.</p> <p>Attributes:</p> Name Type Description <code>m_Mode</code> <code>c_ubyte</code> <p>m_Mode</p> <code>m_Source</code> <code>c_ubyte</code> <p>m_Source</p> <code>m_SourceType</code> <code>c_ubyte</code> <p>m_SourceType</p>"},{"location":"resources/avantes/avaspec/#msl.equipment_resources.avantes.avaspec.avaspec_callback","title":"avaspec_callback","text":"<pre><code>avaspec_callback(f: AvaSpecCallback) -&gt; _CFunctionType\n</code></pre> <p>Use as a decorator for a callback function when a measurement scan is available.</p> <p>See avaspec_callback.py for an example usage.</p> Source code in <code>packages/resources/src/msl/equipment_resources/avantes/avaspec.py</code> <pre><code>def avaspec_callback(f: AvaSpecCallback) -&gt; _CFunctionType:\n    \"\"\"Use as a decorator for a callback function when a measurement scan is available.\n\n    See [avaspec_callback.py](https://github.com/MSLNZ/msl-equipment/blob/main/packages/resources/examples/avantes/avaspec_callback.py)\n    for an example usage.\n    \"\"\"\n    return MeasureCallback(f)\n</code></pre>"},{"location":"resources/cmi/sia3/","title":"Switched Integrator Amplifier","text":"<p>A Switched Integrator Amplifier (SIA) designed by the Czech Metrology Institute.</p>"},{"location":"resources/cmi/sia3/#msl.equipment_resources.cmi.sia3.IntegrationTime","title":"IntegrationTime","text":"<p>               Bases: <code>IntEnum</code></p> <p>The amount of time to integrate the photodiode signal.</p> <p>Attributes:</p> Name Type Description <code>TIME_50us</code> <code>int</code> <p>5</p> <code>TIME_100us</code> <code>int</code> <p>6</p> <code>TIME_1ms</code> <code>int</code> <p>7</p> <code>TIME_10ms</code> <code>int</code> <p>8</p> <code>TIME_20ms</code> <code>int</code> <p>9</p> <code>TIME_100ms</code> <code>int</code> <p>10</p> <code>TIME_200ms</code> <code>int</code> <p>11</p> <code>TIME_500ms</code> <code>int</code> <p>12</p> <code>TIME_1s</code> <code>int</code> <p>13</p> <code>TIME_2s</code> <code>int</code> <p>14</p>"},{"location":"resources/cmi/sia3/#msl.equipment_resources.cmi.sia3.PreScale","title":"PreScale","text":"<p>               Bases: <code>IntEnum</code></p> <p>Pre-scale factor for the microprocessor frequency.</p> <p>Attributes:</p> Name Type Description <code>PS_0</code> <code>int</code> <p>0</p> <code>PS_1</code> <code>int</code> <p>1</p> <code>PS_2</code> <code>int</code> <p>2</p> <code>PS_3</code> <code>int</code> <p>3</p> <code>PS_4</code> <code>int</code> <p>4</p> <code>PS_5</code> <code>int</code> <p>5</p> <code>PS_6</code> <code>int</code> <p>6</p> <code>PS_7</code> <code>int</code> <p>7</p>"},{"location":"resources/cmi/sia3/#msl.equipment_resources.cmi.sia3.SIA3","title":"SIA3","text":"<pre><code>SIA3(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Serial</code></p> <p>A Switched Integrator Amplifier (SIA) designed by the Czech Metrology Institute.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/cmi/sia3.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"A Switched Integrator Amplifier (SIA) designed by the Czech Metrology Institute.\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"\n    assert equipment.connection is not None  # noqa: S101\n    if not equipment.connection.properties:\n        # then use the default connection properties\n        equipment.connection.properties = {\n            \"baud_rate\": 14400,\n            \"termination\": None,\n            \"timeout\": 10.0,\n        }\n    super().__init__(equipment)\n</code></pre>"},{"location":"resources/cmi/sia3/#msl.equipment_resources.cmi.sia3.SIA3.set_integration_time","title":"set_integration_time","text":"<pre><code>set_integration_time(\n    time: str | int | IntegrationTime,\n) -&gt; None\n</code></pre> <p>Set the integration time (i.e., the gain).</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>str | int | IntegrationTime</code> <p>The integration time. The following are equivalent to set the integration time to 10 milliseconds:</p> <ul> <li><code>set_integration_time(\"10ms\")</code></li> <li><code>set_integration_time(8)</code></li> <li><code>set_integration_time(cmi.IntegrationTime.TIME_10ms)</code></li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/cmi/sia3.py</code> <pre><code>def set_integration_time(self, time: str | int | IntegrationTime) -&gt; None:\n    \"\"\"Set the integration time (i.e., the gain).\n\n    Args:\n        time: The integration time. The following are equivalent to set the\n            integration time to 10 milliseconds:\n\n            * `set_integration_time(\"10ms\")`\n            * `set_integration_time(8)`\n            * `set_integration_time(cmi.IntegrationTime.TIME_10ms)`\n    \"\"\"\n    value = to_enum(time, IntegrationTime, prefix=\"TIME_\")\n    self._send_byte(7)\n    self._send_byte(value)\n</code></pre>"},{"location":"resources/cmi/sia3/#msl.equipment_resources.cmi.sia3.SIA3.set_ps","title":"set_ps","text":"<pre><code>set_ps(ps: int | PreScale) -&gt; None\n</code></pre> <p>Set the timer pre-scale value.</p> <p>The timer pre-scale value divides the microprocessor internal frequency by something similar to \\(2^{PS}\\). Therefore, to reach a 2-second integration time the <code>ps</code> value must be set to the maximum value of 7.</p> <p>Parameters:</p> Name Type Description Default <code>ps</code> <code>int | PreScale</code> <p>The timer pre-scale value. The following are equivalent to set the pre-scale value to 7</p> <ul> <li><code>set_ps(7)</code></li> <li><code>set_ps(cmi.PreScale.PS_7)</code></li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/cmi/sia3.py</code> <pre><code>def set_ps(self, ps: int | PreScale) -&gt; None:\n    \"\"\"Set the timer pre-scale value.\n\n    The timer pre-scale value divides the microprocessor internal frequency\n    by something similar to $2^{PS}$. Therefore, to reach a 2-second integration time\n    the `ps` value must be set to the maximum value of 7.\n\n    Args:\n        ps: The timer pre-scale value. The following are equivalent to set the\n            pre-scale value to 7\n\n            * `set_ps(7)`\n            * `set_ps(cmi.PreScale.PS_7)`\n    \"\"\"\n    value = to_enum(ps, PreScale, prefix=\"PS_\")\n    self._send_byte(1)\n    self._send_byte(4)\n    self._send_byte(value)\n    self._send_byte(value)\n</code></pre>"},{"location":"resources/dataray/wincamd/","title":"WinCamD","text":"<p>Connect to a WinCamD beam-profiling camera from DataRay.</p> <p>Tested with the WinCamD-LCM-8.0E45 (x64) software version.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD","title":"WinCamD","text":"<pre><code>WinCamD(equipment: Equipment)\n</code></pre> <p>               Bases: <code>SDK</code></p> <p>Connect to a WinCamD beam-profiling camera from DataRay.</p> <p>The bitness (32 or 64 bit) of the DataRay Beam Profiling Software that is installed must match the bitness of the Python interpreter that is used to load the <code>DATARAYOCX</code> library.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for the <code>WinCamD</code> class.</p> <p>Connection Properties:</p> Name Type Description <code>area_filter</code> <code>int | None</code> <p>Area filter:</p> <ul> <li><code>1</code>: 1 pixel</li> <li><code>2</code>: 3 pixels</li> <li><code>3</code>: 5 pixels</li> <li><code>4</code>: 7 pixels</li> <li><code>5</code>: 9 pixels</li> </ul> <p>If <code>None</code>, use the value saved in the device firmware. Default: <code>None</code></p> <code>camera_index</code> <code>int</code> <p>The camera to use (between 0 and 7). Default: <code>0</code></p> <code>centroid_method</code> <code>int | None</code> <p>The centroid method to use (0, 1 or 2). If <code>None</code>, use the value saved in the device firmware. Default: <code>None</code></p> <code>full_scale_filter</code> <code>float | None</code> <p>Percent full scale filter (0, 0.1, 0.2, 0.5, 1, 2, 5 or 10). If <code>None</code>, use the value saved in the device firmware. Default: <code>None</code></p> <code>major_minor_method</code> <code>int | None</code> <p>The major/minor method to use (0, 1 or 2). If <code>None</code>, use the value saved in the device firmware. Default: <code>None</code></p> <code>plateau_uniformity</code> <code>bool | None</code> <p>Whether to enable or disable plateau uniformity. If <code>None</code>, use the value saved in the device firmware. Default: <code>None</code></p> <code>wavelength</code> <code>float | None</code> <p>The wavelength, in nm, of the incident light. If <code>None</code>, use the value saved in the device firmware. Default: <code>None</code></p> <code>ui_size</code> <code>int</code> <p>The height, in pixels, of a button for the user interface. Default: <code>25</code></p> Source code in <code>packages/resources/src/msl/equipment_resources/dataray/wincamd.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Connect to a WinCamD beam-profiling camera from DataRay.\n\n    The bitness (32 or 64 bit) of the DataRay Beam Profiling Software that\n    is installed must match the bitness of the Python interpreter that is used\n    to load the `DATARAYOCX` library.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for the `WinCamD` class.\n\n    Attributes: Connection Properties:\n        area_filter (int | None): Area filter:\n\n            * `1`: 1 pixel\n            * `2`: 3 pixels\n            * `3`: 5 pixels\n            * `4`: 7 pixels\n            * `5`: 9 pixels\n\n            If `None`, use the value saved in the device firmware. _Default: `None`_\n        camera_index (int): The camera to use (between 0 and 7). _Default: `0`_\n        centroid_method (int | None): The centroid method to use (0, 1 or 2).\n            If `None`, use the value saved in the device firmware. _Default: `None`_\n        full_scale_filter (float | None): Percent full scale filter (0, 0.1, 0.2, 0.5, 1, 2, 5 or 10).\n            If `None`, use the value saved in the device firmware. _Default: `None`_\n        major_minor_method (int | None): The major/minor method to use (0, 1 or 2).\n            If `None`, use the value saved in the device firmware. _Default: `None`_\n        plateau_uniformity (bool | None): Whether to enable or disable plateau uniformity.\n            If `None`, use the value saved in the device firmware. _Default: `None`_\n        wavelength (float | None): The wavelength, in nm, of the incident light.\n            If `None`, use the value saved in the device firmware. _Default: `None`_\n        ui_size (int): The height, in pixels, of a button for the user interface. _Default: `25`_\n    \"\"\"\n    from msl.loadlib.activex import WindowClassStyle  # noqa: PLC0415\n\n    assert equipment.connection is not None  # noqa: S101\n    prefix = equipment.connection.address[len(\"SDK::\") :]\n    super().__init__(\n        equipment, libtype=\"activex\", path=f\"{prefix}.GetDataCtrl.1\", class_style=WindowClassStyle.NOCLOSE\n    )\n\n    assert self.application is not None  # noqa: S101\n    p = equipment.connection.properties\n\n    self._ocx: _WinCam = _WinCam(\n        app=self.application,\n        sdk=self.sdk,\n        prefix=prefix,\n        camera_index=p.get(\"camera_index\", 0),\n        major_minor_method=p.get(\"major_minor_method\"),\n        centroid_method=p.get(\"centroid_method\"),\n        area_filter=p.get(\"area_filter\"),\n        full_scale_filter=p.get(\"full_scale_filter\"),\n        ui_size=p.get(\"ui_size\", 25),\n        plateau_uniformity=p.get(\"plateau_uniformity\"),\n    )\n\n    wavelength = p.get(\"wavelength\")\n    if wavelength:\n        self.wavelength = wavelength\n\n    if not self.sdk.StartDriver():\n        msg = \"Cannot start the DataRay driver\"\n        raise RuntimeError(msg)\n</code></pre>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.adc_peak_percent","title":"adc_peak_percent  <code>property</code>","text":"<pre><code>adc_peak_percent: float\n</code></pre> <p>Returns the peak value as a percentage of the maximum possible ADC level.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.centroid","title":"centroid  <code>property</code>","text":"<pre><code>centroid: tuple[float, float]\n</code></pre> <p>Returns the <code>(x, y)</code> coordinate of the centroid.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.crosshair","title":"crosshair  <code>property</code>","text":"<pre><code>crosshair: float\n</code></pre> <p>Returns the angle between the horizontal x-axis and the solid crosshair line, in degrees.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.effective_2w","title":"effective_2w  <code>property</code>","text":"<pre><code>effective_2w: float\n</code></pre> <p>Returns the effective beam size, in um.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.ellipticity","title":"ellipticity  <code>property</code>","text":"<pre><code>ellipticity: float\n</code></pre> <p>Returns the ratio between the minor/major axis.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.exposure_time","title":"exposure_time  <code>property</code>","text":"<pre><code>exposure_time: float\n</code></pre> <p>Returns the exposure time, in ms.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.homogeneity","title":"homogeneity  <code>property</code>","text":"<pre><code>homogeneity: float\n</code></pre> <p>Returns the 2D homogeneity of the beam (between 0 and 1).</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.image","title":"image  <code>property</code>","text":"<pre><code>image: NDArray[int64]\n</code></pre> <p>Returns the image data.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.major","title":"major  <code>property</code>","text":"<pre><code>major: float\n</code></pre> <p>Returns the beam size along the major axis, in um.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.major_iso","title":"major_iso  <code>property</code>","text":"<pre><code>major_iso: float\n</code></pre> <p>Returns the ISO 11146 beam size along the major axis, in um.</p> <p>The camera must be configured for ISO 11146 mode.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.mean","title":"mean  <code>property</code>","text":"<pre><code>mean: float\n</code></pre> <p>Returns the mean beam size, in um.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.mean_theta","title":"mean_theta  <code>property</code>","text":"<pre><code>mean_theta: float\n</code></pre> <p>Returns the DXX mean angle, in radians.</p> <p>The camera must be configured for DXX mode.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.minor","title":"minor  <code>property</code>","text":"<pre><code>minor: float\n</code></pre> <p>Returns the beam size along the minor axis, in um.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.minor_iso","title":"minor_iso  <code>property</code>","text":"<pre><code>minor_iso: float\n</code></pre> <p>Returns the ISO 11146 beam size along the minor axis, in um.</p> <p>The camera must be configured for ISO 11146 mode.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.orientation","title":"orientation  <code>property</code>","text":"<pre><code>orientation: float\n</code></pre> <p>Returns the angle between the x-axis and the major or minor axis closest to the x-axis, in degrees.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.pixel_size","title":"pixel_size  <code>property</code>","text":"<pre><code>pixel_size: tuple[float, float]\n</code></pre> <p>Returns the <code>(width, height)</code> size, in um, of a pixel.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.pk_to_avg","title":"pk_to_avg  <code>property</code>","text":"<pre><code>pk_to_avg: float\n</code></pre> <p>Returns the peak to average value.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.plateau_uniformity","title":"plateau_uniformity  <code>property</code>","text":"<pre><code>plateau_uniformity: float\n</code></pre> <p>Returns the flatness of the plateau.</p> <p>A value between 0 and 1 denoting how closely the beam resembles a theoretically perfect flat-top beam.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.profile_x","title":"profile_x  <code>property</code>","text":"<pre><code>profile_x: NDArray[int64]\n</code></pre> <p>Returns the profile data along X.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.profile_y","title":"profile_y  <code>property</code>","text":"<pre><code>profile_y: NDArray[int64]\n</code></pre> <p>Returns the profile data along Y.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.rc","title":"rc  <code>property</code>","text":"<pre><code>rc: float\n</code></pre> <p>Returns the radial distance from the center of the sensor to the center of the crosshair position.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.roi","title":"roi  <code>property</code>","text":"<pre><code>roi: tuple[int, int, int, int]\n</code></pre> <p>Returns the region of interest <code>(x, y, width, height)</code>.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.wavelength","title":"wavelength  <code>property</code> <code>writable</code>","text":"<pre><code>wavelength: float\n</code></pre> <p>Get/Set the wavelength, in nm, of the incident light.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.xc","title":"xc  <code>property</code>","text":"<pre><code>xc: float\n</code></pre> <p>Returns the centroid position along X, in um.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.xg","title":"xg  <code>property</code>","text":"<pre><code>xg: float\n</code></pre> <p>Returns the geometric centroid position along X, in um.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.xp","title":"xp  <code>property</code>","text":"<pre><code>xp: float\n</code></pre> <p>Returns the peak-intensity centroid position along X, in um.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.yc","title":"yc  <code>property</code>","text":"<pre><code>yc: float\n</code></pre> <p>Returns the centroid position along Y, in um.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.yg","title":"yg  <code>property</code>","text":"<pre><code>yg: float\n</code></pre> <p>Returns the geometric centroid position along Y, in um.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.yp","title":"yp  <code>property</code>","text":"<pre><code>yp: float\n</code></pre> <p>Returns the peak-intensity centroid position along Y, in um.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.zoom_factor","title":"zoom_factor  <code>property</code>","text":"<pre><code>zoom_factor: float\n</code></pre> <p>Returns the zoom factor of the image.</p>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.capture","title":"capture","text":"<pre><code>capture(timeout: float | None = None) -&gt; None\n</code></pre> <p>Capture image.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float | None</code> <p>The maximum number of seconds to wait to capture the image.</p> <code>None</code> Source code in <code>packages/resources/src/msl/equipment_resources/dataray/wincamd.py</code> <pre><code>def capture(self, timeout: float | None = None) -&gt; None:\n    \"\"\"Capture image.\n\n    Args:\n        timeout: The maximum number of seconds to wait to capture the image.\n    \"\"\"\n    try:\n        self._ocx.capture(timeout)\n    except (RuntimeError, TimeoutError) as e:\n        raise MSLConnectionError(self, message=str(e)) from None\n</code></pre>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the <code>DATARAYOCX</code> library.</p> Source code in <code>packages/resources/src/msl/equipment_resources/dataray/wincamd.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Disconnect from the `DATARAYOCX` library.\"\"\"\n    if hasattr(self, \"_ocx\") and self.application is not None:\n        self._ocx.stop_device()\n        self.application.close()\n        super().disconnect()\n</code></pre>"},{"location":"resources/dataray/wincamd/#msl.equipment_resources.dataray.wincamd.WinCamD.wait_to_configure","title":"wait_to_configure","text":"<pre><code>wait_to_configure() -&gt; None\n</code></pre> <p>Wait until the camera has been configured.</p> <p>This is a blocking call and waits until the popup window is closed.</p> Source code in <code>packages/resources/src/msl/equipment_resources/dataray/wincamd.py</code> <pre><code>def wait_to_configure(self) -&gt; None:\n    \"\"\"Wait until the camera has been configured.\n\n    This is a blocking call and waits until the popup window is closed.\n    \"\"\"\n    self._ocx.wait_to_configure()\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/","title":"TC Temperature Controller","text":"<p>Establishes a connection to a TC Series Temperature Controller from Electron Dynamics Ltd.</p> <p>The main communication class is TCSeries.</p>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.Alarm","title":"Alarm  <code>dataclass</code>","text":"<pre><code>Alarm(\n    type: AlarmType,\n    alarm_min: float,\n    alarm_max: float,\n    ok_min: float,\n    ok_max: float,\n    limit_min: float,\n    limit_max: float,\n)\n</code></pre> <p>Alarm parameters.</p> <p>Parameters:</p> Name Type Description Default <code>alarm_min</code> <code>float</code> <p>The temperature below which the alarm is activated.</p> required <code>alarm_max</code> <code>float</code> <p>The temperature above which the alarm is activated.</p> required <code>ok_min</code> <code>float</code> <p>The minimum temperature difference from the setpoint for the temperature to be okay.</p> required <code>ok_max</code> <code>float</code> <p>The maximum temperature difference from the setpoint for the temperature to be okay.</p> required <code>limit_min</code> <code>float</code> <p>The minimum temperature below which the drive output is disabled.</p> required <code>limit_max</code> <code>float</code> <p>The maximum temperature above which the drive output is disabled.</p> required"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.AlarmType","title":"AlarmType","text":"<p>               Bases: <code>IntEnum</code></p> <p>Alarm type.</p> <p>Attributes:</p> Name Type Description <code>OFF</code> <code>int</code> <p>0</p> <code>MIN</code> <code>int</code> <p>1</p> <code>MAX</code> <code>int</code> <p>2</p> <code>BOTH</code> <code>int</code> <p>3</p>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.Control","title":"Control  <code>dataclass</code>","text":"<pre><code>Control(\n    type: ControlType,\n    p: float,\n    i: float,\n    d: float,\n    d_filter: float,\n    dead_band: float,\n    power_up_state: PowerUpState,\n)\n</code></pre> <p>The PID control parameters.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>ControlType</code> <p>The control type.</p> required <code>p</code> <code>float</code> <p>The proportional (gain) value. With a proportional control type, the controller output is proportional to the temperature error from the setpoint. The proportional terms sets the gain for this, i.e., <code>Output = setpoint-actual-temperature * proportional-term</code></p> required <code>i</code> <code>float</code> <p>The integral value. With integral action, the controller output is proportional to the amount of time the error is present. Integral action eliminates offset. The integral term is a time unit in seconds. NB for larger effects of integration reduce the integral time, also for operation without integral, integral time can be set to a large number, e.g. 1e6.</p> required <code>d</code> <code>float</code> <p>The derivative value. With derivative action, the controller output is proportional to the rate of change of the measurement or error. The controller output is calculated by the rate of change of the measurement with time, in seconds. To increase the derivative action increase the derivative value.</p> required <code>d_filter</code> <code>float</code> <p>The derivative filter is a low pass filter function on the derivative value. This allows the filtration of noise components which are a problem with a pure derivative function. The filter value should be set to be between 0 and 1.</p> required <code>dead_band</code> <code>float</code> <p>For use with On/Off control the dead band specifies the temperature range around the set point where the output is zero. For example:</p> <ul> <li>Temperature &gt; setpoint + dead_band (Fully Cooling)</li> <li>Temperature &lt; setpoint - dead_band (Fully Heating)</li> <li>Temperature &lt; setpoint + dead_band AND &gt; setpoint-dead_band (Output off)</li> </ul> required <code>power_up_state</code> <code>PowerUpState</code> <p>Temperature control state from power up.</p> required"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.ControlType","title":"ControlType","text":"<p>               Bases: <code>IntEnum</code></p> <p>Control type.</p> <p>Attributes:</p> Name Type Description <code>ON_OFF</code> <code>int</code> <p>Output drive is only fully on (heating or cooling) or off, <code>1</code>.</p> <code>P</code> <code>int</code> <p>Proportional, <code>2</code>.</p> <code>PI</code> <code>int</code> <p>Proportional and integral, <code>3</code>.</p> <code>PID</code> <code>int</code> <p>Proportional, integral and derivative, <code>4</code>.</p>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.Method","title":"Method","text":"<p>               Bases: <code>IntEnum</code></p> <p>Setpoint method type.</p> <p>The temperature setpoint can be set via software or by altering the potentiometer on the temperature controller hardware.</p> <p>Attributes:</p> Name Type Description <code>POTENTIOMETER</code> <code>int</code> <p>0</p> <code>SOFTWARE</code> <code>int</code> <p>1</p> <code>INPUT</code> <code>int</code> <p>2</p>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.Output","title":"Output  <code>dataclass</code>","text":"<pre><code>Output(\n    polarity: int | Polarity,\n    minimum: float,\n    maximum: float,\n    frequency: float,\n)\n</code></pre> <p>Output parameters.</p> <p>Parameters:</p> Name Type Description Default <code>polarity</code> <code>int | Polarity</code> <p>Output drive polarity.</p> required <code>minimum</code> <code>float</code> <p>The minimum value limit of the output. Range -100 to +100.</p> required <code>maximum</code> <code>float</code> <p>The maximum value limit of the output. Range -100 to +100.</p> required <code>frequency</code> <code>float</code> <p>Sets the pulse-width modulation repetition frequency of the output drive. Range 20 to 1000 Hz.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def __init__(self, polarity: int | Polarity, minimum: float, maximum: float, frequency: float) -&gt; None:\n    \"\"\"Output parameters.\n\n    Args:\n        polarity: Output drive polarity.\n        minimum: The minimum value limit of the output. Range -100 to +100.\n        maximum: The maximum value limit of the output. Range -100 to +100.\n        frequency: Sets the pulse-width modulation repetition frequency of the output drive.\n            Range 20 to 1000 Hz.\n    \"\"\"\n    if abs(minimum) &gt; 100:  # noqa: PLR2004\n        msg = f\"Invalid minimum={minimum}. Must be between -100 and +100\"\n        raise ValueError(msg)\n    if abs(maximum) &gt; 100:  # noqa: PLR2004\n        msg = f\"Invalid maximum={maximum}. Must be between -100 and +100\"\n        raise ValueError(msg)\n    if minimum &gt; maximum:\n        msg = f\"The minimum={minimum} value must be less than the maximum={maximum}\"\n        raise ValueError(msg)\n    if frequency &lt; 20 or frequency &gt; 1000:  # noqa: PLR2004\n        msg = f\"Invalid frequency={frequency}. Must be between 20 and 1000\"\n        raise ValueError(msg)\n\n    self.polarity: Polarity = to_enum(polarity, Polarity)\n    self.minimum: float = minimum\n    self.maximum: float = maximum\n    self.frequency: float = frequency\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.Polarity","title":"Polarity","text":"<p>               Bases: <code>IntEnum</code></p> <p>Output drive polarity.</p> <p>Attributes:</p> Name Type Description <code>NEGATIVE</code> <code>int</code> <p>0</p> <code>POSITIVE</code> <code>int</code> <p>1</p>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.PowerUpState","title":"PowerUpState","text":"<p>               Bases: <code>IntEnum</code></p> <p>Temperature control state from power up.</p> <p>Attributes:</p> Name Type Description <code>OFF</code> <code>int</code> <p>0</p> <code>ON</code> <code>int</code> <p>1</p> <code>LAST</code> <code>int</code> <p>2 (same as the last setting prior to power off)</p>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.Sensor","title":"Sensor  <code>dataclass</code>","text":"<pre><code>Sensor(\n    type: SensorType,\n    x2: float,\n    x: float,\n    c: float,\n    unit: Unit,\n    averaging: bool,\n    r: float = 22000.0,\n)\n</code></pre> <p>Sensor parameters.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>SensorType</code> <p>Sensor type.</p> required <code>x2</code> <code>float</code> <p>See <code>c</code> description.</p> required <code>x</code> <code>float</code> <p>See <code>c</code> description.</p> required <code>c</code> <code>float</code> <p>The <code>x2</code>, <code>x</code> and <code>c</code> parameters are the quadratic, linear and constant coefficients that are used to convert the sensor voltage into a temperature, i.e., <code>temperature = (v * v * x2) + (v * x) + c</code>, where <code>v</code> is the measured sensor voltage. For NTC thermistors, <code>x2</code> is the beta value as specified for the thermistor type, <code>x</code> is the resistance at \\(25~^\\circ\\text{C}\\), and <code>c</code> is still the offset.</p> required <code>unit</code> <code>Unit</code> <p>The temperature unit.</p> required <code>averaging</code> <code>bool</code> <p>Whether to enable or disable averaging.</p> required <code>r</code> <code>float</code> <p>Used for NTC or RES sensors and corresponds to the RL drive resistance.</p> <code>22000.0</code>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.SensorType","title":"SensorType","text":"<p>               Bases: <code>IntEnum</code></p> <p>Sensor type.</p> <p>Attributes:</p> Name Type Description <code>VOLTAGE</code> <code>int</code> <p>0</p> <code>PT100</code> <code>int</code> <p>1</p> <code>LM35</code> <code>int</code> <p>2</p> <code>LM50</code> <code>int</code> <p>3</p> <code>LM60</code> <code>int</code> <p>4</p> <code>LM61</code> <code>int</code> <p>5</p> <code>NTC_THERMISTOR</code> <code>int</code> <p>6</p> <code>RES</code> <code>int</code> <p>7</p> <code>PT1000</code> <code>int</code> <p>8</p> <code>RTD</code> <code>int</code> <p>9</p>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.Setpoint","title":"Setpoint  <code>dataclass</code>","text":"<pre><code>Setpoint(\n    method: Method,\n    value: float,\n    pot_range: float,\n    pot_offset: float,\n)\n</code></pre> <p>The setpoint parameters.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Method</code> <p>The setpoint method.</p> required <code>value</code> <code>float</code> <p>The setpoint value.</p> required <code>pot_range</code> <code>float</code> <p>The temperature range of the potentiometer.</p> required <code>pot_offset</code> <code>float</code> <p>The minimum temperature value of the potentiometer.</p> required"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.Status","title":"Status  <code>dataclass</code>","text":"<pre><code>Status(\n    setpoint: float,\n    temperature: float,\n    controlled: bool,\n    output: float,\n    alarm_type: AlarmType,\n    faults: int,\n    temp_ok: bool,\n    supply_v: float,\n    version: str,\n    test_cycles: float,\n    test_mode_completed: bool,\n)\n</code></pre> <p>Controller status.</p> <p>Parameters:</p> Name Type Description Default <code>setpoint</code> <code>float</code> <p>Setpoint value.</p> required <code>temperature</code> <code>float</code> <p>The measured temperature (for the specified Sensor Unit).</p> required <code>controlled</code> <code>bool</code> <p>Whether the temperature control drive is on or off.</p> required <code>output</code> <code>float</code> <p>The output value (between -100 and 100).</p> required <code>alarm_type</code> <code>AlarmType</code> <p>The type of alarm used.</p> required <code>faults</code> <code>int</code> <p>Fault flags.</p> <ul> <li>bit 0: ADC fault.</li> <li>bit 1: ADCR fault.</li> <li>bit 2: VDC limit.</li> <li>bit 3: Temperature limit.</li> <li>bit 4: Inhibited.</li> </ul> required <code>temp_ok</code> <code>bool</code> <p>Whether the temperature is ok (within range).</p> required <code>supply_v</code> <code>float</code> <p>The supply voltage.</p> required <code>version</code> <code>str</code> <p>The firmware version number of the controller.</p> required <code>test_cycles</code> <code>float</code> <p>The number of test cycles that have occurred.</p> required <code>test_mode_completed</code> <code>bool</code> <p>Whether the test has completed.</p> required"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries","title":"TCSeries","text":"<pre><code>TCSeries(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Serial</code></p> <p>Establishes a connection to a TC Series Temperature Controller from Electron Dynamics Ltd.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Establishes a connection to a TC Series Temperature Controller from Electron Dynamics Ltd.\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"\n    assert equipment.connection is not None  # noqa: S101\n    if not equipment.connection.properties:\n        # then use the default connection properties\n        equipment.connection.properties = {\n            \"baud_rate\": 19200,\n            \"write_termination\": None,\n            \"read_termination\": \"\\r\\n\",\n            \"timeout\": 10.0,\n        }\n    super().__init__(equipment)\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries.get_alarm","title":"get_alarm","text":"<pre><code>get_alarm() -&gt; Alarm\n</code></pre> <p>Get the alarm parameters.</p> <p>Returns:</p> Type Description <code>Alarm</code> <p>The alarm parameters.</p> Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def get_alarm(self) -&gt; Alarm:\n    \"\"\"Get the alarm parameters.\n\n    Returns:\n        The alarm parameters.\n    \"\"\"\n    a, b, c, d, e, f, g = map(float, self._reply(\"d\"))\n    return Alarm(\n        type=AlarmType(int(a)),\n        alarm_min=b,\n        alarm_max=c,\n        ok_min=d,\n        ok_max=e,\n        limit_min=f,\n        limit_max=g,\n    )\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries.get_control","title":"get_control","text":"<pre><code>get_control() -&gt; Control\n</code></pre> <p>Get the PID control parameters.</p> <p>Returns:</p> Type Description <code>Control</code> <p>The control parameters.</p> Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def get_control(self) -&gt; Control:\n    \"\"\"Get the PID control parameters.\n\n    Returns:\n        The control parameters.\n    \"\"\"\n    a, b, c, d, e, f, g = map(float, self._reply(\"b\"))\n    return Control(\n        type=ControlType(int(a)),\n        p=b,\n        i=c,\n        d=d,\n        d_filter=e,\n        dead_band=f,\n        power_up_state=PowerUpState(int(g)),\n    )\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries.get_output","title":"get_output","text":"<pre><code>get_output() -&gt; Output\n</code></pre> <p>Get the output parameters.</p> <p>Returns:</p> Type Description <code>Output</code> <p>The output parameters.</p> Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def get_output(self) -&gt; Output:\n    \"\"\"Get the output parameters.\n\n    Returns:\n        The output parameters.\n    \"\"\"\n    a, b, c, d = map(float, self._reply(\"h\"))\n    return Output(\n        polarity=Polarity(int(a)),\n        minimum=b,\n        maximum=c,\n        frequency=d,\n    )\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries.get_sensor","title":"get_sensor","text":"<pre><code>get_sensor() -&gt; Sensor\n</code></pre> <p>Get the sensor parameters.</p> <p>Returns:</p> Type Description <code>Sensor</code> <p>The sensor parameters.</p> Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def get_sensor(self) -&gt; Sensor:\n    \"\"\"Get the sensor parameters.\n\n    Returns:\n        The sensor parameters.\n    \"\"\"\n    data = list(map(float, self._reply(\"f\")))\n    return Sensor(\n        type=SensorType(int(data[0])),\n        x2=data[1],\n        x=data[2],\n        c=data[3],\n        unit=Unit(data[4]),\n        averaging=data[5] == 1,\n        r=0.0 if len(data) &lt; 7 else data[6],  # noqa: PLR2004\n    )\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries.get_setpoint","title":"get_setpoint","text":"<pre><code>get_setpoint() -&gt; Setpoint\n</code></pre> <p>Get the setpoint parameters.</p> <p>Returns:</p> Type Description <code>Setpoint</code> <p>The setpoint parameters.</p> Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def get_setpoint(self) -&gt; Setpoint:\n    \"\"\"Get the setpoint parameters.\n\n    Returns:\n        The setpoint parameters.\n    \"\"\"\n    a, b, c, d = map(float, self._reply(\"q\"))\n    return Setpoint(\n        method=Method(int(a)),\n        value=b,\n        pot_range=c,\n        pot_offset=d,\n    )\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries.get_status","title":"get_status","text":"<pre><code>get_status() -&gt; Status\n</code></pre> <p>Get the status.</p> <p>Returns:</p> Type Description <code>Status</code> <p>The status parameters.</p> Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def get_status(self) -&gt; Status:\n    \"\"\"Get the status.\n\n    Returns:\n        The status parameters.\n    \"\"\"\n    r = self._reply(\"j\")\n    return Status(\n        setpoint=float(r[0]),\n        temperature=float(r[1]),\n        controlled=r[2] == \"1\",\n        output=float(r[3]),\n        alarm_type=AlarmType(int(r[4])),\n        faults=int(r[5]),\n        temp_ok=r[6] == \"1\",\n        supply_v=float(r[7]),\n        version=r[8],\n        test_cycles=int(r[9]),\n        test_mode_completed=r[10] == \"1\",\n    )\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries.set_alarm","title":"set_alarm","text":"<pre><code>set_alarm(alarm: Alarm) -&gt; None\n</code></pre> <p>Set the alarm parameters.</p> <p>Parameters:</p> Name Type Description Default <code>alarm</code> <code>Alarm</code> <p>The alarm parameters.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def set_alarm(self, alarm: Alarm) -&gt; None:\n    \"\"\"Set the alarm parameters.\n\n    Args:\n        alarm: The alarm parameters.\n    \"\"\"\n    data = (\n        f\"{alarm.type};{alarm.alarm_min:.3f};{alarm.alarm_max:.3f};{alarm.ok_min:.3f};\"\n        f\"{alarm.ok_max:.3f};{alarm.limit_min:.3f};{alarm.limit_max:.3f};\"\n    )\n    self._send(\"c\", data)\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries.set_control","title":"set_control","text":"<pre><code>set_control(control: Control) -&gt; None\n</code></pre> <p>Set the PID control parameters.</p> <p>Parameters:</p> Name Type Description Default <code>control</code> <code>Control</code> <p>The control parameters.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def set_control(self, control: Control) -&gt; None:\n    \"\"\"Set the PID control parameters.\n\n    Args:\n        control: The control parameters.\n    \"\"\"\n    data = (\n        f\"{control.type};{control.p:.3f};{control.i:.3f};{control.d:.3f};\"\n        f\"{control.d_filter:.3f};{control.dead_band:.3f};{control.power_up_state};\"\n    )\n    self._send(\"a\", data)\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries.set_output","title":"set_output","text":"<pre><code>set_output(output: Output) -&gt; None\n</code></pre> <p>Set the output parameters.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>Output</code> <p>The output parameters.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def set_output(self, output: Output) -&gt; None:\n    \"\"\"Set the output parameters.\n\n    Args:\n        output: The output parameters.\n    \"\"\"\n    data = f\"{output.polarity};{output.minimum:.3f};{output.maximum:.3f};{output.frequency:.3f};\"\n    self._send(\"g\", data)\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries.set_output_drive","title":"set_output_drive","text":"<pre><code>set_output_drive(*, enable: bool, value: float) -&gt; None\n</code></pre> <p>Set the output drive state and value.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>Whether to enable or disable the output drive.</p> required <code>value</code> <code>float</code> <p>Percent drive output.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def set_output_drive(self, *, enable: bool, value: float) -&gt; None:\n    \"\"\"Set the output drive state and value.\n\n    Args:\n        enable: Whether to enable or disable the output drive.\n        value: Percent drive output.\n    \"\"\"\n    self._send(\"m\", f\"{int(enable)};{value:.3f};\")\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries.set_sensor","title":"set_sensor","text":"<pre><code>set_sensor(sensor: Sensor) -&gt; None\n</code></pre> <p>Set the sensor type and the sensor parameters.</p> <p>Parameters:</p> Name Type Description Default <code>sensor</code> <code>Sensor</code> <p>The sensor parameters.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def set_sensor(self, sensor: Sensor) -&gt; None:\n    \"\"\"Set the sensor type and the sensor parameters.\n\n    Args:\n        sensor: The sensor parameters.\n    \"\"\"\n    data = f\"{sensor.type};{sensor.x2:.3f};{sensor.x:.3f};{sensor.c:.3f};{sensor.unit};{int(sensor.averaging)};\"\n    if sensor.type in (SensorType.NTC_THERMISTOR, SensorType.RES):\n        data += f\"{sensor.r:.3f};\"\n    self._send(\"e\", data)\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries.set_setpoint","title":"set_setpoint","text":"<pre><code>set_setpoint(setpoint: Setpoint) -&gt; None\n</code></pre> <p>Set the setpoint parameters.</p> <p>Parameters:</p> Name Type Description Default <code>setpoint</code> <code>Setpoint</code> <p>The setpoint parameters.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def set_setpoint(self, setpoint: Setpoint) -&gt; None:\n    \"\"\"Set the setpoint parameters.\n\n    Args:\n        setpoint: The setpoint parameters.\n    \"\"\"\n    data = f\"{setpoint.method};{setpoint.value:.3f};{setpoint.pot_range:.3f};{setpoint.pot_offset:.3f};\"\n    self._send(\"i\", data)\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.TCSeries.set_test","title":"set_test","text":"<pre><code>set_test(mode: int, *data: float) -&gt; None\n</code></pre> <p>Set the test parameters.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>int</code> <p>The test mode. One of:</p> <ul> <li><code>0</code>: Off</li> <li><code>1</code>: Normal</li> <li><code>2</code>: Temperature cycle</li> <li><code>3</code>: Temperature ramp</li> <li><code>4</code>: Auto tune</li> </ul> required <code>data</code> <code>float</code> <p>The test data.</p> <code>()</code> Source code in <code>packages/resources/src/msl/equipment_resources/electron_dynamics/tc_series.py</code> <pre><code>def set_test(self, mode: int, *data: float) -&gt; None:\n    \"\"\"Set the test parameters.\n\n    Args:\n        mode: The test mode. One of:\n\n            * `0`: Off\n            * `1`: Normal\n            * `2`: Temperature cycle\n            * `3`: Temperature ramp\n            * `4`: Auto tune\n\n        data: The test data.\n    \"\"\"\n    if mode &lt; 0 or mode &gt; 4:  # noqa: PLR2004\n        msg = f\"Invalid test mode={mode}. Must be 0, 1, 2, 3 or 4\"\n        raise ValueError(msg)\n\n    values = \";\".join(f\"{v:.3f}\" for v in data)\n    self._send(\"k\", f\"{mode};{values};\")\n</code></pre>"},{"location":"resources/electron_dynamics/tc_series/#msl.equipment_resources.electron_dynamics.tc_series.Unit","title":"Unit","text":"<p>               Bases: <code>Enum</code></p> <p>The temperature unit.</p> <p>Attributes:</p> Name Type Description <code>C</code> <code>str</code> <p>Celsius, <code>\"C\"</code>.</p> <code>F</code> <code>str</code> <p>Fahrenheit, <code>\"F\"</code>.</p> <code>K</code> <code>str</code> <p>Kelvin, <code>\"K\"</code>.</p> <code>V</code> <code>str</code> <p>Voltage, <code>\"V\"</code>.</p> <code>R</code> <code>str</code> <p>Resistance, <code>\"R\"</code>.</p>"},{"location":"resources/energetiq/eq99/","title":"EQ-99","text":"<p>Communicate with the EQ-99 Manager from Energetiq.</p>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99","title":"EQ99","text":"<pre><code>EQ99(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Serial</code></p> <p>Communicate with the EQ-99 Manager from Energetiq.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Communicate with the EQ-99 Manager from Energetiq.\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"\n    assert equipment.connection is not None  # noqa: S101\n    equipment.connection.properties.setdefault(\"baud_rate\", 38400)\n    super().__init__(equipment)\n    self.rstrip: bool = True\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.condition_register","title":"condition_register","text":"<pre><code>condition_register() -&gt; int\n</code></pre> <p>Query the LDLS condition register.</p> <p>The condition register reflects the state of the instrument at the time the condition register is read.</p> <p>The bit-mask sequence is as follows:</p> Bit Index Value Description 0 1 Interlock 1 2 Controller not detected 2 4 Controller fault 3 8 Lamp fault 4 16 Output on 5 32 Lamp on 6 64 Laser on 7 128 Laser stable 8 256 Shutter open <p>Returns:</p> Type Description <code>int</code> <p>The condition register value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def condition_register(self) -&gt; int:\n    \"\"\"Query the LDLS condition register.\n\n    The condition register reflects the state of the instrument\n    at the time the condition register is read.\n\n    The bit-mask sequence is as follows:\n\n    | Bit Index | Value | Description             |\n    | :-------: | :---: | :---------------------- |\n    |   0       |    1  | Interlock               |\n    |   1       |    2  | Controller not detected |\n    |   2       |    4  | Controller fault        |\n    |   3       |    8  | Lamp fault              |\n    |   4       |   16  | Output on               |\n    |   5       |   32  | Lamp on                 |\n    |   6       |   64  | Laser on                |\n    |   7       |  128  | Laser stable            |\n    |   8       |  256  | Shutter open            |\n\n    Returns:\n        The condition register value.\n    \"\"\"\n    return int(self.query(\"LDLS:COND?\"))\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.delay","title":"delay","text":"<pre><code>delay(milliseconds: int) -&gt; None\n</code></pre> <p>Specify a delay to use in command processing.</p> <p>Parameters:</p> Name Type Description Default <code>milliseconds</code> <code>int</code> <p>Causes command processing to be delayed for the specified number of milliseconds. Valid range is from 1 to 30000 milliseconds.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def delay(self, milliseconds: int) -&gt; None:\n    \"\"\"Specify a delay to use in command processing.\n\n    Args:\n        milliseconds: Causes command processing to be delayed for the specified number\n            of milliseconds. Valid range is from 1 to 30000 milliseconds.\n    \"\"\"\n    if not (1 &lt;= milliseconds &lt;= MAX_TIME):\n        msg = f\"Invalid delay of {milliseconds} milliseconds, must be in the range [1, {MAX_TIME}]\"\n        raise ValueError(msg)\n    self._write_check(f\"DELAY {milliseconds}\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.event_register","title":"event_register","text":"<pre><code>event_register() -&gt; int\n</code></pre> <p>Query the LDLS event register.</p> <p>Returns the LDLS event register. The event register reflects the occurrence of any condition since the last time the event register was read. For example, if the output was turned on and then turned off, the Output on the bit in the condition register will be zero, but the same bit in the event register will be one.</p> <p>The bit-mask sequence is as follows:</p> Bit Index Value Description 0 1 Interlock 1 2 Controller not detected 2 4 Controller fault 3 8 Lamp fault 4 16 Output on 5 32 Lamp on 6 64 Laser on 7 128 Laser stable 8 256 Shutter open <p>Returns:</p> Type Description <code>int</code> <p>The event register value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def event_register(self) -&gt; int:\n    \"\"\"Query the LDLS event register.\n\n    Returns the LDLS event register. The event register reflects the\n    occurrence of any condition since the last time the event register\n    was read. For example, if the output was turned on and then turned off,\n    the Output on the bit in the condition register will be zero, but the\n    same bit in the event register will be one.\n\n    The bit-mask sequence is as follows:\n\n    | Bit Index | Value | Description             |\n    | :-------: | :---: | :---------------------- |\n    |   0       |    1  | Interlock               |\n    |   1       |    2  | Controller not detected |\n    |   2       |    4  | Controller fault        |\n    |   3       |    8  | Lamp fault              |\n    |   4       |   16  | Output on               |\n    |   5       |   32  | Lamp on                 |\n    |   6       |   64  | Laser on                |\n    |   7       |  128  | Laser stable            |\n    |   8       |  256  | Shutter open            |\n\n    Returns:\n        The event register value.\n    \"\"\"\n    return int(self.query(\"LDLS:EVENT?\"))\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.get_beep","title":"get_beep","text":"<pre><code>get_beep() -&gt; bool\n</code></pre> <p>Query whether beeps are enabled.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether beeps are enabled.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def get_beep(self) -&gt; bool:\n    \"\"\"Query whether beeps are enabled.\n\n    Returns:\n        Whether beeps are enabled.\n    \"\"\"\n    return bool(int(self.query(\"BEEP?\")))\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.get_brightness","title":"get_brightness","text":"<pre><code>get_brightness() -&gt; int\n</code></pre> <p>Query the display brightness.</p> <p>Returns:</p> Type Description <code>int</code> <p>Returns the value of the display brightness (between 0 and 100).</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def get_brightness(self) -&gt; int:\n    \"\"\"Query the display brightness.\n\n    Returns:\n        Returns the value of the display brightness (between 0 and 100).\n    \"\"\"\n    return int(self.query(\"BRIGHT?\"))\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.get_exposure_mode","title":"get_exposure_mode","text":"<pre><code>get_exposure_mode() -&gt; int\n</code></pre> <p>Query the exposure mode.</p> <p>Returns:</p> Type Description <code>int</code> <p>The exposure mode.</p> <ul> <li>0 \u2014 Manual mode</li> <li>1 \u2014 Exposure mode</li> </ul> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def get_exposure_mode(self) -&gt; int:\n    \"\"\"Query the exposure mode.\n\n    Returns:\n        The exposure mode.\n\n            * 0 &amp;mdash; Manual mode\n            * 1 &amp;mdash; Exposure mode\n    \"\"\"\n    return int(self.query(\"LDLS:EXPMODE?\"))\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.get_exposure_time","title":"get_exposure_time","text":"<pre><code>get_exposure_time() -&gt; int\n</code></pre> <p>Query the exposure time.</p> <p>Returns:</p> Type Description <code>int</code> <p>The exposure time, in milliseconds.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def get_exposure_time(self) -&gt; int:\n    \"\"\"Query the exposure time.\n\n    Returns:\n        The exposure time, in milliseconds.\n    \"\"\"\n    return int(self.query(\"LDLS:EXPOSURE?\"))\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.get_lamp_runtime","title":"get_lamp_runtime","text":"<pre><code>get_lamp_runtime() -&gt; float\n</code></pre> <p>Query the lamp runtime.</p> <p>Returns:</p> Type Description <code>float</code> <p>The number of hours accumulated while the lamp was on.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def get_lamp_runtime(self) -&gt; float:\n    \"\"\"Query the lamp runtime.\n\n    Returns:\n        The number of hours accumulated while the lamp was on.\n    \"\"\"\n    return float(self.query(\"LDLS:LAMPTIME?\"))\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.get_message_buffer","title":"get_message_buffer","text":"<pre><code>get_message_buffer() -&gt; str\n</code></pre> <p>Query the internal message buffer.</p> <p>Returns:</p> Type Description <code>str</code> <p>The value of the internal message buffer.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def get_message_buffer(self) -&gt; str:\n    \"\"\"Query the internal message buffer.\n\n    Returns:\n        The value of the internal message buffer.\n    \"\"\"\n    return self.query(\"MESSAGE?\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.get_output_state","title":"get_output_state","text":"<pre><code>get_output_state() -&gt; bool\n</code></pre> <p>Query the output state.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the output is enabled or disabled.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def get_output_state(self) -&gt; bool:\n    \"\"\"Query the output state.\n\n    Returns:\n        Whether the output is enabled or disabled.\n    \"\"\"\n    return bool(int(self.query(\"LDLS:OUTPUT?\")))\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.get_remote_mode_error","title":"get_remote_mode_error","text":"<pre><code>get_remote_mode_error() -&gt; bool\n</code></pre> <p>Query whether errors are displayed while in remote mode.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether errors are displayed while in remote mode.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def get_remote_mode_error(self) -&gt; bool:\n    \"\"\"Query whether errors are displayed while in remote mode.\n\n    Returns:\n        Whether errors are displayed while in remote mode.\n    \"\"\"\n    return bool(int(self.query(\"REMERR?\")))\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.get_shutter_power_up_state","title":"get_shutter_power_up_state","text":"<pre><code>get_shutter_power_up_state() -&gt; bool\n</code></pre> <p>Query the power-up shutter state.</p> <p>Returns:</p> Type Description <code>bool</code> <p>The power-up shutter state.</p> <ul> <li><code>False</code> \u2014 Shutter is closed on power-up</li> <li><code>True</code> \u2014 Shutter is open on power-up</li> </ul> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def get_shutter_power_up_state(self) -&gt; bool:\n    \"\"\"Query the power-up shutter state.\n\n    Returns:\n        The power-up shutter state.\n\n            * `False` &amp;mdash; Shutter is closed on power-up\n            * `True` &amp;mdash; Shutter is open on power-up\n    \"\"\"\n    return bool(int(self.query(\"LDLS:SHUTINIT?\")))\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.get_shutter_state","title":"get_shutter_state","text":"<pre><code>get_shutter_state() -&gt; bool\n</code></pre> <p>Query the shutter state.</p> <p>Returns:</p> Type Description <code>bool</code> <p>The state of the shutter.</p> <ul> <li><code>False</code> \u2014 Shutter is closed</li> <li><code>True</code> \u2014 Shutter is open</li> </ul> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def get_shutter_state(self) -&gt; bool:\n    \"\"\"Query the shutter state.\n\n    Returns:\n        The state of the shutter.\n\n            * `False` &amp;mdash; Shutter is closed\n            * `True` &amp;mdash; Shutter is open\n    \"\"\"\n    return bool(int(self.query(\"LDLS:SHUTTER?\")))\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.get_termination","title":"get_termination","text":"<pre><code>get_termination() -&gt; int\n</code></pre> <p>Query response terminator.</p> <p>Returns the current response terminator setting. See set_termination for possible return values.</p> <p>Returns:</p> Type Description <code>int</code> <p>The response terminator.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def get_termination(self) -&gt; int:\n    \"\"\"Query response terminator.\n\n    Returns the current response terminator setting. See\n    [set_termination][msl.equipment_resources.energetiq.eq99.EQ99.set_termination]\n    for possible return values.\n\n    Returns:\n        The response terminator.\n    \"\"\"\n    return int(self.query(\"TERM?\"))\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.get_trigger_mode","title":"get_trigger_mode","text":"<pre><code>get_trigger_mode() -&gt; int\n</code></pre> <p>Query the trigger mode.</p> <p>Returns:</p> Type Description <code>int</code> <p>The trigger mode. See set_trigger_mode for more details.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def get_trigger_mode(self) -&gt; int:\n    \"\"\"Query the trigger mode.\n\n    Returns:\n        The trigger mode. See [set_trigger_mode][msl.equipment_resources.energetiq.eq99.EQ99.set_trigger_mode]\n            for more details.\n    \"\"\"\n    return int(self.query(\"LDLS:TRIGMODE?\"))\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.identity","title":"identity","text":"<pre><code>identity() -&gt; str\n</code></pre> <p>Query the instrument identification.</p> <p>Returns:</p> Type Description <code>str</code> <p>Returns the identification string for the instrument in the following format: Energetiq Model SN Ver Build</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def identity(self) -&gt; str:\n    \"\"\"Query the instrument identification.\n\n    Returns:\n        Returns the identification string for the instrument in the following format:\n            *Energetiq Model SN Ver Build*\n    \"\"\"\n    return self.query(\"*IDN?\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Resets the instrument to factory defaults and the output is shut off.</p> <p>The unit remains in remote mode.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Resets the instrument to factory defaults and the output is shut off.\n\n    The unit remains in remote mode.\n    \"\"\"\n    _ = self._write_check(\"*RST\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.serial_number","title":"serial_number","text":"<pre><code>serial_number() -&gt; str\n</code></pre> <p>Query the serial number of the instrument.</p> <p>Returns:</p> Type Description <code>str</code> <p>The serial number of the instrument. This is the same information that is part of the <code>*IDN?</code> query.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def serial_number(self) -&gt; str:\n    \"\"\"Query the serial number of the instrument.\n\n    Returns:\n        The serial number of the instrument. This is the same information that is part of the `*IDN?` query.\n    \"\"\"\n    return self.query(\"SN?\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.set_beep","title":"set_beep","text":"<pre><code>set_beep(beep: bool | int = 2) -&gt; None\n</code></pre> <p>Set the beep value.</p> <p>Parameters:</p> Name Type Description Default <code>beep</code> <code>bool | int</code> <p>Causes the instrument to beep, or enables or disabled the beep sound for error messages and other events that generate and audible response.</p> <ul> <li>0 or <code>False</code> \u2014 Disable the beep sound</li> <li>1 or <code>True</code> \u2014 Enable the beep sound</li> <li>2 \u2014 Generate one beep</li> </ul> <code>2</code> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def set_beep(self, beep: bool | int = 2) -&gt; None:  # noqa: FBT001\n    \"\"\"Set the beep value.\n\n    Args:\n        beep: Causes the instrument to beep, or enables or disabled the beep\n            sound for error messages and other events that generate and\n            audible response.\n\n            * 0 or `False` &amp;mdash; Disable the beep sound\n            * 1 or `True` &amp;mdash; Enable the beep sound\n            * 2 &amp;mdash; Generate one beep\n    \"\"\"\n    if beep not in [0, 1, 2, True, False]:\n        msg = f\"Invalid beep value '{beep}'\"\n        raise MSLConnectionError(self, msg)\n    self._write_check(f\"BEEP {beep}\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.set_brightness","title":"set_brightness","text":"<pre><code>set_brightness(brightness: int) -&gt; None\n</code></pre> <p>Set the display brightness.</p> <p>Parameters:</p> Name Type Description Default <code>brightness</code> <code>int</code> <p>Sets the display brightness level from 0 to 100 percent. There are only 8 brightness levels (each separated by about 12.5 percent) and the brightness value is used to select an appropriate level.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def set_brightness(self, brightness: int) -&gt; None:\n    \"\"\"Set the display brightness.\n\n    Args:\n        brightness: Sets the display brightness level from 0 to 100 percent.\n            There are only 8 brightness levels (each separated by about\n            12.5 percent) and the brightness value is used to select an\n            appropriate level.\n    \"\"\"\n    self._write_check(f\"BRIGHT {int(brightness)}\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.set_exposure_mode","title":"set_exposure_mode","text":"<pre><code>set_exposure_mode(mode: int) -&gt; None\n</code></pre> <p>Set the exposure mode.</p> <p>Same as the Shutter setting in the menu.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>int</code> <p>The exposure mode.</p> <ul> <li>0 \u2014 Manual mode</li> <li>1 \u2014 Exposure mode</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def set_exposure_mode(self, mode: int) -&gt; None:\n    \"\"\"Set the exposure mode.\n\n    Same as the *Shutter* setting in the menu.\n\n    Args:\n        mode: The exposure mode.\n\n            * 0 &amp;mdash; Manual mode\n            * 1 &amp;mdash; Exposure mode\n    \"\"\"\n    self._write_check(f\"LDLS:EXPMODE {mode}\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.set_exposure_time","title":"set_exposure_time","text":"<pre><code>set_exposure_time(milliseconds: int) -&gt; None\n</code></pre> <p>Set the exposure time.</p> <p>Exposure time is used when the shutter exposure mode is set to <code>Exposure mode</code> (see set_exposure_mode). An exposure is triggered by a shutter button press or the shutter trigger input.</p> <p>Parameters:</p> Name Type Description Default <code>milliseconds</code> <code>int</code> <p>The exposure time, in milliseconds, from 100 to 30000 ms.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def set_exposure_time(self, milliseconds: int) -&gt; None:\n    \"\"\"Set the exposure time.\n\n    Exposure time is used when the shutter exposure mode is set to `Exposure mode`\n    (see [set_exposure_mode][msl.equipment_resources.energetiq.eq99.EQ99.set_exposure_mode]).\n    An exposure is triggered by a shutter button press or the shutter trigger input.\n\n    Args:\n        milliseconds: The exposure time, in milliseconds, from 100 to 30000 ms.\n    \"\"\"\n    if not (MIN_EXPOSURE_TIME &lt;= milliseconds &lt;= MAX_TIME):\n        msg = (\n            f\"Invalid exposure time of {milliseconds} milliseconds, \"\n            f\"must be in the range [{MIN_EXPOSURE_TIME}, {MAX_TIME}]\"\n        )\n        raise ValueError(msg)\n    self._write_check(f\"LDLS:EXPOSURE {milliseconds}\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.set_lamp_runtime","title":"set_lamp_runtime","text":"<pre><code>set_lamp_runtime(hours: float) -&gt; None\n</code></pre> <p>Set the lamp runtime.</p> <p>Resets the runtime to the new value. Useful for resetting the runtime to zero when the lamp has been serviced or replaced, or when moving the manager to a new LDLS system.</p> <p>Parameters:</p> Name Type Description Default <code>hours</code> <code>float</code> <p>The lamp runtime, in hours, between 0 and 9999.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def set_lamp_runtime(self, hours: float) -&gt; None:\n    \"\"\"Set the lamp runtime.\n\n    Resets the runtime to the new value. Useful for resetting the runtime\n    to zero when the lamp has been serviced or replaced, or when moving\n    the manager to a new LDLS system.\n\n    Args:\n        hours: The lamp runtime, in hours, between 0 and 9999.\n    \"\"\"\n    if not (0 &lt;= hours &lt;= MAX_RUNTIME):\n        msg = f\"Invalid lamp runtime of {hours} hours, must be in the range [0, {MAX_RUNTIME}]\"\n        raise ValueError(msg)\n    self._write_check(f\"LDLS:LAMPTIME {hours}\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.set_message_buffer","title":"set_message_buffer","text":"<pre><code>set_message_buffer(message: str) -&gt; None\n</code></pre> <p>Set the message buffer.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Sets the internal message buffer, up to a maximum of 16 characters. If more than 16 characters are specified then the additional characters are silently ignored.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def set_message_buffer(self, message: str) -&gt; None:\n    \"\"\"Set the message buffer.\n\n    Args:\n        message: Sets the internal message buffer, up to a maximum of 16 characters. If more than\n            16 characters are specified then the additional characters are silently ignored.\n    \"\"\"\n    self._write_check(f\"MESSAGE {message}\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.set_output_state","title":"set_output_state","text":"<pre><code>set_output_state(enable: bool) -&gt; None\n</code></pre> <p>Turn the output on or off.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>Whether to enable or disable the output.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def set_output_state(self, enable: bool) -&gt; None:  # noqa: FBT001\n    \"\"\"Turn the output on or off.\n\n    Args:\n        enable: Whether to enable or disable the output.\n    \"\"\"\n    self._write_check(f\"LDLS:OUTPUT {enable}\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.set_remote_mode_error","title":"set_remote_mode_error","text":"<pre><code>set_remote_mode_error(enable: bool | int) -&gt; None\n</code></pre> <p>Set whether to display errors while in remote mode.</p> <p>This command controls if the instrument will display errors while in remote mode. If set to <code>0</code>/<code>False</code>, then errors will not be displayed. If set to <code>1</code>/<code>True</code>, errors will be displayed. Errors will always accumulate in the error queue.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool | int</code> <p>Whether to display errors while in remote mode.</p> <ul> <li>0 or <code>False</code> \u2014 Do not display errors in remote mode</li> <li>1 or <code>True</code> \u2014 Display errors in remote mode</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def set_remote_mode_error(self, enable: bool | int) -&gt; None:  # noqa: FBT001\n    \"\"\"Set whether to display errors while in remote mode.\n\n    This command controls if the instrument will display errors while in\n    remote mode. If set to `0`/`False`, then errors will not be displayed. If\n    set to `1`/`True`, errors will be displayed. Errors will always accumulate\n    in the error queue.\n\n    Args:\n        enable: Whether to display errors while in remote mode.\n\n            * 0 or `False` &amp;mdash; Do not display errors in remote mode\n            * 1 or `True` &amp;mdash; Display errors in remote mode\n    \"\"\"\n    self._write_check(f\"REMERR {enable}\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.set_shutter_power_up_state","title":"set_shutter_power_up_state","text":"<pre><code>set_shutter_power_up_state(state: bool) -&gt; None\n</code></pre> <p>Set the power-up shutter state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>Sets the initial state of the shutter on power-up of the manager.</p> <ul> <li><code>False</code> \u2014 Shutter is closed on power-up</li> <li><code>True</code> \u2014 Shutter is open on power-up</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def set_shutter_power_up_state(self, state: bool) -&gt; None:  # noqa: FBT001\n    \"\"\"Set the power-up shutter state.\n\n    Args:\n        state: Sets the initial state of the shutter on power-up of the manager.\n\n            * `False` &amp;mdash; Shutter is closed on power-up\n            * `True` &amp;mdash; Shutter is open on power-up\n    \"\"\"\n    self._write_check(f\"LDLS:SHUTINIT {state}\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.set_shutter_state","title":"set_shutter_state","text":"<pre><code>set_shutter_state(state: bool) -&gt; None\n</code></pre> <p>Open, close, or trigger the shutter.</p> <p>A close command (state is <code>False</code>) will always close the shutter, regardless of exposure mode. An open command (state is <code>True</code>) will open the shutter if exposure mode is set to Manual, or trigger a shutter if exposure mode is set to Exposure.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>The state of the shutter.</p> <ul> <li><code>False</code> \u2014 Close the shutter</li> <li><code>True</code> \u2014 Open or trigger the shutter</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def set_shutter_state(self, state: bool) -&gt; None:  # noqa: FBT001\n    \"\"\"Open, close, or trigger the shutter.\n\n    A close command (state is `False`) will always close the shutter,\n    regardless of exposure mode. An open command (state is `True`)\n    will open the shutter if exposure mode is set to *Manual*, or\n    trigger a shutter if exposure mode is set to *Exposure*.\n\n    Args:\n        state: The state of the shutter.\n\n            * `False` &amp;mdash; Close the shutter\n            * `True` &amp;mdash; Open or trigger the shutter\n    \"\"\"\n    self._write_check(f\"LDLS:SHUTTER {state}\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.set_termination","title":"set_termination","text":"<pre><code>set_termination(value: int) -&gt; None\n</code></pre> <p>Set the response terminator character(s).</p> <p>This command controls the termination characters used for responses to queries.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The response terminator character(s).</p> <ul> <li>0 or 1 \u2014 <code>&lt;CR&gt;&lt;LF&gt;</code></li> <li>2 or 3 \u2014 <code>&lt;CR&gt;</code></li> <li>4 or 5 \u2014 <code>&lt;LF&gt;</code></li> <li>6 or 7 \u2014 no terminator</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def set_termination(self, value: int) -&gt; None:\n    \"\"\"Set the response terminator character(s).\n\n    This command controls the termination characters used for\n    responses to queries.\n\n    Args:\n        value: The response terminator character(s).\n\n            * 0 or 1 &amp;mdash; `&lt;CR&gt;&lt;LF&gt;`\n            * 2 or 3 &amp;mdash; `&lt;CR&gt;`\n            * 4 or 5 &amp;mdash; `&lt;LF&gt;`\n            * 6 or 7 &amp;mdash; no terminator\n    \"\"\"\n    self._write_check(f\"TERM {value}\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.set_trigger_mode","title":"set_trigger_mode","text":"<pre><code>set_trigger_mode(mode: int) -&gt; None\n</code></pre> <p>Set the trigger mode.</p> <p>The trigger mode controls how the shutter trigger input controls the operation of the shutter. For more information on trigger modes, see Shutter Operation in the Operating the Instrument section of the manual for more details.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>int</code> <p>The trigger mode.</p> <ul> <li>0 \u2014 Positive edge trigger</li> <li>1 \u2014 Negative edge trigger</li> <li>2 \u2014 Positive level trigger</li> <li>3 \u2014 Negative level trigger</li> <li>4 \u2014 Off (trigger disabled)</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def set_trigger_mode(self, mode: int) -&gt; None:\n    \"\"\"Set the trigger mode.\n\n    The trigger mode controls how the shutter trigger input controls the\n    operation of the shutter. For more information on trigger modes, see\n    *Shutter Operation* in the *Operating the Instrument* section of the\n    manual for more details.\n\n    Args:\n        mode: The trigger mode.\n\n            * 0 &amp;mdash; Positive edge trigger\n            * 1 &amp;mdash; Negative edge trigger\n            * 2 &amp;mdash; Positive level trigger\n            * 3 &amp;mdash; Negative level trigger\n            * 4 &amp;mdash; Off (trigger disabled)\n    \"\"\"\n    self._write_check(f\"LDLS:TRIGMODE {mode}\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.timer","title":"timer","text":"<pre><code>timer() -&gt; str\n</code></pre> <p>Query the elapsed time since the last time this method was called.</p> <p>Returns:</p> Type Description <code>str</code> <p>Returns the elapsed time since the last time this method was called, or, if this is the first time calling this method then the time since unit has been turned on. Format is in HH:MM:SS.ss, where HH is hours, MM is minutes, SS is seconds, and ss is hundredths of a second.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def timer(self) -&gt; str:\n    \"\"\"Query the elapsed time since the last time this method was called.\n\n    Returns:\n        Returns the elapsed time since the last time this method was\n            called, or, if this is the first time calling this method\n            then the time since unit has been turned on. Format is in\n            HH:MM:SS.ss, where HH is hours, MM is minutes, SS is seconds,\n            and ss is hundredths of a second.\n    \"\"\"\n    return self.query(\"TIMER?\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.unit_runtime","title":"unit_runtime","text":"<pre><code>unit_runtime() -&gt; str\n</code></pre> <p>Query unit run time.</p> <p>Returns:</p> Type Description <code>str</code> <p>Returns the elapsed time since the unit has been turned on. Format is in HH:MM:SS.ss, where HH is hours, MM is minutes, SS is seconds, and ss is hundredths of a second.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def unit_runtime(self) -&gt; str:\n    \"\"\"Query unit run time.\n\n    Returns:\n        Returns the elapsed time since the unit has been turned on.\n            Format is in HH:MM:SS.ss, where HH is hours, MM is minutes,\n            SS is seconds, and ss is hundredths of a second.\n    \"\"\"\n    return self.query(\"TIME?\")\n</code></pre>"},{"location":"resources/energetiq/eq99/#msl.equipment_resources.energetiq.eq99.EQ99.version","title":"version","text":"<pre><code>version() -&gt; str\n</code></pre> <p>Query the firmware version.</p> <p>Returns:</p> Type Description <code>str</code> <p>Returns the firmware version. This is the same information that is part of the <code>*IDN?</code> query.</p> Source code in <code>packages/resources/src/msl/equipment_resources/energetiq/eq99.py</code> <pre><code>def version(self) -&gt; str:\n    \"\"\"Query the firmware version.\n\n    Returns:\n        Returns the firmware version. This is the same information that is part of the `*IDN?` query.\n    \"\"\"\n    return self.query(\"VER?\")\n</code></pre>"},{"location":"resources/greisinger/gmh3000/","title":"GMH 3000 Series thermometer","text":"<p>Communicate with a Greisinger GMH 3000 Series thermometer.</p>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000","title":"GMH3000","text":"<pre><code>GMH3000(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Serial</code></p> <p>Communicate with a Greisinger GMH 3000 Series thermometer.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for a GMH thermometer.</p> <p>Connection Properties:</p> Name Type Description <code>gmh_address</code> <code>int</code> <p>The GMH address of the device. Default: <code>1</code></p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Communicate with a Greisinger GMH 3000 Series thermometer.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for a GMH thermometer.\n\n    Attributes: Connection Properties:\n        gmh_address (int): The GMH address of the device. _Default: `1`_\n    \"\"\"\n    assert equipment.connection is not None  # noqa: S101\n    props = equipment.connection.properties\n    props.setdefault(\"baud_rate\", 4800)\n    super().__init__(equipment)\n\n    # termination characters are not used\n    self.read_termination: None = None\n    self.write_termination: None = None\n\n    self._address: int = self._invert(int(props.get(\"gmh_address\", 1)))\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.channel_count","title":"channel_count","text":"<pre><code>channel_count() -&gt; int\n</code></pre> <p>Get the number of channels.</p> <p>Returns:</p> Type Description <code>int</code> <p>The channel count.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def channel_count(self) -&gt; int:\n    \"\"\"Get the number of channels.\n\n    Returns:\n        The channel count.\n    \"\"\"\n    reply = self._get(code=208)\n    return self._to_uint16(*reply[3:5])\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.clear_max_value","title":"clear_max_value","text":"<pre><code>clear_max_value() -&gt; float\n</code></pre> <p>Clear the maximum value stored in the device memory.</p> <p>Returns:</p> Type Description <code>float</code> <p>The current value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def clear_max_value(self) -&gt; float:\n    \"\"\"Clear the maximum value stored in the device memory.\n\n    Returns:\n        The current value.\n    \"\"\"\n    # used Wireshark with the USBPcap plugin to eavesdrop on the\n    # GMH_Transmit(1, 175, 0, 0.0, 1) call of the DLL to get the\n    # hex values and message lengths\n    code, value = self._invert(175), 1\n    _ = self.write(\n        bytes(\n            [\n                self._address,\n                0xF6,\n                self._crc(self._address, 0xF6),\n                code,\n                value,\n                self._crc(code, value),\n                0x00,\n                0xFF,\n                0x0C,\n                0x00,\n                0xFF,\n                0x0C,\n            ]\n        )\n    )\n    reply = self.read(size=12, decode=False)\n    self._check_crc(reply)\n    return self._decode32(*reply[6:8], *reply[9:11])\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.clear_min_value","title":"clear_min_value","text":"<pre><code>clear_min_value() -&gt; float\n</code></pre> <p>Clear the minimum value stored in the device memory.</p> <p>Returns:</p> Type Description <code>float</code> <p>The current value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def clear_min_value(self) -&gt; float:\n    \"\"\"Clear the minimum value stored in the device memory.\n\n    Returns:\n        The current value.\n    \"\"\"\n    # used Wireshark with the USBPcap plugin to eavesdrop on the\n    # GMH_Transmit(1, 174, 0, 0.0, 1) call of the DLL to get the\n    # hex values and message lengths\n    code, value = self._invert(174), 1\n    _ = self.write(\n        bytes(\n            [\n                self._address,\n                0xF6,\n                self._crc(self._address, 0xF6),\n                code,\n                value,\n                self._crc(code, value),\n                0x00,\n                0xFF,\n                0x0C,\n                0x00,\n                0xFF,\n                0x0C,\n            ]\n        )\n    )\n    reply = self.read(size=12, decode=False)\n    self._check_crc(reply)\n    return self._decode32(*reply[6:8], *reply[9:11])\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.display_range","title":"display_range","text":"<pre><code>display_range() -&gt; tuple[float, float]\n</code></pre> <p>Get the range of the display.</p> <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>The <code>(minimum, maximum)</code> value that the device can display.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def display_range(self) -&gt; tuple[float, float]:\n    \"\"\"Get the range of the display.\n\n    Returns:\n        The `(minimum, maximum)` value that the device can display.\n    \"\"\"\n    reply = self._get(code=200)\n    minimum = self._decode32(*reply[3:5], *reply[6:8])\n    reply = self._get(code=201)\n    maximum = self._decode32(*reply[3:5], *reply[6:8])\n    return minimum, maximum\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.firmware_version","title":"firmware_version","text":"<pre><code>firmware_version() -&gt; tuple[int, int]\n</code></pre> <p>Get the version information of the firmware.</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>The version number, version identifier.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def firmware_version(self) -&gt; tuple[int, int]:\n    \"\"\"Get the version information of the firmware.\n\n    Returns:\n        The version number, version identifier.\n    \"\"\"\n    reply = self._get(code=254)\n    return reply[4], self._invert(reply[3])\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.id_number","title":"id_number","text":"<pre><code>id_number() -&gt; str\n</code></pre> <p>Get the device ID (serial) number.</p> <p>Returns:</p> Type Description <code>str</code> <p>The ID (serial) number of the device.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def id_number(self) -&gt; str:\n    \"\"\"Get the device ID (serial) number.\n\n    Returns:\n        The ID (serial) number of the device.\n    \"\"\"\n    reply = self._get(code=12)\n    a = self._to_uint16(*reply[:2])\n    b = self._to_uint16(*reply[3:5])\n    return f\"{self._to_uint32(a, b):x}\"\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.max_value","title":"max_value","text":"<pre><code>max_value() -&gt; float\n</code></pre> <p>Get the maximum value that has been read.</p> <p>Returns:</p> Type Description <code>float</code> <p>The maximum value that has been read since the device was turned on or since clear_max_value was called.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def max_value(self) -&gt; float:\n    \"\"\"Get the maximum value that has been read.\n\n    Returns:\n        The maximum value that has been read since the device was turned on or since\n            [clear_max_value][msl.equipment_resources.greisinger.gmh3000.GMH3000.clear_max_value]\n            was called.\n    \"\"\"\n    return self._decode(self._get(code=7))\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.measurement_range","title":"measurement_range","text":"<pre><code>measurement_range() -&gt; tuple[float, float]\n</code></pre> <p>Get the measurement range.</p> <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>The <code>(minimum, maximum)</code> value that the device can measure.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def measurement_range(self) -&gt; tuple[float, float]:\n    \"\"\"Get the measurement range.\n\n    Returns:\n        The `(minimum, maximum)` value that the device can measure.\n    \"\"\"\n    reply = self._get(code=176)\n    minimum = self._decode16(*reply[3:5])\n    reply = self._get(code=177)\n    maximum = self._decode16(*reply[3:5])\n    return minimum, maximum\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.min_value","title":"min_value","text":"<pre><code>min_value() -&gt; float\n</code></pre> <p>Get the minimum value that has been read.</p> <p>Returns:</p> Type Description <code>float</code> <p>The minimum value that has been read since the device was turned on or since clear_min_value was called.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def min_value(self) -&gt; float:\n    \"\"\"Get the minimum value that has been read.\n\n    Returns:\n        The minimum value that has been read since the device was turned on or since\n            [clear_min_value][msl.equipment_resources.greisinger.gmh3000.GMH3000.clear_min_value]\n            was called.\n    \"\"\"\n    return self._decode(self._get(code=6))\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.offset_correction","title":"offset_correction","text":"<pre><code>offset_correction() -&gt; float\n</code></pre> <p>Get the offset-correction value.</p> <p>The zero point (intercept in a linear calibration equation) of the measurement will be displaced by this value to compensate for deviations in the temperature probe or in the measuring device.</p> <p>Returns:</p> Type Description <code>float</code> <p>The offset-correction value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def offset_correction(self) -&gt; float:\n    \"\"\"Get the offset-correction value.\n\n    The zero point (intercept in a linear calibration equation) of the\n    measurement will be displaced by this value to compensate for\n    deviations in the temperature probe or in the measuring device.\n\n    Returns:\n        The offset-correction value.\n    \"\"\"\n    reply = self._get(code=216)\n    return self._decode16(*reply[3:5])\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.power_off_time","title":"power_off_time","text":"<pre><code>power_off_time() -&gt; int\n</code></pre> <p>Get the power-off time.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of minutes that the device will automatically power off as soon as this time has elapsed if no key is pressed or if no interface communication takes place. A value of 0 means that power off is disabled.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def power_off_time(self) -&gt; int:\n    \"\"\"Get the power-off time.\n\n    Returns:\n        The number of minutes that the device will automatically power off as soon as\n            this time has elapsed if no key is pressed or if no interface communication\n            takes place. A value of 0 means that power off is disabled.\n    \"\"\"\n    reply = self._get(code=222)\n    return self._to_uint16(*reply[3:5])\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.resolution","title":"resolution","text":"<pre><code>resolution() -&gt; int\n</code></pre> <p>Get the measurement resolution.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of digits after the decimal point that is acquired for the measured value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def resolution(self) -&gt; int:\n    \"\"\"Get the measurement resolution.\n\n    Returns:\n        The number of digits after the decimal point that is acquired for the measured value.\n    \"\"\"\n    # The manual says to use code=204, however, using Wireshark to eavesdrop\n    # on the GMH_Transmit(address, 204, ...) DLL call the actual code sent\n    # is 0, which is the code to read the nominal value\n    reply = self._get(code=0)\n    return (self._invert(reply[0]) &gt;&gt; 3) - 15\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.scale_correction","title":"scale_correction","text":"<pre><code>scale_correction() -&gt; float\n</code></pre> <p>Get the scale-correction factor.</p> <p>The scale (slope in a linear calibration equation) of the measurement will be changed by this factor to compensate for deviations in the temperature probe or in the measuring device.</p> <p>Returns:</p> Type Description <code>float</code> <p>The scale-correction factor.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def scale_correction(self) -&gt; float:\n    \"\"\"Get the scale-correction factor.\n\n    The scale (slope in a linear calibration equation) of the measurement\n    will be changed by this factor to compensate for deviations in the\n    temperature probe or in the measuring device.\n\n    Returns:\n        The scale-correction factor.\n    \"\"\"\n    reply = self._get(code=214)\n    return self._decode16(*reply[3:5])\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.set_power_off_time","title":"set_power_off_time","text":"<pre><code>set_power_off_time(minutes: int) -&gt; int\n</code></pre> <p>Set the power-off time.</p> <p>Parameters:</p> Name Type Description Default <code>minutes</code> <code>int</code> <p>The number of minutes that the device will automatically power off as soon as this time has elapsed if no key is pressed or if no interface communication takes place. A value of 0 means that power off is disabled.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The actual power-off time that the device was set to. If you set the power-off time to a value greater than the maximum time allowed, the device automatically coerces the value to be the maximum time.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def set_power_off_time(self, minutes: int) -&gt; int:\n    \"\"\"Set the power-off time.\n\n    Args:\n        minutes: The number of minutes that the device will automatically power off\n            as soon as this time has elapsed if no key is pressed or if no interface\n            communication takes place. A value of 0 means that power off is disabled.\n\n    Returns:\n        The actual power-off time that the device was set to. If you set\n            the power-off time to a value greater than the maximum time allowed,\n            the device automatically coerces the value to be the maximum time.\n    \"\"\"\n    # used Wireshark with the USBPcap plugin to eavesdrop on the\n    # GMH_Transmit(1, 223, 0, 0.0, minutes) call of the DLL to get the\n    # hex values and message lengths\n    code = self._invert(223)\n    _ = self.write(\n        bytes(\n            [\n                self._address,\n                0xF4,\n                self._crc(self._address, 0xF4),\n                code,\n                0x00,\n                self._crc(code, 0x00),\n                0xFF,\n                minutes,\n                self._crc(0xFF, minutes),\n            ]\n        )\n    )\n    reply = self.read(size=9, decode=False)\n    self._check_crc(reply)\n    # do not check if reply[7]==minutes and raise an exception if not equal\n    # because if, for example, minutes=121 the device will automatically\n    # set the power-off time to the maximum value that it supports (120) and\n    # raising an exception would be very confusing to the end user because\n    # the power-off value has changed, but not to the expected value. It's\n    # better to mention in the docstring that the returned value is what\n    # actually happened so the end user can do their own checks.\n    return reply[7]\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.status","title":"status","text":"<pre><code>status() -&gt; int\n</code></pre> <p>Get the system status.</p> <p>The status value represents a bit mask:</p> Bit Index Value Description 0 1 Max. alarm 1 2 Min. alarm 2 4 Display over range 3 8 Display under range 4 16 Reserved 5 32 Reserved 6 64 Reserved 7 128 Reserved 8 256 Measuring over range 9 512 Measuring under range 10 1024 Sensor error 11 2048 Reserved 12 4096 System fault 13 8192 Calculation not possible 14 16384 Reserved 15 32768 Low battery <p>Returns:</p> Type Description <code>int</code> <p>The system status.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def status(self) -&gt; int:\n    \"\"\"Get the system status.\n\n    The status value represents a bit mask:\n\n    | Bit Index | Value | Description              |\n    | :-------: | :---: | :----------------------- |\n    |   0       |     1 | Max. alarm               |\n    |   1       |     2 | Min. alarm               |\n    |   2       |     4 | Display over range       |\n    |   3       |     8 | Display under range      |\n    |   4       |    16 | Reserved                 |\n    |   5       |    32 | Reserved                 |\n    |   6       |    64 | Reserved                 |\n    |   7       |   128 | Reserved                 |\n    |   8       |   256 | Measuring over range     |\n    |   9       |   512 | Measuring under range    |\n    |   10      |  1024 | Sensor error             |\n    |   11      |  2048 | Reserved                 |\n    |   12      |  4096 | System fault             |\n    |   13      |  8192 | Calculation not possible |\n    |   14      | 16384 | Reserved                 |\n    |   15      | 32768 | Low battery              |\n\n    Returns:\n        The system status.\n    \"\"\"\n    reply = self._get(code=3)\n    return self._to_uint16(*reply[:2])\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.unit","title":"unit","text":"<pre><code>unit() -&gt; str\n</code></pre> <p>Get the measurement unit.</p> <p>Returns:</p> Type Description <code>str</code> <p>The measurement unit.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def unit(self) -&gt; str:\n    \"\"\"Get the measurement unit.\n\n    Returns:\n        The measurement unit.\n    \"\"\"\n    reply = self._get(code=202)\n    unit = self._to_uint16(*reply[3:5])\n    if unit == 1:\n        return \"\\u00b0C\"\n    if unit == 2:  # noqa: PLR2004\n        return \"\\u00b0F\"\n\n    raise MSLConnectionError(self, f\"Unimplemented unit ID {unit}\")\n</code></pre>"},{"location":"resources/greisinger/gmh3000/#msl.equipment_resources.greisinger.gmh3000.GMH3000.value","title":"value","text":"<pre><code>value() -&gt; float\n</code></pre> <p>Get the current measurement value.</p> <p>Returns:</p> Type Description <code>float</code> <p>The current value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/greisinger/gmh3000.py</code> <pre><code>def value(self) -&gt; float:\n    \"\"\"Get the current measurement value.\n\n    Returns:\n        The current value.\n    \"\"\"\n    return self._decode(self._get(code=0))\n</code></pre>"},{"location":"resources/isotech/millik/","title":"milliK","text":"<p>IsoTech milliK Precision Thermometer.</p> <p>There can also be multiple millisKanner Channel Expanders connected to the milliK.</p>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.Current","title":"Current","text":"<p>Measure the current on channel 3.</p>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.MilliK","title":"MilliK","text":"<pre><code>MilliK(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MultiMessageBased</code></p> <p>IsoTech milliK Precision Thermometer.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/isotech/millik.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"[IsoTech](https://isotech.co.uk/) milliK Precision Thermometer.\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"\n    super().__init__(equipment)\n    self.rstrip: bool = True\n    self.read_termination: bytes = b\"\\r\"\n    self.write_termination: bytes = b\"\\r\"\n\n    # REMOTE mode speeds up communication and is required for voltage measurements\n    _ = self.write(\"MILLIK:REMOTE\")\n\n    devices, channels = _find_channel_numbers(self)\n\n    # These are the strings that would be returned from each device by the *IDN? command\n    # e.g. ['Isothermal Technology,millisKanner,21-P2593,2.01', 'Isothermal Technology,milliK,21-P2460,4.0.0']\n    self._devices: list[MilliKDevice] = [MilliKDevice(*d.split(\",\")) for d in devices]\n\n    self._channels: list[int] = channels\n\n    self.channel_configuration: dict[int, Current | Resistance | Voltage] = {}\n    \"\"\"The channels that have been configured.\"\"\"\n</code></pre>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.MilliK.channel_configuration","title":"channel_configuration  <code>instance-attribute</code>","text":"<pre><code>channel_configuration: dict[\n    int, Current | Resistance | Voltage\n] = {}\n</code></pre> <p>The channels that have been configured.</p>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.MilliK.channel_numbers","title":"channel_numbers  <code>property</code>","text":"<pre><code>channel_numbers: list[int]\n</code></pre> <p>A list of available channel numbers.</p> <p>For example, [1, 2] for a single milliK or [1, 10, 11, 12, 13, 14, 15, 16, 17] for a milliK connected to a single millisKanner.</p>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.MilliK.connected_devices","title":"connected_devices  <code>property</code>","text":"<pre><code>connected_devices: list[MilliKDevice]\n</code></pre> <p>A list of information about the connected devices.</p>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.MilliK.num_devices","title":"num_devices  <code>property</code>","text":"<pre><code>num_devices: int\n</code></pre> <p>The number of connected devices.</p>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.MilliK.configure_current_measurement","title":"configure_current_measurement","text":"<pre><code>configure_current_measurement() -&gt; None\n</code></pre> <p>Configure the milliK to measure current on channel 3.</p> <p>The current is from a 4-20 mA transmitter on the rear of the milliK.</p> Source code in <code>packages/resources/src/msl/equipment_resources/isotech/millik.py</code> <pre><code>def configure_current_measurement(self) -&gt; None:\n    \"\"\"Configure the milliK to measure current on channel 3.\n\n    The current is from a 4-20 mA transmitter on the rear of the milliK.\n    \"\"\"\n    self.channel_configuration[3] = Current()\n</code></pre>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.MilliK.configure_resistance_measurement","title":"configure_resistance_measurement","text":"<pre><code>configure_resistance_measurement(\n    channel: int,\n    resistance: float,\n    *,\n    root2: bool = False,\n    wire3: bool = False\n) -&gt; None\n</code></pre> <p>Configure the milliK to measure resistance for the specified channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The channel to configure for resistance measurements.</p> required <code>resistance</code> <code>float</code> <p>The largest resistance value, in \u03a9, that is expected to be measured. The milliK selects the most sensitive range that can accommodate the specified value (up to 115 \u03a9, 460 \u03a9 or 500 k\u03a9 for the three supported ranges).</p> required <code>root2</code> <code>bool</code> <p>Use \\(\\sqrt{2}\\) mA sense current instead of the normal 1 mA sense current. Thermistors (resistance measurements in the 500 k\u03a9 range) always use 2 \u03bcA.</p> <code>False</code> <code>wire3</code> <code>bool</code> <p>Whether the wiring arrangement is for 3 wires instead of the typical 4 wires.</p> <code>False</code> Source code in <code>packages/resources/src/msl/equipment_resources/isotech/millik.py</code> <pre><code>def configure_resistance_measurement(\n    self, channel: int, resistance: float, *, root2: bool = False, wire3: bool = False\n) -&gt; None:\n    r\"\"\"Configure the milliK to measure resistance for the specified channel.\n\n    Args:\n        channel: The channel to configure for resistance measurements.\n        resistance: The largest resistance value, in &amp;Omega;, that is expected to be measured.\n            The milliK selects the most sensitive range that can accommodate the specified value\n            (up to 115 &amp;Omega;, 460 &amp;Omega; or 500 k&amp;Omega; for the three supported ranges).\n        root2: Use $\\sqrt{2}$ mA sense current instead of the normal 1 mA sense current.\n            Thermistors (resistance measurements in the 500 k&amp;Omega; range) always use 2 \u03bcA.\n        wire3: Whether the wiring arrangement is for 3 wires instead of the typical 4 wires.\n    \"\"\"\n    if channel not in self._channels:\n        msg = f\"Channel {channel} is not available in the connected milliK devices\"\n        raise ValueError(msg)\n\n    self.channel_configuration[channel] = Resistance(\n        range=round(resistance), current=\"ROOT2\" if root2 else \"NORMAL\", wires=3 if wire3 else 4\n    )\n</code></pre>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.MilliK.configure_voltage_measurement","title":"configure_voltage_measurement","text":"<pre><code>configure_voltage_measurement(\n    channel: int,\n    *,\n    rjc: bool = False,\n    thermocouple: str | Type | None = None\n) -&gt; None\n</code></pre> <p>Configure the milliK to measure voltage for the specified channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The channel to configure for voltage measurements.</p> required <code>rjc</code> <code>bool</code> <p>Whether to use reference junction compensation for the measurements.</p> <code>False</code> <code>thermocouple</code> <code>str | Type | None</code> <p>The type of thermocouple that is used. If the <code>thermocouple</code> value is of type str, it must be a member name of the Type enumeration, e.g., <code>K</code>, <code>J</code>, <code>AU_PT</code>.</p> <code>None</code> Source code in <code>packages/resources/src/msl/equipment_resources/isotech/millik.py</code> <pre><code>def configure_voltage_measurement(\n    self, channel: int, *, rjc: bool = False, thermocouple: str | Type | None = None\n) -&gt; None:\n    \"\"\"Configure the milliK to measure voltage for the specified channel.\n\n    Args:\n        channel: The channel to configure for voltage measurements.\n        rjc: Whether to use reference junction compensation for the measurements.\n        thermocouple: The type of thermocouple that is used. If the `thermocouple` value is\n            of type [str][], it must be a member name of the [Type][msl.equipment_resources.isotech.millik.Type]\n            enumeration, e.g., `K`, `J`, `AU_PT`.\n    \"\"\"\n    if channel not in self._channels:\n        msg = f\"Channel {channel} is not available in the connected milliK devices\"\n        raise ValueError(msg)\n\n    self.channel_configuration[channel] = Voltage(\n        rjc=\"INTERNAL\" if rjc else \"NONE\",\n        thermocouple=\"NONE\" if thermocouple is None else to_enum(thermocouple, Type, to_upper=True),\n    )\n</code></pre>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.MilliK.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Return the milliK device to LOCAL mode then disconnect from the device.</p> Source code in <code>packages/resources/src/msl/equipment_resources/isotech/millik.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Return the milliK device to LOCAL mode then disconnect from the device.\"\"\"\n    if not self._connected:\n        return\n\n    _ = self.write(\"MILLIK:LOCAL\")\n    super().disconnect()\n</code></pre>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.MilliK.read_all_channels","title":"read_all_channels","text":"<pre><code>read_all_channels(\n    n: int = 1,\n) -&gt; Iterator[tuple[int, float]]\n</code></pre> <p>Read from all configured channels.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of readings to average for each channel.</p> <code>1</code> <p>Yields:</p> Type Description <code>tuple[int, float]</code> <p>The channel number and the average measurement value for that channel.</p> Source code in <code>packages/resources/src/msl/equipment_resources/isotech/millik.py</code> <pre><code>def read_all_channels(self, n: int = 1) -&gt; Iterator[tuple[int, float]]:\n    \"\"\"Read from all configured channels.\n\n    Args:\n        n: The number of readings to average for each channel.\n\n    Yields:\n        The channel number and the average measurement value for that channel.\n    \"\"\"\n    for c in sorted(self.channel_configuration):\n        if n == 1:  # already a single float value\n            yield c, self.read_channel(c)\n        else:  # average multiple readings\n            readings = self.read_channel(c, n=n)\n            yield c, sum(readings) / len(readings)\n</code></pre>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.MilliK.read_channel","title":"read_channel","text":"<pre><code>read_channel(channel: int, n: Literal[1] = 1) -&gt; float\n</code></pre><pre><code>read_channel(channel: int, n: int) -&gt; list[float]\n</code></pre> <pre><code>read_channel(\n    channel: int, n: int = 1\n) -&gt; float | list[float]\n</code></pre> <p>Read a configured channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The channel to read.</p> required <code>n</code> <code>int</code> <p>The number of readings to acquire.</p> <code>1</code> <p>Returns:</p> Type Description <code>float | list[float]</code> <p>A list of <code>n</code> readings or a single value if only one reading is requested.</p> Source code in <code>packages/resources/src/msl/equipment_resources/isotech/millik.py</code> <pre><code>def read_channel(self, channel: int, n: int = 1) -&gt; float | list[float]:\n    \"\"\"Read a configured channel.\n\n    Args:\n        channel: The channel to read.\n        n: The number of readings to acquire.\n\n    Returns:\n        A list of `n` readings or a single value if only one reading is requested.\n    \"\"\"\n    cfg = self.channel_configuration.get(channel)\n    if cfg is None:\n        msg = f\"Please first configure channel {channel} before attempting to read values\"\n        raise ValueError(msg)\n\n    if isinstance(cfg, Resistance):\n        commands = [\n            f\"SENSE:CHANNEL {channel}\",\n            \"SENSE:FUNCTION RESISTANCE\",\n            f\"SENSE:RESISTANCE:RANGE {cfg.range}\",\n            f\"SENSE:RESISTANCE:WIRES {cfg.wires}\",\n            f\"SENSE:CURRENT {cfg.current}\",\n        ]\n    elif isinstance(cfg, Voltage):\n        commands = [\n            f\"SENSE:CHANNEL {channel}\",\n            \"SENSE:FUNCTION VOLTAGE\",\n            f\"SENSE:PROBE {cfg.thermocouple}\",\n            f\"SENSE:RJC {cfg.rjc}\",\n        ]\n    else:\n        commands = [\"SENSE:CHANNEL 3\", \"SENSE:FUNCTION CURRENT\"]\n\n    commands.append(f\"READ? {n}\" if n &gt; 1 else \"READ?\")\n    reply = self.query(\";\".join(commands))\n\n    try:\n        readings = list(map(float, reply.split(\",\")))\n    except ValueError:\n        raise MSLConnectionError(self, f\"Cannot map reply to float, {reply!r}\") from None\n\n    if len(readings) == 1:\n        return readings[0]\n    return readings\n</code></pre>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.MilliKDevice","title":"MilliKDevice  <code>dataclass</code>","text":"<pre><code>MilliKDevice(\n    manufacturer: str,\n    model: str,\n    serial: str,\n    firmware: str,\n)\n</code></pre> <p>Information about a connected milliK device.</p> <p>Parameters:</p> Name Type Description Default <code>manufacturer</code> <code>str</code> <p>Manufacturer's name.</p> required <code>model</code> <code>str</code> <p>Model number.</p> required <code>serial</code> <code>str</code> <p>Serial number.</p> required <code>firmware</code> <code>str</code> <p>Firmware revision number.</p> required"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.Resistance","title":"Resistance  <code>dataclass</code>","text":"<pre><code>Resistance(\n    range: int,\n    current: Literal[\"NORMAL\", \"ROOT2\"],\n    wires: Literal[3, 4],\n)\n</code></pre> <p>A channel configured to measure resistance.</p> <p>Parameters:</p> Name Type Description Default <code>range</code> <code>int</code> <p>The largest resistance that is expected to be measured.</p> required <code>current</code> <code>Literal['NORMAL', 'ROOT2']</code> <p>The type of sense current to use.</p> required <code>wires</code> <code>Literal[3, 4]</code> <p>The number of wires that are used for the resistance measurement.</p> required"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.Type","title":"Type","text":"<p>               Bases: <code>Enum</code></p> <p>Standard thermocouple types.</p> <p>Attributes:</p> Name Type Description <code>B</code> <code>str</code> <p><code>\"TYPE B\"</code></p> <code>E</code> <code>str</code> <p><code>\"TYPE E\"</code></p> <code>J</code> <code>str</code> <p><code>\"TYPE J\"</code></p> <code>K</code> <code>str</code> <p><code>\"TYPE K\"</code></p> <code>L</code> <code>str</code> <p><code>\"TYPE L\"</code></p> <code>N</code> <code>str</code> <p><code>\"TYPE N\"</code></p> <code>R</code> <code>str</code> <p><code>\"TYPE R\"</code></p> <code>S</code> <code>str</code> <p><code>\"TYPE S\"</code></p> <code>T</code> <code>str</code> <p><code>\"TYPE T\"</code></p> <code>AU_PT</code> <code>str</code> <p><code>\"TYPE AU-PT\"</code></p> <code>PT_PD</code> <code>str</code> <p><code>\"TYPE PT-PD\"</code></p>"},{"location":"resources/isotech/millik/#msl.equipment_resources.isotech.millik.Voltage","title":"Voltage  <code>dataclass</code>","text":"<pre><code>Voltage(\n    rjc: Literal[\"NONE\", \"INTERNAL\"],\n    thermocouple: Type | Literal[\"NONE\"],\n)\n</code></pre> <p>A channel configured to measure voltage.</p> <p>Parameters:</p> Name Type Description Default <code>rjc</code> <code>Literal['NONE', 'INTERNAL']</code> <p>The reference junction compensation type.</p> required <code>thermocouple</code> <code>Type | Literal['NONE']</code> <p>The thermocouple type.</p> required"},{"location":"resources/mks/pr4000b/","title":"PR4000B","text":"<p>Flow and Pressure controller, PR4000B, from MKS Instruments.</p>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.UNIT","title":"UNIT  <code>module-attribute</code>","text":"<pre><code>UNIT = {\n    0: \"ubar\",\n    1: \"mbar\",\n    2: \"bar\",\n    3: \"mTorr\",\n    4: \"Torr\",\n    5: \"kTorr\",\n    6: \"Pa\",\n    7: \"kPa\",\n    8: \"mH2O\",\n    9: \"cH2O\",\n    10: \"PSI\",\n    11: \"N/qm\",\n    12: \"SCCM\",\n    13: \"SLM\",\n    14: \"SCM\",\n    15: \"SCFH\",\n    16: \"SCFM\",\n    17: \"mA\",\n    18: \"V\",\n    19: \"%\",\n    20: \"C\",\n}\n</code></pre> <p>Mapping from an index value to a unit name.</p>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.LimitMode","title":"LimitMode","text":"<p>               Bases: <code>IntEnum</code></p> <p>Limit mode type.</p> <p>Attributes:</p> Name Type Description <code>SLEEP</code> <code>int</code> <p>0</p> <code>LIMIT</code> <code>int</code> <p>1</p> <code>BAND</code> <code>int</code> <p>2</p> <code>MLIMIT</code> <code>int</code> <p>3</p> <code>MBAND</code> <code>int</code> <p>4</p>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B","title":"PR4000B","text":"<pre><code>PR4000B(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Serial</code></p> <p>Flow and Pressure controller, PR4000B, from MKS Instruments.</p> <p>The default settings for the RS232 connection are:</p> <ul> <li>Baud rate: 9600</li> <li>Parity: ODD</li> <li>Data bits: 7</li> <li>Stop bits: 1</li> <li>Flow control: None</li> </ul> <p>The baud rate and parity can be changed on the controller. The data bits, stop bits, and flow control cannot be changed. A null modem (cross over) cable is required when using a USB to RS232 converter. RS485 support is not implemented.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance..</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Flow and Pressure controller, PR4000B, from [MKS](https://www.mks.com/) Instruments.\n\n    The default settings for the RS232 connection are:\n\n    * Baud rate: 9600\n    * Parity: ODD\n    * Data bits: 7\n    * Stop bits: 1\n    * Flow control: None\n\n    The baud rate and parity can be changed on the controller. The data bits,\n    stop bits, and flow control cannot be changed. A null modem (cross over)\n    cable is required when using a USB to RS232 converter. RS485 support is\n    not implemented.\n\n    Args:\n        equipment: An [Equipment][] instance..\n    \"\"\"\n    assert equipment.connection is not None  # noqa: S101\n    equipment.connection.properties.setdefault(\"data_bits\", DataBits.SEVEN)\n    super().__init__(equipment)\n    self.read_termination: bytes = b\"\\r\"\n    self.write_termination: bytes = b\"\\r\"\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.auto_zero","title":"auto_zero","text":"<pre><code>auto_zero(channel: Literal[1, 2]) -&gt; int\n</code></pre> <p>Auto zero a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The offset.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def auto_zero(self, channel: Literal[1, 2]) -&gt; int:\n    \"\"\"Auto zero a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The offset.\n    \"\"\"\n    self._check_channel(channel)\n    return int(self.query(f\"AZ{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.default","title":"default","text":"<pre><code>default(\n    mode: Literal[\"pressure\", \"p\", \"flow\", \"f\"],\n) -&gt; None\n</code></pre> <p>Reset to the default configuration.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>Literal['pressure', 'p', 'flow', 'f']</code> <p>The mode to reset.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def default(self, mode: Literal[\"pressure\", \"p\", \"flow\", \"f\"]) -&gt; None:\n    \"\"\"Reset to the default configuration.\n\n    Args:\n        mode: The mode to reset.\n    \"\"\"\n    upper = mode.upper()\n    if upper not in {\"P\", \"F\", \"PRESSURE\", \"FLOW\"}:\n        msg = f\"Invalid default mode {mode!r}, must one of: pressure, flow, p or f\"\n        raise ValueError(msg)\n\n    _ = self._check(f\"DF,{upper[0]}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.display_4","title":"display_4","text":"<pre><code>display_4(*, enable: bool) -&gt; None\n</code></pre> <p>Whether to enable or disable display 4.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>Whether to enable or disable display 4.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def display_4(self, *, enable: bool) -&gt; None:\n    \"\"\"Whether to enable or disable display 4.\n\n    Args:\n        enable: Whether to enable or disable display 4.\n    \"\"\"\n    state = \"ON\" if enable else \"OFF\"\n    _ = self._check(f\"DP4,{state}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.display_enable","title":"display_enable","text":"<pre><code>display_enable(\n    display: Literal[1, 2, 3, 4], *, enable: bool\n) -&gt; None\n</code></pre> <p>Turn a display on or off.</p> <p>Parameters:</p> Name Type Description Default <code>display</code> <code>Literal[1, 2, 3, 4]</code> <p>The display number.</p> required <code>enable</code> <code>bool</code> <p>Whether to turn the display on (<code>True</code>) or off (<code>False</code>).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def display_enable(self, display: Literal[1, 2, 3, 4], *, enable: bool) -&gt; None:\n    \"\"\"Turn a display on or off.\n\n    Args:\n        display: The display number.\n        enable: Whether to turn the display on (`True`) or off (`False`).\n    \"\"\"\n    if display not in {1, 2, 3, 4}:\n        msg = f\"Invalid display number {display}, must be 1, 2, 3 or 4\"\n        raise ValueError(msg)\n\n    state = \"ON\" if enable else \"OFF\"\n    _ = self._check(f\"DP{display},{state}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.display_setup","title":"display_setup","text":"<pre><code>display_setup(\n    display: Literal[1, 2, 3, 4],\n    line: Literal[1, 2],\n    channel: Literal[1, 2],\n    tag: int | str | Tag,\n) -&gt; None\n</code></pre> <p>Configure a display.</p> <p>Parameters:</p> Name Type Description Default <code>display</code> <code>Literal[1, 2, 3, 4]</code> <p>The display number.</p> required <code>line</code> <code>Literal[1, 2]</code> <p>The line number.</p> required <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>tag</code> <code>int | str | Tag</code> <p>The tag to use. Can be a Tag member name or value. For example, <code>Tag.PR</code>, <code>4</code>, or <code>\"PR\"</code> are equivalent.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def display_setup(\n    self, display: Literal[1, 2, 3, 4], line: Literal[1, 2], channel: Literal[1, 2], tag: int | str | Tag\n) -&gt; None:\n    \"\"\"Configure a display.\n\n    Args:\n        display: The display number.\n        line: The line number.\n        channel: The channel number.\n        tag: The tag to use. Can be a [Tag][msl.equipment_resources.mks.pr4000b.Tag] member name or value.\n            For example, `Tag.PR`, `4`, or `\"PR\"` are equivalent.\n    \"\"\"\n    if display not in {1, 2, 3, 4}:\n        msg = f\"Invalid display number {display}, must be 1, 2, 3 or 4\"\n        raise ValueError(msg)\n\n    if line not in {1, 2}:\n        msg = f\"Invalid line number {line}, must be 1 or 2\"\n        raise ValueError(msg)\n\n    self._check_channel(channel)\n    tag = to_enum(tag, Tag, to_upper=True)\n    _ = self._check(f\"DP{display},{line},{tag},{channel}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.external_input","title":"external_input","text":"<pre><code>external_input(channel: Literal[1, 2]) -&gt; float\n</code></pre> <p>Return the external input of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The external input.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def external_input(self, channel: Literal[1, 2]) -&gt; float:\n    \"\"\"Return the external input of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The external input.\n    \"\"\"\n    self._check_channel(channel)\n    return float(self.query(f\"EX{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_access_channel","title":"get_access_channel","text":"<pre><code>get_access_channel(\n    channel: Literal[1, 2],\n) -&gt; tuple[float, bool]\n</code></pre> <p>Get the setpoint and the state of the valve of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>tuple[float, bool]</code> <p>The setpoint value and whether the valve is on (<code>True</code>) or off (<code>False</code>).</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_access_channel(self, channel: Literal[1, 2]) -&gt; tuple[float, bool]:\n    \"\"\"Get the setpoint and the state of the valve of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The setpoint value and whether the valve is on (`True`) or off (`False`).\n    \"\"\"\n    self._check_channel(channel)\n    a, b = self.query(f\"?AC{channel}\").rstrip().split(\",\")\n    return float(a), b == \"ON\"\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_actual_value","title":"get_actual_value","text":"<pre><code>get_actual_value(channel: Literal[1, 2]) -&gt; float\n</code></pre> <p>Get the actual value of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_actual_value(self, channel: Literal[1, 2]) -&gt; float:\n    \"\"\"Get the actual value of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The value.\n    \"\"\"\n    self._check_channel(channel)\n    return float(self.query(f\"AV{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_address","title":"get_address","text":"<pre><code>get_address() -&gt; int\n</code></pre> <p>Get the address.</p> <p>Returns:</p> Type Description <code>int</code> <p>The address.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_address(self) -&gt; int:\n    \"\"\"Get the address.\n\n    Returns:\n        The address.\n    \"\"\"\n    return int(self.query(\"?AD\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_dead_band","title":"get_dead_band","text":"<pre><code>get_dead_band(channel: Literal[1, 2]) -&gt; float\n</code></pre> <p>Get the dead band of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The dead band.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_dead_band(self, channel: Literal[1, 2]) -&gt; float:\n    \"\"\"Get the dead band of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The dead band.\n    \"\"\"\n    self._check_channel(channel)\n    return float(self.query(f\"?DB{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_dialog","title":"get_dialog","text":"<pre><code>get_dialog() -&gt; int\n</code></pre> <p>Get the current dialog index that is displayed.</p> <p>Returns:</p> Type Description <code>int</code> <p>The dialog index.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_dialog(self) -&gt; int:\n    \"\"\"Get the current dialog index that is displayed.\n\n    Returns:\n        The dialog index.\n    \"\"\"\n    return int(self.query(\"?DG\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_display_text","title":"get_display_text","text":"<pre><code>get_display_text() -&gt; str\n</code></pre> <p>Get the display text.</p> <p>Returns:</p> Type Description <code>str</code> <p>The display text.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_display_text(self) -&gt; str:\n    \"\"\"Get the display text.\n\n    Returns:\n        The display text.\n    \"\"\"\n    return self.query(\"?DT\").rstrip()\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_external_input_range","title":"get_external_input_range","text":"<pre><code>get_external_input_range(channel: Literal[1, 2]) -&gt; int\n</code></pre> <p>Get the external input range of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The external input range.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_external_input_range(self, channel: Literal[1, 2]) -&gt; int:\n    \"\"\"Get the external input range of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The external input range.\n    \"\"\"\n    self._check_channel(channel)\n    return int(self.query(f\"?EI{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_external_output_range","title":"get_external_output_range","text":"<pre><code>get_external_output_range(channel: Literal[1, 2]) -&gt; int\n</code></pre> <p>Get the external output range of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The external output range.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_external_output_range(self, channel: Literal[1, 2]) -&gt; int:\n    \"\"\"Get the external output range of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The external output range.\n    \"\"\"\n    self._check_channel(channel)\n    return int(self.query(f\"?EO{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_formula_relay","title":"get_formula_relay","text":"<pre><code>get_formula_relay(channel: Literal[1, 2]) -&gt; str\n</code></pre> <p>Get the relay formula of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The formula.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_formula_relay(self, channel: Literal[1, 2]) -&gt; str:\n    \"\"\"Get the relay formula of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The formula.\n    \"\"\"\n    self._check_channel(channel)\n    return self.query(f\"?FR{channel}\").strip()\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_formula_temporary","title":"get_formula_temporary","text":"<pre><code>get_formula_temporary(channel: Literal[1, 2]) -&gt; str\n</code></pre> <p>Get the temporary formula of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The formula.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_formula_temporary(self, channel: Literal[1, 2]) -&gt; str:\n    \"\"\"Get the temporary formula of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The formula.\n    \"\"\"\n    self._check_channel(channel)\n    return self.query(f\"?FT{channel}\").strip()\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_gain","title":"get_gain","text":"<pre><code>get_gain(channel: Literal[1, 2]) -&gt; float\n</code></pre> <p>Get the gain of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The gain.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_gain(self, channel: Literal[1, 2]) -&gt; float:\n    \"\"\"Get the gain of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The gain.\n    \"\"\"\n    self._check_channel(channel)\n    return float(self.query(f\"?GN{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_input_range","title":"get_input_range","text":"<pre><code>get_input_range(channel: Literal[1, 2]) -&gt; int\n</code></pre> <p>Get the input range of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The input range.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_input_range(self, channel: Literal[1, 2]) -&gt; int:\n    \"\"\"Get the input range of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The input range.\n    \"\"\"\n    self._check_channel(channel)\n    return int(self.query(f\"?IN{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_interface_mode","title":"get_interface_mode","text":"<pre><code>get_interface_mode() -&gt; int\n</code></pre> <p>Get the interface mode.</p> <p>Returns:</p> Type Description <code>int</code> <p>The interface mode.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_interface_mode(self) -&gt; int:\n    \"\"\"Get the interface mode.\n\n    Returns:\n        The interface mode.\n    \"\"\"\n    return int(self.query(\"?IM\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_limit_mode","title":"get_limit_mode","text":"<pre><code>get_limit_mode(channel: Literal[1, 2]) -&gt; LimitMode\n</code></pre> <p>Get the limit mode of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>LimitMode</code> <p>The limit mode.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_limit_mode(self, channel: Literal[1, 2]) -&gt; LimitMode:\n    \"\"\"Get the limit mode of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The limit mode.\n    \"\"\"\n    self._check_channel(channel)\n    mode = int(self.query(f\"?LM{channel}\"))\n    return LimitMode(mode)\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_linearization_point","title":"get_linearization_point","text":"<pre><code>get_linearization_point(\n    channel: Literal[1, 2], point: int\n) -&gt; tuple[float, float]\n</code></pre> <p>Get the point in the linearization table of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>point</code> <code>int</code> <p>The point in the table [0, 10].</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>The <code>(x, y)</code> point.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_linearization_point(self, channel: Literal[1, 2], point: int) -&gt; tuple[float, float]:\n    \"\"\"Get the point in the linearization table of a channel.\n\n    Args:\n        channel: The channel number.\n        point: The point in the table [0, 10].\n\n    Returns:\n        The `(x, y)` point.\n    \"\"\"\n    self._check_channel(channel)\n    if point &lt; 0 or point &gt; MAX_POINT:\n        msg = f\"Invalid point {point}, must be between [0, 10]\"\n        raise ValueError(msg)\n    a, b = self.query(f\"?LN{channel},{point}\").split(\",\")\n    return float(a), float(b)\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_linearization_size","title":"get_linearization_size","text":"<pre><code>get_linearization_size(channel: Literal[1, 2]) -&gt; int\n</code></pre> <p>Get the size of the linearization table of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The size of the table.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_linearization_size(self, channel: Literal[1, 2]) -&gt; int:\n    \"\"\"Get the size of the linearization table of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The size of the table.\n    \"\"\"\n    self._check_channel(channel)\n    return int(self.query(f\"?LS{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_lower_limit","title":"get_lower_limit","text":"<pre><code>get_lower_limit(channel: Literal[1, 2]) -&gt; float\n</code></pre> <p>Get the lower limit of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The lower limit.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_lower_limit(self, channel: Literal[1, 2]) -&gt; float:\n    \"\"\"Get the lower limit of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The lower limit.\n    \"\"\"\n    self._check_channel(channel)\n    return float(self.query(f\"?LL{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_offset","title":"get_offset","text":"<pre><code>get_offset(channel: Literal[1, 2]) -&gt; int\n</code></pre> <p>Get the offset of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The offset.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_offset(self, channel: Literal[1, 2]) -&gt; int:\n    \"\"\"Get the offset of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The offset.\n    \"\"\"\n    self._check_channel(channel)\n    return int(self.query(f\"?OF{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_output_range","title":"get_output_range","text":"<pre><code>get_output_range(channel: Literal[1, 2]) -&gt; int\n</code></pre> <p>Get the output range of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The output range.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_output_range(self, channel: Literal[1, 2]) -&gt; int:\n    \"\"\"Get the output range of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The output range.\n    \"\"\"\n    self._check_channel(channel)\n    return int(self.query(f\"?OT{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_range","title":"get_range","text":"<pre><code>get_range(channel: Literal[1, 2]) -&gt; tuple[float, int, str]\n</code></pre> <p>Get the range and unit of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>tuple[float, int, str]</code> <p>The range, unit index and unit name.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_range(self, channel: Literal[1, 2]) -&gt; tuple[float, int, str]:\n    \"\"\"Get the range and unit of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The range, unit index and unit name.\n    \"\"\"\n    self._check_channel(channel)\n    a, b = self.query(f\"?RG{channel}\").split(\",\")\n    unit = int(b)\n    return float(a), unit, UNIT[unit]\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_relays","title":"get_relays","text":"<pre><code>get_relays(channel: Literal[1, 2]) -&gt; bool\n</code></pre> <p>Get the relay state of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the relay is enabled or disabled.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_relays(self, channel: Literal[1, 2]) -&gt; bool:\n    \"\"\"Get the relay state of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        Whether the relay is enabled or disabled.\n    \"\"\"\n    self._check_channel(channel)\n    return self.query(f\"?RL{channel}\").rstrip() == \"ON\"\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_remote_mode","title":"get_remote_mode","text":"<pre><code>get_remote_mode() -&gt; bool\n</code></pre> <p>Get the remote operation mode.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the remote operation mode is enabled (<code>True</code>) or disabled (<code>False</code>).</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_remote_mode(self) -&gt; bool:\n    \"\"\"Get the remote operation mode.\n\n    Returns:\n        Whether the remote operation mode is enabled (`True`) or disabled (`False`).\n    \"\"\"\n    return self.query(\"?RT\").rstrip() == \"ON\"\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_resolution","title":"get_resolution","text":"<pre><code>get_resolution() -&gt; bool\n</code></pre> <p>Get whether 16-bit resolution is enabled.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether 16-bit resolution is enabled (<code>True</code>) or disabled (<code>False</code>).</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_resolution(self) -&gt; bool:\n    \"\"\"Get whether 16-bit resolution is enabled.\n\n    Returns:\n        Whether 16-bit resolution is enabled (`True`) or disabled (`False`).\n    \"\"\"\n    return self.query(\"?RS\").rstrip() == \"ON\"\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_rtd_offset","title":"get_rtd_offset","text":"<pre><code>get_rtd_offset(channel: Literal[1, 2]) -&gt; int\n</code></pre> <p>Get the RTD offset of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The offset.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_rtd_offset(self, channel: Literal[1, 2]) -&gt; int:\n    \"\"\"Get the RTD offset of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The offset.\n    \"\"\"\n    self._check_channel(channel)\n    return int(self.query(f\"?RO{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_scale","title":"get_scale","text":"<pre><code>get_scale(channel: Literal[1, 2]) -&gt; float\n</code></pre> <p>Get the scale of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The scale.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_scale(self, channel: Literal[1, 2]) -&gt; float:\n    \"\"\"Get the scale of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The scale.\n    \"\"\"\n    return float(self.query(f\"?SC{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_setpoint","title":"get_setpoint","text":"<pre><code>get_setpoint(channel: Literal[1, 2]) -&gt; float\n</code></pre> <p>Get the setpoint of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The setpoint.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_setpoint(self, channel: Literal[1, 2]) -&gt; float:\n    \"\"\"Get the setpoint of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The setpoint.\n    \"\"\"\n    self._check_channel(channel)\n    return float(self.query(f\"?SP{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_signal_mode","title":"get_signal_mode","text":"<pre><code>get_signal_mode(channel: Literal[1, 2]) -&gt; SignalMode\n</code></pre> <p>Get the signal mode of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>SignalMode</code> <p>The signal mode.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_signal_mode(self, channel: Literal[1, 2]) -&gt; SignalMode:\n    \"\"\"Get the signal mode of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The signal mode.\n    \"\"\"\n    self._check_channel(channel)\n    mode = int(self.query(f\"?SM{channel}\"))\n    return SignalMode(mode)\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_upper_limit","title":"get_upper_limit","text":"<pre><code>get_upper_limit(channel: Literal[1, 2]) -&gt; float\n</code></pre> <p>Get the upper limit of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The upper limit.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_upper_limit(self, channel: Literal[1, 2]) -&gt; float:\n    \"\"\"Get the upper limit of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        The upper limit.\n    \"\"\"\n    self._check_channel(channel)\n    return float(self.query(f\"?UL{channel}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.get_valve","title":"get_valve","text":"<pre><code>get_valve(channel: Literal[1, 2]) -&gt; bool\n</code></pre> <p>Get the state of the valve of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the valve is enabled (<code>True</code>) or disabled (<code>False</code>).</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def get_valve(self, channel: Literal[1, 2]) -&gt; bool:\n    \"\"\"Get the state of the valve of a channel.\n\n    Args:\n        channel: The channel number.\n\n    Returns:\n        Whether the valve is enabled (`True`) or disabled (`False`).\n    \"\"\"\n    self._check_channel(channel)\n    return self.query(f\"?VL{channel}\").rstrip() == \"ON\"\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.identity","title":"identity","text":"<pre><code>identity() -&gt; str\n</code></pre> <p>Returns the identity.</p> <p>Returns:</p> Type Description <code>str</code> <p>The identity. For example, <code>PR42vvrrsssss</code>, where <code>vv</code> is the version, <code>rr</code> is the release and <code>sssss</code> is the serial number.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def identity(self) -&gt; str:\n    \"\"\"Returns the identity.\n\n    Returns:\n        The identity. For example, `PR42vvrrsssss`, where `vv` is the version,\n            `rr` is the release and `sssss` is the serial number.\n    \"\"\"\n    return self.query(\"?ID\").rstrip()\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.lock","title":"lock","text":"<pre><code>lock() -&gt; None\n</code></pre> <p>Lock setup.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def lock(self) -&gt; None:\n    \"\"\"Lock setup.\"\"\"\n    _ = self._check(\"#1\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.request_key","title":"request_key","text":"<pre><code>request_key() -&gt; tuple[int, int]\n</code></pre> <p>Requests most recent key that was pressed.</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>The key that was most recently pressed and the number of key presses that occurred since the last time this method was called.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def request_key(self) -&gt; tuple[int, int]:\n    \"\"\"Requests most recent key that was pressed.\n\n    Returns:\n        The key that was most recently pressed and the number of key presses\n            that occurred since the last time this method was called.\n    \"\"\"\n    a, b = self.query(\"?KY\").split(\",\")\n    return int(a), int(b)\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.reset_status","title":"reset_status","text":"<pre><code>reset_status() -&gt; None\n</code></pre> <p>Send the reset/status command.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def reset_status(self) -&gt; None:\n    \"\"\"Send the reset/status command.\"\"\"\n    _ = self._check(\"RE\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_access_channel","title":"set_access_channel","text":"<pre><code>set_access_channel(\n    channel: Literal[1, 2], setpoint: float, *, enable: bool\n) -&gt; float\n</code></pre> <p>Set the setpoint and the state of the valve for a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>setpoint</code> <code>float</code> <p>The setpoint value.</p> required <code>enable</code> <code>bool</code> <p>Whether to enable (<code>True</code>) or disable (<code>False</code>) the valve.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The actual setpoint value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_access_channel(self, channel: Literal[1, 2], setpoint: float, *, enable: bool) -&gt; float:\n    \"\"\"Set the setpoint and the state of the valve for a channel.\n\n    Args:\n        channel: The channel number.\n        setpoint: The setpoint value.\n        enable: Whether to enable (`True`) or disable (`False`) the valve.\n\n    Returns:\n        The actual setpoint value.\n    \"\"\"\n    self._check_channel(channel)\n    state = \"ON\" if enable else \"OFF\"\n    return float(self._check(f\"AC{channel},{setpoint},{state}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_actual_value","title":"set_actual_value","text":"<pre><code>set_actual_value(\n    channel: Literal[1, 2], setpoint: float\n) -&gt; float\n</code></pre> <p>Set the actual value of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>setpoint</code> <code>float</code> <p>The setpoint.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The actual value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_actual_value(self, channel: Literal[1, 2], setpoint: float) -&gt; float:\n    \"\"\"Set the actual value of a channel.\n\n    Args:\n        channel: The channel number.\n        setpoint: The setpoint.\n\n    Returns:\n        The actual value.\n    \"\"\"\n    self._check_channel(channel)\n    return float(self.query(f\"AV{channel},{setpoint}\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_address","title":"set_address","text":"<pre><code>set_address(address: int) -&gt; None\n</code></pre> <p>Set the address.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address [0, 31].</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_address(self, address: int) -&gt; None:\n    \"\"\"Set the address.\n\n    Args:\n        address: The address [0, 31].\n    \"\"\"\n    if address &lt; 0 or address &gt; 31:  # noqa: PLR2004\n        msg = f\"Invalid address {address}, must be between [0, 31]\"\n        raise ValueError(msg)\n\n    _ = self._check(f\"AD,{address}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_dead_band","title":"set_dead_band","text":"<pre><code>set_dead_band(channel: Literal[1, 2], band: float) -&gt; None\n</code></pre> <p>Set the dead band of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>band</code> <code>float</code> <p>The dead band (0.0% to 9.9% of full scale).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_dead_band(self, channel: Literal[1, 2], band: float) -&gt; None:\n    \"\"\"Set the dead band of a channel.\n\n    Args:\n        channel: The channel number.\n        band: The dead band (0.0% to 9.9% of full scale).\n    \"\"\"\n    self._check_channel(channel)\n    _ = self._check(f\"DB{channel},{band}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_dialog","title":"set_dialog","text":"<pre><code>set_dialog(index: int) -&gt; None\n</code></pre> <p>Set the display dialog.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The dialog index [0, 29]. See Appendix D of the manual for more information.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_dialog(self, index: int) -&gt; None:\n    \"\"\"Set the display dialog.\n\n    Args:\n        index: The dialog index [0, 29]. See Appendix D of the manual for more information.\n    \"\"\"\n    if index &lt; 0 or index &gt; 29:  # noqa: PLR2004\n        msg = f\"Invalid dialog index {index}, must be in the range [0, 29]\"\n        raise ValueError(msg)\n    _ = self._check(f\"DG,{index}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_display_text","title":"set_display_text","text":"<pre><code>set_display_text(text: str, *, clear: bool = True) -&gt; None\n</code></pre> <p>Set the display text.</p> <p>To view the text on the display you must call set_dialog with the index equal to 3.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to display. Maximum 32 characters.</p> required <code>clear</code> <code>bool</code> <p>Whether to clear the current display text before setting the new text.</p> <code>True</code> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_display_text(self, text: str, *, clear: bool = True) -&gt; None:\n    \"\"\"Set the display text.\n\n    To view the text on the display you must call\n    [set_dialog][msl.equipment_resources.mks.pr4000b.PR4000B.set_dialog]\n    with the index equal to 3.\n\n    Args:\n        text: The text to display. Maximum 32 characters.\n        clear: Whether to clear the current display text before setting the new text.\n    \"\"\"\n    if len(text) &gt; 32:  # noqa: PLR2004\n        msg = f\"The display text must be &lt;= 32 characters, got {text!r}\"\n        raise ValueError(msg)\n    if clear:\n        _ = self._check(\"!DT\")\n    _ = self._check(f\"DT,{text}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_external_input_range","title":"set_external_input_range","text":"<pre><code>set_external_input_range(\n    channel: Literal[1, 2], range: int\n) -&gt; None\n</code></pre> <p>Set the external input range of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>range</code> <code>int</code> <p>The external input range [1, 10] in Volts.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_external_input_range(self, channel: Literal[1, 2], range: int) -&gt; None:  # noqa: A002\n    \"\"\"Set the external input range of a channel.\n\n    Args:\n        channel: The channel number.\n        range: The external input range [1, 10] in Volts.\n    \"\"\"\n    self._check_channel(channel)\n    if range &lt; 1 or range &gt; MAX_RANGE:\n        msg = f\"Invalid external input range {range}\"\n        raise ValueError(msg)\n    _ = self._check(f\"EI{channel},{range}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_external_output_range","title":"set_external_output_range","text":"<pre><code>set_external_output_range(\n    channel: Literal[1, 2], range: int\n) -&gt; None\n</code></pre> <p>Set the external output range of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>range</code> <code>int</code> <p>The external output range [1, 10] in Volts.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_external_output_range(self, channel: Literal[1, 2], range: int) -&gt; None:  # noqa: A002\n    \"\"\"Set the external output range of a channel.\n\n    Args:\n        channel: The channel number.\n        range: The external output range [1, 10] in Volts.\n    \"\"\"\n    self._check_channel(channel)\n    if range &lt; 1 or range &gt; MAX_RANGE:\n        msg = f\"Invalid external output range {range}\"\n        raise ValueError(msg)\n    _ = self._check(f\"EO{channel},{range}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_formula_relay","title":"set_formula_relay","text":"<pre><code>set_formula_relay(\n    channel: Literal[1, 2], formula: str\n) -&gt; None\n</code></pre> <p>Set the relay formula of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>formula</code> <code>str</code> <p>The relay formula.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_formula_relay(self, channel: Literal[1, 2], formula: str) -&gt; None:\n    \"\"\"Set the relay formula of a channel.\n\n    Args:\n        channel: The channel number.\n        formula: The relay formula.\n    \"\"\"\n    self._check_channel(channel)\n    _ = self._check(f\"FR{channel},{formula}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_formula_temporary","title":"set_formula_temporary","text":"<pre><code>set_formula_temporary(\n    channel: Literal[1, 2], formula: str\n) -&gt; None\n</code></pre> <p>Set the temporary formula of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>formula</code> <code>str</code> <p>The temporary formula.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_formula_temporary(self, channel: Literal[1, 2], formula: str) -&gt; None:\n    \"\"\"Set the temporary formula of a channel.\n\n    Args:\n        channel: The channel number.\n        formula: The temporary formula.\n    \"\"\"\n    self._check_channel(channel)\n    _ = self._check(f\"FT{channel},{formula}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_gain","title":"set_gain","text":"<pre><code>set_gain(channel: Literal[1, 2], gain: float) -&gt; None\n</code></pre> <p>Set the gain of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>gain</code> <code>float</code> <p>The gain [0.001, 2.000].</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_gain(self, channel: Literal[1, 2], gain: float) -&gt; None:\n    \"\"\"Set the gain of a channel.\n\n    Args:\n        channel: The channel number.\n        gain: The gain [0.001, 2.000].\n    \"\"\"\n    self._check_channel(channel)\n    _ = self._check(f\"GN{channel},{gain}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_input_range","title":"set_input_range","text":"<pre><code>set_input_range(channel: Literal[1, 2], range: int) -&gt; None\n</code></pre> <p>Set the input range of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>range</code> <code>int</code> <p>The input range [1, 10] in Volts.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_input_range(self, channel: Literal[1, 2], range: int) -&gt; None:  # noqa: A002\n    \"\"\"Set the input range of a channel.\n\n    Args:\n        channel: The channel number.\n        range: The input range [1, 10] in Volts.\n    \"\"\"\n    self._check_channel(channel)\n    if range &lt; 1 or range &gt; MAX_RANGE:\n        msg = f\"Invalid input range {range}\"\n        raise ValueError(msg)\n    _ = self._check(f\"IN{channel},{range}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_interface_mode","title":"set_interface_mode","text":"<pre><code>set_interface_mode(mode: int) -&gt; None\n</code></pre> <p>Set the interface mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>int</code> <p>The interface mode.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_interface_mode(self, mode: int) -&gt; None:\n    \"\"\"Set the interface mode.\n\n    Args:\n        mode: The interface mode.\n    \"\"\"\n    _ = self._check(f\"IM,{mode}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_limit_mode","title":"set_limit_mode","text":"<pre><code>set_limit_mode(\n    channel: Literal[1, 2], mode: int | str | LimitMode\n) -&gt; None\n</code></pre> <p>Set the limit mode of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>mode</code> <code>int | str | LimitMode</code> <p>The limit mode. Can be a LimitMode member name or value. For example, <code>LimitMode.BAND</code>, <code>2</code>, or <code>\"BAND\"</code> are equivalent.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_limit_mode(self, channel: Literal[1, 2], mode: int | str | LimitMode) -&gt; None:\n    \"\"\"Set the limit mode of a channel.\n\n    Args:\n        channel: The channel number.\n        mode: The limit mode. Can be a [LimitMode][msl.equipment_resources.mks.pr4000b.LimitMode]\n            member name or value. For example, `LimitMode.BAND`, `2`, or `\"BAND\"` are equivalent.\n    \"\"\"\n    self._check_channel(channel)\n    lm = to_enum(mode, LimitMode, to_upper=True)\n    _ = self._check(f\"LM{channel},{lm}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_linearization_point","title":"set_linearization_point","text":"<pre><code>set_linearization_point(\n    channel: Literal[1, 2], point: int, x: float, y: float\n) -&gt; None\n</code></pre> <p>Set a point in the linearization table of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>point</code> <code>int</code> <p>The point in the table [0, 10].</p> required <code>x</code> <code>float</code> <p>The x value [-5% to 100% of full scale].</p> required <code>y</code> <code>float</code> <p>The y value [-5% to 100% of full scale].</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_linearization_point(self, channel: Literal[1, 2], point: int, x: float, y: float) -&gt; None:\n    \"\"\"Set a point in the linearization table of a channel.\n\n    Args:\n        channel: The channel number.\n        point: The point in the table [0, 10].\n        x: The x value [-5% to 100% of full scale].\n        y: The y value [-5% to 100% of full scale].\n    \"\"\"\n    self._check_channel(channel)\n    if point &lt; 0 or point &gt; MAX_POINT:\n        msg = f\"Invalid point {point}\"\n        raise ValueError(msg)\n    _ = self._check(f\"LN{channel},{point},{x},{y}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_linearization_size","title":"set_linearization_size","text":"<pre><code>set_linearization_size(\n    channel: Literal[1, 2], size: int\n) -&gt; None\n</code></pre> <p>Set the size of the linearization table of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>size</code> <code>int</code> <p>The size of the table.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_linearization_size(self, channel: Literal[1, 2], size: int) -&gt; None:\n    \"\"\"Set the size of the linearization table of a channel.\n\n    Args:\n        channel: The channel number.\n        size: The size of the table.\n    \"\"\"\n    self._check_channel(channel)\n    if size &lt; 0 or size &gt; MAX_SIZE:\n        msg = f\"Invalid size {size}\"\n        raise ValueError(msg)\n    _ = self._check(f\"LS{channel},{size}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_lower_limit","title":"set_lower_limit","text":"<pre><code>set_lower_limit(\n    channel: Literal[1, 2], limit: float\n) -&gt; None\n</code></pre> <p>Set the lower limit of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>limit</code> <code>float</code> <p>The lower limit [-5% to 110% of full scale].</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_lower_limit(self, channel: Literal[1, 2], limit: float) -&gt; None:\n    \"\"\"Set the lower limit of a channel.\n\n    Args:\n        channel: The channel number.\n        limit: The lower limit [-5% to 110% of full scale].\n    \"\"\"\n    self._check_channel(channel)\n    _ = self._check(f\"LL{channel},{limit}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_offset","title":"set_offset","text":"<pre><code>set_offset(channel: Literal[1, 2], offset: int) -&gt; None\n</code></pre> <p>Set the offset of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>offset</code> <code>int</code> <p>The offset [-250, 250].</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_offset(self, channel: Literal[1, 2], offset: int) -&gt; None:\n    \"\"\"Set the offset of a channel.\n\n    Args:\n        channel: The channel number.\n        offset: The offset [-250, 250].\n    \"\"\"\n    self._check_channel(channel)\n    if offset &lt; -MAX_OFFSET or offset &gt; MAX_OFFSET:\n        msg = f\"Invalid offset {offset}, must be between [-{MAX_OFFSET}, {MAX_OFFSET}]\"\n        raise ValueError(msg)\n    _ = self._check(f\"OF{channel},{offset}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_output_range","title":"set_output_range","text":"<pre><code>set_output_range(\n    channel: Literal[1, 2], range: int\n) -&gt; None\n</code></pre> <p>Set the output range of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>range</code> <code>int</code> <p>The output range [1, 10] in Volts.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_output_range(self, channel: Literal[1, 2], range: int) -&gt; None:  # noqa: A002\n    \"\"\"Set the output range of a channel.\n\n    Args:\n        channel: The channel number.\n        range: The output range [1, 10] in Volts.\n    \"\"\"\n    self._check_channel(channel)\n    if range &lt; 1 or range &gt; MAX_RANGE:\n        msg = f\"Invalid output range {range}\"\n        raise ValueError(msg)\n    _ = self._check(f\"OT{channel},{range}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_range","title":"set_range","text":"<pre><code>set_range(\n    channel: Literal[1, 2], range: float, unit: int | str\n) -&gt; None\n</code></pre> <p>Set the range and unit of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>range</code> <code>float</code> <p>The range value.</p> required <code>unit</code> <code>int | str</code> <p>The unit as either an index number [0, 20] or a name (e.g., <code>7</code> or <code>\"kPa\"</code>). See UNIT for the supported unit values.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_range(self, channel: Literal[1, 2], range: float, unit: int | str) -&gt; None:  # noqa: A002\n    \"\"\"Set the range and unit of a channel.\n\n    Args:\n        channel: The channel number.\n        range: The range value.\n        unit: The unit as either an index number [0, 20] or a name (e.g., `7` or `\"kPa\"`).\n            See [UNIT][msl.equipment_resources.mks.pr4000b.UNIT] for the supported unit values.\n    \"\"\"\n    self._check_channel(channel)\n    index = -1\n    if isinstance(unit, str):\n        lower = unit.lower()\n        for i, v in enumerate(UNIT.values()):\n            if v.lower() == lower:\n                index = i\n                break\n    elif unit in UNIT:\n        index = unit\n\n    if index == -1:\n        msg = f\"Invalid unit {unit!r}\"\n        raise ValueError(msg)\n\n    _ = self._check(f\"RG{channel},{range},{index}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_relays","title":"set_relays","text":"<pre><code>set_relays(channel: Literal[1, 2], *, enable: bool) -&gt; None\n</code></pre> <p>Set the relay state of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>enable</code> <code>bool</code> <p>Whether to enable or disable the relay.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_relays(self, channel: Literal[1, 2], *, enable: bool) -&gt; None:\n    \"\"\"Set the relay state of a channel.\n\n    Args:\n        channel: The channel number.\n        enable: Whether to enable or disable the relay.\n    \"\"\"\n    self._check_channel(channel)\n    state = \"ON\" if enable else \"OFF\"\n    _ = self._check(f\"RL{channel},{state}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_remote_mode","title":"set_remote_mode","text":"<pre><code>set_remote_mode(*, enable: bool) -&gt; None\n</code></pre> <p>Set the remote operation mode to be enable or disabled.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>Whether to enable or disable remote operation.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_remote_mode(self, *, enable: bool) -&gt; None:\n    \"\"\"Set the remote operation mode to be enable or disabled.\n\n    Args:\n        enable: Whether to enable or disable remote operation.\n    \"\"\"\n    mode = \"ON\" if enable else \"OFF\"\n    _ = self._check(f\"RT,{mode}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_resolution","title":"set_resolution","text":"<pre><code>set_resolution(*, enable: bool) -&gt; None\n</code></pre> <p>Set the 16-bit resolution to be enabled or disabled.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>Whether to enable or disable 16-bit resolution.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_resolution(self, *, enable: bool) -&gt; None:\n    \"\"\"Set the 16-bit resolution to be enabled or disabled.\n\n    Args:\n        enable: Whether to enable or disable 16-bit resolution.\n    \"\"\"\n    state = \"ON\" if enable else \"OFF\"\n    _ = self._check(f\"RS,{state}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_rtd_offset","title":"set_rtd_offset","text":"<pre><code>set_rtd_offset(channel: Literal[1, 2], offset: int) -&gt; None\n</code></pre> <p>Set the RTD offset of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>offset</code> <code>int</code> <p>The RTD offset [-250, 250].</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_rtd_offset(self, channel: Literal[1, 2], offset: int) -&gt; None:\n    \"\"\"Set the RTD offset of a channel.\n\n    Args:\n        channel: The channel number.\n        offset: The RTD offset [-250, 250].\n    \"\"\"\n    self._check_channel(channel)\n    if offset &lt; -MAX_OFFSET or offset &gt; MAX_OFFSET:\n        msg = f\"Invalid RTD offset {offset}, must be between [-{MAX_OFFSET}, {MAX_OFFSET}]\"\n        raise ValueError(msg)\n    _ = self._check(f\"RO{channel},{offset}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_scale","title":"set_scale","text":"<pre><code>set_scale(channel: Literal[1, 2], scale: float) -&gt; None\n</code></pre> <p>Set the scale of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>scale</code> <code>float</code> <p>The scale.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_scale(self, channel: Literal[1, 2], scale: float) -&gt; None:\n    \"\"\"Set the scale of a channel.\n\n    Args:\n        channel: The channel number.\n        scale: The scale.\n    \"\"\"\n    self._check_channel(channel)\n    _ = self._check(f\"SC{channel},{scale}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_setpoint","title":"set_setpoint","text":"<pre><code>set_setpoint(\n    channel: Literal[1, 2], setpoint: float\n) -&gt; None\n</code></pre> <p>Set the setpoint of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>setpoint</code> <code>float</code> <p>The setpoint.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_setpoint(self, channel: Literal[1, 2], setpoint: float) -&gt; None:\n    \"\"\"Set the setpoint of a channel.\n\n    Args:\n        channel: The channel number.\n        setpoint: The setpoint.\n    \"\"\"\n    self._check_channel(channel)\n    _ = self._check(f\"SP{channel},{setpoint}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_signal_mode","title":"set_signal_mode","text":"<pre><code>set_signal_mode(\n    channel: Literal[1, 2], mode: SignalMode\n) -&gt; None\n</code></pre> <p>Set the range and unit of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>mode</code> <code>SignalMode</code> <p>The signal mode. Can be a SignalMode member name or value. For example, <code>SignalMode.OFF</code>, <code>1</code>, or <code>\"OFF\"</code> are equivalent.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_signal_mode(self, channel: Literal[1, 2], mode: SignalMode) -&gt; None:\n    \"\"\"Set the range and unit of a channel.\n\n    Args:\n        channel: The channel number.\n        mode: The signal mode. Can be a [SignalMode][msl.equipment_resources.mks.pr4000b.SignalMode]\n            member name or value. For example, `SignalMode.OFF`, `1`, or `\"OFF\"` are equivalent.\n    \"\"\"\n    self._check_channel(channel)\n    sm = to_enum(mode, SignalMode, to_upper=True)\n    _ = self._check(f\"SM{channel},{sm}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_tweak_control","title":"set_tweak_control","text":"<pre><code>set_tweak_control(*, enable: bool) -&gt; None\n</code></pre> <p>Set tweak control.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>Whether to switch tweak control on or off.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_tweak_control(self, *, enable: bool) -&gt; None:\n    \"\"\"Set tweak control.\n\n    Args:\n        enable: Whether to switch tweak control on or off.\n    \"\"\"\n    _ = self._check(\"$1\" if enable else \"$0\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_upper_limit","title":"set_upper_limit","text":"<pre><code>set_upper_limit(\n    channel: Literal[1, 2], limit: float\n) -&gt; None\n</code></pre> <p>Set the upper limit of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>limit</code> <code>float</code> <p>The upper limit [-5% to 110% of full scale].</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_upper_limit(self, channel: Literal[1, 2], limit: float) -&gt; None:\n    \"\"\"Set the upper limit of a channel.\n\n    Args:\n        channel: The channel number.\n        limit: The upper limit [-5% to 110% of full scale].\n    \"\"\"\n    self._check_channel(channel)\n    _ = self._check(f\"UL{channel},{limit}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.set_valve","title":"set_valve","text":"<pre><code>set_valve(channel: Literal[1, 2], *, enable: bool) -&gt; None\n</code></pre> <p>Set the state of the valve of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Literal[1, 2]</code> <p>The channel number.</p> required <code>enable</code> <code>bool</code> <p>Whether to enable or disable the valve state.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def set_valve(self, channel: Literal[1, 2], *, enable: bool) -&gt; None:\n    \"\"\"Set the state of the valve of a channel.\n\n    Args:\n        channel: The channel number.\n        enable: Whether to enable or disable the valve state.\n    \"\"\"\n    if channel == 0:  # pyright: ignore[reportUnnecessaryComparison]\n        msg = (  # pyright: ignore[reportUnreachable]\n            \"The manual indicates that you can specify channel=0 \"\n            \"to set both valves simultaneously, but that does not work\"\n        )\n        raise ValueError(msg)\n\n    self._check_channel(channel)\n    state = \"ON\" if enable else \"OFF\"\n    _ = self._check(f\"VL{channel},{state}\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.status","title":"status","text":"<pre><code>status() -&gt; int\n</code></pre> <p>Request status bits.</p> <p>Returns:</p> Type Description <code>int</code> <p>The status value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def status(self) -&gt; int:\n    \"\"\"Request status bits.\n\n    Returns:\n        The status value.\n    \"\"\"\n    return int(self.query(\"ST\"))\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.PR4000B.unlock","title":"unlock","text":"<pre><code>unlock() -&gt; None\n</code></pre> <p>Unlock setup.</p> Source code in <code>packages/resources/src/msl/equipment_resources/mks/pr4000b.py</code> <pre><code>def unlock(self) -&gt; None:\n    \"\"\"Unlock setup.\"\"\"\n    _ = self._check(\"#0\")\n</code></pre>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.SignalMode","title":"SignalMode","text":"<p>               Bases: <code>IntEnum</code></p> <p>Signal mode type.</p> <p>Determines the source of the setpoint which shall be applied to the respective channel.</p> <p>Attributes:</p> Name Type Description <code>METER</code> <code>int</code> <p>0</p> <code>OFF</code> <code>int</code> <p>1</p> <code>INDEPENDENT</code> <code>int</code> <p>2</p> <code>EXTERNAL</code> <code>int</code> <p>3</p> <code>SLAVE</code> <code>int</code> <p>4</p> <code>RTD</code> <code>int</code> <p>5</p>"},{"location":"resources/mks/pr4000b/#msl.equipment_resources.mks.pr4000b.Tag","title":"Tag","text":"<p>               Bases: <code>IntEnum</code></p> <p>Display tag types.</p> <p>Attributes:</p> Name Type Description <code>SP</code> <code>int</code> <p>0</p> <code>VA</code> <code>int</code> <p>1</p> <code>CH</code> <code>int</code> <p>2</p> <code>FL</code> <code>int</code> <p>3</p> <code>PR</code> <code>int</code> <p>4</p> <code>EX</code> <code>int</code> <p>5</p>"},{"location":"resources/nkt/nktpdll/","title":"NKTPDLL","text":"<p>Wrapper around the <code>NKTPDLL.dll</code> SDK from NKT Photonics.</p> <p>The wrapper was written using v2.1.2.766 of the SDK.</p>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.DeviceStatusCallback","title":"DeviceStatusCallback  <code>module-attribute</code>","text":"<pre><code>DeviceStatusCallback = CFUNCTYPE(\n    None, c_char_p, c_ubyte, c_ubyte, c_ubyte, c_void_p\n)\n</code></pre> <p>A callback function when the status of a device changes.</p>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.PortStatusCallback","title":"PortStatusCallback  <code>module-attribute</code>","text":"<pre><code>PortStatusCallback = CFUNCTYPE(\n    None, c_char_p, c_ubyte, c_ubyte, c_ubyte, c_ubyte\n)\n</code></pre> <p>A callback function when the status of a port changes.</p>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.RegisterStatusCallback","title":"RegisterStatusCallback  <code>module-attribute</code>","text":"<pre><code>RegisterStatusCallback = CFUNCTYPE(\n    None,\n    c_char_p,\n    c_ubyte,\n    c_ubyte,\n    c_ubyte,\n    c_ubyte,\n    c_ubyte,\n    c_void_p,\n)\n</code></pre> <p>A callback function when the status of a register changes.</p>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.DateTime","title":"DateTime","text":"<p>               Bases: <code>Structure</code></p> <p>The DateTimeType struct (24 hour format).</p> <p>Attributes:</p> Name Type Description <code>Sec</code> <code>c_uint8</code> <p>Second.</p> <code>Min</code> <code>c_uint8</code> <p>Minute.</p> <code>Hour</code> <code>c_uint8</code> <p>Hour.</p> <code>Day</code> <code>c_uint8</code> <p>Day.</p> <code>Month</code> <code>c_uint8</code> <p>Month.</p> <code>Year</code> <code>c_uint8</code> <p>Year.</p>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.DeviceMode","title":"DeviceMode","text":"<p>               Bases: <code>IntEnum</code></p> <p>The DeviceModeTypes enum.</p> <p>Attributes:</p> Name Type Description <code>Disabled</code> <code>int</code> <p>The device is disabled. Not being polled and serviced, <code>0</code>.</p> <code>AnalyseInit</code> <code>int</code> <p>The analyse cycle has been started for the device, <code>1</code>.</p> <code>Analyse</code> <code>int</code> <p>The analyse cycle is in progress. All default registers being read to determine its state, <code>2</code>.</p> <code>Normal</code> <code>int</code> <p>The analyse cycle has completed and the device is ready, <code>3</code>.</p> <code>LogDownload</code> <code>int</code> <p>A log is being downloaded from the device, <code>4</code>.</p> <code>Error</code> <code>int</code> <p>The device is in an error state, <code>5</code>.</p> <code>Timeout</code> <code>int</code> <p>The connection to the device has been lost, <code>6</code>.</p> <code>Upload</code> <code>int</code> <p>The device is in upload mode and can not be used normally, <code>7</code>.</p>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.DeviceStatus","title":"DeviceStatus","text":"<p>               Bases: <code>IntEnum</code></p> <p>The DeviceStatusTypes enum.</p> <p>Attributes:</p> Name Type Description <code>ModeChanged</code> <code>int</code> <p>Data contains 1 unsigned byte DeviceMode, <code>0</code>.</p> <code>LiveChanged</code> <code>int</code> <p>Data contains 1 unsigned byte, 0=live off, 1=live on, <code>1</code>.</p> <code>TypeChanged</code> <code>int</code> <p>Data contains 1 unsigned byte with DeviceType, <code>2</code>.</p> <code>PartNumberChanged</code> <code>int</code> <p>Data contains a zero terminated string with part number, <code>3</code>.</p> <code>PCBVersionChanged</code> <code>int</code> <p>Data contains 1 unsigned byte with PCB version number, <code>4</code>.</p> <code>StatusBitsChanged</code> <code>int</code> <p>Data contains 1 unsigned long with status bits, <code>5</code>.</p> <code>ErrorCodeChanged</code> <code>int</code> <p>Data contains 1 unsigned short with error code, <code>6</code>.</p> <code>BlVerChanged</code> <code>int</code> <p>Data contains a zero terminated string with Bootloader version, <code>7</code>.</p> <code>FwVerChanged</code> <code>int</code> <p>Data contains a zero terminated string with Firmware version, <code>8</code>.</p> <code>ModuleSerialChanged</code> <code>int</code> <p>Data contains a zero terminated string with Module serial number, <code>9</code>.</p> <code>PCBSerialChanged</code> <code>int</code> <p>Data contains a zero terminated string with PCB serial number, <code>10</code>.</p> <code>SysTypeChanged</code> <code>int</code> <p>Data contains 1 unsigned byte with SystemType, <code>11</code>.</p>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT","title":"NKT","text":"<pre><code>NKT(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Wrapper around the <code>NKTPDLL.dll</code> SDK from NKT Photonics.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for the NKT wrapper.</p> <p>Connection Properties:</p> Name Type Description <code>sdk_path</code> <code>str</code> <p>The path to the SDK library. Default: <code>\"NKTPDLL.dll\"</code></p> <code>open_port</code> <code>bool</code> <p>Whether to automatically open the port. Default: <code>True</code></p> <code>auto</code> <code>bool</code> <p>Whether to open the port with bus scanning. Default: <code>True</code></p> <code>live</code> <code>bool</code> <p>Whether to open the port in live mode. Default: <code>True</code></p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Wrapper around the `NKTPDLL.dll` SDK from [NKT Photonics](https://www.nktphotonics.com/).\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for the NKT wrapper.\n\n    Attributes: Connection Properties:\n        sdk_path (str): The path to the SDK library. _Default: `\"NKTPDLL.dll\"`_\n        open_port (bool): Whether to automatically open the port. _Default: `True`_\n        auto (bool): Whether to open the port with bus scanning. _Default: `True`_\n        live (bool): Whether to open the port in live mode. _Default: `True`_\n    \"\"\"\n    super().__init__(equipment)\n\n    assert equipment.connection is not None  # noqa: S101\n    address = equipment.connection.address\n    self._portname: bytes = address.encode()\n\n    p = equipment.connection.properties\n    _load_sdk(p.get(\"sdk_path\", _path), self)\n    assert NKT._SDK is not None  # noqa: S101\n\n    self._sdk: CDLL = NKT._SDK\n    if p.get(\"open_port\", True):\n        NKT.open_ports(address, auto=p.get(\"auto\", True), live=p.get(\"live\", True))\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.close_ports","title":"close_ports  <code>staticmethod</code>","text":"<pre><code>close_ports(*ports: str) -&gt; None\n</code></pre> <p>Close the specified port(s).</p> <p>Parameters:</p> Name Type Description Default <code>ports</code> <code>str</code> <p>The name(s) of the port(s) to close. If not specified, close all opened ports. Port names are case sensitive.</p> <code>()</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>@staticmethod\ndef close_ports(*ports: str) -&gt; None:\n    \"\"\"Close the specified port(s).\n\n    Args:\n        ports: The name(s) of the port(s) to close. If not specified, close all opened ports.\n            Port names are case sensitive.\n    \"\"\"\n    if NKT._SDK is None:\n        return\n\n    _names = b\",\".join(port.encode() for port in ports)\n    NKT._SDK.closePorts(ports)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_create","title":"device_create","text":"<pre><code>device_create(device_id: int, *, wait_ready: bool) -&gt; None\n</code></pre> <p>Creates a device in the internal device list.</p> <p>If the open_ports function has been called with <code>live=True</code> then the kernel immediately starts to monitor the device.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>wait_ready</code> <code>bool</code> <p><code>False</code> means don't wait for the device to be ready. <code>True</code> means to wait up to 2 seconds for the device to complete its analyse cycle. (All standard registers being successfully read)</p> required Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_create(self, device_id: int, *, wait_ready: bool) -&gt; None:\n    \"\"\"Creates a device in the internal device list.\n\n    If the [open_ports][msl.equipment_resources.nkt.nktpdll.NKT.open_ports] function has\n    been called with `live=True` then the kernel immediately starts to monitor the device.\n\n    Args:\n        device_id: The device id (module address).\n        wait_ready: `False` means don't wait for the device to be ready. `True` means to\n            wait up to 2 seconds for the device to complete its analyse cycle.\n            (All standard registers being successfully read)\n    \"\"\"\n    self._sdk.deviceCreate(self._portname, device_id, int(bool(wait_ready)))\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_exists","title":"device_exists","text":"<pre><code>device_exists(device_id: int) -&gt; bool\n</code></pre> <p>Checks if a specific device already exists in the internal device list.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the device exists.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_exists(self, device_id: int) -&gt; bool:\n    \"\"\"Checks if a specific device already exists in the internal device list.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        Whether the device exists.\n    \"\"\"\n    exists = c_ubyte(0)\n    self._sdk.deviceExists(self._portname, device_id, exists)\n    return bool(exists.value)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_all_types","title":"device_get_all_types  <code>staticmethod</code>","text":"<pre><code>device_get_all_types(\n    *ports: str, size: int = 255\n) -&gt; dict[str, dict[str, int]]\n</code></pre> <p>Returns all device types (module types) from the internal device list.</p> <p>Parameters:</p> Name Type Description Default <code>ports</code> <code>str</code> <p>A port or multiple ports. If not specified then the get_open_ports method is called.</p> <code>()</code> <code>size</code> <code>int</code> <p>The maximum number of bytes that the device list can be.</p> <code>255</code> <p>Returns:</p> Type Description <code>dict[str, dict[str, int]]</code> <p>The port names are the keys and each value is dict with the module type as the keys and its corresponding device ID as the value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>@staticmethod\ndef device_get_all_types(*ports: str, size: int = 255) -&gt; dict[str, dict[str, int]]:\n    \"\"\"Returns all device types (module types) from the internal device list.\n\n    Args:\n        ports: A port or multiple ports. If not specified then the\n            [get_open_ports][msl.equipment_resources.nkt.nktpdll.NKT.get_open_ports]\n            method is called.\n        size: The maximum number of bytes that the device list can be.\n\n    Returns:\n        The port names are the keys and each value is [dict][] with the\n            module type as the keys and its corresponding device ID as the value.\n    \"\"\"\n    if NKT._SDK is None:\n        msg = \"NKTError: You must first call NKT.load_sdk()\"\n        raise RuntimeError(msg)\n\n    if not ports:\n        opened_ports = [port.encode() for port in NKT.get_open_ports()]\n    else:\n        opened_ports = [port.encode() for port in ports]\n\n    out: dict[str, dict[str, int]] = {}\n    length = c_ubyte(size)\n    types = create_string_buffer(size)\n    for port in opened_ports:\n        NKT._SDK.deviceGetAllTypes(port, types, length)\n        key = port.decode()\n        out[key] = {}\n        for dev_id, typ in enumerate(types.raw):\n            if typ != 0:\n                out[key][f\"0x{typ:02X}\"] = dev_id\n    return out\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_boot_loader_version","title":"device_get_boot_loader_version","text":"<pre><code>device_get_boot_loader_version(device_id: int) -&gt; int\n</code></pre> <p>Returns the boot-loader version (int) for a given device id.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The boot-loader version.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_get_boot_loader_version(self, device_id: int) -&gt; int:\n    \"\"\"Returns the boot-loader version (int) for a given device id.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        The boot-loader version.\n    \"\"\"\n    version = c_ushort(0)\n    self._sdk.deviceGetBootloaderVersion(self._portname, device_id, version)\n    return version.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_boot_loader_version_str","title":"device_get_boot_loader_version_str","text":"<pre><code>device_get_boot_loader_version_str(device_id: int) -&gt; str\n</code></pre> <p>Returns the boot-loader version (string) for a given device id.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>str</code> <p>The boot-loader version.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_get_boot_loader_version_str(self, device_id: int) -&gt; str:\n    \"\"\"Returns the boot-loader version (string) for a given device id.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        The boot-loader version.\n    \"\"\"\n    size = c_ubyte(255)\n    version = create_string_buffer(size.value)\n    self._sdk.deviceGetBootloaderVersionStr(self._portname, device_id, version, size)\n    return bytes(version.value).decode()\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_error_code","title":"device_get_error_code","text":"<pre><code>device_get_error_code(device_id: int) -&gt; int\n</code></pre> <p>Returns the error code for a given device id.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The error code.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_get_error_code(self, device_id: int) -&gt; int:\n    \"\"\"Returns the error code for a given device id.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        The error code.\n    \"\"\"\n    error_code = c_ushort(0)\n    self._sdk.deviceGetErrorCode(self._portname, device_id, error_code)\n    return error_code.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_firmware_version","title":"device_get_firmware_version","text":"<pre><code>device_get_firmware_version(device_id: int) -&gt; int\n</code></pre> <p>Returns the firmware version (int) for a given device id.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The firmware version.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_get_firmware_version(self, device_id: int) -&gt; int:\n    \"\"\"Returns the firmware version (int) for a given device id.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        The firmware version.\n    \"\"\"\n    version = c_ushort(0)\n    self._sdk.deviceGetFirmwareVersion(self._portname, device_id, version)\n    return version.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_firmware_version_str","title":"device_get_firmware_version_str","text":"<pre><code>device_get_firmware_version_str(device_id: int) -&gt; str\n</code></pre> <p>Returns the firmware version (string) for a given device id.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>str</code> <p>The firmware version.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_get_firmware_version_str(self, device_id: int) -&gt; str:\n    \"\"\"Returns the firmware version (string) for a given device id.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        The firmware version.\n    \"\"\"\n    size = c_ubyte(255)\n    version = create_string_buffer(size.value)\n    self._sdk.deviceGetFirmwareVersionStr(self._portname, device_id, version, size)\n    return bytes(version.value).decode()\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_live","title":"device_get_live","text":"<pre><code>device_get_live(device_id: int) -&gt; bool\n</code></pre> <p>Returns the internal device live status for a specific device id.</p> <p>Requires the port being already opened with the open_ports function and the device being already created, either automatically or with the device_create function.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether live mode is enabled.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_get_live(self, device_id: int) -&gt; bool:\n    \"\"\"Returns the internal device live status for a specific device id.\n\n    Requires the port being already opened with the [open_ports][msl.equipment_resources.nkt.nktpdll.NKT.open_ports]\n    function and the device being already created, either automatically or with the\n    [device_create][msl.equipment_resources.nkt.nktpdll.NKT.device_create] function.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        Whether live mode is enabled.\n    \"\"\"\n    live_mode = c_ubyte(0)\n    self._sdk.deviceGetLive(self._portname, device_id, live_mode)\n    return bool(live_mode.value)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_mode","title":"device_get_mode","text":"<pre><code>device_get_mode(device_id: int) -&gt; DeviceMode\n</code></pre> <p>Returns the internal device mode for a specific device id.</p> <p>Requires the port being already opened with the open_ports function and the device being already created, either automatically or with the device_create function.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>DeviceMode</code> <p>The device mode type.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_get_mode(self, device_id: int) -&gt; DeviceMode:\n    \"\"\"Returns the internal device mode for a specific device id.\n\n    Requires the port being already opened with the [open_ports][msl.equipment_resources.nkt.nktpdll.NKT.open_ports]\n    function and the device being already created, either automatically or with the\n    [device_create][msl.equipment_resources.nkt.nktpdll.NKT.device_create] function.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        The device mode type.\n    \"\"\"\n    dev_mode = c_ubyte(0)\n    self._sdk.deviceGetMode(self._portname, device_id, dev_mode)\n    return DeviceMode(dev_mode.value)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_module_serial_number_str","title":"device_get_module_serial_number_str","text":"<pre><code>device_get_module_serial_number_str(device_id: int) -&gt; str\n</code></pre> <p>Returns the module serial number (string) for a given device id.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>str</code> <p>The serial number.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_get_module_serial_number_str(self, device_id: int) -&gt; str:\n    \"\"\"Returns the module serial number (string) for a given device id.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        The serial number.\n    \"\"\"\n    size = c_ubyte(255)\n    serial = create_string_buffer(size.value)\n    self._sdk.deviceGetModuleSerialNumberStr(self._portname, device_id, serial, size)\n    return bytes(serial.value).decode()\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_part_number_str","title":"device_get_part_number_str","text":"<pre><code>device_get_part_number_str(device_id: int) -&gt; str\n</code></pre> <p>Returns the part number for a given device id.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>str</code> <p>The part number.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_get_part_number_str(self, device_id: int) -&gt; str:\n    \"\"\"Returns the part number for a given device id.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        The part number.\n    \"\"\"\n    size = c_ubyte(255)\n    part = create_string_buffer(size.value)\n    self._sdk.deviceGetPartNumberStr(self._portname, device_id, part, size)\n    return bytes(part.value).decode()\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_pcb_serial_number_str","title":"device_get_pcb_serial_number_str","text":"<pre><code>device_get_pcb_serial_number_str(device_id: int) -&gt; str\n</code></pre> <p>Returns the PCB serial number (string) for a given device id.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>str</code> <p>The part number.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_get_pcb_serial_number_str(self, device_id: int) -&gt; str:\n    \"\"\"Returns the PCB serial number (string) for a given device id.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        The part number.\n    \"\"\"\n    size = c_ubyte(255)\n    serial = create_string_buffer(size.value)\n    self._sdk.deviceGetPCBSerialNumberStr(self._portname, device_id, serial, size)\n    return bytes(serial.value).decode()\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_pcb_version","title":"device_get_pcb_version","text":"<pre><code>device_get_pcb_version(device_id: int) -&gt; int\n</code></pre> <p>Returns the PCB version for a given device id.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The PCB version number.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_get_pcb_version(self, device_id: int) -&gt; int:\n    \"\"\"Returns the PCB version for a given device id.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        The PCB version number.\n    \"\"\"\n    version = c_ubyte(0)\n    self._sdk.deviceGetPCBVersion(self._portname, device_id, version)\n    return version.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_status_bits","title":"device_get_status_bits","text":"<pre><code>device_get_status_bits(device_id: int) -&gt; int\n</code></pre> <p>Returns the status bits for a given device id.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The status bits.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_get_status_bits(self, device_id: int) -&gt; int:\n    \"\"\"Returns the status bits for a given device id.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        The status bits.\n    \"\"\"\n    status = c_ushort(0)\n    self._sdk.deviceGetStatusBits(self._portname, device_id, status)\n    return status.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_get_type","title":"device_get_type","text":"<pre><code>device_get_type(device_id: int) -&gt; int\n</code></pre> <p>Returns the module type for a specific device id.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The module type.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_get_type(self, device_id: int) -&gt; int:\n    \"\"\"Returns the module type for a specific device id.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        The module type.\n    \"\"\"\n    dev_type = c_ubyte(0)\n    self._sdk.deviceGetType(self._portname, device_id, dev_type)\n    return dev_type.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_remove","title":"device_remove","text":"<pre><code>device_remove(device_id: int) -&gt; None\n</code></pre> <p>Remove a specific device from the internal device list.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_remove(self, device_id: int) -&gt; None:\n    \"\"\"Remove a specific device from the internal device list.\n\n    Args:\n        device_id: The device id (module address).\n    \"\"\"\n    self._sdk.deviceRemove(self._portname, device_id)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_remove_all","title":"device_remove_all","text":"<pre><code>device_remove_all() -&gt; None\n</code></pre> <p>Remove all devices from the internal device list.</p> <p>No confirmation is given, the list is simply cleared.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_remove_all(self) -&gt; None:\n    \"\"\"Remove all devices from the internal device list.\n\n    No confirmation is given, the list is simply cleared.\n    \"\"\"\n    self._sdk.deviceRemoveAll(self._portname)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.device_set_live","title":"device_set_live","text":"<pre><code>device_set_live(device_id: int, *, enabled: bool) -&gt; None\n</code></pre> <p>Sets the internal device live status for a specific device id (module address).</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>enabled</code> <code>bool</code> <p>Whether to enable (<code>True</code>) or disable (<code>False</code>) live status.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_set_live(self, device_id: int, *, enabled: bool) -&gt; None:\n    \"\"\"Sets the internal device live status for a specific device id (module address).\n\n    Args:\n        device_id: The device id (module address).\n        enabled: Whether to enable (`True`) or disable (`False`) live status.\n    \"\"\"\n    self._sdk.deviceSetLive(self._portname, device_id, int(enabled))\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the port.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Disconnect from the port.\"\"\"\n    if hasattr(self, \"_address\") and self._portname:\n        self.close_ports(self._portname.decode())\n        self._portname = b\"\"\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.get_all_ports","title":"get_all_ports  <code>staticmethod</code>","text":"<pre><code>get_all_ports(size: int = 255) -&gt; list[str]\n</code></pre> <p>Returns a list of all ports.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>The maximum size of the string buffer to fetch the results.</p> <code>255</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of port names.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>@staticmethod\ndef get_all_ports(size: int = 255) -&gt; list[str]:\n    \"\"\"Returns a list of all ports.\n\n    Args:\n        size: The maximum size of the string buffer to fetch the results.\n\n    Returns:\n        A list of port names.\n    \"\"\"\n    if NKT._SDK is None:\n        msg = \"NKTError: You must first call NKT.load_sdk()\"\n        raise RuntimeError(msg)\n\n    length = c_ushort(size)\n    names = create_string_buffer(size)\n    NKT._SDK.getAllPorts(names, length)\n    return [name for name in bytes(names.value).decode().split(\",\") if name]\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.get_legacy_bus_scanning","title":"get_legacy_bus_scanning  <code>staticmethod</code>","text":"<pre><code>get_legacy_bus_scanning() -&gt; bool\n</code></pre> <p>Get the bus-scanning mode.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if in legacy mode, <code>False</code> if in normal mode.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>@staticmethod\ndef get_legacy_bus_scanning() -&gt; bool:\n    \"\"\"Get the bus-scanning mode.\n\n    Returns:\n        `True` if in legacy mode, `False` if in normal mode.\n    \"\"\"\n    if NKT._SDK is None:\n        msg = \"NKTError: You must first call NKT.load_sdk()\"\n        raise RuntimeError(msg)\n\n    return bool(NKT._SDK.getLegacyBusScanning())\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.get_modules","title":"get_modules","text":"<pre><code>get_modules(size: int = 255) -&gt; dict[str, int]\n</code></pre> <p>Returns all device types (module types) from the device.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>The maximum number of bytes that the device list can be.</p> <code>255</code> <p>Returns:</p> Type Description <code>dict[str, int]</code> <p>The module type as the keys and its corresponding device ID as the value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def get_modules(self, size: int = 255) -&gt; dict[str, int]:\n    \"\"\"Returns all device types (module types) from the device.\n\n    Args:\n        size: The maximum number of bytes that the device list can be.\n\n    Returns:\n        The module type as the keys and its corresponding device ID as the value.\n    \"\"\"\n    a = self._portname.decode()\n    return NKT.device_get_all_types(a, size=size)[a]\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.get_open_ports","title":"get_open_ports  <code>staticmethod</code>","text":"<pre><code>get_open_ports(size: int = 255) -&gt; list[str]\n</code></pre> <p>Returns a list of already-opened ports.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>The maximum size of the string buffer to fetch the results.</p> <code>255</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of port names that are already open.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>@staticmethod\ndef get_open_ports(size: int = 255) -&gt; list[str]:\n    \"\"\"Returns a list of already-opened ports.\n\n    Args:\n        size: The maximum size of the string buffer to fetch the results.\n\n    Returns:\n        A list of port names that are already open.\n    \"\"\"\n    if NKT._SDK is None:\n        msg = \"NKTError: You must first call NKT.load_sdk()\"\n        raise RuntimeError(msg)\n\n    length = c_ushort(size)\n    names = create_string_buffer(size)\n    NKT._SDK.getOpenPorts(names, length)\n    return [name for name in bytes(names.value).decode().split(\",\") if name]\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.get_port_error_msg","title":"get_port_error_msg","text":"<pre><code>get_port_error_msg() -&gt; str\n</code></pre> <p>Retrieve error message for the port.</p> <p>Returns:</p> Type Description <code>str</code> <p>The error message. An empty string indicates no error.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def get_port_error_msg(self) -&gt; str:\n    \"\"\"Retrieve error message for the port.\n\n    Returns:\n        The error message. An empty string indicates no error.\n    \"\"\"\n    length = c_ushort(255)\n    msg = create_string_buffer(length.value)\n    self._sdk.getPortErrorMsg(self._portname, msg, length)\n    return bytes(msg.value).decode()\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.get_port_status","title":"get_port_status","text":"<pre><code>get_port_status() -&gt; PortStatus\n</code></pre> <p>Get the status of the port.</p> <p>Returns:</p> Type Description <code>PortStatus</code> <p>The port status.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def get_port_status(self) -&gt; PortStatus:\n    \"\"\"Get the status of the port.\n\n    Returns:\n        The port status.\n    \"\"\"\n    status = c_ubyte(0)\n    self._sdk.getPortStatus(self._portname, status)\n    return PortStatus(status.value)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.load_sdk","title":"load_sdk  <code>staticmethod</code>","text":"<pre><code>load_sdk(path: PathLike | None = None) -&gt; None\n</code></pre> <p>Load the SDK.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>PathLike | None</code> <p>The path to <code>NKTPDLL.dll</code>. Reads from the <code>NKTP_SDK_PATH</code> environment variable if not specified.</p> <code>None</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>@staticmethod\ndef load_sdk(path: PathLike | None = None) -&gt; None:\n    \"\"\"Load the SDK.\n\n    Args:\n        path: The path to `NKTPDLL.dll`. Reads from the `NKTP_SDK_PATH` environment\n            variable if not specified.\n    \"\"\"\n    _load_sdk(_path if not path else os.fsdecode(path))\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.open_ports","title":"open_ports  <code>staticmethod</code>","text":"<pre><code>open_ports(\n    *names: str, auto: bool = True, live: bool = True\n) -&gt; None\n</code></pre> <p>Open the specified port(s).</p> <p>Repeated calls to this function is allowed to reopen and/or rescan for devices.</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>str</code> <p>If not specified then open all available ports are opened. Port names are case sensitive. Example port names are <code>\"AcoustikPort1\"</code>, <code>\"COM6\"</code>.</p> <code>()</code> <code>auto</code> <code>bool</code> <p>If <code>True</code> then automatically start bus scanning and add the found devices in the internal device list. If <code>False</code> then bus scanning and device creation is not automatically handled. The port is automatically closed if no devices are found.</p> <code>True</code> <code>live</code> <code>bool</code> <p>If <code>True</code> then keep all the found or created devices in live mode, which means the inter-bus kernel keeps monitoring all the found devices and their registers. Please note that this will keep the modules watchdog alive as long as the port is open. If <code>False</code> then disable continuous monitoring of the registers. No callback is possible on register changes, so you must call the register_read, register_write and register_write_read methods.</p> <code>True</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>@staticmethod\ndef open_ports(*names: str, auto: bool = True, live: bool = True) -&gt; None:\n    \"\"\"Open the specified port(s).\n\n    Repeated calls to this function is allowed to reopen and/or rescan for devices.\n\n    Args:\n        names: If not specified then open all available ports are opened. Port\n            names are case sensitive. Example port names are `\"AcoustikPort1\"`, `\"COM6\"`.\n        auto: If `True` then automatically start bus scanning and add the\n            found devices in the internal device list. If `False` then\n            bus scanning and device creation is not automatically handled. The\n            port is automatically closed if no devices are found.\n        live: If `True` then keep all the found or created devices in live\n            mode, which means the inter-bus kernel keeps monitoring all the found\n            devices and their registers. Please note that this will keep the modules\n            watchdog alive as long as the port is open. If `False` then disable\n            continuous monitoring of the registers. No callback is possible on register\n            changes, so you must call the [register_read][msl.equipment_resources.nkt.nktpdll.NKT.register_read],\n            [register_write][msl.equipment_resources.nkt.nktpdll.NKT.register_write] and\n            [register_write_read][msl.equipment_resources.nkt.nktpdll.NKT.register_write_read]\n            methods.\n    \"\"\"\n    if NKT._SDK is None:\n        msg = \"NKTError: You must first call NKT.load_sdk()\"\n        raise RuntimeError(msg)\n\n    _names = b\",\".join(name.encode() for name in names)\n    NKT._SDK.openPorts(names, int(bool(auto)), int(bool(live)))\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.point_to_point_port_add","title":"point_to_point_port_add","text":"<pre><code>point_to_point_port_add(port: PointToPoint) -&gt; None\n</code></pre> <p>Creates or modifies a point-to-point port.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>PointToPoint</code> <p>A point-to-point port.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def point_to_point_port_add(self, port: PointToPoint) -&gt; None:\n    \"\"\"Creates or modifies a point-to-point port.\n\n    Args:\n        port: A point-to-point port.\n    \"\"\"\n    self._sdk.pointToPointPortAdd(\n        self._portname,\n        port.host_address.encode(),\n        port.host_port,\n        port.client_address.encode(),\n        port.client_port,\n        port.protocol,\n        port.ms_timeout,\n    )\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.point_to_point_port_del","title":"point_to_point_port_del","text":"<pre><code>point_to_point_port_del() -&gt; None\n</code></pre> <p>Delete the point-to-point port.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def point_to_point_port_del(self) -&gt; None:\n    \"\"\"Delete the point-to-point port.\"\"\"\n    self._sdk.pointToPointPortDel(self._portname)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.point_to_point_port_get","title":"point_to_point_port_get","text":"<pre><code>point_to_point_port_get() -&gt; PointToPoint\n</code></pre> <p>Retrieve the information about the point-to-point port setting.</p> <p>Returns:</p> Type Description <code>PointToPoint</code> <p>The information about the point-to-point port setting.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def point_to_point_port_get(self) -&gt; PointToPoint:\n    \"\"\"Retrieve the information about the point-to-point port setting.\n\n    Returns:\n        The information about the point-to-point port setting.\n    \"\"\"\n    host_length = c_ubyte(255)\n    host_address = create_string_buffer(host_length.value)\n    host_port = c_ushort(0)\n    client_length = c_ubyte(255)\n    client_address = create_string_buffer(client_length.value)\n    client_port = c_ushort(0)\n    protocol = c_ubyte(0)\n    ms_timeout = c_ubyte(0)\n    self._sdk.pointToPointPortGet(\n        self._portname,\n        host_address,\n        host_length,\n        host_port,\n        client_address,\n        client_length,\n        client_port,\n        protocol,\n        ms_timeout,\n    )\n    return PointToPoint(\n        host_address=host_address.value.decode(),\n        host_port=host_port.value,\n        client_address=client_address.value.decode(),\n        client_port=client_port.value,\n        protocol=protocol.value,\n        ms_timeout=ms_timeout.value,\n    )\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_create","title":"register_create","text":"<pre><code>register_create(\n    device_id: int,\n    reg_id: int,\n    priority: int | RegisterPriority,\n    data: int | RegisterData,\n) -&gt; None\n</code></pre> <p>Creates a register in the internal register list.</p> <p>If the open_ports function has been called with <code>live=True</code> then the kernel immediately starts to monitor the register.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>priority</code> <code>int | RegisterPriority</code> <p>The monitoring priority.</p> required <code>data</code> <code>int | RegisterData</code> <p>The register data type. Not used internally but could be used in a common callback function to determine the data type.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_create(\n    self, device_id: int, reg_id: int, priority: int | RegisterPriority, data: int | RegisterData\n) -&gt; None:\n    \"\"\"Creates a register in the internal register list.\n\n    If the [open_ports][msl.equipment_resources.nkt.nktpdll.NKT.open_ports] function has\n    been called with `live=True` then the kernel immediately starts to monitor the register.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        priority: The monitoring priority.\n        data: The register data type. Not used internally but could be used in a\n            common callback function to determine the data type.\n    \"\"\"\n    self._sdk.registerCreate(self._portname, device_id, reg_id, RegisterPriority(priority), RegisterData(data))\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_exists","title":"register_exists","text":"<pre><code>register_exists(device_id: int, reg_id: int) -&gt; bool\n</code></pre> <p>Checks if a specific register already exists in the internal register list.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the register exists.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_exists(self, device_id: int, reg_id: int) -&gt; bool:\n    \"\"\"Checks if a specific register already exists in the internal register list.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n\n    Returns:\n        Whether the register exists.\n    \"\"\"\n    exists = c_ubyte(0)\n    self._sdk.registerExists(self._portname, device_id, reg_id, exists)\n    return bool(exists.value)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_get_all","title":"register_get_all","text":"<pre><code>register_get_all(device_id: int) -&gt; list[int]\n</code></pre> <p>Returns the register ids (register addresses) from the internal register list.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>The register ids.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_get_all(self, device_id: int) -&gt; list[int]:\n    \"\"\"Returns the register ids (register addresses) from the internal register list.\n\n    Args:\n        device_id: The device id (module address).\n\n    Returns:\n        The register ids.\n    \"\"\"\n    size = c_ubyte(255)\n    regs = create_string_buffer(size.value)\n    self._sdk.registerGetAll(self._portname, device_id, regs, size)\n    ids: list[int] = list(regs.value)\n    return ids\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_read","title":"register_read","text":"<pre><code>register_read(\n    device_id: int, reg_id: int, index: int = -1\n) -&gt; bytes\n</code></pre> <p>Reads a register value and returns the result.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to extract data from a specific position in the register. Index is byte counted.</p> <code>-1</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The register value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_read(self, device_id: int, reg_id: int, index: int = -1) -&gt; bytes:\n    \"\"\"Reads a register value and returns the result.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        index: Value index. Typically -1, but could be used to extract data from\n            a specific position in the register. Index is byte counted.\n\n    Returns:\n        The register value.\n    \"\"\"\n    size = c_ubyte(255)\n    data = create_string_buffer(size.value)\n    self._sdk.registerRead(self._portname, device_id, reg_id, data, size, index)\n    return data.raw[: size.value]\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_read_ascii","title":"register_read_ascii","text":"<pre><code>register_read_ascii(\n    device_id: int, reg_id: int, index: int = -1\n) -&gt; str\n</code></pre> <p>Reads an ascii string from the register.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to extract data from a specific position in the register. Index is byte counted.</p> <code>-1</code> <p>Returns:</p> Type Description <code>str</code> <p>The ascii value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_read_ascii(self, device_id: int, reg_id: int, index: int = -1) -&gt; str:\n    \"\"\"Reads an ascii string from the register.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        index: Value index. Typically -1, but could be used to extract data from\n            a specific position in the register. Index is byte counted.\n\n    Returns:\n        The ascii value.\n    \"\"\"\n    size = c_ubyte(255)\n    data = create_string_buffer(size.value)\n    self._sdk.registerReadAscii(self._portname, device_id, reg_id, data, size, index)\n    return bytes(data.value).decode()\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_read_f32","title":"register_read_f32","text":"<pre><code>register_read_f32(\n    device_id: int, reg_id: int, index: int = -1\n) -&gt; float\n</code></pre> <p>Reads 32-bit float value from the register.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to extract data from a specific position in the register. Index is byte counted.</p> <code>-1</code> <p>Returns:</p> Type Description <code>float</code> <p>The 32-bit float value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_read_f32(self, device_id: int, reg_id: int, index: int = -1) -&gt; float:\n    \"\"\"Reads 32-bit float value from the register.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        index: Value index. Typically -1, but could be used to extract data from\n            a specific position in the register. Index is byte counted.\n\n    Returns:\n        The 32-bit float value.\n    \"\"\"\n    data = c_float(0)\n    self._sdk.registerReadF32(self._portname, device_id, reg_id, data, index)\n    return data.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_read_f64","title":"register_read_f64","text":"<pre><code>register_read_f64(\n    device_id: int, reg_id: int, index: int = -1\n) -&gt; float\n</code></pre> <p>Reads 64-bit double value from the register.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to extract data from a specific position in the register. Index is byte counted.</p> <code>-1</code> <p>Returns:</p> Type Description <code>float</code> <p>The 64-bit double value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_read_f64(self, device_id: int, reg_id: int, index: int = -1) -&gt; float:\n    \"\"\"Reads 64-bit double value from the register.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        index: Value index. Typically -1, but could be used to extract data from\n            a specific position in the register. Index is byte counted.\n\n    Returns:\n        The 64-bit double value.\n    \"\"\"\n    data = c_double(0)\n    self._sdk.registerReadF64(self._portname, device_id, reg_id, data, index)\n    return data.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_read_s16","title":"register_read_s16","text":"<pre><code>register_read_s16(\n    device_id: int, reg_id: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Reads 16-bit signed short value from the register.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to extract data from a specific position in the register. Index is byte counted.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 16-bit signed short value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_read_s16(self, device_id: int, reg_id: int, index: int = -1) -&gt; int:\n    \"\"\"Reads 16-bit signed short value from the register.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        index: Value index. Typically -1, but could be used to extract data from\n            a specific position in the register. Index is byte counted.\n\n    Returns:\n        The 16-bit signed short value.\n    \"\"\"\n    data = c_short(0)\n    self._sdk.registerReadS16(self._portname, device_id, reg_id, data, index)\n    return data.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_read_s32","title":"register_read_s32","text":"<pre><code>register_read_s32(\n    device_id: int, reg_id: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Reads 32-bit signed long value from the register.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to extract data from a specific position in the register. Index is byte counted.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 32-bit signed long value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_read_s32(self, device_id: int, reg_id: int, index: int = -1) -&gt; int:\n    \"\"\"Reads 32-bit signed long value from the register.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        index: Value index. Typically -1, but could be used to extract data from\n            a specific position in the register. Index is byte counted.\n\n    Returns:\n        The 32-bit signed long value.\n    \"\"\"\n    data = c_long(0)\n    self._sdk.registerReadS32(self._portname, device_id, reg_id, data, index)\n    return data.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_read_s64","title":"register_read_s64","text":"<pre><code>register_read_s64(\n    device_id: int, reg_id: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Reads 64-bit signed long long value from the register.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to extract data from a specific position in the register. Index is byte counted.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 64-bit signed long long value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_read_s64(self, device_id: int, reg_id: int, index: int = -1) -&gt; int:\n    \"\"\"Reads 64-bit signed long long value from the register.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        index: Value index. Typically -1, but could be used to extract data from\n            a specific position in the register. Index is byte counted.\n\n    Returns:\n        The 64-bit signed long long value.\n    \"\"\"\n    data = c_longlong(0)\n    self._sdk.registerReadS64(self._portname, device_id, reg_id, data, index)\n    return data.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_read_s8","title":"register_read_s8","text":"<pre><code>register_read_s8(\n    device_id: int, reg_id: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Reads 8-bit signed char value from the register.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to extract data from a specific position in the register. Index is byte counted.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 8-bit signed char value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_read_s8(self, device_id: int, reg_id: int, index: int = -1) -&gt; int:\n    \"\"\"Reads 8-bit signed char value from the register.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        index: Value index. Typically -1, but could be used to extract data from\n            a specific position in the register. Index is byte counted.\n\n    Returns:\n        The 8-bit signed char value.\n    \"\"\"\n    data = c_byte(0)\n    self._sdk.registerReadS8(self._portname, device_id, reg_id, data, index)\n    return data.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_read_u16","title":"register_read_u16","text":"<pre><code>register_read_u16(\n    device_id: int, reg_id: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Reads 16-bit unsigned short value from the register.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to extract data from a specific position in the register. Index is byte counted.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 16-bit unsigned short value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_read_u16(self, device_id: int, reg_id: int, index: int = -1) -&gt; int:\n    \"\"\"Reads 16-bit unsigned short value from the register.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        index: Value index. Typically -1, but could be used to extract data from\n            a specific position in the register. Index is byte counted.\n\n    Returns:\n        The 16-bit unsigned short value.\n    \"\"\"\n    data = c_ushort(0)\n    self._sdk.registerReadU16(self._portname, device_id, reg_id, data, index)\n    return data.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_read_u32","title":"register_read_u32","text":"<pre><code>register_read_u32(\n    device_id: int, reg_id: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Reads 32-bit unsigned long value from the register.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to extract data from a specific position in the register. Index is byte counted.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 32-bit unsigned long value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_read_u32(self, device_id: int, reg_id: int, index: int = -1) -&gt; int:\n    \"\"\"Reads 32-bit unsigned long value from the register.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        index: Value index. Typically -1, but could be used to extract data from\n            a specific position in the register. Index is byte counted.\n\n    Returns:\n        The 32-bit unsigned long value.\n    \"\"\"\n    data = c_ulong(0)\n    self._sdk.registerReadU32(self._portname, device_id, reg_id, data, index)\n    return data.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_read_u64","title":"register_read_u64","text":"<pre><code>register_read_u64(\n    device_id: int, reg_id: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Reads 64-bit unsigned long long value from the register.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to extract data from a specific position in the register. Index is byte counted.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 64-bit unsigned long long value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_read_u64(self, device_id: int, reg_id: int, index: int = -1) -&gt; int:\n    \"\"\"Reads 64-bit unsigned long long value from the register.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        index: Value index. Typically -1, but could be used to extract data from\n            a specific position in the register. Index is byte counted.\n\n    Returns:\n        The 64-bit unsigned long long value.\n    \"\"\"\n    data = c_ulonglong(0)\n    self._sdk.registerReadU64(self._portname, device_id, reg_id, data, index)\n    return data.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_read_u8","title":"register_read_u8","text":"<pre><code>register_read_u8(\n    device_id: int, reg_id: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Reads 8-bit unsigned char value from the register.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to extract data from a specific position in the register. Index is byte counted.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 8-bit unsigned char value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_read_u8(self, device_id: int, reg_id: int, index: int = -1) -&gt; int:\n    \"\"\"Reads 8-bit unsigned char value from the register.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        index: Value index. Typically -1, but could be used to extract data from\n            a specific position in the register. Index is byte counted.\n\n    Returns:\n        The 8-bit unsigned char value.\n    \"\"\"\n    data = c_ubyte(0)\n    self._sdk.registerReadU8(self._portname, device_id, reg_id, data, index)\n    return data.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_remove","title":"register_remove","text":"<pre><code>register_remove(device_id: int, reg_id: int) -&gt; None\n</code></pre> <p>Remove a specific register from the internal register list.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_remove(self, device_id: int, reg_id: int) -&gt; None:\n    \"\"\"Remove a specific register from the internal register list.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n    \"\"\"\n    self._sdk.registerRemove(self._portname, device_id, reg_id)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_remove_all","title":"register_remove_all","text":"<pre><code>register_remove_all(device_id: int) -&gt; None\n</code></pre> <p>Remove all registers from the internal register list.</p> <p>No confirmation given, the list is simply cleared.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_remove_all(self, device_id: int) -&gt; None:\n    \"\"\"Remove all registers from the internal register list.\n\n    No confirmation given, the list is simply cleared.\n\n    Args:\n        device_id: The device id (module address).\n    \"\"\"\n    self._sdk.registerRemoveAll(self._portname, device_id)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write","title":"register_write","text":"<pre><code>register_write(\n    device_id: int,\n    reg_id: int,\n    data: bytes,\n    index: int = -1,\n) -&gt; None\n</code></pre> <p>Writes a register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>data</code> <code>bytes</code> <p>The data to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write(self, device_id: int, reg_id: int, data: bytes, index: int = -1) -&gt; None:\n    \"\"\"Writes a register value.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated write.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        data: The data to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n    \"\"\"\n    self._sdk.registerWrite(self._portname, device_id, reg_id, data, len(data), index)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_ascii","title":"register_write_ascii","text":"<pre><code>register_write_ascii(\n    device_id: int,\n    reg_id: int,\n    string: str,\n    *,\n    write_eol: bool = False,\n    index: int = -1\n) -&gt; None\n</code></pre> <p>Writes a string to the register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>string</code> <code>str</code> <p>The string to write to the register.</p> required <code>write_eol</code> <code>bool</code> <p>Whether to append the End Of Line character (a null character) to the string.</p> <code>False</code> <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a mixed-type register.</p> <code>-1</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_ascii(\n    self, device_id: int, reg_id: int, string: str, *, write_eol: bool = False, index: int = -1\n) -&gt; None:\n    \"\"\"Writes a string to the register value.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated write.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        string: The string to write to the register.\n        write_eol: Whether to append the End Of Line character (a null character) to the string.\n        index: Value index. Typically -1, but could be used to write a value in a mixed-type register.\n    \"\"\"\n    buffer = create_string_buffer(string.encode(\"ascii\"))\n    self._sdk.registerWriteAscii(self._portname, device_id, reg_id, buffer, int(write_eol), index)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_f32","title":"register_write_f32","text":"<pre><code>register_write_f32(\n    device_id: int,\n    reg_id: int,\n    value: float,\n    index: int = -1,\n) -&gt; None\n</code></pre> <p>Writes a 32-bit float register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>float</code> <p>The 32-bit float to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_f32(self, device_id: int, reg_id: int, value: float, index: int = -1) -&gt; None:\n    \"\"\"Writes a 32-bit float register value.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated write.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 32-bit float to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n    \"\"\"\n    self._sdk.registerWriteF32(self._portname, device_id, reg_id, value, index)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_f64","title":"register_write_f64","text":"<pre><code>register_write_f64(\n    device_id: int,\n    reg_id: int,\n    value: float,\n    index: int = -1,\n) -&gt; None\n</code></pre> <p>Writes a 64-bit double register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>float</code> <p>The 64-bit double to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_f64(self, device_id: int, reg_id: int, value: float, index: int = -1) -&gt; None:\n    \"\"\"Writes a 64-bit double register value.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated write.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 64-bit double to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n    \"\"\"\n    self._sdk.registerWriteF64(self._portname, device_id, reg_id, value, index)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_read","title":"register_write_read","text":"<pre><code>register_write_read(\n    device_id: int,\n    reg_id: int,\n    data: bytes,\n    index: int = -1,\n) -&gt; bytes\n</code></pre> <p>Writes then reads a register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write followed by a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>data</code> <code>bytes</code> <p>The data to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The data that was written to the register.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_read(self, device_id: int, reg_id: int, data: bytes, index: int = -1) -&gt; bytes:\n    \"\"\"Writes then reads a register value.\n\n    It is not necessary to open the port, create the device or register before using\n    this function, since it will do a dedicated write followed by a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        data: The data to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n\n    Returns:\n        The data that was written to the register.\n    \"\"\"\n    size = c_ubyte(255)\n    read = create_string_buffer(size.value)\n    self._sdk.registerWriteRead(self._portname, device_id, reg_id, data, len(data), index, read, size, index)\n    return read.raw[: size.value]\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_read_ascii","title":"register_write_read_ascii","text":"<pre><code>register_write_read_ascii(\n    device_id: int,\n    reg_id: int,\n    string: str,\n    *,\n    write_eol: bool = False,\n    index: int = -1\n) -&gt; str\n</code></pre> <p>Writes then reads a string register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write followed by a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>string</code> <code>str</code> <p>The string to write to the register.</p> required <code>write_eol</code> <code>bool</code> <p>Whether to append the End Of Line character (a null character) to the string.</p> <code>False</code> <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> <p>Returns:</p> Type Description <code>str</code> <p>The string that was written to the register.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_read_ascii(\n    self, device_id: int, reg_id: int, string: str, *, write_eol: bool = False, index: int = -1\n) -&gt; str:\n    \"\"\"Writes then reads a string register value.\n\n    It is not necessary to open the port, create the device or register before using\n    this function, since it will do a dedicated write followed by a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        string: The string to write to the register.\n        write_eol: Whether to append the End Of Line character (a null character) to the string.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n\n    Returns:\n        The string that was written to the register.\n    \"\"\"\n    ascii_value = create_string_buffer(string.encode(\"ascii\"))\n    size = c_ubyte(255)\n    read = create_string_buffer(size.value)\n    self._sdk.registerWriteReadAscii(\n        self._portname, device_id, reg_id, ascii_value, int(write_eol), read, size, index\n    )\n    return bytes(read.value).decode(\"ascii\")\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_read_f32","title":"register_write_read_f32","text":"<pre><code>register_write_read_f32(\n    device_id: int,\n    reg_id: int,\n    value: float,\n    index: int = -1,\n) -&gt; float\n</code></pre> <p>Writes then reads a 32-bit float register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write followed by a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>float</code> <p>The 32-bit float value to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> <p>Returns:</p> Type Description <code>float</code> <p>The 32-bit float value that was written to the register.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_read_f32(self, device_id: int, reg_id: int, value: float, index: int = -1) -&gt; float:\n    \"\"\"Writes then reads a 32-bit float register value.\n\n    It is not necessary to open the port, create the device or register before using\n    this function, since it will do a dedicated write followed by a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 32-bit float value to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n\n    Returns:\n        The 32-bit float value that was written to the register.\n    \"\"\"\n    read = c_float(0)\n    self._sdk.registerWriteReadF32(self._portname, device_id, reg_id, value, read, index)\n    return read.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_read_f64","title":"register_write_read_f64","text":"<pre><code>register_write_read_f64(\n    device_id: int,\n    reg_id: int,\n    value: float,\n    index: int = -1,\n) -&gt; float\n</code></pre> <p>Writes then reads a 64-bit double register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write followed by a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>float</code> <p>The 64-bit double value to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> <p>Returns:</p> Type Description <code>float</code> <p>The 64-bit double value that was written to the register.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_read_f64(self, device_id: int, reg_id: int, value: float, index: int = -1) -&gt; float:\n    \"\"\"Writes then reads a 64-bit double register value.\n\n    It is not necessary to open the port, create the device or register before using\n    this function, since it will do a dedicated write followed by a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 64-bit double value to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n\n    Returns:\n        The 64-bit double value that was written to the register.\n    \"\"\"\n    read = c_double(0)\n    self._sdk.registerWriteReadF64(self._portname, device_id, reg_id, value, read, index)\n    return read.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_read_s16","title":"register_write_read_s16","text":"<pre><code>register_write_read_s16(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Writes then reads a 16-bit signed short register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write followed by a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 16-bit signed short value to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 16-bit signed short value that was written to the register.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_read_s16(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; int:\n    \"\"\"Writes then reads a 16-bit signed short register value.\n\n    It is not necessary to open the port, create the device or register before using\n    this function, since it will do a dedicated write followed by a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 16-bit signed short value to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n\n    Returns:\n        The 16-bit signed short value that was written to the register.\n    \"\"\"\n    read = c_short(0)\n    self._sdk.registerWriteReadS16(self._portname, device_id, reg_id, value, read, index)\n    return read.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_read_s32","title":"register_write_read_s32","text":"<pre><code>register_write_read_s32(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Writes then reads a 32-bit signed long register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write followed by a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 32-bit signed long value to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 32-bit signed long value that was written to the register.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_read_s32(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; int:\n    \"\"\"Writes then reads a 32-bit signed long register value.\n\n    It is not necessary to open the port, create the device or register before using\n    this function, since it will do a dedicated write followed by a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 32-bit signed long value to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n\n    Returns:\n        The 32-bit signed long value that was written to the register.\n    \"\"\"\n    read = c_long(0)\n    self._sdk.registerWriteReadS32(self._portname, device_id, reg_id, value, read, index)\n    return read.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_read_s64","title":"register_write_read_s64","text":"<pre><code>register_write_read_s64(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Writes then reads a 64-bit signed long long register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write followed by a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 64-bit signed long long value to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 64-bit signed long long value that was written to the register.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_read_s64(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; int:\n    \"\"\"Writes then reads a 64-bit signed long long register value.\n\n    It is not necessary to open the port, create the device or register before using\n    this function, since it will do a dedicated write followed by a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 64-bit signed long long value to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n\n    Returns:\n        The 64-bit signed long long value that was written to the register.\n    \"\"\"\n    read = c_longlong(0)\n    self._sdk.registerWriteReadS64(self._portname, device_id, reg_id, value, read, index)\n    return read.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_read_s8","title":"register_write_read_s8","text":"<pre><code>register_write_read_s8(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Writes then reads a 8-bit signed char register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write followed by a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 8-bit signed char value to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 8-bit signed char value that was written to the register.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_read_s8(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; int:\n    \"\"\"Writes then reads a 8-bit signed char register value.\n\n    It is not necessary to open the port, create the device or register before using\n    this function, since it will do a dedicated write followed by a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 8-bit signed char value to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n\n    Returns:\n        The 8-bit signed char value that was written to the register.\n    \"\"\"\n    read = c_byte(0)\n    self._sdk.registerWriteReadS8(self._portname, device_id, reg_id, value, read, index)\n    return read.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_read_u16","title":"register_write_read_u16","text":"<pre><code>register_write_read_u16(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Writes then reads a 16-bit unsigned short register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write followed by a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 16-bit unsigned short value to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 16-bit unsigned short value that was written to the register.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_read_u16(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; int:\n    \"\"\"Writes then reads a 16-bit unsigned short register value.\n\n    It is not necessary to open the port, create the device or register before using\n    this function, since it will do a dedicated write followed by a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 16-bit unsigned short value to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n\n    Returns:\n        The 16-bit unsigned short value that was written to the register.\n    \"\"\"\n    read = c_ushort(0)\n    self._sdk.registerWriteReadU16(self._portname, device_id, reg_id, value, read, index)\n    return read.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_read_u32","title":"register_write_read_u32","text":"<pre><code>register_write_read_u32(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Writes then reads a 32-bit unsigned long register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write followed by a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 32-bit unsigned long value to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 32-bit unsigned long value that was written to the register.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_read_u32(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; int:\n    \"\"\"Writes then reads a 32-bit unsigned long register value.\n\n    It is not necessary to open the port, create the device or register before using\n    this function, since it will do a dedicated write followed by a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 32-bit unsigned long value to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n\n    Returns:\n        The 32-bit unsigned long value that was written to the register.\n    \"\"\"\n    read = c_ulong(0)\n    self._sdk.registerWriteReadU32(self._portname, device_id, reg_id, value, read, index)\n    return read.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_read_u64","title":"register_write_read_u64","text":"<pre><code>register_write_read_u64(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Writes then reads a 64-bit unsigned long long register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write followed by a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 64-bit unsigned long long value to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 64-bit unsigned long long value that was written to the register.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_read_u64(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; int:\n    \"\"\"Writes then reads a 64-bit unsigned long long register value.\n\n    It is not necessary to open the port, create the device or register before using\n    this function, since it will do a dedicated write followed by a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 64-bit unsigned long long value to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n\n    Returns:\n        The 64-bit unsigned long long value that was written to the register.\n    \"\"\"\n    read = c_ulonglong(0)\n    self._sdk.registerWriteReadU64(self._portname, device_id, reg_id, value, read, index)\n    return read.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_read_u8","title":"register_write_read_u8","text":"<pre><code>register_write_read_u8(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; int\n</code></pre> <p>Writes then reads a 8-bit unsigned char register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write followed by a dedicated read.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 8-bit unsigned char value to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> <p>Returns:</p> Type Description <code>int</code> <p>The 8-bit unsigned char value that was written to the register.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_read_u8(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; int:\n    \"\"\"Writes then reads a 8-bit unsigned char register value.\n\n    It is not necessary to open the port, create the device or register before using\n    this function, since it will do a dedicated write followed by a dedicated read.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 8-bit unsigned char value to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n\n    Returns:\n        The 8-bit unsigned char value that was written to the register.\n    \"\"\"\n    read = c_ubyte(0)\n    self._sdk.registerWriteReadU8(self._portname, device_id, reg_id, value, read, index)\n    return read.value\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_s16","title":"register_write_s16","text":"<pre><code>register_write_s16(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; None\n</code></pre> <p>Writes a 16-bit signed short register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 16-bit signed short to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_s16(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; None:\n    \"\"\"Writes a 16-bit signed short register value.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated write.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 16-bit signed short to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n    \"\"\"\n    self._sdk.registerWriteS16(self._portname, device_id, reg_id, value, index)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_s32","title":"register_write_s32","text":"<pre><code>register_write_s32(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; None\n</code></pre> <p>Writes a 32-bit signed long register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 32-bit signed long to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_s32(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; None:\n    \"\"\"Writes a 32-bit signed long register value.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated write.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 32-bit signed long to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n    \"\"\"\n    self._sdk.registerWriteS32(self._portname, device_id, reg_id, value, index)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_s64","title":"register_write_s64","text":"<pre><code>register_write_s64(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; None\n</code></pre> <p>Writes a 64-bit signed long long register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 64-bit signed long long to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_s64(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; None:\n    \"\"\"Writes a 64-bit signed long long register value.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated write.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 64-bit signed long long to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n    \"\"\"\n    self._sdk.registerWriteS64(self._portname, device_id, reg_id, value, index)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_s8","title":"register_write_s8","text":"<pre><code>register_write_s8(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; None\n</code></pre> <p>Writes a 8-bit signed char register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 8-bit signed char to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_s8(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; None:\n    \"\"\"Writes a 8-bit signed char register value.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated write.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 8-bit signed char to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n    \"\"\"\n    self._sdk.registerWriteS8(self._portname, device_id, reg_id, value, index)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_u16","title":"register_write_u16","text":"<pre><code>register_write_u16(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; None\n</code></pre> <p>Writes a 16-bit unsigned short register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 16-bit unsigned short to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_u16(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; None:\n    \"\"\"Writes a 16-bit unsigned short register value.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated write.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 16-bit unsigned short to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n    \"\"\"\n    self._sdk.registerWriteU16(self._portname, device_id, reg_id, value, index)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_u32","title":"register_write_u32","text":"<pre><code>register_write_u32(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; None\n</code></pre> <p>Writes a 32-bit unsigned long register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 32-bit unsigned long to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_u32(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; None:\n    \"\"\"Writes a 32-bit unsigned long register value.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated write.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 32-bit unsigned long to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n    \"\"\"\n    self._sdk.registerWriteU32(self._portname, device_id, reg_id, value, index)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_u64","title":"register_write_u64","text":"<pre><code>register_write_u64(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; None\n</code></pre> <p>Writes a 64-bit unsigned long long register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 64-bit unsigned long long to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_u64(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; None:\n    \"\"\"Writes a 64-bit unsigned long long register value.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated write.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 64-bit unsigned long long to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n    \"\"\"\n    self._sdk.registerWriteU64(self._portname, device_id, reg_id, value, index)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.register_write_u8","title":"register_write_u8","text":"<pre><code>register_write_u8(\n    device_id: int, reg_id: int, value: int, index: int = -1\n) -&gt; None\n</code></pre> <p>Writes a 8-bit unsigned char register value.</p> <p>It is not necessary to open the port, create the device or register before using this function, since it will do a dedicated write.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device id (module address).</p> required <code>reg_id</code> <code>int</code> <p>The register id (register address).</p> required <code>value</code> <code>int</code> <p>The 8-bit unsigned char to write to the register.</p> required <code>index</code> <code>int</code> <p>Value index. Typically -1, but could be used to write a value in a multi-value register.</p> <code>-1</code> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_write_u8(self, device_id: int, reg_id: int, value: int, index: int = -1) -&gt; None:\n    \"\"\"Writes a 8-bit unsigned char register value.\n\n    It is not necessary to open the port, create the device or register before\n    using this function, since it will do a dedicated write.\n\n    Args:\n        device_id: The device id (module address).\n        reg_id: The register id (register address).\n        value: The 8-bit unsigned char to write to the register.\n        index: Value index. Typically -1, but could be used to write a value in a multi-value register.\n    \"\"\"\n    self._sdk.registerWriteU8(self._portname, device_id, reg_id, value, index)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.set_callback_device_status","title":"set_callback_device_status  <code>staticmethod</code>","text":"<pre><code>set_callback_device_status(\n    callback: NKTDeviceStatusCallback | None,\n) -&gt; None\n</code></pre> <p>Enables/Disables a callback for device status changes.</p> <p>See superk_callback.py for an example usage.</p> <p>Note</p> <p>Due to a risk of circular runaway leading to stack overflow, it is not allowed to call functions in the DLL from within the callback function. If a call is made to a function in the DLL the function will raise an exception.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>NKTDeviceStatusCallback | None</code> <p>A callback function. Pass in <code>None</code> to disable the device-status callback.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>@staticmethod\ndef set_callback_device_status(callback: NKTDeviceStatusCallback | None) -&gt; None:\n    \"\"\"Enables/Disables a callback for device status changes.\n\n    See [superk_callback.py](https://github.com/MSLNZ/msl-equipment/blob/main/packages/resources/examples/nkt/superk_callback.py)\n    for an example usage.\n\n    !!! note\n        Due to a risk of circular runaway leading to stack overflow, it is not allowed\n        to call functions in the DLL from within the callback function. If a call is\n        made to a function in the DLL the function will raise an exception.\n\n    Args:\n        callback: A callback function. Pass in `None` to disable the device-status callback.\n    \"\"\"\n    if NKT._SDK is None:\n        msg = \"NKTError: You must first call NKT.load_sdk()\"\n        raise RuntimeError(msg)\n\n    if callback is not None and not isinstance(callback, DeviceStatusCallback):\n        msg = \"NKTError: Must pass in a DeviceStatusCallback object\"\n        raise TypeError(msg)\n\n    NKT._SDK.setCallbackPtrDeviceInfo(callback)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.set_callback_port_status","title":"set_callback_port_status  <code>staticmethod</code>","text":"<pre><code>set_callback_port_status(\n    callback: NKTPortStatusCallback | None,\n) -&gt; None\n</code></pre> <p>Enables/Disables a callback for port status changes.</p> <p>Used by the open_ports and close_ports functions.</p> <p>See superk_callback.py for an example usage.</p> <p>Note</p> <p>Due to a risk of circular runaway leading to stack overflow, it is not allowed to call functions in the DLL from within the callback function. If a call is made to a function in the DLL the function will raise an exception.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>NKTPortStatusCallback | None</code> <p>A callback function. Pass in <code>None</code> to disable the port-status callback.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>@staticmethod\ndef set_callback_port_status(callback: NKTPortStatusCallback | None) -&gt; None:\n    \"\"\"Enables/Disables a callback for port status changes.\n\n    Used by the [open_ports][msl.equipment_resources.nkt.nktpdll.NKT.open_ports] and\n    [close_ports][msl.equipment_resources.nkt.nktpdll.NKT.close_ports] functions.\n\n    See [superk_callback.py](https://github.com/MSLNZ/msl-equipment/blob/main/packages/resources/examples/nkt/superk_callback.py)\n    for an example usage.\n\n    !!! note\n        Due to a risk of circular runaway leading to stack overflow, it is not allowed\n        to call functions in the DLL from within the callback function. If a call is\n        made to a function in the DLL the function will raise an exception.\n\n    Args:\n        callback: A callback function. Pass in `None` to disable the port-status callback.\n    \"\"\"\n    if NKT._SDK is None:\n        msg = \"NKTError: You must first call NKT.load_sdk()\"\n        raise RuntimeError(msg)\n\n    if callback is not None and not isinstance(callback, PortStatusCallback):\n        msg = \"NKTError: Must pass in a PortStatusCallback object\"\n        raise TypeError(msg)\n\n    NKT._SDK.setCallbackPtrPortInfo(callback)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.set_callback_register_status","title":"set_callback_register_status  <code>staticmethod</code>","text":"<pre><code>set_callback_register_status(\n    callback: NKTRegisterStatusCallback | None,\n) -&gt; None\n</code></pre> <p>Enables/Disables a callback for register status changes.</p> <p>See superk_callback.py for an example usage.</p> <p>Note</p> <p>Due to a risk of circular runaway leading to stack overflow, it is not allowed to call functions in the DLL from within the callback function. If a call is made to a function in the DLL the function will raise an exception.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>NKTRegisterStatusCallback | None</code> <p>A callback function. Pass in <code>None</code> to disable the register-status callback.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>@staticmethod\ndef set_callback_register_status(callback: NKTRegisterStatusCallback | None) -&gt; None:\n    \"\"\"Enables/Disables a callback for register status changes.\n\n    See [superk_callback.py](https://github.com/MSLNZ/msl-equipment/blob/main/packages/resources/examples/nkt/superk_callback.py)\n    for an example usage.\n\n    !!! note\n        Due to a risk of circular runaway leading to stack overflow, it is not allowed\n        to call functions in the DLL from within the callback function. If a call is\n        made to a function in the DLL the function will raise an exception.\n\n    Args:\n        callback: A callback function. Pass in `None` to disable the register-status callback.\n    \"\"\"\n    if NKT._SDK is None:\n        msg = \"NKTError: You must first call NKT.load_sdk()\"\n        raise RuntimeError(msg)\n\n    if callback is not None and not isinstance(callback, RegisterStatusCallback):\n        msg = \"NKTError: Must pass in a RegisterStatusCallback object\"\n        raise TypeError(msg)\n\n    NKT._SDK.setCallbackPtrRegisterInfo(callback)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.NKT.set_legacy_bus_scanning","title":"set_legacy_bus_scanning  <code>staticmethod</code>","text":"<pre><code>set_legacy_bus_scanning(*, mode: bool) -&gt; None\n</code></pre> <p>Set the bus-scanning mode to normal or legacy.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>bool</code> <p>If <code>False</code>, bus scanning is set to normal mode and allows for a rolling masterId. In this mode the masterId is changed for each message to allow for out-of-sync detection. If <code>True</code>, bus scanning is set to legacy mode and fixes the masterId at address 66 (0x42). Some older modules do not accept masterIds other than 66 (0x42).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>@staticmethod\ndef set_legacy_bus_scanning(*, mode: bool) -&gt; None:\n    \"\"\"Set the bus-scanning mode to normal or legacy.\n\n    Args:\n        mode: If `False`, bus scanning is set to normal mode and allows for a\n            rolling _masterId_. In this mode the _masterId_ is changed for each\n            message to allow for out-of-sync detection. If `True`, bus scanning\n            is set to legacy mode and fixes the _masterId_ at address 66 (0x42).\n            Some older modules do not accept _masterIds_ other than 66 (0x42).\n    \"\"\"\n    if NKT._SDK is None:\n        msg = \"NKTError: You must first call NKT.load_sdk()\"\n        raise RuntimeError(msg)\n\n    NKT._SDK.setLegacyBusScanning(int(bool(mode)))\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.ParameterSet","title":"ParameterSet","text":"<p>               Bases: <code>Structure</code></p> <p>The ParameterSet struct.</p> <p>This is how a calculation on parameter sets is done internally by modules:</p> <p>DAC_value = (value * (X/Y)) + Offset</p> <p>where, value is either <code>ParameterSet.StartVal</code> or <code>ParameterSet.FactoryVal</code></p> <p>value = (ADC_value * (X/Y)) + Offset</p> <p>where, value often is available via another measurement register.</p> <p>Attributes:</p> Name Type Description <code>Unit</code> <code>c_uint8</code> <p>Unit type as defined in tParamSetUnitTypes.</p> <code>ErrorHandler</code> <code>c_uint8</code> <p>Warning/Error handler not used.</p> <code>StartVal</code> <code>c_ushort</code> <p>Setpoint for Settings parameter set, unused in Measurement parameter sets.</p> <code>FactoryVal</code> <code>c_ushort</code> <p>Factory Setpoint for Settings parameter set, unused in Measurement parameter sets.</p> <code>ULimit</code> <code>c_ushort</code> <p>Upper limit.</p> <code>LLimit</code> <code>c_ushort</code> <p>Lower limit.</p> <code>Numerator</code> <code>c_short</code> <p>Numerator(X) for calculation.</p> <code>Denominator</code> <code>c_short</code> <p>Denominator(Y) for calculation.</p> <code>Offset</code> <code>c_short</code> <p>Offset for calculation.</p>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.PointToPoint","title":"PointToPoint  <code>dataclass</code>","text":"<pre><code>PointToPoint(\n    host_address: str,\n    host_port: int,\n    client_address: str,\n    client_port: int,\n    protocol: int,\n    ms_timeout: int,\n)\n</code></pre> <p>A point-to-point port.</p> <p>Parameters:</p> Name Type Description Default <code>host_address</code> <code>str</code> <p>The local ip address, e.g., <code>\"192.168.1.67\"</code>.</p> required <code>host_port</code> <code>int</code> <p>The local port number.</p> required <code>client_address</code> <code>str</code> <p>The remote ip address, e.g., <code>\"192.168.1.100\"</code>.</p> required <code>client_port</code> <code>int</code> <p>The remote port number.</p> required <code>protocol</code> <code>int</code> <p>Either <code>0</code> (TCP) or <code>1</code> (UDP).</p> required <code>ms_timeout</code> <code>int</code> <p>Telegram timeout value in milliseconds.</p> required"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.PortStatus","title":"PortStatus","text":"<p>               Bases: <code>IntEnum</code></p> <p>The PortStatusTypes enum.</p> <p>Attributes:</p> Name Type Description <code>Unknown</code> <code>int</code> <p>Unknown status, <code>0</code>.</p> <code>Opening</code> <code>int</code> <p>The port is opening, <code>1</code>.</p> <code>Opened</code> <code>int</code> <p>The port is now open, <code>2</code>.</p> <code>OpenFail</code> <code>int</code> <p>The port open failed, <code>3</code>.</p> <code>ScanStarted</code> <code>int</code> <p>The port scanning is started, <code>4</code>.</p> <code>ScanProgress</code> <code>int</code> <p>The port scanning progress, <code>5</code>.</p> <code>ScanDeviceFound</code> <code>int</code> <p>The port scan found a device, <code>6</code>.</p> <code>ScanEnded</code> <code>int</code> <p>The port scanning ended, <code>7</code>.</p> <code>Closing</code> <code>int</code> <p>The port is closing, <code>8</code>.</p> <code>Closed</code> <code>int</code> <p>The port is now closed, <code>9</code>.</p> <code>Ready</code> <code>int</code> <p>The port is open and ready, <code>10</code>.</p>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.RegisterData","title":"RegisterData","text":"<p>               Bases: <code>IntEnum</code></p> <p>The RegisterDataTypes enum.</p> <p>Attributes:</p> Name Type Description <code>UNKNOWN</code> <code>int</code> <p>Unknown/Undefined data type, <code>0</code>.</p> <code>MIXED</code> <code>int</code> <p>Mixed content data type, <code>1</code>.</p> <code>U8</code> <code>int</code> <p>8-bit unsigned data type (unsigned char), <code>2</code>.</p> <code>S8</code> <code>int</code> <p>8-bit signed data type (char), <code>3</code>.</p> <code>U16</code> <code>int</code> <p>16-bit unsigned data type (unsigned short), <code>4</code>.</p> <code>S16</code> <code>int</code> <p>16-bit signed data type (short), <code>5</code>.</p> <code>U32</code> <code>int</code> <p>32-bit unsigned data type (unsigned long), <code>6</code>.</p> <code>S32</code> <code>int</code> <p>32-bit signed data type (long), <code>7</code>.</p> <code>F32</code> <code>int</code> <p>32-bit floating point data type (float), <code>8</code>.</p> <code>U64</code> <code>int</code> <p>64-bit unsigned data type (unsigned long long), <code>9</code>.</p> <code>S64</code> <code>int</code> <p>64-bit signed data type (long long), <code>10</code>.</p> <code>F64</code> <code>int</code> <p>64-bit floating point data type (double), <code>11</code>.</p> <code>ASCII</code> <code>int</code> <p>Zero terminated ascii string data type, <code>12</code>.</p> <code>ParamSet</code> <code>int</code> <p>ParameterSet data type, <code>13</code>.</p> <code>B8</code> <code>int</code> <p>8-bit binary data type (unsigned char), <code>14</code>.</p> <code>H8</code> <code>int</code> <p>8-bit hexadecimal data type (unsigned char), <code>15</code>.</p> <code>B16</code> <code>int</code> <p>16-bit binary data type (unsigned short), <code>16</code>.</p> <code>H16</code> <code>int</code> <p>16-bit hexadecimal data type (unsigned short), <code>17</code>.</p> <code>B32</code> <code>int</code> <p>32-bit binary data type (unsigned long), <code>18</code>.</p> <code>H32</code> <code>int</code> <p>32-bit hexadecimal data type (unsigned long), <code>19</code>.</p> <code>B64</code> <code>int</code> <p>64-bit binary data type (unsigned long long), <code>20</code>.</p> <code>H64</code> <code>int</code> <p>64-bit hexadecimal data type (unsigned long long), <code>21</code>.</p> <code>DATETIME</code> <code>int</code> <p>DateTime data type, <code>22</code>.</p>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.RegisterPriority","title":"RegisterPriority","text":"<p>               Bases: <code>IntEnum</code></p> <p>The RegisterPriorityTypes enum.</p> <p>Attributes:</p> Name Type Description <code>Low</code> <code>int</code> <p>The register is polled with low priority, <code>0</code>.</p> <code>High</code> <code>int</code> <p>The register is polled with high priority, <code>1</code>.</p>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.RegisterStatus","title":"RegisterStatus","text":"<p>               Bases: <code>IntEnum</code></p> <p>The RegisterStatusTypes enum.</p> <p>Attributes:</p> Name Type Description <code>Success</code> <code>int</code> <p>Register operation was successful <code>0</code>.</p> <code>Busy</code> <code>int</code> <p>Register operation resulted in a busy, <code>1</code>.</p> <code>Knackered</code> <code>int</code> <p>Register operation resulted in a knackered register (a non-existing register), <code>2</code>.</p> <code>CRCErr</code> <code>int</code> <p>Register operation resulted in a CRC error, <code>3</code>.</p> <code>Timeout</code> <code>int</code> <p>Register operation resulted in a timeout, <code>4</code>.</p> <code>ComError</code> <code>int</code> <p>Register operation resulted in a COM error. Out of sync. or garbage error, <code>5</code>.</p>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.Unit","title":"Unit","text":"<p>               Bases: <code>IntEnum</code></p> <p>The ParamSetUnitTypes enum.</p> <p>Attributes:</p> Name Type Description <code>NONE</code> <code>int</code> <p>None/Unknown, <code>0</code>.</p> <code>mV</code> <code>int</code> <p>mV, <code>1</code>.</p> <code>V</code> <code>int</code> <p>V, <code>2</code>.</p> <code>uA</code> <code>int</code> <p>uA, <code>3</code>.</p> <code>mA</code> <code>int</code> <p>mA, <code>4</code>.</p> <code>A</code> <code>int</code> <p>A, <code>5</code>.</p> <code>uW</code> <code>int</code> <p>uW, <code>6</code>.</p> <code>cmW</code> <code>int</code> <p>mW/100, <code>7</code>.</p> <code>dmW</code> <code>int</code> <p>mW/10, <code>8</code>.</p> <code>mW</code> <code>int</code> <p>mW, <code>9</code>.</p> <code>W</code> <code>int</code> <p>W, <code>10</code>.</p> <code>mC</code> <code>int</code> <p>degC/1000, <code>11</code>.</p> <code>cC</code> <code>int</code> <p>degC/100, <code>12</code>.</p> <code>dC</code> <code>int</code> <p>degC/10, <code>13</code>.</p> <code>pm</code> <code>int</code> <p>pm, <code>14</code>.</p> <code>dnm</code> <code>int</code> <p>nm/10, <code>15</code>.</p> <code>nm</code> <code>int</code> <p>nm, <code>16</code>.</p> <code>percent</code> <code>int</code> <p>%, <code>17</code>.</p> <code>perMile</code> <code>int</code> <p>per mile, <code>18</code>.</p> <code>cmA</code> <code>int</code> <p>mA/100, <code>19</code>.</p> <code>dmA</code> <code>int</code> <p>mA/10, <code>20</code>.</p> <code>RPM</code> <code>int</code> <p>RPM, <code>21</code>.</p> <code>dBm</code> <code>int</code> <p>dBm, <code>22</code>.</p> <code>cBm</code> <code>int</code> <p>dBm/10, <code>23</code>.</p> <code>mBm</code> <code>int</code> <p>dBm/100, <code>24</code>.</p> <code>dB</code> <code>int</code> <p>dB, <code>25</code>.</p> <code>cB</code> <code>int</code> <p>dB/10, <code>26</code>.</p> <code>mB</code> <code>int</code> <p>dB/100, <code>27</code>.</p> <code>dpm</code> <code>int</code> <p>pm/10, <code>28</code>.</p> <code>cV</code> <code>int</code> <p>V/100, <code>29</code>.</p> <code>dV</code> <code>int</code> <p>V/10, <code>30</code>.</p> <code>lm</code> <code>int</code> <p>lm (lumen), <code>31</code>.</p> <code>dlm</code> <code>int</code> <p>lm/10, <code>32</code>.</p> <code>clm</code> <code>int</code> <p>lm/100, <code>33</code>.</p> <code>mlm</code> <code>int</code> <p>lm/1000, <code>34</code>.</p>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.device_status_callback","title":"device_status_callback","text":"<pre><code>device_status_callback(\n    f: NKTDeviceStatusCallback,\n) -&gt; _CFunctionType\n</code></pre> <p>Use as a decorator for a callback function when the status of a device changes.</p> <p>See superk_callback.py for an example usage.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def device_status_callback(f: NKTDeviceStatusCallback) -&gt; _CFunctionType:\n    \"\"\"Use as a decorator for a callback function when the status of a device changes.\n\n    See [superk_callback.py](https://github.com/MSLNZ/msl-equipment/blob/main/packages/resources/examples/nkt/superk_callback.py)\n    for an example usage.\n    \"\"\"\n    return DeviceStatusCallback(f)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.port_status_callback","title":"port_status_callback","text":"<pre><code>port_status_callback(\n    f: NKTPortStatusCallback,\n) -&gt; _CFunctionType\n</code></pre> <p>Use as a decorator for a callback function when the status of a port changes.</p> <p>See superk_callback.py for an example usage.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def port_status_callback(f: NKTPortStatusCallback) -&gt; _CFunctionType:\n    \"\"\"Use as a decorator for a callback function when the status of a port changes.\n\n    See [superk_callback.py](https://github.com/MSLNZ/msl-equipment/blob/main/packages/resources/examples/nkt/superk_callback.py)\n    for an example usage.\n    \"\"\"\n    return PortStatusCallback(f)\n</code></pre>"},{"location":"resources/nkt/nktpdll/#msl.equipment_resources.nkt.nktpdll.register_status_callback","title":"register_status_callback","text":"<pre><code>register_status_callback(\n    f: NKTRegisterStatusCallback,\n) -&gt; _CFunctionType\n</code></pre> <p>Use as a decorator for a callback function when the status of a register changes.</p> <p>See superk_callback.py for an example usage.</p> Source code in <code>packages/resources/src/msl/equipment_resources/nkt/nktpdll.py</code> <pre><code>def register_status_callback(f: NKTRegisterStatusCallback) -&gt; _CFunctionType:\n    \"\"\"Use as a decorator for a callback function when the status of a register changes.\n\n    See [superk_callback.py](https://github.com/MSLNZ/msl-equipment/blob/main/packages/resources/examples/nkt/superk_callback.py)\n    for an example usage.\n    \"\"\"\n    return RegisterStatusCallback(f)\n</code></pre>"},{"location":"resources/omega/ithx/","title":"ITHX iServer","text":"<p>OMEGA iTHX Series Temperature and Humidity Chart Recorder.</p> <p>This class is compatible with the following model numbers:</p> <ul> <li>iTHX-W3</li> <li>iTHX-D3</li> <li>iTHX-SD</li> <li>iTHX-M</li> <li>iTHX-W</li> <li>iTHX-2</li> </ul>"},{"location":"resources/omega/ithx/#msl.equipment_resources.omega.ithx.ITHX","title":"ITHX","text":"<pre><code>ITHX(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Socket</code></p> <p>OMEGA iTHX Series Temperature and Humidity Chart Recorder.</p> <p>The default termination character for read and write operations is <code>\\r</code>.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/omega/ithx.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    r\"\"\"OMEGA iTHX Series Temperature and Humidity Chart Recorder.\n\n    The default termination character for read and write operations is `\\r`.\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"\n    super().__init__(equipment)\n    self.read_termination: bytes = b\"\\r\"\n    self.write_termination: bytes = b\"\\r\"\n</code></pre>"},{"location":"resources/omega/ithx/#msl.equipment_resources.omega.ithx.ITHX.dewpoint","title":"dewpoint","text":"<pre><code>dewpoint(\n    probe: Literal[1, 2] = 1, *, celsius: bool = True\n) -&gt; float\n</code></pre> <p>Read the dewpoint.</p> <p>Parameters:</p> Name Type Description Default <code>probe</code> <code>Literal[1, 2]</code> <p>The probe number to read the dewpoint of (for iTHX's that contain multiple probes).</p> <code>1</code> <code>celsius</code> <code>bool</code> <p><code>True</code> to return the dewpoint in celsius, <code>False</code> for fahrenheit.</p> <code>True</code> <p>Returns:</p> Type Description <code>float</code> <p>The dewpoint for the specified probe.</p> Source code in <code>packages/resources/src/msl/equipment_resources/omega/ithx.py</code> <pre><code>def dewpoint(self, probe: Literal[1, 2] = 1, *, celsius: bool = True) -&gt; float:\n    \"\"\"Read the dewpoint.\n\n    Args:\n        probe: The probe number to read the dewpoint of (for iTHX's that contain multiple probes).\n        celsius: `True` to return the dewpoint in celsius, `False` for fahrenheit.\n\n    Returns:\n        The dewpoint for the specified probe.\n    \"\"\"\n    return self._get(\"DC\" if celsius else \"DF\", probe)\n</code></pre>"},{"location":"resources/omega/ithx/#msl.equipment_resources.omega.ithx.ITHX.humidity","title":"humidity","text":"<pre><code>humidity(probe: Literal[1, 2] = 1) -&gt; float\n</code></pre> <p>Read the percent humidity.</p> <p>Parameters:</p> Name Type Description Default <code>probe</code> <code>Literal[1, 2]</code> <p>The probe number to read the humidity of (for iTHX's that contain multiple probes).</p> <code>1</code> <p>Returns:</p> Type Description <code>float</code> <p>The percent humidity for the specified probe.</p> Source code in <code>packages/resources/src/msl/equipment_resources/omega/ithx.py</code> <pre><code>def humidity(self, probe: Literal[1, 2] = 1) -&gt; float:\n    \"\"\"Read the percent humidity.\n\n    Args:\n        probe: The probe number to read the humidity of (for iTHX's that contain multiple probes).\n\n    Returns:\n        The percent humidity for the specified probe.\n    \"\"\"\n    return self._get(\"H\", probe)\n</code></pre>"},{"location":"resources/omega/ithx/#msl.equipment_resources.omega.ithx.ITHX.reset","title":"reset","text":"<pre><code>reset(\n    *,\n    wait: bool = True,\n    password: str | None = None,\n    port: int = 2002,\n    timeout: float = 10\n) -&gt; None\n</code></pre> <p>Power reset the iServer.</p> <p>Some iServers accept the reset command (<code>*SRYRST</code>) to be sent via the TCP/UDP protocol and some require the reset command to be sent via the Telnet protocol.</p> <p>Info</p> <p>The <code>telnetlib</code> module was removed from the standard library in Python 3.13. If you need Telnet support consider using a third-party library from PyPI. You can review the source code of this method to see how Telnet messages are sent to the device to perform the reset.</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>bool</code> <p>Whether to wait for the connection to the iServer to be re-established before returning to the calling program. Rebooting an iServer takes about 10 to 15 seconds.</p> <code>True</code> <code>password</code> <code>str | None</code> <p>The administrator's password of the iServer. If not specified then uses the default manufacturer's password. Only used if the iServer needs to be reset via the Telnet protocol.</p> <code>None</code> <code>port</code> <code>int</code> <p>The port to use for the Telnet connection.</p> <code>2002</code> <code>timeout</code> <code>float</code> <p>The timeout value to use during the Telnet session.</p> <code>10</code> Source code in <code>packages/resources/src/msl/equipment_resources/omega/ithx.py</code> <pre><code>def reset(self, *, wait: bool = True, password: str | None = None, port: int = 2002, timeout: float = 10) -&gt; None:\n    \"\"\"Power reset the iServer.\n\n    Some iServers accept the reset command (`*SRYRST`) to be sent via the TCP/UDP protocol and\n    some require the reset command to be sent via the Telnet protocol.\n\n    !!! info\n        The `telnetlib` module was removed from the standard library in Python 3.13.\n        If you need Telnet support consider using a third-party library from PyPI.\n        You can review the source code of this method to see how Telnet messages\n        are sent to the device to perform the reset.\n\n    Args:\n        wait: Whether to wait for the connection to the iServer to be re-established before\n            returning to the calling program. Rebooting an iServer takes about 10 to 15 seconds.\n        password: The administrator's password of the iServer. If not specified then uses the\n            default manufacturer's password. Only used if the iServer needs to be reset via\n            the Telnet protocol.\n        port: The port to use for the Telnet connection.\n        timeout: The timeout value to use during the Telnet session.\n    \"\"\"\n\n    def use_telnet() -&gt; None:\n        try:\n            # telnetlib was removed in Python 3.13\n            from telnetlib import Telnet  # type: ignore[import-not-found]  # pyright: ignore[reportUnknownVariableType, reportMissingImports]  # noqa: I001, PLC0415\n        except ImportError:\n            msg = \"iTHX reset requires telnet, which is no longer part of the Python standard library\"\n            raise MSLConnectionError(self, msg) from None\n\n        pw = password or \"00000000\"\n        with Telnet(self._info.host, port, timeout=timeout) as tn:  # pyright: ignore[reportUnknownVariableType]  # noqa: S312\n            tn.read_until(b\"Password:\", timeout=timeout)  # pyright: ignore[reportUnknownMemberType]\n            tn.write(pw.encode() + b\"\\n\")  # pyright: ignore[reportUnknownMemberType]\n            tn.read_until(b\"Login Successful\", timeout=timeout)  # pyright: ignore[reportUnknownMemberType]\n            tn.write(b\"reset\\n\")  # pyright: ignore[reportUnknownMemberType]\n            tn.read_until(b\"The unit will reset in 5 seconds.\", timeout=timeout)  # pyright: ignore[reportUnknownMemberType]\n\n        if wait:\n            # 5 seconds from the Telnet message\n            # 10 seconds for the time it takes to reboot\n            time.sleep(15)\n            self.reconnect(max_attempts=-1)\n\n    # according to the manual, these models require Telnet\n    if self.equipment.model in [\"iTHX-W\", \"iTHX-2\"]:\n        return use_telnet()\n\n    # The manual indicates that iTHX-W3, iTHX-D3, iTHX-SD and iTHX-M\n    # all accept the *SRYRST command\n    reply = self.query(\"*SRYRST\").strip()\n    if reply == \"Reset\":\n        # this was the reply that was received with an iTHX-W3\n        # which accepts the reset command via TCP/UDP\n        if wait:\n            time.sleep(10)\n            self.reconnect(max_attempts=-1)\n    elif reply == \"Serial Time Out\":\n        # this was the reply that was received with an iTHX-W\n        # which does not recognize the *SRYRST command\n        use_telnet()\n    else:\n        msg = f\"Received an unexpected reply, {reply!r}, for the *SRYRST command\"\n        raise MSLConnectionError(self, msg)\n\n    return None\n</code></pre>"},{"location":"resources/omega/ithx/#msl.equipment_resources.omega.ithx.ITHX.temperature","title":"temperature","text":"<pre><code>temperature(\n    probe: Literal[1, 2] = 1, *, celsius: bool = True\n) -&gt; float\n</code></pre> <p>Read the temperature.</p> <p>Parameters:</p> Name Type Description Default <code>probe</code> <code>Literal[1, 2]</code> <p>The probe number to read the temperature of (for iTHX's that contain multiple probes).</p> <code>1</code> <code>celsius</code> <code>bool</code> <p><code>True</code> to return the temperature in celsius, <code>False</code> for fahrenheit.</p> <code>True</code> <p>Returns:</p> Type Description <code>float</code> <p>The temperature for the specified probe.</p> Source code in <code>packages/resources/src/msl/equipment_resources/omega/ithx.py</code> <pre><code>def temperature(self, probe: Literal[1, 2] = 1, *, celsius: bool = True) -&gt; float:\n    \"\"\"Read the temperature.\n\n    Args:\n        probe: The probe number to read the temperature of (for iTHX's that contain multiple probes).\n        celsius: `True` to return the temperature in celsius, `False` for fahrenheit.\n\n    Returns:\n        The temperature for the specified probe.\n    \"\"\"\n    return self._get(\"TC\" if celsius else \"TF\", probe)\n</code></pre>"},{"location":"resources/optosigma/shot702/","title":"SHOT-702","text":"<p>Two-axis stage controller (SHOT-702) from OptoSigma.</p>"},{"location":"resources/optosigma/shot702/#msl.equipment_resources.optosigma.shot702.Mode","title":"Mode","text":"<p>               Bases: <code>IntEnum</code></p> <p>The mode by which a stage can be be moved.</p> <p>Attributes:</p> Name Type Description <code>HAND</code> <code>int</code> <p>Move by hand, <code>0</code>.</p> <code>MOTOR</code> <code>int</code> <p>Move by motor, <code>1</code>.</p>"},{"location":"resources/optosigma/shot702/#msl.equipment_resources.optosigma.shot702.SHOT702","title":"SHOT702","text":"<pre><code>SHOT702(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Serial</code></p> <p>Two-axis stage controller (SHOT-702) from OptoSigma.</p> <p>The default baud rate is set to 38400 and the read/write termination characters are <code>\\r\\n</code>.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optosigma/shot702.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    r\"\"\"Two-axis stage controller (SHOT-702) from OptoSigma.\n\n    The default baud rate is set to 38400 and the read/write termination characters are `\\r\\n`.\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"\n    assert equipment.connection is not None  # noqa: S101\n    equipment.connection.properties.setdefault(\"baud_rate\", 38400)\n    super().__init__(equipment)\n\n    self.read_termination: bytes = b\"\\r\\n\"\n    self.write_termination: bytes = b\"\\r\\n\"\n\n    self._status_regex: Pattern[str] = re.compile(r\"(-*)\\s*(\\d+),(-*)\\s*(\\d+),([XK]),([LMWK]),([BR])\")\n    self._speed_regex: Pattern[str] = re.compile(r\"S(\\d+)F(\\d+)R(\\d+)S(\\d+)F(\\d+)R(\\d+)\")\n</code></pre>"},{"location":"resources/optosigma/shot702/#msl.equipment_resources.optosigma.shot702.SHOT702.get_input_status","title":"get_input_status","text":"<pre><code>get_input_status() -&gt; int\n</code></pre> <p>Get the I/O input connector status.</p> <p>Returns:</p> Type Description <code>int</code> <p>Can either be 0 or 1 (see manual).</p> Source code in <code>packages/resources/src/msl/equipment_resources/optosigma/shot702.py</code> <pre><code>def get_input_status(self) -&gt; int:\n    \"\"\"Get the I/O input connector status.\n\n    Returns:\n        Can either be 0 or 1 (see manual).\n    \"\"\"\n    return int(self.query(\"I:\"))\n</code></pre>"},{"location":"resources/optosigma/shot702/#msl.equipment_resources.optosigma.shot702.SHOT702.get_speed","title":"get_speed","text":"<pre><code>get_speed() -&gt; tuple[Speed, Speed]\n</code></pre> <p>Get the speed that each stage moves to a position.</p> <p>Returns:</p> Type Description <code>tuple[Speed, Speed]</code> <p>The speed of each stage, <code>(stage1, stage2)</code>.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optosigma/shot702.py</code> <pre><code>def get_speed(self) -&gt; tuple[Speed, Speed]:\n    \"\"\"Get the speed that each stage moves to a position.\n\n    Returns:\n        The speed of each stage, `(stage1, stage2)`.\n    \"\"\"\n    reply = self.query(\"?:DW\")\n    match = self._speed_regex.match(reply)\n    if match is None:\n        msg = f\"Invalid speed regex expression for the reply {reply!r}\"\n        raise MSLConnectionError(self, msg)\n\n    a, b, c, d, e, f = map(int, match.groups())\n    return Speed(a, b, c), Speed(d, e, f)\n</code></pre>"},{"location":"resources/optosigma/shot702/#msl.equipment_resources.optosigma.shot702.SHOT702.get_speed_origin","title":"get_speed_origin","text":"<pre><code>get_speed_origin() -&gt; tuple[Speed, Speed]\n</code></pre> <p>Get the speed that each stage moves to the origin.</p> <p>Returns:</p> Type Description <code>tuple[Speed, Speed]</code> <p>The speed of each stage, <code>(stage1, stage2)</code>.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optosigma/shot702.py</code> <pre><code>def get_speed_origin(self) -&gt; tuple[Speed, Speed]:\n    \"\"\"Get the speed that each stage moves to the origin.\n\n    Returns:\n        The speed of each stage, `(stage1, stage2)`.\n    \"\"\"\n    reply = self.query(\"?:BW\")\n    match = self._speed_regex.match(reply)\n    if match is None:\n        msg = f\"Invalid speed regex expression for the reply {reply!r}\"\n        raise MSLConnectionError(self, msg)\n\n    a, b, c, d, e, f = map(int, match.groups())\n    return Speed(a, b, c), Speed(d, e, f)\n</code></pre>"},{"location":"resources/optosigma/shot702/#msl.equipment_resources.optosigma.shot702.SHOT702.get_steps","title":"get_steps","text":"<pre><code>get_steps() -&gt; tuple[int, int]\n</code></pre> <p>Get the number of steps for each stage.</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>The number of steps for <code>(stage1, stage2)</code>.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optosigma/shot702.py</code> <pre><code>def get_steps(self) -&gt; tuple[int, int]:\n    \"\"\"Get the number of steps for each stage.\n\n    Returns:\n        The number of steps for `(stage1, stage2)`.\n    \"\"\"\n    a, b = map(int, self.query(\"?:SW\").split(\",\"))\n    return a, b\n</code></pre>"},{"location":"resources/optosigma/shot702/#msl.equipment_resources.optosigma.shot702.SHOT702.get_travel_per_pulse","title":"get_travel_per_pulse","text":"<pre><code>get_travel_per_pulse() -&gt; tuple[float, float]\n</code></pre> <p>Get the travel per pulse for each stage.</p> <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>The travel per pulse for <code>(stage1, stage2)</code>.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optosigma/shot702.py</code> <pre><code>def get_travel_per_pulse(self) -&gt; tuple[float, float]:\n    \"\"\"Get the travel per pulse for each stage.\n\n    Returns:\n        The travel per pulse for `(stage1, stage2)`.\n    \"\"\"\n    a, b = map(float, self.query(\"?:PW\").split(\",\"))\n    return a, b\n</code></pre>"},{"location":"resources/optosigma/shot702/#msl.equipment_resources.optosigma.shot702.SHOT702.get_version","title":"get_version","text":"<pre><code>get_version() -&gt; str\n</code></pre> <p>Get the firmware version number.</p> <p>Returns:</p> Type Description <code>str</code> <p>The version number.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optosigma/shot702.py</code> <pre><code>def get_version(self) -&gt; str:\n    \"\"\"Get the firmware version number.\n\n    Returns:\n        The version number.\n    \"\"\"\n    return self.query(\"?:V\").rstrip()\n</code></pre>"},{"location":"resources/optosigma/shot702/#msl.equipment_resources.optosigma.shot702.SHOT702.home","title":"home","text":"<pre><code>home(stage: Literal[1, 2, 'W']) -&gt; None\n</code></pre> <p>Move the stage(s) to the home position.</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>Literal[1, 2, 'W']</code> <p>The stage(s) to home.</p> <ul> <li><code>1</code> \u2014 home stage 1</li> <li><code>2</code> \u2014 home stage 2</li> <li><code>\"W\"</code> \u2014 home stages 1 and 2</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/optosigma/shot702.py</code> <pre><code>def home(self, stage: Literal[1, 2, \"W\"]) -&gt; None:\n    \"\"\"Move the stage(s) to the home position.\n\n    Args:\n        stage: The stage(s) to home.\n\n            * `1` &amp;mdash; home stage 1\n            * `2` &amp;mdash; home stage 2\n            * `\"W\"` &amp;mdash; home stages 1 and 2\n    \"\"\"\n    reply = self.query(f\"H:{stage}\")\n    if not reply.startswith(\"OK\"):\n        msg = f\"Cannot home stage {stage}\"\n        raise MSLConnectionError(self, msg)\n</code></pre>"},{"location":"resources/optosigma/shot702/#msl.equipment_resources.optosigma.shot702.SHOT702.is_moving","title":"is_moving","text":"<pre><code>is_moving() -&gt; bool\n</code></pre> <p>Check if a stage is busy moving.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether a stage is busy moving.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optosigma/shot702.py</code> <pre><code>def is_moving(self) -&gt; bool:\n    \"\"\"Check if a stage is busy moving.\n\n    Returns:\n        Whether a stage is busy moving.\n    \"\"\"\n    return self.query(\"!:\").startswith(\"B\")\n</code></pre>"},{"location":"resources/optosigma/shot702/#msl.equipment_resources.optosigma.shot702.SHOT702.move","title":"move","text":"<pre><code>move(\n    stage: Literal[1, 2, \"W\"],\n    direction: Literal[\"+\", \"-\", \"++\", \"+-\", \"-+\", \"--\"],\n) -&gt; None\n</code></pre> <p>Start moving the stage(s), at the minimum speed, in the specified direction.</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>Literal[1, 2, 'W']</code> <p>The stage(s) to move.</p> <ul> <li><code>1</code> \u2014 move stage 1</li> <li><code>2</code> \u2014 move stage 2</li> <li><code>\"W\"</code> \u2014 move stages 1 and 2</li> </ul> required <code>direction</code> <code>Literal['+', '-', '++', '+-', '-+', '--']</code> <p>The direction that the stage(s) should move.</p> <ul> <li><code>\"+\"</code> \u2014 move a single stage in the <code>+</code> direction</li> <li><code>\"-\"</code> \u2014 move a single stage in the <code>-</code> direction</li> <li><code>\"++\"</code> \u2014 move stage 1 in the <code>+</code> direction, stage 2 in the <code>+</code> direction</li> <li><code>\"+-\"</code> \u2014 move stage 1 in the <code>+</code> direction, stage 2 in the <code>-</code> direction</li> <li><code>\"-+\"</code> \u2014 move stage 1 in the <code>-</code> direction, stage 2 in the <code>+</code> direction</li> <li><code>\"--\"</code> \u2014 move stage 1 in the <code>-</code> direction, stage 2 in the <code>-</code> direction</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/optosigma/shot702.py</code> <pre><code>def move(self, stage: Literal[1, 2, \"W\"], direction: Literal[\"+\", \"-\", \"++\", \"+-\", \"-+\", \"--\"]) -&gt; None:\n    \"\"\"Start moving the stage(s), at the minimum speed, in the specified direction.\n\n    Args:\n        stage: The stage(s) to move.\n\n            * `1` &amp;mdash; move stage 1\n            * `2` &amp;mdash; move stage 2\n            * `\"W\"` &amp;mdash; move stages 1 and 2\n\n        direction: The direction that the stage(s) should move.\n\n            * `\"+\"` &amp;mdash; move a single stage in the `+` direction\n            * `\"-\"` &amp;mdash; move a single stage in the `-` direction\n            * `\"++\"` &amp;mdash; move stage 1 in the `+` direction, stage 2 in the `+` direction\n            * `\"+-\"` &amp;mdash; move stage 1 in the `+` direction, stage 2 in the `-` direction\n            * `\"-+\"` &amp;mdash; move stage 1 in the `-` direction, stage 2 in the `+` direction\n            * `\"--\"` &amp;mdash; move stage 1 in the `-` direction, stage 2 in the `-` direction\n    \"\"\"\n    reply = self.query(f\"J:{stage}{direction}\")\n    if not reply.startswith(\"OK\") or not self.query(\"G:\").startswith(\"OK\"):\n        msg = f\"Cannot move stage {stage} in direction={direction!r}\"\n        raise MSLConnectionError(self, msg)\n</code></pre>"},{"location":"resources/optosigma/shot702/#msl.equipment_resources.optosigma.shot702.SHOT702.move_absolute","title":"move_absolute","text":"<pre><code>move_absolute(\n    stage: Literal[1, 2, \"W\"], *position: int\n) -&gt; None\n</code></pre> <p>Move the stage(s) to the specified position.</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>Literal[1, 2, 'W']</code> <p>The stage(s) to move.</p> <ul> <li><code>1</code> \u2014 move stage 1</li> <li><code>2</code> \u2014 move stage 2</li> <li><code>\"W\"</code> \u2014 move stages 1 and 2</li> </ul> required <code>position</code> <code>int</code> <p>The position the stage(s) should move to.</p> <code>()</code> <p>Example</p> <ul> <li><code>move_absolute(1, 1000)</code> \u2014 move stage 1 to position 1000 in the <code>+</code> direction</li> <li><code>move_absolute(2, -5000)</code> \u2014 move stage 2 to position 5000 in the <code>-</code> direction</li> <li><code>move_absolute('W', 1000, -5000)</code> \u2014 move stage 1 to position 1000 in the <code>+</code> direction, and     move stage 2 to position 5000 in the <code>-</code> direction</li> </ul> Source code in <code>packages/resources/src/msl/equipment_resources/optosigma/shot702.py</code> <pre><code>def move_absolute(self, stage: Literal[1, 2, \"W\"], *position: int) -&gt; None:\n    \"\"\"Move the stage(s) to the specified position.\n\n    Args:\n        stage: The stage(s) to move.\n\n            * `1` &amp;mdash; move stage 1\n            * `2` &amp;mdash; move stage 2\n            * `\"W\"` &amp;mdash; move stages 1 and 2\n\n        position: The position the stage(s) should move to.\n\n    !!! example\n        * `move_absolute(1, 1000)` &amp;mdash; move stage 1 to position 1000 in the `+` direction\n        * `move_absolute(2, -5000)` &amp;mdash; move stage 2 to position 5000 in the `-` direction\n        * `move_absolute('W', 1000, -5000)` &amp;mdash; move stage 1 to position 1000 in the `+` direction, and\n            move stage 2 to position 5000 in the `-` direction\n    \"\"\"\n    self._move(\"A\", stage, *position)\n</code></pre>"},{"location":"resources/optosigma/shot702/#msl.equipment_resources.optosigma.shot702.SHOT702.move_relative","title":"move_relative","text":"<pre><code>move_relative(\n    stage: Literal[1, 2, \"W\"], *num_pulses: int\n) -&gt; None\n</code></pre> <p>Move the stage(s) by a relative amount.</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>Literal[1, 2, 'W']</code> <p>The stage(s) to move.</p> <ul> <li><code>1</code> \u2014 move stage 1</li> <li><code>2</code> \u2014 move stage 2</li> <li><code>\"W\"</code> \u2014 move stages 1 and 2</li> </ul> required <code>num_pulses</code> <code>int</code> <p>The number of pulses the stage(s) should move.</p> <code>()</code> <p>Example</p> <ul> <li><code>move_relative(1, 1000)</code> \u2014 move stage 1 by 1000 pulses in the <code>+</code> direction</li> <li><code>move_relative(2, -5000)</code> \u2014 move stage 2 by 5000 pulses in the <code>-</code> direction</li> <li><code>move_relative('W', 1000, -5000)</code> \u2014 move stage 1 by 1000 pulses in the <code>+</code> direction, and     move stage 2 by 5000 pulses in the <code>-</code> direction</li> </ul> Source code in <code>packages/resources/src/msl/equipment_resources/optosigma/shot702.py</code> <pre><code>def move_relative(self, stage: Literal[1, 2, \"W\"], *num_pulses: int) -&gt; None:\n    \"\"\"Move the stage(s) by a relative amount.\n\n    Args:\n        stage: The stage(s) to move.\n\n            * `1` &amp;mdash; move stage 1\n            * `2` &amp;mdash; move stage 2\n            * `\"W\"` &amp;mdash; move stages 1 and 2\n\n        num_pulses: The number of pulses the stage(s) should move.\n\n    !!! example\n        * `move_relative(1, 1000)` &amp;mdash; move stage 1 by 1000 pulses in the `+` direction\n        * `move_relative(2, -5000)` &amp;mdash; move stage 2 by 5000 pulses in the `-` direction\n        * `move_relative('W', 1000, -5000)` &amp;mdash; move stage 1 by 1000 pulses in the `+` direction, and\n            move stage 2 by 5000 pulses in the `-` direction\n    \"\"\"\n    self._move(\"M\", stage, *num_pulses)\n</code></pre>"},{"location":"resources/optosigma/shot702/#msl.equipment_resources.optosigma.shot702.SHOT702.set_mode","title":"set_mode","text":"<pre><code>set_mode(\n    stage: Literal[1, 2, \"W\"], mode: Literal[0, 1] | Mode\n) -&gt; None\n</code></pre> <p>Set whether the stage(s) can be moved by hand or by the motor.</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>Literal[1, 2, 'W']</code> <p>The stage(s) to set the mode of.</p> <ul> <li><code>1</code> \u2014 set the mode for stage 1</li> <li><code>2</code> \u2014 set the mode for stage 2</li> <li><code>\"W\"</code> \u2014 set the mode for stages 1 and 2</li> </ul> required <code>mode</code> <code>Literal[0, 1] | Mode</code> <p>Whether the stage(s) can be moved by hand (0) or by motor (1).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optosigma/shot702.py</code> <pre><code>def set_mode(self, stage: Literal[1, 2, \"W\"], mode: Literal[0, 1] | Mode) -&gt; None:\n    \"\"\"Set whether the stage(s) can be moved by hand or by the motor.\n\n    Args:\n        stage: The stage(s) to set the mode of.\n\n            * `1` &amp;mdash; set the mode for stage 1\n            * `2` &amp;mdash; set the mode for stage 2\n            * `\"W\"` &amp;mdash; set the mode for stages 1 and 2\n\n        mode: Whether the stage(s) can be moved by hand (0) or by motor (1).\n    \"\"\"\n    reply = self.query(f\"C:{stage}{mode}\")\n    if not reply.startswith(\"OK\"):\n        msg = f\"Cannot set stage {stage} to mode={mode}\"\n        raise MSLConnectionError(self, msg)\n</code></pre>"},{"location":"resources/optosigma/shot702/#msl.equipment_resources.optosigma.shot702.SHOT702.set_origin","title":"set_origin","text":"<pre><code>set_origin(stage: Literal[1, 2, 'W']) -&gt; None\n</code></pre> <p>Set the origin of the stage(s) to its current position.</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>Literal[1, 2, 'W']</code> <p>The stage(s) to set the home of.</p> <ul> <li><code>1</code> \u2014 set the home for stage 1</li> <li><code>2</code> \u2014 set the home for stage 2</li> <li><code>\"W\"</code> \u2014 set the home for stages 1 and 2</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/optosigma/shot702.py</code> <pre><code>def set_origin(self, stage: Literal[1, 2, \"W\"]) -&gt; None:\n    \"\"\"Set the origin of the stage(s) to its current position.\n\n    Args:\n        stage: The stage(s) to set the home of.\n\n            * `1` &amp;mdash; set the home for stage 1\n            * `2` &amp;mdash; set the home for stage 2\n            * `\"W\"` &amp;mdash; set the home for stages 1 and 2\n    \"\"\"\n    reply = self.query(f\"R:{stage}\")\n    if not reply.startswith(\"OK\"):\n        msg = f\"Cannot set the origin for stage {stage}\"\n        raise MSLConnectionError(self, msg)\n</code></pre>"},{"location":"resources/optosigma/shot702/#msl.equipment_resources.optosigma.shot702.SHOT702.set_output_status","title":"set_output_status","text":"<pre><code>set_output_status(status: Literal[0, 1]) -&gt; None\n</code></pre> <p>Set the I/O output status.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>Literal[0, 1]</code> <p>Can either be 0 or 1 (see manual).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optosigma/shot702.py</code> <pre><code>def set_output_status(self, status: Literal[0, 1]) -&gt; None:\n    \"\"\"Set the I/O output status.\n\n    Args:\n        status: Can either be 0 or 1 (see manual).\n    \"\"\"\n    reply = self.query(f\"O:{status}\")\n    if not reply.startswith(\"OK\"):\n        msg = f\"Cannot set the output status to {status}\"\n        raise MSLConnectionError(self, msg)\n</code></pre>"},{"location":"resources/optosigma/shot702/#msl.equipment_resources.optosigma.shot702.SHOT702.set_speed","title":"set_speed","text":"<pre><code>set_speed(\n    stage: Literal[1, 2, \"W\"], *speeds: Speed\n) -&gt; None\n</code></pre> <p>Set the speed when moving to a position.</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>Literal[1, 2, 'W']</code> <p>The stage(s) to set the speed settings for.</p> <ul> <li><code>1</code> \u2014 set the speed for stage 1</li> <li><code>2</code> \u2014 set the speed for stage 2</li> <li><code>\"W\"</code> \u2014 set the speed for stages 1 and 2     (<code>speeds</code> is then the speed settings for stage 1, stage 2)</li> </ul> required <code>speeds</code> <code>Speed</code> <p>The speed settings.</p> <code>()</code> <p>Example</p> <ul> <li><code>set_speed(1, Speed(100, 1000, 50))</code> \u2014 stage 1 moves at a minimum speed of 100 PPS,     maximum speed of 1000 PPS and a 50 ms acceleration/deceleration time.</li> <li><code>set_speed(\"W\", Speed(100, 1000, 50), Speed(200, 2000, 100))</code> \u2014 stage 1 moves at a     minimum speed of 100 PPS, maximum speed of 1000 PPS and a 50 ms acceleration/deceleration time, and,     stage 2 moves at a minimum speed of 200 PPS, maximum speed of 2000 PPS and a 100 ms     acceleration/deceleration time.</li> </ul> Source code in <code>packages/resources/src/msl/equipment_resources/optosigma/shot702.py</code> <pre><code>def set_speed(self, stage: Literal[1, 2, \"W\"], *speeds: Speed) -&gt; None:\n    \"\"\"Set the speed when moving to a position.\n\n    Args:\n        stage: The stage(s) to set the speed settings for.\n\n            * `1` &amp;mdash; set the speed for stage 1\n            * `2` &amp;mdash; set the speed for stage 2\n            * `\"W\"` &amp;mdash; set the speed for stages 1 and 2\n                (`speeds` is then the speed settings for stage 1, stage 2)\n\n        speeds: The speed settings.\n\n    !!! example\n        * `set_speed(1, Speed(100, 1000, 50))` &amp;mdash; stage 1 moves at a minimum speed of 100 PPS,\n            maximum speed of 1000 PPS and a 50 ms acceleration/deceleration time.\n        * `set_speed(\"W\", Speed(100, 1000, 50), Speed(200, 2000, 100))` &amp;mdash; stage 1 moves at a\n            minimum speed of 100 PPS, maximum speed of 1000 PPS and a 50 ms acceleration/deceleration time, and,\n            stage 2 moves at a minimum speed of 200 PPS, maximum speed of 2000 PPS and a 100 ms\n            acceleration/deceleration time.\n    \"\"\"\n    self._speed(\"D\", stage, *speeds)\n</code></pre>"},{"location":"resources/optosigma/shot702/#msl.equipment_resources.optosigma.shot702.SHOT702.set_speed_origin","title":"set_speed_origin","text":"<pre><code>set_speed_origin(\n    stage: Literal[1, 2, \"W\"], *speeds: Speed\n) -&gt; None\n</code></pre> <p>Set the speed when moving to the origin.</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>Literal[1, 2, 'W']</code> <p>The stage(s) to set the speed settings for.</p> <ul> <li><code>1</code> \u2014 set the speed for stage 1</li> <li><code>2</code> \u2014 set the speed for stage 2</li> <li><code>\"W\"</code> \u2014 set the speed for stages 1 and 2     (<code>speeds</code> is then the speed settings for stage 1, stage 2)</li> </ul> required <code>speeds</code> <code>Speed</code> <p>The speed settings.</p> <code>()</code> <p>Example</p> <ul> <li><code>set_speed_origin(2, Speed(100, 1000, 50))</code> \u2014 stage 2 moves at a minimum speed of 100 PPS,     maximum speed of 1000 PPS and a 50 ms acceleration/deceleration time.</li> <li><code>set_speed_origin(\"W\", Speed(100, 1000, 50), Speed(200, 2000, 100))</code> \u2014 stage 1 moves at a     minimum speed of 100 PPS, maximum speed of 1000 PPS and a 50 ms acceleration/deceleration time, and,     stage 2 moves at a minimum speed of 200 PPS, maximum speed of 2000 PPS and a 100 ms     acceleration/deceleration time.</li> </ul> Source code in <code>packages/resources/src/msl/equipment_resources/optosigma/shot702.py</code> <pre><code>def set_speed_origin(self, stage: Literal[1, 2, \"W\"], *speeds: Speed) -&gt; None:\n    \"\"\"Set the speed when moving to the origin.\n\n    Args:\n        stage: The stage(s) to set the speed settings for.\n\n            * `1` &amp;mdash; set the speed for stage 1\n            * `2` &amp;mdash; set the speed for stage 2\n            * `\"W\"` &amp;mdash; set the speed for stages 1 and 2\n                (`speeds` is then the speed settings for stage 1, stage 2)\n\n        speeds: The speed settings.\n\n    !!! example\n        * `set_speed_origin(2, Speed(100, 1000, 50))` &amp;mdash; stage 2 moves at a minimum speed of 100 PPS,\n            maximum speed of 1000 PPS and a 50 ms acceleration/deceleration time.\n        * `set_speed_origin(\"W\", Speed(100, 1000, 50), Speed(200, 2000, 100))` &amp;mdash; stage 1 moves at a\n            minimum speed of 100 PPS, maximum speed of 1000 PPS and a 50 ms acceleration/deceleration time, and,\n            stage 2 moves at a minimum speed of 200 PPS, maximum speed of 2000 PPS and a 100 ms\n            acceleration/deceleration time.\n    \"\"\"\n    self._speed(\"V\", stage, *speeds)\n</code></pre>"},{"location":"resources/optosigma/shot702/#msl.equipment_resources.optosigma.shot702.SHOT702.set_steps","title":"set_steps","text":"<pre><code>set_steps(stage: Literal[1, 2], steps: int) -&gt; None\n</code></pre> <p>Set the number of steps that the stage motor will use.</p> <p>See the manual for more details (the <code>S</code> command).</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>Literal[1, 2]</code> <p>The stage to set the steps of.</p> required <code>steps</code> <code>int</code> <p>The number of steps that the motor should use (must be one of <code>1</code>, <code>2</code>, <code>4</code>, <code>5</code>, <code>8</code>, <code>10</code>, <code>20</code>, <code>25</code>, <code>40</code>, <code>50</code>, <code>80</code>, <code>100</code>, <code>125</code>, <code>200</code>, <code>250</code>).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optosigma/shot702.py</code> <pre><code>def set_steps(self, stage: Literal[1, 2], steps: int) -&gt; None:\n    \"\"\"Set the number of steps that the stage motor will use.\n\n    See the manual for more details (the `S` command).\n\n    Args:\n        stage: The stage to set the steps of.\n        steps: The number of steps that the motor should use (must be one of\n            `1`, `2`, `4`, `5`, `8`, `10`, `20`, `25`, `40`, `50`, `80`, `100`, `125`, `200`, `250`).\n    \"\"\"\n    reply = self.query(f\"S:{stage}{steps}\")\n    if not reply.startswith(\"OK\"):\n        msg = f\"Cannot set stage {stage} to #steps={steps}\"\n        raise MSLConnectionError(self, msg)\n</code></pre>"},{"location":"resources/optosigma/shot702/#msl.equipment_resources.optosigma.shot702.SHOT702.status","title":"status","text":"<pre><code>status() -&gt; Status\n</code></pre> <p>Get the current position and state of each stage.</p> <p>Returns:</p> Type Description <code>Status</code> <p>The current position and state of each stage.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optosigma/shot702.py</code> <pre><code>def status(self) -&gt; Status:\n    \"\"\"Get the current position and state of each stage.\n\n    Returns:\n        The current position and state of each stage.\n    \"\"\"\n    reply = self.query(\"Q:\")\n    if reply == \"NG\":  # then try again\n        self.serial.reset_input_buffer()\n        self.serial.reset_output_buffer()\n        return self.status()\n\n    match = self._status_regex.match(reply)\n    if not match:\n        msg = f\"Invalid regex expression for the reply {reply!r}\"\n        raise MSLConnectionError(self, msg)\n\n    negative1, position1, negative2, position2, ok, state, moving = match.groups()\n    if ok != \"K\":\n        msg = f\"Controller indicates a command or parameter error, reply={reply!r}\"\n        raise MSLConnectionError(self, msg)\n\n    pos1 = -int(position1) if negative1 else int(position1)\n    pos2 = -int(position2) if negative2 else int(position2)\n    return Status(pos1, pos2, State(state), moving == \"B\")\n</code></pre>"},{"location":"resources/optosigma/shot702/#msl.equipment_resources.optosigma.shot702.SHOT702.stop","title":"stop","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Immediately stop both stages from moving.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optosigma/shot702.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Immediately stop both stages from moving.\"\"\"\n    reply = self.query(\"L:E\")\n    if not reply.startswith(\"OK\"):\n        msg = \"Cannot stop the stages\"\n        raise MSLConnectionError(self, msg)\n</code></pre>"},{"location":"resources/optosigma/shot702/#msl.equipment_resources.optosigma.shot702.SHOT702.stop_slowly","title":"stop_slowly","text":"<pre><code>stop_slowly(stage: Literal[1, 2, 'W']) -&gt; None\n</code></pre> <p>Slowly bring the stage(s) to a stop.</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>Literal[1, 2, 'W']</code> <p>The stage(s) to slowly stop.</p> <ul> <li><code>1</code> \u2014 slowly stop stage 1</li> <li><code>2</code> \u2014 slowly stop stage 2</li> <li><code>\"W\"</code> \u2014 slowly stop stages 1 and 2</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/optosigma/shot702.py</code> <pre><code>def stop_slowly(self, stage: Literal[1, 2, \"W\"]) -&gt; None:\n    \"\"\"Slowly bring the stage(s) to a stop.\n\n    Args:\n        stage: The stage(s) to slowly stop.\n\n            * `1` &amp;mdash; slowly stop stage 1\n            * `2` &amp;mdash; slowly stop stage 2\n            * `\"W\"` &amp;mdash; slowly stop stages 1 and 2\n    \"\"\"\n    reply = self.query(f\"L:{stage}\")\n    if not reply.startswith(\"OK\"):\n        msg = f\"cannot slowly stop stage {stage}\"\n        raise MSLConnectionError(self, msg)\n</code></pre>"},{"location":"resources/optosigma/shot702/#msl.equipment_resources.optosigma.shot702.SHOT702.wait","title":"wait","text":"<pre><code>wait(\n    callback: Callable[[Status], None] | None = None,\n    sleep: float = 0.05,\n) -&gt; None\n</code></pre> <p>Wait for all stages to finish moving.</p> <p>This is a blocking call because it uses sleep.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Status], None] | None</code> <p>A callable function. The function will receive 1 argument, the Status</p> <code>None</code> <code>sleep</code> <code>float</code> <p>The number of seconds to wait between calls to the <code>callback</code>.</p> <code>0.05</code> Source code in <code>packages/resources/src/msl/equipment_resources/optosigma/shot702.py</code> <pre><code>def wait(self, callback: Callable[[Status], None] | None = None, sleep: float = 0.05) -&gt; None:\n    \"\"\"Wait for all stages to finish moving.\n\n    This is a blocking call because it uses [sleep][time.sleep].\n\n    Args:\n        callback: A callable function. The function will receive 1 argument,\n            the [Status][msl.equipment_resources.optosigma.shot702.Status]\n        sleep: The number of seconds to wait between calls to the `callback`.\n    \"\"\"\n    while True:\n        status = self.status()\n        if callback is not None:\n            callback(status)\n        if not status.is_moving:\n            return\n        time.sleep(sleep)\n</code></pre>"},{"location":"resources/optosigma/shot702/#msl.equipment_resources.optosigma.shot702.Speed","title":"Speed  <code>dataclass</code>","text":"<pre><code>Speed(minimum: int, maximum: int, acceleration: int)\n</code></pre> <p>Speed settings.</p> <p>Parameters:</p> Name Type Description Default <code>minimum</code> <code>int</code> <p>Minimum speed (1 - 500k pulses/second).</p> required <code>maximum</code> <code>int</code> <p>Maximum speed (1 - 500k pulses/second).</p> required <code>acceleration</code> <code>int</code> <p>Acceleration (deceleration) time in milliseconds (1 - 1000 ms).</p> required"},{"location":"resources/optosigma/shot702/#msl.equipment_resources.optosigma.shot702.State","title":"State","text":"<p>               Bases: <code>Enum</code></p> <p>Stage stopped state.</p> <p>Attributes:</p> Name Type Description <code>L</code> <code>str</code> <p>Stage 1 stopped at a limit sensor.</p> <code>M</code> <code>str</code> <p>Stage 2 stopped at a limit sensor.</p> <code>W</code> <code>str</code> <p>Stage 1 and stage 2 stopped at a limit sensor.</p> <code>K</code> <code>str</code> <p>Normal stop.</p>"},{"location":"resources/optosigma/shot702/#msl.equipment_resources.optosigma.shot702.Status","title":"Status","text":"<p>               Bases: <code>NamedTuple</code></p> <p>The status of each stage.</p> <p>Attributes:</p> Name Type Description <code>position1</code> <code>int</code> <p>The current position of stage 1.</p> <code>position2</code> <code>int</code> <p>The current position of stage 2.</p> <code>state</code> <code>State</code> <p>The stopped state of the stage.</p> <code>is_moving</code> <code>bool</code> <p>Whether a stage is busy moving.</p>"},{"location":"resources/optronic_labs/ol756/","title":"OL 756","text":"<p>Communicate with an OL 756 spectroradiometer from Optronic Laboratories.</p>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756","title":"OL756","text":"<pre><code>OL756(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Communicate with an OL 756 spectroradiometer from Optronic Laboratories.</p> <p>This class can be used with either a 32- or 64-bit Python interpreter to call the 32-bit functions in the <code>OL756SDKActiveXCtrl</code> library.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for an OL 756 spectroradiometer.</p> <p>Connection Properties:</p> Name Type Description <code>mode</code> <code>int</code> <p>Connection mode (<code>0</code>: RS-232, <code>1</code>: USB). Default: <code>1</code> (USB)</p> <code>com_port</code> <code>int</code> <p>The COM port number (RS-232 mode only). Default: <code>1</code></p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Communicate with an OL 756 spectroradiometer from Optronic Laboratories.\n\n    This class can be used with either a 32- or 64-bit Python interpreter\n    to call the 32-bit functions in the `OL756SDKActiveXCtrl` library.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following\n    _properties_ for an OL 756 spectroradiometer.\n\n    Attributes: Connection Properties:\n        mode (int): Connection mode (`0`: RS-232, `1`: USB). _Default: `1` (USB)_\n        com_port (int): The COM port number (RS-232 mode only). _Default: `1`_\n    \"\"\"\n    self._client: Client64 | None = None\n    super().__init__(equipment)\n\n    assert equipment.connection is not None  # noqa: S101\n\n    try:\n        self._client = Client64(\n            Path(__file__).parent / \"ol756ocx_32.py\",\n            prog_id=equipment.connection.address[5:],\n            mode=equipment.connection.properties.get(\"mode\", 1),\n            com_port=equipment.connection.properties.get(\"com_port\", 1),\n        )\n    except ConnectionTimeoutError as e:\n        msg = f\"Cannot initialize the OL756 SDK.\\n{e.reason}\"\n        raise MSLConnectionError(self, msg) from None\n\n    self._request32: Callable[..., Any] = self._client.request32\n\n    if self._request32(\"mode\") == -1:\n        self.disconnect()\n        msg = \"Cannot connect to the OL756 spectroradiometer. Is it turned on and connected to the computer?\"\n        raise MSLConnectionError(self, msg) from None\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.accumulate_signals","title":"accumulate_signals","text":"<pre><code>accumulate_signals(\n    meas_type: Literal[0, 1, 2, 3, 4, 5],\n) -&gt; None\n</code></pre> <p>Function needs to be called after a measurement was performed.</p> <p>This essentially accumulates the data together until the user is ready to average out the data. This function is used in combination with reset_averaging and do_averaging.</p> <p>Parameters:</p> Name Type Description Default <code>meas_type</code> <code>Literal[0, 1, 2, 3, 4, 5]</code> <p>The measurement type.</p> <ul> <li><code>0</code> \u2014 Irradiance</li> <li><code>1</code> \u2014 Radiance</li> <li><code>2</code> \u2014 Transmittance</li> <li><code>3</code> \u2014 Irradiance Calibration</li> <li><code>4</code> \u2014 Radiance Calibration</li> <li><code>5</code> \u2014 Transmittance Calibration</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def accumulate_signals(self, meas_type: Literal[0, 1, 2, 3, 4, 5]) -&gt; None:\n    \"\"\"Function needs to be called after a measurement was performed.\n\n    This essentially accumulates the data together until the user is\n    ready to average out the data. This function is used in combination with\n    [reset_averaging][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.reset_averaging]\n    and [do_averaging][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.do_averaging].\n\n    Args:\n        meas_type: The measurement type.\n\n            * `0` &amp;mdash; Irradiance\n            * `1` &amp;mdash; Radiance\n            * `2` &amp;mdash; Transmittance\n            * `3` &amp;mdash; Irradiance Calibration\n            * `4` &amp;mdash; Radiance Calibration\n            * `5` &amp;mdash; Transmittance Calibration\n\n    \"\"\"\n    self._send(\"accumulate_signals\", meas_type)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the OL756 spectroradiometer.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Disconnect from the OL756 spectroradiometer.\"\"\"\n    if self._client is None:\n        return\n\n    with contextlib.suppress(Server32Error):\n        self._send(\"connect_to_ol756\", -1)\n\n    try:\n        stdout, stderr = self._client.shutdown_server32()\n    except Server32Error:\n        pass\n    else:\n        stdout.close()\n        stderr.close()\n\n    self._client = None\n    super().disconnect()\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.do_averaging","title":"do_averaging","text":"<pre><code>do_averaging(\n    meas_type: Literal[0, 1, 2, 3, 4, 5], n_scans: int\n) -&gt; None\n</code></pre> <p>Function divides the accumulated signal by the number of scans performed.</p> <p>It then sets the array containing the data with the averaged data. This function is used in combination with reset_averaging and accumulate_signals.</p> <p>Parameters:</p> Name Type Description Default <code>meas_type</code> <code>Literal[0, 1, 2, 3, 4, 5]</code> <p>The measurement type.</p> <ul> <li><code>0</code> \u2014 Irradiance</li> <li><code>1</code> \u2014 Radiance</li> <li><code>2</code> \u2014 Transmittance</li> <li><code>3</code> \u2014 Irradiance Calibration</li> <li><code>4</code> \u2014 Radiance Calibration</li> <li><code>5</code> \u2014 Transmittance Calibration</li> </ul> required <code>n_scans</code> <code>int</code> <p>The number of scans to average.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def do_averaging(self, meas_type: Literal[0, 1, 2, 3, 4, 5], n_scans: int) -&gt; None:\n    \"\"\"Function divides the accumulated signal by the number of scans performed.\n\n    It then sets the array containing the data with the averaged data. This function is used in combination with\n    [reset_averaging][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.reset_averaging]\n    and [accumulate_signals][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.accumulate_signals].\n\n    Args:\n        meas_type: The measurement type.\n\n            * `0` &amp;mdash; Irradiance\n            * `1` &amp;mdash; Radiance\n            * `2` &amp;mdash; Transmittance\n            * `3` &amp;mdash; Irradiance Calibration\n            * `4` &amp;mdash; Radiance Calibration\n            * `5` &amp;mdash; Transmittance Calibration\n\n        n_scans: The number of scans to average.\n    \"\"\"\n    self._send(\"do_averaging\", meas_type, n_scans)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.do_calculations","title":"do_calculations","text":"<pre><code>do_calculations(\n    meas_type: Literal[0, 1, 2, 3, 4, 5],\n) -&gt; None\n</code></pre> <p>Function needs to be called after each measurement to update the calculations.</p> <p>Parameters:</p> Name Type Description Default <code>meas_type</code> <code>Literal[0, 1, 2, 3, 4, 5]</code> <p>The measurement type.</p> <ul> <li><code>0</code> \u2014 Irradiance</li> <li><code>1</code> \u2014 Radiance</li> <li><code>2</code> \u2014 Transmittance</li> <li><code>3</code> \u2014 Irradiance Calibration</li> <li><code>4</code> \u2014 Radiance Calibration</li> <li><code>5</code> \u2014 Transmittance Calibration</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def do_calculations(self, meas_type: Literal[0, 1, 2, 3, 4, 5]) -&gt; None:\n    \"\"\"Function needs to be called after each measurement to update the calculations.\n\n    Args:\n        meas_type: The measurement type.\n\n            * `0` &amp;mdash; Irradiance\n            * `1` &amp;mdash; Radiance\n            * `2` &amp;mdash; Transmittance\n            * `3` &amp;mdash; Irradiance Calibration\n            * `4` &amp;mdash; Radiance Calibration\n            * `5` &amp;mdash; Transmittance Calibration\n\n    \"\"\"\n    self._send(\"do_calculations\", meas_type)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.enable_calibration_file","title":"enable_calibration_file","text":"<pre><code>enable_calibration_file(\n    meas_type: Literal[3, 4, 5], *, enable: bool\n) -&gt; None\n</code></pre> <p>Enables or disables the use of a calibration file.</p> <p>Use this option to generate calibrated results. To open a standard file used to create a calibration, use enable_standard_file instead.</p> <p>The user should call load_calibration_file first to load the calibration file before enabling it.</p> <p>Parameters:</p> Name Type Description Default <code>meas_type</code> <code>Literal[3, 4, 5]</code> <p>The measurement type.</p> <ul> <li><code>3</code> \u2014 Irradiance Calibration</li> <li><code>4</code> \u2014 Radiance Calibration</li> <li><code>5</code> \u2014 Transmittance Calibration</li> </ul> required <code>enable</code> <code>bool</code> <p>Whether to enable or disable the use of a calibration file.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def enable_calibration_file(self, meas_type: Literal[3, 4, 5], *, enable: bool) -&gt; None:\n    \"\"\"Enables or disables the use of a calibration file.\n\n    Use this option to generate calibrated results. To open a standard file\n    used to create a calibration, use\n    [enable_standard_file][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.enable_standard_file]\n    instead.\n\n    The user should call\n    [load_calibration_file][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.load_calibration_file]\n    first to load the calibration file before enabling it.\n\n    Args:\n        meas_type: The measurement type.\n\n            * `3` &amp;mdash; Irradiance Calibration\n            * `4` &amp;mdash; Radiance Calibration\n            * `5` &amp;mdash; Transmittance Calibration\n\n        enable: Whether to enable or disable the use of a calibration file.\n    \"\"\"\n    self._send(\"enable_calibration_file\", meas_type, enable)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.enable_dark_current","title":"enable_dark_current","text":"<pre><code>enable_dark_current(*, enable: bool = True) -&gt; None\n</code></pre> <p>Turn the dark current on or off.</p> <p>Enable this feature if you want the dark current automatically acquired and subtracted before each measurement. If you wish to take a dark current manually, see the get_dark_current function.</p> <p>The parameters for the dark current will need to be set using set_dark_current_params.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>Whether to turn the dark current on or off.</p> <code>True</code> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def enable_dark_current(self, *, enable: bool = True) -&gt; None:\n    \"\"\"Turn the dark current on or off.\n\n    Enable this feature if you want the dark current automatically\n    acquired and subtracted before each measurement. If you wish to\n    take a dark current manually, see the\n    [get_dark_current][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_dark_current]\n    function.\n\n    The parameters for the dark current will need to be set using\n    [set_dark_current_params][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.set_dark_current_params].\n\n    Args:\n        enable: Whether to turn the dark current on or off.\n    \"\"\"\n    self._send(\"enable_dark_current\", enable)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.enable_pmt_protection_mode","title":"enable_pmt_protection_mode","text":"<pre><code>enable_pmt_protection_mode(*, enable: bool) -&gt; None\n</code></pre> <p>Turn the PMT protection routines on or off.</p> <p>Enable this feature if you want the PMT to be shielded while travelling through high intensity spikes. This feature will make the scan slower since the wavelength and filter drive will move asynchronously.</p> <p>The PMT is still protected by the hardware. This function prevents exposure of the PMT while travelling.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>Whether to turn the PMT protection routines on or off.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def enable_pmt_protection_mode(self, *, enable: bool) -&gt; None:\n    \"\"\"Turn the PMT protection routines on or off.\n\n    Enable this feature if you want the PMT to be shielded while travelling\n    through high intensity spikes. This feature will make the scan slower\n    since the wavelength and filter drive will move asynchronously.\n\n    The PMT is still protected by the hardware. This function prevents\n    exposure of the PMT while travelling.\n\n    Args:\n        enable: Whether to turn the PMT protection routines on or off.\n    \"\"\"\n    self._send(\"enable_pmt_protection_mode\", enable)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.enable_standard_file","title":"enable_standard_file","text":"<pre><code>enable_standard_file(\n    meas_type: Literal[0, 1, 2], *, enable: bool\n) -&gt; None\n</code></pre> <p>Function enables standard files to be used.</p> <p>To open a calibration file used to create a measurement, use enable_calibration_file instead.</p> <p>The user should call load_standard_file first to load the standard file before enabling it.</p> <p>Parameters:</p> Name Type Description Default <code>meas_type</code> <code>Literal[0, 1, 2]</code> <p>The calibration measurement type.</p> <ul> <li><code>0</code> \u2014 Irradiance</li> <li><code>1</code> \u2014 Radiance</li> <li><code>2</code> \u2014 Transmittance</li> </ul> required <code>enable</code> <code>bool</code> <p>Whether to turn the application of the standard file on or off.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def enable_standard_file(self, meas_type: Literal[0, 1, 2], *, enable: bool) -&gt; None:\n    \"\"\"Function enables standard files to be used.\n\n    To open a calibration file used to create a measurement, use\n    [enable_calibration_file][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.enable_calibration_file]\n    instead.\n\n    The user should call\n    [load_standard_file][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.load_standard_file]\n    first to load the standard file before enabling it.\n\n    Args:\n        meas_type: The calibration measurement type.\n\n            * `0` &amp;mdash; Irradiance\n            * `1` &amp;mdash; Radiance\n            * `2` &amp;mdash; Transmittance\n\n        enable: Whether to turn the application of the standard file on or off.\n    \"\"\"\n    self._send(\"enable_standard_file\", meas_type, enable)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.export_config_file","title":"export_config_file","text":"<pre><code>export_config_file(file_path: PathLike) -&gt; None\n</code></pre> <p>Exports the config file into a OL756 compatible configuration file.</p> <p>Not all settings used will be applicable.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>PathLike</code> <p>A valid path to save the file at.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def export_config_file(self, file_path: PathLike) -&gt; None:\n    \"\"\"Exports the config file into a OL756 compatible configuration file.\n\n    Not all settings used will be applicable.\n\n    Args:\n        file_path: A valid path to save the file at.\n    \"\"\"\n    self._send(\"export_config_file\", os.fsdecode(file_path))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.export_registry","title":"export_registry","text":"<pre><code>export_registry() -&gt; None\n</code></pre> <p>Save data out to the Windows registry.</p> <p>Make sure that a read was done at some point using import_registry. Does not create a configuration file that can be loaded into another computer. For that particular function, call export_config_file.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def export_registry(self) -&gt; None:\n    \"\"\"Save data out to the Windows registry.\n\n    Make sure that a read was done at some point using\n    [import_registry][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.import_registry].\n    Does not create a configuration file that can be loaded into another computer. For that particular function,\n    call [export_config_file][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.export_config_file].\n    \"\"\"\n    self._send(\"export_registry\")\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_adaptive_int_time_index","title":"get_adaptive_int_time_index","text":"<pre><code>get_adaptive_int_time_index(gain_index: int) -&gt; int\n</code></pre> <p>Get the adaptive integration time index.</p> <p>Parameters:</p> Name Type Description Default <code>gain_index</code> <code>int</code> <p>The index of the gain to use to get the integration time.</p> <ul> <li><code>0</code> \u2014 1.0E-5</li> <li><code>1</code> \u2014 1.0E-6</li> <li><code>2</code> \u2014 1.0E-7</li> <li><code>3</code> \u2014 1.0E-8</li> <li><code>4</code> \u2014 1.0E-9</li> <li><code>5</code> \u2014 1.0E-10</li> <li><code>6</code> \u2014 1.0E-11</li> </ul> required <p>Returns:</p> Type Description <code>int</code> <p>The adaptive integration time index.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_adaptive_int_time_index(self, gain_index: int) -&gt; int:\n    \"\"\"Get the adaptive integration time index.\n\n    Args:\n        gain_index: The index of the gain to use to get the integration time.\n\n            * `0` &amp;mdash; 1.0E-5\n            * `1` &amp;mdash; 1.0E-6\n            * `2` &amp;mdash; 1.0E-7\n            * `3` &amp;mdash; 1.0E-8\n            * `4` &amp;mdash; 1.0E-9\n            * `5` &amp;mdash; 1.0E-10\n            * `6` &amp;mdash; 1.0E-11\n\n    Returns:\n        The adaptive integration time index.\n    \"\"\"\n    index = int(self._send(\"get_adaptive_int_time_index\", gain_index))\n    if index == -1:\n        msg = f\"Invalid gain index, {gain_index}\"\n        raise MSLConnectionError(self, msg)\n    return index\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_cal_array","title":"get_cal_array","text":"<pre><code>get_cal_array() -&gt; NDArray[int32]\n</code></pre> <p>This method allows user to get the spectral data of a calibration after it is made.</p> <p>Returns:</p> Type Description <code>NDArray[int32]</code> <p>The calibrated spectral data.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_cal_array(self) -&gt; NDArray[np.int32]:\n    \"\"\"This method allows user to get the spectral data of a calibration after it is made.\n\n    Returns:\n        The calibrated spectral data.\n    \"\"\"\n    return np.array(self._send(\"get_cal_array\"))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_cal_file_enabled","title":"get_cal_file_enabled","text":"<pre><code>get_cal_file_enabled(meas_type: Literal[3, 4, 5]) -&gt; bool\n</code></pre> <p>Checks to see if the calibration file is enabled.</p> <p>The user should call load_calibration_file first to load the calibration file before enabling it.</p> <p>Parameters:</p> Name Type Description Default <code>meas_type</code> <code>Literal[3, 4, 5]</code> <p>The measurement type.</p> <ul> <li><code>3</code> \u2014 Irradiance Calibration</li> <li><code>4</code> \u2014 Radiance Calibration</li> <li><code>5</code> \u2014 Transmittance Calibration</li> </ul> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the calibration file is enabled.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_cal_file_enabled(self, meas_type: Literal[3, 4, 5]) -&gt; bool:\n    \"\"\"Checks to see if the calibration file is enabled.\n\n    The user should call\n    [load_calibration_file][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.load_calibration_file]\n    first to load the calibration file before enabling it.\n\n    Args:\n        meas_type: The measurement type.\n\n            * `3` &amp;mdash; Irradiance Calibration\n            * `4` &amp;mdash; Radiance Calibration\n            * `5` &amp;mdash; Transmittance Calibration\n\n    Returns:\n        Whether the calibration file is enabled.\n    \"\"\"\n    return bool(self._send(\"get_cal_file_enabled\", meas_type))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_calculated_data","title":"get_calculated_data","text":"<pre><code>get_calculated_data(\n    meas_type: Literal[0, 1, 2, 3, 4, 5], index: int\n) -&gt; float\n</code></pre> <p>Get data calculated from the intensities.</p> <p>The user should call do_calculations at least once before calling this function.</p> <p>Parameters:</p> Name Type Description Default <code>meas_type</code> <code>Literal[0, 1, 2, 3, 4, 5]</code> <p>The measurement type.</p> <ul> <li><code>0</code> \u2014 Irradiance</li> <li><code>1</code> \u2014 Radiance</li> <li><code>2</code> \u2014 Transmittance</li> <li><code>3</code> \u2014 Irradiance Calibration</li> <li><code>4</code> \u2014 Radiance Calibration</li> <li><code>5</code> \u2014 Transmittance Calibration</li> </ul> required <code>index</code> <code>int</code> <p>The index to retrieve data of.</p> <ul> <li><code>0</code> \u2014 Color Temperature</li> <li><code>1</code> \u2014 Dominant Wavelength</li> <li><code>2</code> \u2014 LED Half Bandwidth</li> <li><code>3</code> \u2014 Left Half Bandwidth</li> <li><code>4</code> \u2014 Right Half Bandwidth</li> <li><code>5</code> \u2014 Peak Spectral Value</li> <li><code>6</code> \u2014 LEDPeakWavelength</li> <li><code>7</code> \u2014 Radiometric Value</li> <li><code>8</code> \u2014 Purity</li> <li><code>9</code> \u2014 Center Wavelength</li> <li><code>10</code> \u2014 Photometric Value</li> </ul> required <p>Returns:</p> Type Description <code>float</code> <p>The calculated data.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_calculated_data(self, meas_type: Literal[0, 1, 2, 3, 4, 5], index: int) -&gt; float:\n    \"\"\"Get data calculated from the intensities.\n\n    The user should call\n    [do_calculations][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.do_calculations]\n    at least once before calling this function.\n\n    Args:\n        meas_type: The measurement type.\n\n            * `0` &amp;mdash; Irradiance\n            * `1` &amp;mdash; Radiance\n            * `2` &amp;mdash; Transmittance\n            * `3` &amp;mdash; Irradiance Calibration\n            * `4` &amp;mdash; Radiance Calibration\n            * `5` &amp;mdash; Transmittance Calibration\n\n        index: The index to retrieve data of.\n\n            * `0` &amp;mdash; Color Temperature\n            * `1` &amp;mdash; Dominant Wavelength\n            * `2` &amp;mdash; LED Half Bandwidth\n            * `3` &amp;mdash; Left Half Bandwidth\n            * `4` &amp;mdash; Right Half Bandwidth\n            * `5` &amp;mdash; Peak Spectral Value\n            * `6` &amp;mdash; LEDPeakWavelength\n            * `7` &amp;mdash; Radiometric Value\n            * `8` &amp;mdash; Purity\n            * `9` &amp;mdash; Center Wavelength\n            * `10` &amp;mdash; Photometric Value\n\n    Returns:\n        The calculated data.\n    \"\"\"\n    return float(self._send(\"get_calculated_data\", meas_type, index))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_calibration_file","title":"get_calibration_file","text":"<pre><code>get_calibration_file(meas_type: Literal[0, 1, 2]) -&gt; str\n</code></pre> <p>Get a calibration file that is loaded.</p> <p>Parameters:</p> Name Type Description Default <code>meas_type</code> <code>Literal[0, 1, 2]</code> <p>The measurement type.</p> <ul> <li><code>0</code> \u2014 Irradiance</li> <li><code>1</code> \u2014 Radiance</li> <li><code>2</code> \u2014 Transmittance</li> </ul> required <p>Returns:</p> Type Description <code>str</code> <p>String containing the name and path of the calibration file that is loaded for a particular measurement type.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_calibration_file(self, meas_type: Literal[0, 1, 2]) -&gt; str:\n    \"\"\"Get a calibration file that is loaded.\n\n    Args:\n        meas_type: The measurement type.\n\n            * `0` &amp;mdash; Irradiance\n            * `1` &amp;mdash; Radiance\n            * `2` &amp;mdash; Transmittance\n\n    Returns:\n        String containing the name and path of the calibration file\n            that is loaded for a particular measurement type.\n    \"\"\"\n    return str(self._send(\"get_calibration_file\", meas_type))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_chromaticity_data","title":"get_chromaticity_data","text":"<pre><code>get_chromaticity_data(\n    meas_type: Literal[0, 1, 2, 3, 4, 5], index: int\n) -&gt; float\n</code></pre> <p>Get the calculated chromaticity values requested.</p> <p>Must have called do_calculations at least once.</p> <p>Parameters:</p> Name Type Description Default <code>meas_type</code> <code>Literal[0, 1, 2, 3, 4, 5]</code> <p>The measurement type.</p> <ul> <li><code>0</code> \u2014 Irradiance</li> <li><code>1</code> \u2014 Radiance</li> <li><code>2</code> \u2014 Transmittance</li> <li><code>3</code> \u2014 Irradiance Calibration</li> <li><code>4</code> \u2014 Radiance Calibration</li> <li><code>5</code> \u2014 Transmittance Calibration</li> </ul> required <code>index</code> <code>int</code> <p>The chromaticity index value [0..70]. See the SDK manual for more details.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The chromaticity data.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_chromaticity_data(self, meas_type: Literal[0, 1, 2, 3, 4, 5], index: int) -&gt; float:\n    \"\"\"Get the calculated chromaticity values requested.\n\n    Must have called [do_calculations][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.do_calculations]\n    at least once.\n\n    Args:\n        meas_type: The measurement type.\n\n            * `0` &amp;mdash; Irradiance\n            * `1` &amp;mdash; Radiance\n            * `2` &amp;mdash; Transmittance\n            * `3` &amp;mdash; Irradiance Calibration\n            * `4` &amp;mdash; Radiance Calibration\n            * `5` &amp;mdash; Transmittance Calibration\n\n        index: The chromaticity index value [0..70]. See the SDK manual for more details.\n\n    Returns:\n        The chromaticity data.\n    \"\"\"\n    return float(self._send(\"get_chromaticity_data\", meas_type, index))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_cri","title":"get_cri","text":"<pre><code>get_cri(\n    meas_type: Literal[0, 1, 2, 3, 4, 5], index: int\n) -&gt; float\n</code></pre> <p>Get the color-rendering information.</p> <p>The user should call do_calculations at least once before calling this function.</p> <p>Parameters:</p> Name Type Description Default <code>meas_type</code> <code>Literal[0, 1, 2, 3, 4, 5]</code> <p>The measurement type.</p> <ul> <li><code>0</code> \u2014 Irradiance</li> <li><code>1</code> \u2014 Radiance</li> <li><code>2</code> \u2014 Transmittance</li> <li><code>3</code> \u2014 Irradiance Calibration</li> <li><code>4</code> \u2014 Radiance Calibration</li> <li><code>5</code> \u2014 Transmittance Calibration</li> </ul> required <code>index</code> <code>int</code> <p>The color-rendering index.</p> <ul> <li><code>0</code> \u2014 General CRI</li> <li><code>1</code> \u2014 Light Greyish Red (CRI#1)</li> <li><code>2</code> \u2014 Dark Greyish Yellow (CRI#2)</li> <li><code>3</code> \u2014 Strong Yellow Green (CRI#3)</li> <li><code>4</code> \u2014 Moderate Yellowish Green (CRI#4)</li> <li><code>5</code> \u2014 Light Bluish Green (CRI#5)</li> <li><code>6</code> \u2014 Light Blue (CRI#6)</li> <li><code>7</code> \u2014 Light Violet (CRI#7)</li> <li><code>8</code> \u2014 Light Reddish Purple (CRI#8)</li> <li><code>9</code> \u2014 Strong Red (CRI#9)</li> <li><code>10</code> \u2014 Strong Yellow (CRI#10)</li> <li><code>11</code> \u2014 Strong Green (CRI#11)</li> <li><code>12</code> \u2014 Strong Blue (CRI#12)</li> <li><code>13</code> \u2014 Light Yellowish Pink (CRI#13)</li> <li><code>14</code> \u2014 Moderate Olive Green (CRI#14)</li> </ul> required <p>Returns:</p> Type Description <code>float</code> <p>The color-rendering information.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_cri(self, meas_type: Literal[0, 1, 2, 3, 4, 5], index: int) -&gt; float:\n    \"\"\"Get the color-rendering information.\n\n    The user should call\n    [do_calculations][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.do_calculations]\n    at least once before calling this function.\n\n    Args:\n        meas_type: The measurement type.\n\n            * `0` &amp;mdash; Irradiance\n            * `1` &amp;mdash; Radiance\n            * `2` &amp;mdash; Transmittance\n            * `3` &amp;mdash; Irradiance Calibration\n            * `4` &amp;mdash; Radiance Calibration\n            * `5` &amp;mdash; Transmittance Calibration\n\n        index: The color-rendering index.\n\n            * `0` &amp;mdash; General CRI\n            * `1` &amp;mdash; Light Greyish Red (CRI#1)\n            * `2` &amp;mdash; Dark Greyish Yellow (CRI#2)\n            * `3` &amp;mdash; Strong Yellow Green (CRI#3)\n            * `4` &amp;mdash; Moderate Yellowish Green (CRI#4)\n            * `5` &amp;mdash; Light Bluish Green (CRI#5)\n            * `6` &amp;mdash; Light Blue (CRI#6)\n            * `7` &amp;mdash; Light Violet (CRI#7)\n            * `8` &amp;mdash; Light Reddish Purple (CRI#8)\n            * `9` &amp;mdash; Strong Red (CRI#9)\n            * `10` &amp;mdash; Strong Yellow (CRI#10)\n            * `11` &amp;mdash; Strong Green (CRI#11)\n            * `12` &amp;mdash; Strong Blue (CRI#12)\n            * `13` &amp;mdash; Light Yellowish Pink (CRI#13)\n            * `14` &amp;mdash; Moderate Olive Green (CRI#14)\n\n    Returns:\n        The color-rendering information.\n    \"\"\"\n    return float(self._send(\"get_cri\", meas_type, index))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_dark_current","title":"get_dark_current","text":"<pre><code>get_dark_current(use_compensation: int) -&gt; float\n</code></pre> <p>Takes a manual dark current.</p> <p>User will have to subtract from data array by retrieving this array via a get_cal_array or get_signal_array. This is a special function and most users will want to use enable_dark_current instead because it automatically does the subtraction.</p> <p>Function if called externally by user program will not have result saved out to data file. If the enable_dark_current was enabled, then this function need should not be called.</p> <p>Parameters:</p> Name Type Description Default <code>use_compensation</code> <code>int</code> <p>Adjusts dark current for more dynamic ranging using reverse current.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The dark current.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_dark_current(self, use_compensation: int) -&gt; float:\n    \"\"\"Takes a manual dark current.\n\n    User will have to subtract from data array by retrieving this array via\n    a [get_cal_array][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_cal_array] or\n    [get_signal_array][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_signal_array].\n    This is a special function and most users will want to use\n    [enable_dark_current][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.enable_dark_current]\n    instead because it automatically does the subtraction.\n\n    Function if called externally by user program will not have result\n    saved out to data file. If the\n    [enable_dark_current][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.enable_dark_current]\n    was enabled, then this function need should not be called.\n\n    Args:\n        use_compensation: Adjusts dark current for more dynamic ranging using reverse current.\n\n    Returns:\n        The dark current.\n    \"\"\"\n    return float(self._send(\"get_dark_current\", use_compensation))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_dark_current_enable","title":"get_dark_current_enable","text":"<pre><code>get_dark_current_enable() -&gt; bool\n</code></pre> <p>Returns whether the dark-current mode is enabled.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the dark-current mode is enabled or disabled.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_dark_current_enable(self) -&gt; bool:\n    \"\"\"Returns whether the dark-current mode is enabled.\n\n    Returns:\n        Whether the dark-current mode is enabled or disabled.\n    \"\"\"\n    return bool(self._send(\"get_dark_current_enable\"))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_dark_current_mode","title":"get_dark_current_mode","text":"<pre><code>get_dark_current_mode() -&gt; int\n</code></pre> <p>Returns whether the dark current is taken at a wavelength or in shutter mode.</p> <p>Returns:</p> Type Description <code>int</code> <p>The dark-current mode.</p> <ul> <li><code>0</code> \u2014 Dark current in wavelength mode (taken at a particular wavelength designated by the user).</li> <li><code>1</code> \u2014 Dark current in shutter mode</li> </ul> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_dark_current_mode(self) -&gt; int:\n    \"\"\"Returns whether the dark current is taken at a wavelength or in shutter mode.\n\n    Returns:\n        The dark-current mode.\n\n            * `0` &amp;mdash; Dark current in wavelength mode (taken at a particular wavelength designated by the user).\n            * `1` &amp;mdash; Dark current in shutter mode\n\n    \"\"\"\n    return int(self._send(\"get_dark_current_mode\"))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_dark_current_wavelength","title":"get_dark_current_wavelength","text":"<pre><code>get_dark_current_wavelength() -&gt; float\n</code></pre> <p>Get the dark current wavelength.</p> <p>Returns:</p> Type Description <code>float</code> <p>Wavelength that the dark current will be taken at.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_dark_current_wavelength(self) -&gt; float:\n    \"\"\"Get the dark current wavelength.\n\n    Returns:\n        Wavelength that the dark current will be taken at.\n    \"\"\"\n    return float(self._send(\"get_dark_current_wavelength\"))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_ending_wavelength","title":"get_ending_wavelength","text":"<pre><code>get_ending_wavelength() -&gt; float\n</code></pre> <p>Get the ending wavelength of the scan range.</p> <p>Returns:</p> Type Description <code>float</code> <p>The ending wavelength, in nm, of the scan range.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_ending_wavelength(self) -&gt; float:\n    \"\"\"Get the ending wavelength of the scan range.\n\n    Returns:\n        The ending wavelength, in nm, of the scan range.\n    \"\"\"\n    return float(self._send(\"get_ending_wavelength\"))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_gain_index","title":"get_gain_index","text":"<pre><code>get_gain_index() -&gt; int\n</code></pre> <p>Get the index of the gain that will be applied when the parameters are to be sent down.</p> <p>Applies to both quick scan and point to point scans.</p> <p>Returns:</p> Type Description <code>int</code> <p>The gain index.</p> <ul> <li><code>0</code> \u2014 1.0E-5</li> <li><code>1</code> \u2014 1.0E-6</li> <li><code>2</code> \u2014 1.0E-7</li> <li><code>3</code> \u2014 1.0E-8</li> <li><code>4</code> \u2014 1.0E-9</li> <li><code>5</code> \u2014 1.0E-10 (Point to Point mode only)</li> <li><code>6</code> \u2014 1.0E-11 (Point to Point mode only)</li> <li><code>7</code> \u2014 Auto Gain Ranging (Point to Point mode only)</li> </ul> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_gain_index(self) -&gt; int:\n    \"\"\"Get the index of the gain that will be applied when the parameters are to be sent down.\n\n    Applies to both quick scan and point to point scans.\n\n    Returns:\n        The gain index.\n\n            * `0` &amp;mdash; 1.0E-5\n            * `1` &amp;mdash; 1.0E-6\n            * `2` &amp;mdash; 1.0E-7\n            * `3` &amp;mdash; 1.0E-8\n            * `4` &amp;mdash; 1.0E-9\n            * `5` &amp;mdash; 1.0E-10 (Point to Point mode only)\n            * `6` &amp;mdash; 1.0E-11 (Point to Point mode only)\n            * `7` &amp;mdash; Auto Gain Ranging (Point to Point mode only)\n\n    \"\"\"\n    return int(self._send(\"get_gain_index\"))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_increment","title":"get_increment","text":"<pre><code>get_increment() -&gt; float\n</code></pre> <p>Get the wavelength increment that is used for a scan.</p> <p>Returns:</p> Type Description <code>float</code> <p>The wavelength increment, in nm.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_increment(self) -&gt; float:\n    \"\"\"Get the wavelength increment that is used for a scan.\n\n    Returns:\n        The wavelength increment, in nm.\n    \"\"\"\n    return float(self._send(\"get_increment\"))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_increment_index","title":"get_increment_index","text":"<pre><code>get_increment_index() -&gt; int\n</code></pre> <p>Get the index of the wavelength increment that is used for a scan.</p> <p>Applies to both quick scan and point to point scans.</p> <p>Returns:</p> Type Description <code>int</code> <p>Index of the wavelength increment of a scan.</p> <ul> <li><code>0</code> \u2014 0.025 nm</li> <li><code>1</code> \u2014 0.05 nm</li> <li><code>2</code> \u2014 0.1 nm</li> <li><code>3</code> \u2014 0.2 nm</li> <li><code>4</code> \u2014 0.5 nm</li> <li><code>5</code> \u2014 1.0 nm</li> <li><code>6</code> \u2014 2.0 nm</li> <li><code>7</code> \u2014 5.0 nm</li> <li><code>8</code> \u2014 10.0 nm</li> </ul> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_increment_index(self) -&gt; int:\n    \"\"\"Get the index of the wavelength increment that is used for a scan.\n\n    Applies to both quick scan and point to point scans.\n\n    Returns:\n        Index of the wavelength increment of a scan.\n\n            * `0` &amp;mdash; 0.025 nm\n            * `1` &amp;mdash; 0.05 nm\n            * `2` &amp;mdash; 0.1 nm\n            * `3` &amp;mdash; 0.2 nm\n            * `4` &amp;mdash; 0.5 nm\n            * `5` &amp;mdash; 1.0 nm\n            * `6` &amp;mdash; 2.0 nm\n            * `7` &amp;mdash; 5.0 nm\n            * `8` &amp;mdash; 10.0 nm\n\n    \"\"\"\n    return int(self._send(\"get_increment_index\"))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_integration_time_index","title":"get_integration_time_index","text":"<pre><code>get_integration_time_index(scan_mode: Literal[0, 1]) -&gt; int\n</code></pre> <p>Get the index into the integration time array.</p> <p>Applies to both quick scan and point to point scans. In quick scan, the speed will vary based on the scan range and increments.</p> <p>Parameters:</p> Name Type Description Default <code>scan_mode</code> <code>Literal[0, 1]</code> <p>The scan mode to use to get the index of. Point to Point mode (0) or Quick Scan mode (1).</p> required <p>Returns:</p> Type Description <code>int</code> <p>Point to Point mode</p> <ul> <li><code>0</code> \u2014 1.000 sec</li> <li><code>1</code> \u2014 0.500 sec</li> <li><code>2</code> \u2014 0.200 sec</li> <li><code>3</code> \u2014 0.100 sec</li> <li><code>4</code> \u2014 0.050 sec</li> <li><code>5</code> \u2014 0.020 sec</li> <li><code>6</code> \u2014 0.010 sec</li> <li><code>7</code> \u2014 0.005 sec</li> <li><code>8</code> \u2014 0.002 sec</li> <li><code>9</code> \u2014 0.001 sec</li> <li><code>10</code> \u2014 Adaptive (Point To Point mode only)</li> </ul> <p>Quick Scan mode</p> <pre><code>* `0` &amp;mdash; slowest\n* `10` &amp;mdash; fastest\n</code></pre> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_integration_time_index(self, scan_mode: Literal[0, 1]) -&gt; int:\n    \"\"\"Get the index into the integration time array.\n\n    Applies to both quick scan and point to point scans. In quick scan,\n    the speed will vary based on the scan range and increments.\n\n    Args:\n        scan_mode: The scan mode to use to get the index of.\n            Point to Point mode (0) or Quick Scan mode (1).\n\n    Returns:\n        Point to Point mode\n\n            * `0` &amp;mdash; 1.000 sec\n            * `1` &amp;mdash; 0.500 sec\n            * `2` &amp;mdash; 0.200 sec\n            * `3` &amp;mdash; 0.100 sec\n            * `4` &amp;mdash; 0.050 sec\n            * `5` &amp;mdash; 0.020 sec\n            * `6` &amp;mdash; 0.010 sec\n            * `7` &amp;mdash; 0.005 sec\n            * `8` &amp;mdash; 0.002 sec\n            * `9` &amp;mdash; 0.001 sec\n            * `10` &amp;mdash; Adaptive\t(Point To Point mode only)\n\n            Quick Scan mode\n\n                * `0` &amp;mdash; slowest\n                * `10` &amp;mdash; fastest\n\n    \"\"\"\n    return int(self._send(\"get_integration_time_index\", scan_mode))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_ocx_version","title":"get_ocx_version","text":"<pre><code>get_ocx_version() -&gt; str\n</code></pre> <p>Get the version of the OL756 SDK ActiveX control.</p> <p>Returns:</p> Type Description <code>str</code> <p>The software version.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_ocx_version(self) -&gt; str:\n    \"\"\"Get the version of the OL756 SDK ActiveX control.\n\n    Returns:\n        The software version.\n    \"\"\"\n    return str(self._send(\"get_ocx_version\"))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_pmt_flux_overload","title":"get_pmt_flux_overload","text":"<pre><code>get_pmt_flux_overload() -&gt; float\n</code></pre> <p>Get the voltage of the photomultiplier tube flux overload.</p> <p>Returns:</p> Type Description <code>float</code> <p>Voltage that the PMT will determine to be at the overload point.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_pmt_flux_overload(self) -&gt; float:\n    \"\"\"Get the voltage of the photomultiplier tube flux overload.\n\n    Returns:\n        Voltage that the PMT will determine to be at the overload point.\n    \"\"\"\n    return float(self._send(\"get_pmt_flux_overload\"))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_pmt_voltage","title":"get_pmt_voltage","text":"<pre><code>get_pmt_voltage() -&gt; float\n</code></pre> <p>Returns the voltage that will sent or has been sent down to the PMT.</p> <p>Returns:</p> Type Description <code>float</code> <p>Voltage value, in volts, of the photomultiplier tube.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_pmt_voltage(self) -&gt; float:\n    \"\"\"Returns the voltage that will sent or has been sent down to the PMT.\n\n    Returns:\n        Voltage value, in volts, of the photomultiplier tube.\n    \"\"\"\n    return float(self._send(\"get_pmt_voltage\"))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_quick_scan_rate","title":"get_quick_scan_rate","text":"<pre><code>get_quick_scan_rate() -&gt; float\n</code></pre> <p>Returns the rate at the quick scan index.</p> <p>Returns:</p> Type Description <code>float</code> <p>Rate of the quick scan at the current index in nm/s.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_quick_scan_rate(self) -&gt; float:\n    \"\"\"Returns the rate at the quick scan index.\n\n    Returns:\n        Rate of the quick scan at the current index in nm/s.\n    \"\"\"\n    return float(self._send(\"get_quick_scan_rate\"))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_quick_scan_rate_index","title":"get_quick_scan_rate_index","text":"<pre><code>get_quick_scan_rate_index() -&gt; int\n</code></pre> <p>Returns the index of the quick scan rate.</p> <p>Returns:</p> Type Description <code>int</code> <p>Index of the quick scan rate.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_quick_scan_rate_index(self) -&gt; int:\n    \"\"\"Returns the index of the quick scan rate.\n\n    Returns:\n        Index of the quick scan rate.\n    \"\"\"\n    return int(self._send(\"get_quick_scan_rate_index\"))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_scan_mode","title":"get_scan_mode","text":"<pre><code>get_scan_mode() -&gt; int\n</code></pre> <p>Get the mode the scan will be done in.</p> <p>Returns:</p> Type Description <code>int</code> <p>The scan mode.</p> <ul> <li><code>0</code> \u2014 Point to Point mode</li> <li><code>1</code> \u2014 Quick Scan mode</li> </ul> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_scan_mode(self) -&gt; int:\n    \"\"\"Get the mode the scan will be done in.\n\n    Returns:\n        The scan mode.\n\n            * `0` &amp;mdash; Point to Point mode\n            * `1` &amp;mdash; Quick Scan mode\n\n    \"\"\"\n    return int(self._send(\"get_scan_mode\"))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_settling_time","title":"get_settling_time","text":"<pre><code>get_settling_time() -&gt; float\n</code></pre> <p>Get the settling time.</p> <p>Settling time is time where the wavelength drive pauses once it reaches its target wavelength.</p> <p>Returns:</p> Type Description <code>float</code> <p>Settling time, in seconds, to be sent down or has already been sent to the system.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_settling_time(self) -&gt; float:\n    \"\"\"Get the settling time.\n\n    Settling time is time where the wavelength drive pauses once it reaches its target wavelength.\n\n    Returns:\n        Settling time, in seconds, to be sent down or has already been sent to the system.\n    \"\"\"\n    return float(self._send(\"get_settling_time\"))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_signal_array","title":"get_signal_array","text":"<pre><code>get_signal_array() -&gt; NDArray[int32]\n</code></pre> <p>Get the spectral data of a measurement after it is made.</p> <p>Returns:</p> Type Description <code>NDArray[int32]</code> <p>The spectral data.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_signal_array(self) -&gt; NDArray[np.int32]:\n    \"\"\"Get the spectral data of a measurement after it is made.\n\n    Returns:\n        The spectral data.\n    \"\"\"\n    return np.array(self._send(\"get_signal_array\"))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_standard_file","title":"get_standard_file","text":"<pre><code>get_standard_file(meas_type: Literal[3, 4, 5]) -&gt; str\n</code></pre> <p>Retrieves the name of standard file.</p> <p>Parameters:</p> Name Type Description Default <code>meas_type</code> <code>Literal[3, 4, 5]</code> <p>The calibration measurement type.</p> <ul> <li><code>3</code> \u2014 Irradiance calibration</li> <li><code>4</code> \u2014 Radiance calibration</li> <li><code>5</code> \u2014 Transmittance calibration</li> </ul> required <p>Returns:</p> Type Description <code>str</code> <p>String containing the name and path of the standard file that is loaded for a particular calibration type.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_standard_file(self, meas_type: Literal[3, 4, 5]) -&gt; str:\n    \"\"\"Retrieves the name of standard file.\n\n    Args:\n        meas_type: The calibration measurement type.\n\n            * `3` &amp;mdash; Irradiance calibration\n            * `4` &amp;mdash; Radiance calibration\n            * `5` &amp;mdash; Transmittance calibration\n\n    Returns:\n        String containing the name and path of the standard file that is\n            loaded for a particular calibration type.\n    \"\"\"\n    return str(self._send(\"get_standard_file\", meas_type))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_start_wavelength","title":"get_start_wavelength","text":"<pre><code>get_start_wavelength() -&gt; float\n</code></pre> <p>Get the starting wavelength of a scan.</p> <p>Applies to both quick scan and point to point scans.</p> <p>Returns:</p> Type Description <code>float</code> <p>The wavelength, in nm, that the scan will start from.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_start_wavelength(self) -&gt; float:\n    \"\"\"Get the starting wavelength of a scan.\n\n    Applies to both quick scan and point to point scans.\n\n    Returns:\n        The wavelength, in nm, that the scan will start from.\n    \"\"\"\n    return float(self._send(\"get_start_wavelength\"))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_std_file_enabled","title":"get_std_file_enabled","text":"<pre><code>get_std_file_enabled(meas_type: Literal[0, 1, 2]) -&gt; bool\n</code></pre> <p>Checks to see if the standard file is enabled.</p> <p>The user should call load_standard_file first to load the standard file before enabling it.</p> <p>Parameters:</p> Name Type Description Default <code>meas_type</code> <code>Literal[0, 1, 2]</code> <p>The measurement type.</p> <ul> <li><code>0</code> \u2014 Irradiance</li> <li><code>1</code> \u2014 Radiance</li> <li><code>2</code> \u2014 Transmittance</li> </ul> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether a standard file is enabled.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def get_std_file_enabled(self, meas_type: Literal[0, 1, 2]) -&gt; bool:\n    \"\"\"Checks to see if the standard file is enabled.\n\n    The user should call\n    [load_standard_file][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.load_standard_file]\n    first to load the standard file before enabling it.\n\n    Args:\n        meas_type: The measurement type.\n\n            * `0` &amp;mdash; Irradiance\n            * `1` &amp;mdash; Radiance\n            * `2` &amp;mdash; Transmittance\n\n    Returns:\n        Whether a standard file is enabled.\n    \"\"\"\n    return bool(self._send(\"get_std_file_enabled\", meas_type))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.import_config_file","title":"import_config_file","text":"<pre><code>import_config_file(path: PathLike) -&gt; None\n</code></pre> <p>The file is a standard OL756 configuration file.</p> <p>Not all settings used will be applicable. Measurement type is not used because in the SDK, the take_point_to_point_measurement function has as an input the measurement type. The user should select the type and not have it based on the configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>PathLike</code> <p>A valid path to load the file at.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def import_config_file(self, path: PathLike) -&gt; None:\n    \"\"\"The file is a standard OL756 configuration file.\n\n    Not all settings used will be applicable. Measurement type is not used\n    because in the SDK, the\n    [take_point_to_point_measurement][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.take_point_to_point_measurement]\n    function has as an input the measurement type. The user should select\n    the type and not have it based on the configuration file.\n\n    Args:\n        path: A valid path to load the file at.\n    \"\"\"\n    self._send(\"import_config_file\", os.fsdecode(path))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.import_registry","title":"import_registry","text":"<pre><code>import_registry() -&gt; None\n</code></pre> <p>Loads data from the registry.</p> <p>Loads default if no registry exists. To import the configuration from another computer, use import_config_file instead.</p> <p>Not all settings used will be applicable. Measurement type is not used because in the SDK, the take_point_to_point_measurement function has as an input the measurement type. The user should select the type and not have it based on the configuration file.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def import_registry(self) -&gt; None:\n    \"\"\"Loads data from the registry.\n\n    Loads default if no registry exists. To import the configuration\n    from another computer, use\n    [import_config_file][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.import_config_file]\n    instead.\n\n    Not all settings used will be applicable. Measurement type is not\n    used because in the SDK, the\n    [take_point_to_point_measurement][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.take_point_to_point_measurement]\n    function has as an input the measurement type. The user should\n    select the type and not have it based on the configuration file.\n    \"\"\"\n    self._send(\"import_registry\")\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.load_calibration_file","title":"load_calibration_file","text":"<pre><code>load_calibration_file(\n    path: PathLike, meas_type: Literal[3, 4, 5]\n) -&gt; None\n</code></pre> <p>Load a calibration file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>PathLike</code> <p>The path of a calibration file.</p> required <code>meas_type</code> <code>Literal[3, 4, 5]</code> <p>The calibration measurement type.</p> <ul> <li><code>3</code> \u2014 Irradiance calibration</li> <li><code>4</code> \u2014 Radiance calibration</li> <li><code>5</code> \u2014 Transmittance calibration</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def load_calibration_file(self, path: PathLike, meas_type: Literal[3, 4, 5]) -&gt; None:\n    \"\"\"Load a calibration file.\n\n    Args:\n        path: The path of a calibration file.\n        meas_type: The calibration measurement type.\n\n            * `3` &amp;mdash; Irradiance calibration\n            * `4` &amp;mdash; Radiance calibration\n            * `5` &amp;mdash; Transmittance calibration\n\n    \"\"\"\n    self._send(\"load_calibration_file\", os.fsdecode(path), meas_type)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.load_standard_file","title":"load_standard_file","text":"<pre><code>load_standard_file(\n    path: PathLike, meas_type: Literal[0, 1, 2]\n) -&gt; None\n</code></pre> <p>Load a standard file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>PathLike</code> <p>The path of a standard file.</p> required <code>meas_type</code> <code>Literal[0, 1, 2]</code> <p>The measurement type.</p> <ul> <li><code>0</code> \u2014 Irradiance</li> <li><code>1</code> \u2014 Radiance</li> <li><code>2</code> \u2014 Transmittance</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def load_standard_file(self, path: PathLike, meas_type: Literal[0, 1, 2]) -&gt; None:\n    \"\"\"Load a standard file.\n\n    Args:\n        path: The path of a standard file.\n        meas_type: The measurement type.\n\n            * `0` &amp;mdash; Irradiance\n            * `1` &amp;mdash; Radiance\n            * `2` &amp;mdash; Transmittance\n\n    \"\"\"\n    self._send(\"load_standard_file\", os.fsdecode(path), meas_type)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.manual_filter_drive_connect","title":"manual_filter_drive_connect","text":"<pre><code>manual_filter_drive_connect(*, connect: bool) -&gt; None\n</code></pre> <p>Used to connect or disconnect the filter drive.</p> <p>Disconnecting essentially acquires scans without the filter.</p> <p>Parameters:</p> Name Type Description Default <code>connect</code> <code>bool</code> <p>Connect or disconnect the filter drive. Reconnecting will home the wavelength and filter drive.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def manual_filter_drive_connect(self, *, connect: bool) -&gt; None:\n    \"\"\"Used to connect or disconnect the filter drive.\n\n    Disconnecting essentially acquires scans without the filter.\n\n    Args:\n        connect: Connect or disconnect the filter drive. Reconnecting will\n            home the wavelength and filter drive.\n    \"\"\"\n    self._send(\"manual_filter_drive_connect\", connect)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.manual_get_gain","title":"manual_get_gain","text":"<pre><code>manual_get_gain() -&gt; int\n</code></pre> <p>The index of the gain that will be applied when the parameters are to be sent down.</p> <p>Returns:</p> Type Description <code>int</code> <p>The gain index.</p> <ul> <li><code>0</code> \u2014 1.0E-5</li> <li><code>1</code> \u2014 1.0E-6</li> <li><code>2</code> \u2014 1.0E-7</li> <li><code>3</code> \u2014 1.0E-8</li> <li><code>4</code> \u2014 1.0E-9</li> <li><code>5</code> \u2014 1.0E-10 (Point to Point mode only)</li> <li><code>6</code> \u2014 1.0E-11 (Point to Point mode only)</li> <li><code>7</code> \u2014 Auto Gain Ranging (Point to Point mode only)</li> </ul> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def manual_get_gain(self) -&gt; int:\n    \"\"\"The index of the gain that will be applied when the parameters are to be sent down.\n\n    Returns:\n        The gain index.\n\n            * `0` &amp;mdash; 1.0E-5\n            * `1` &amp;mdash; 1.0E-6\n            * `2` &amp;mdash; 1.0E-7\n            * `3` &amp;mdash; 1.0E-8\n            * `4` &amp;mdash; 1.0E-9\n            * `5` &amp;mdash; 1.0E-10 (Point to Point mode only)\n            * `6` &amp;mdash; 1.0E-11 (Point to Point mode only)\n            * `7` &amp;mdash; Auto Gain Ranging (Point to Point mode only)\n\n    \"\"\"\n    return int(self._send(\"manual_get_gain\"))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.manual_get_integration_time","title":"manual_get_integration_time","text":"<pre><code>manual_get_integration_time() -&gt; float\n</code></pre> <p>Returns the integration time set in the system.</p> <p>Only applies to the integration time used for Point to Point scans.</p> <p>Returns:</p> Type Description <code>float</code> <p>The integration time in seconds.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def manual_get_integration_time(self) -&gt; float:\n    \"\"\"Returns the integration time set in the system.\n\n    Only applies to the integration time used for Point to Point scans.\n\n    Returns:\n        The integration time in seconds.\n    \"\"\"\n    return float(self._send(\"manual_get_integration_time\"))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.manual_get_pmt_overload","title":"manual_get_pmt_overload","text":"<pre><code>manual_get_pmt_overload() -&gt; float\n</code></pre> <p>Returns the PMT overload voltage set in the system.</p> <p>Returns:</p> Type Description <code>float</code> <p>Overload voltage, in volts, of the photomultiplier tube.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def manual_get_pmt_overload(self) -&gt; float:\n    \"\"\"Returns the PMT overload voltage set in the system.\n\n    Returns:\n        Overload voltage, in volts, of the photomultiplier tube.\n    \"\"\"\n    return float(self._send(\"manual_get_pmt_overload\"))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.manual_get_pmt_voltage","title":"manual_get_pmt_voltage","text":"<pre><code>manual_get_pmt_voltage() -&gt; float\n</code></pre> <p>Returns the PMT high voltage set in the system.</p> <p>Returns:</p> Type Description <code>float</code> <p>Voltage, in volts, of the photomultiplier tube.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def manual_get_pmt_voltage(self) -&gt; float:\n    \"\"\"Returns the PMT high voltage set in the system.\n\n    Returns:\n        Voltage, in volts, of the photomultiplier tube.\n    \"\"\"\n    return float(self._send(\"manual_get_pmt_voltage\"))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.manual_get_settling_time","title":"manual_get_settling_time","text":"<pre><code>manual_get_settling_time() -&gt; float\n</code></pre> <p>Returns the settling time of the instrument.</p> <p>Returns:</p> Type Description <code>float</code> <p>Settling time of the system in seconds.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def manual_get_settling_time(self) -&gt; float:\n    \"\"\"Returns the settling time of the instrument.\n\n    Returns:\n        Settling time of the system in seconds.\n    \"\"\"\n    return float(self._send(\"manual_get_settling_time\"))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.manual_get_signal","title":"manual_get_signal","text":"<pre><code>manual_get_signal() -&gt; float\n</code></pre> <p>Returns the signal at the current position of the wavelength drive.</p> <p>Returns:</p> Type Description <code>float</code> <p>The signal, in amperes.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def manual_get_signal(self) -&gt; float:\n    \"\"\"Returns the signal at the current position of the wavelength drive.\n\n    Returns:\n        The signal, in amperes.\n    \"\"\"\n    return float(self._send(\"manual_get_signal\"))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.manual_home_ol756","title":"manual_home_ol756","text":"<pre><code>manual_home_ol756() -&gt; None\n</code></pre> <p>Homes the wavelength and filter drive.</p> <p>Will reconnect the filter drive if it was disconnected</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def manual_home_ol756(self) -&gt; None:\n    \"\"\"Homes the wavelength and filter drive.\n\n    Will reconnect the filter drive if it was disconnected\n    \"\"\"\n    self._send(\"manual_home_ol756\")\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.manual_move_to_wavelength","title":"manual_move_to_wavelength","text":"<pre><code>manual_move_to_wavelength(wavelength: float) -&gt; None\n</code></pre> <p>Moves the wavelength drive to a particular location.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float</code> <p>The wavelength to move the wavelength drive to.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def manual_move_to_wavelength(self, wavelength: float) -&gt; None:\n    \"\"\"Moves the wavelength drive to a particular location.\n\n    Args:\n        wavelength: The wavelength to move the wavelength drive to.\n    \"\"\"\n    self._send(\"manual_move_to_wavelength\", wavelength)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.manual_set_gain","title":"manual_set_gain","text":"<pre><code>manual_set_gain(gain_index: int, mode: int) -&gt; None\n</code></pre> <p>Set the gain.</p> <p>Parameters:</p> Name Type Description Default <code>gain_index</code> <code>int</code> <p>The gain index.</p> <ul> <li><code>0</code> \u2014 1.0E-5</li> <li><code>1</code> \u2014 1.0E-6</li> <li><code>2</code> \u2014 1.0E-7</li> <li><code>3</code> \u2014 1.0E-8</li> <li><code>4</code> \u2014 1.0E-9</li> <li><code>5</code> \u2014 1.0E-10 (Point to Point mode only)</li> <li><code>6</code> \u2014 1.0E-11 (Point to Point mode only)</li> <li><code>7</code> \u2014 Auto Gain Ranging (Point to Point mode only)</li> </ul> required <code>mode</code> <code>int</code> <p>The scan mode.</p> <ul> <li><code>0</code> \u2014 Point to point</li> <li><code>1</code> \u2014 Quick scan</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def manual_set_gain(self, gain_index: int, mode: int) -&gt; None:\n    \"\"\"Set the gain.\n\n    Args:\n        gain_index: The gain index.\n\n            * `0` &amp;mdash; 1.0E-5\n            * `1` &amp;mdash; 1.0E-6\n            * `2` &amp;mdash; 1.0E-7\n            * `3` &amp;mdash; 1.0E-8\n            * `4` &amp;mdash; 1.0E-9\n            * `5` &amp;mdash; 1.0E-10 (Point to Point mode only)\n            * `6` &amp;mdash; 1.0E-11 (Point to Point mode only)\n            * `7` &amp;mdash; Auto Gain Ranging (Point to Point mode only)\n\n        mode: The scan mode.\n\n            * `0` &amp;mdash; Point to point\n            * `1` &amp;mdash; Quick scan\n    \"\"\"\n    self._send(\"manual_set_gain\", gain_index, mode)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.manual_set_integration_time","title":"manual_set_integration_time","text":"<pre><code>manual_set_integration_time(time: float) -&gt; None\n</code></pre> <p>Sets the integration time set in the system.</p> <p>Only applies to the integration time used for Point to Point scans.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The integration time in seconds.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def manual_set_integration_time(self, time: float) -&gt; None:\n    \"\"\"Sets the integration time set in the system.\n\n    Only applies to the integration time used for Point to Point scans.\n\n    Args:\n        time: The integration time in seconds.\n    \"\"\"\n    self._send(\"manual_set_integration_time\", time)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.manual_set_pmt_overload","title":"manual_set_pmt_overload","text":"<pre><code>manual_set_pmt_overload(overload: float) -&gt; None\n</code></pre> <p>Sets the PMT overload voltage set in the system.</p> <p>Parameters:</p> Name Type Description Default <code>overload</code> <code>float</code> <p>Overload voltage, in volts, of the photomultiplier tube in Volts.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def manual_set_pmt_overload(self, overload: float) -&gt; None:\n    \"\"\"Sets the PMT overload voltage set in the system.\n\n    Args:\n        overload: Overload voltage, in volts, of the photomultiplier tube in Volts.\n    \"\"\"\n    self._send(\"manual_set_pmt_overload\", overload)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.manual_set_pmt_voltage","title":"manual_set_pmt_voltage","text":"<pre><code>manual_set_pmt_voltage(voltage: float) -&gt; None\n</code></pre> <p>Sets the PMT high voltage set in the system.</p> <p>Parameters:</p> Name Type Description Default <code>voltage</code> <code>float</code> <p>Voltage, in volts, of the photomultiplier tube.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def manual_set_pmt_voltage(self, voltage: float) -&gt; None:\n    \"\"\"Sets the PMT high voltage set in the system.\n\n    Args:\n        voltage: Voltage, in volts, of the photomultiplier tube.\n    \"\"\"\n    self._send(\"manual_set_pmt_voltage\", voltage)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.manual_set_settling_time","title":"manual_set_settling_time","text":"<pre><code>manual_set_settling_time(time: float) -&gt; None\n</code></pre> <p>Sets the settling time of the instrument.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>Settling time of the system.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def manual_set_settling_time(self, time: float) -&gt; None:\n    \"\"\"Sets the settling time of the instrument.\n\n    Args:\n        time: Settling time of the system.\n    \"\"\"\n    self._send(\"manual_set_settling_time\", time)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.move_to_wavelength","title":"move_to_wavelength","text":"<pre><code>move_to_wavelength(wavelength: float) -&gt; None\n</code></pre> <p>Moves the wavelength drive to a particular location.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float</code> <p>The wavelength, in nm, to move the wavelength drive to.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def move_to_wavelength(self, wavelength: float) -&gt; None:\n    \"\"\"Moves the wavelength drive to a particular location.\n\n    Args:\n        wavelength: The wavelength, in nm, to move the wavelength drive to.\n    \"\"\"\n    self._send(\"move_to_wavelength\", wavelength)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.read_ol756_flash_settings","title":"read_ol756_flash_settings","text":"<pre><code>read_ol756_flash_settings() -&gt; None\n</code></pre> <p>Reads the saved settings from the flash memory.</p> <p>Reads the settings such as the grating alignment factor, filter skew and wavelength skew. Loads these values into the ActiveX control memory.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def read_ol756_flash_settings(self) -&gt; None:\n    \"\"\"Reads the saved settings from the flash memory.\n\n    Reads the settings such as the grating alignment factor, filter skew\n    and wavelength skew. Loads these values into the ActiveX control memory.\n    \"\"\"\n    self._send(\"read_ol756_flash_settings\")\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.reset_averaging","title":"reset_averaging","text":"<pre><code>reset_averaging(\n    meas_type: Literal[0, 1, 2, 3, 4, 5],\n) -&gt; None\n</code></pre> <p>Resets the accumulated signal array for the specified measurement type.</p> <p>This function is used in combination with do_averaging and accumulate_signals.</p> <p>Parameters:</p> Name Type Description Default <code>meas_type</code> <code>Literal[0, 1, 2, 3, 4, 5]</code> <p>The measurement type.</p> <ul> <li><code>0</code> \u2014 Irradiance</li> <li><code>1</code> \u2014 Radiance</li> <li><code>2</code> \u2014 Transmittance</li> <li><code>3</code> \u2014 Irradiance Calibration</li> <li><code>4</code> \u2014 Radiance Calibration</li> <li><code>5</code> \u2014 Transmittance Calibration</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def reset_averaging(self, meas_type: Literal[0, 1, 2, 3, 4, 5]) -&gt; None:\n    \"\"\"Resets the accumulated signal array for the specified measurement type.\n\n    This function is used in combination with\n    [do_averaging][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.do_averaging]\n    and [accumulate_signals][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.accumulate_signals].\n\n    Args:\n        meas_type: The measurement type.\n\n            * `0` &amp;mdash; Irradiance\n            * `1` &amp;mdash; Radiance\n            * `2` &amp;mdash; Transmittance\n            * `3` &amp;mdash; Irradiance Calibration\n            * `4` &amp;mdash; Radiance Calibration\n            * `5` &amp;mdash; Transmittance Calibration\n\n    \"\"\"\n    self._send(\"reset_averaging\", meas_type)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.save_calibration_file","title":"save_calibration_file","text":"<pre><code>save_calibration_file(\n    meas_type: Literal[3, 4, 5], path: PathLike\n) -&gt; None\n</code></pre> <p>Create a OL756-compatible calibration file.</p> <p>Parameters:</p> Name Type Description Default <code>meas_type</code> <code>Literal[3, 4, 5]</code> <p>The calibration measurement type.</p> <ul> <li><code>3</code> \u2014 Irradiance Calibration</li> <li><code>4</code> \u2014 Radiance Calibration</li> <li><code>5</code> \u2014 Transmittance Calibration</li> </ul> required <code>path</code> <code>PathLike</code> <p>The path to save the calibration file to.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def save_calibration_file(self, meas_type: Literal[3, 4, 5], path: PathLike) -&gt; None:\n    \"\"\"Create a OL756-compatible calibration file.\n\n    Args:\n        meas_type: The calibration measurement type.\n\n            * `3` &amp;mdash; Irradiance Calibration\n            * `4` &amp;mdash; Radiance Calibration\n            * `5` &amp;mdash; Transmittance Calibration\n\n        path: The path to save the calibration file to.\n    \"\"\"\n    self._send(\"save_calibration_file\", meas_type, os.fsdecode(path))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.save_measurement_data","title":"save_measurement_data","text":"<pre><code>save_measurement_data(\n    meas_type: Literal[0, 1, 2], path: PathLike\n) -&gt; None\n</code></pre> <p>Save the measurement data to a OL756-compatible data file.</p> <p>Parameters:</p> Name Type Description Default <code>meas_type</code> <code>Literal[0, 1, 2]</code> <p>The measurement type.</p> <ul> <li><code>0</code> \u2014 Irradiance</li> <li><code>1</code> \u2014 Radiance</li> <li><code>2</code> \u2014 Transmittance</li> </ul> required <code>path</code> <code>PathLike</code> <p>The path to save the data to.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def save_measurement_data(self, meas_type: Literal[0, 1, 2], path: PathLike) -&gt; None:\n    \"\"\"Save the measurement data to a OL756-compatible data file.\n\n    Args:\n        meas_type: The measurement type.\n\n            * `0` &amp;mdash; Irradiance\n            * `1` &amp;mdash; Radiance\n            * `2` &amp;mdash; Transmittance\n\n        path: The path to save the data to.\n    \"\"\"\n    self._send(\"save_measurement_data\", meas_type, os.fsdecode(path))\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.send_down_parameters","title":"send_down_parameters","text":"<pre><code>send_down_parameters(scan_mode: Literal[0, 1]) -&gt; None\n</code></pre> <p>Sends down the parameters to the system.</p> <p>This needs to be called whenever parameters dealing with the PMT or integration time and gain has changed. Needs to be called once before doing any measurements or other signal acquisition including dark current.</p> <p>The following methods affect the parameters</p> <ul> <li>set_pmt_flux_overload_voltage</li> <li>set_gain</li> <li>set_integration_time</li> <li>set_pmt_high_voltage</li> <li>set_settling_time</li> <li>set_scan_range</li> <li>set_adaptive_integration_time</li> </ul> <p>Parameters:</p> Name Type Description Default <code>scan_mode</code> <code>Literal[0, 1]</code> <p>The scan mode.</p> <ul> <li><code>0</code> \u2014 Point to point</li> <li><code>1</code> \u2014 Quick scan</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def send_down_parameters(self, scan_mode: Literal[0, 1]) -&gt; None:\n    \"\"\"Sends down the parameters to the system.\n\n    This needs to be called whenever parameters dealing with the PMT or\n    integration time and gain has changed. Needs to be called once before\n    doing any measurements or other signal acquisition including dark\n    current.\n\n    The following methods affect the parameters\n\n    * [set_pmt_flux_overload_voltage][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.set_pmt_flux_overload_voltage]\n    * [set_gain][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.set_gain]\n    * [set_integration_time][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.set_integration_time]\n    * [set_pmt_high_voltage][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.set_pmt_high_voltage]\n    * [set_settling_time][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.set_settling_time]\n    * [set_scan_range][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.set_scan_range]\n    * [set_adaptive_integration_time][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.set_adaptive_integration_time]\n\n    Args:\n        scan_mode: The scan mode.\n\n            * `0` &amp;mdash; Point to point\n            * `1` &amp;mdash; Quick scan\n\n    \"\"\"  # noqa: E501\n    self._send(\"send_down_parameters\", scan_mode)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.set_adaptive_integration_time","title":"set_adaptive_integration_time","text":"<pre><code>set_adaptive_integration_time(\n    gain_index: int, speed_index: int\n) -&gt; None\n</code></pre> <p>Sets the scan speed of the scan at a particular gain range.</p> <p>Adaptive integration time is used solely for point to point scans in auto-gain ranging.</p> <p>Parameters:</p> Name Type Description Default <code>gain_index</code> <code>int</code> <p>The index of the gain to use to set the integration time.</p> <ul> <li><code>0</code> \u2014 1.0E-5</li> <li><code>1</code> \u2014 1.0E-6</li> <li><code>2</code> \u2014 1.0E-7</li> <li><code>3</code> \u2014 1.0E-8</li> <li><code>4</code> \u2014 1.0E-9</li> <li><code>5</code> \u2014 1.0E-10</li> <li><code>6</code> \u2014 1.0E-11</li> </ul> required <code>speed_index</code> <code>int</code> <p>The scan speed index [0..12] \u2014 <code>0</code> (Slowest), <code>12</code> (Fastest).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def set_adaptive_integration_time(self, gain_index: int, speed_index: int) -&gt; None:\n    \"\"\"Sets the scan speed of the scan at a particular gain range.\n\n    Adaptive integration time is used solely for point to point\n    scans in auto-gain ranging.\n\n    Args:\n        gain_index: The index of the gain to use to set the integration time.\n\n            * `0` &amp;mdash; 1.0E-5\n            * `1` &amp;mdash; 1.0E-6\n            * `2` &amp;mdash; 1.0E-7\n            * `3` &amp;mdash; 1.0E-8\n            * `4` &amp;mdash; 1.0E-9\n            * `5` &amp;mdash; 1.0E-10\n            * `6` &amp;mdash; 1.0E-11\n\n        speed_index: The scan speed index [0..12] &amp;mdash; `0` (Slowest), `12` (Fastest).\n    \"\"\"\n    self._send(\"set_adaptive_integration_time\", gain_index, speed_index)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.set_averaging_number_of_scan","title":"set_averaging_number_of_scan","text":"<pre><code>set_averaging_number_of_scan(n_scans: int) -&gt; None\n</code></pre> <p>Set the number of scans to average.</p> <p>Parameters:</p> Name Type Description Default <code>n_scans</code> <code>int</code> <p>The number of scans to average.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def set_averaging_number_of_scan(self, n_scans: int) -&gt; None:\n    \"\"\"Set the number of scans to average.\n\n    Args:\n        n_scans: The number of scans to average.\n    \"\"\"\n    self._send(\"set_averaging_number_of_scan\", n_scans)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.set_dark_current_params","title":"set_dark_current_params","text":"<pre><code>set_dark_current_params(\n    mode: Literal[0, 1], wavelength: float\n) -&gt; None\n</code></pre> <p>Sets the mode and the wavelength to use for a dark-current measurement.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>Literal[0, 1]</code> <p>The mode to use to acquire a dark-current measurement.</p> <ul> <li><code>0</code> \u2014 wavelength</li> <li><code>1</code> \u2014 shutter</li> </ul> required <code>wavelength</code> <code>float</code> <p>The wavelength, in nm, to use for a dark-current measurement.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def set_dark_current_params(self, mode: Literal[0, 1], wavelength: float) -&gt; None:\n    \"\"\"Sets the mode and the wavelength to use for a dark-current measurement.\n\n    Args:\n        mode: The mode to use to acquire a dark-current measurement.\n\n            * `0` &amp;mdash; wavelength\n            * `1` &amp;mdash; shutter\n\n        wavelength: The wavelength, in nm, to use for a dark-current measurement.\n    \"\"\"\n    self._send(\"set_dark_current_params\", mode, wavelength)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.set_gain","title":"set_gain","text":"<pre><code>set_gain(scan_mode: Literal[0, 1], gain_index: int) -&gt; None\n</code></pre> <p>Sets the index of the gain that will be applied when the parameters are to be sent down.</p> <p>Applies to both quick scan and point to point scans.</p> <p>Parameters:</p> Name Type Description Default <code>scan_mode</code> <code>Literal[0, 1]</code> <p>The scan mode.</p> <ul> <li><code>0</code> \u2014 Point to Point</li> <li><code>1</code> \u2014 Quick Scan</li> </ul> required <code>gain_index</code> <code>int</code> <p>The gain index.</p> <ul> <li><code>0</code> \u2014 1.0E-5</li> <li><code>1</code> \u2014 1.0E-6</li> <li><code>2</code> \u2014 1.0E-7</li> <li><code>3</code> \u2014 1.0E-8</li> <li><code>4</code> \u2014 1.0E-9</li> <li><code>5</code> \u2014 1.0E-10 (available only in Point to Point mode)</li> <li><code>6</code> \u2014 1.0E-11 (available only in Point to Point mode)</li> <li><code>7</code> \u2014 Auto Gain Ranging (available only in Point to Point mode)</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def set_gain(self, scan_mode: Literal[0, 1], gain_index: int) -&gt; None:\n    \"\"\"Sets the index of the gain that will be applied when the parameters are to be sent down.\n\n    Applies to both quick scan and point to point scans.\n\n    Args:\n        scan_mode: The scan mode.\n\n            * `0` &amp;mdash; Point to Point\n            * `1` &amp;mdash; Quick Scan\n\n        gain_index: The gain index.\n\n            * `0` &amp;mdash; 1.0E-5\n            * `1` &amp;mdash; 1.0E-6\n            * `2` &amp;mdash; 1.0E-7\n            * `3` &amp;mdash; 1.0E-8\n            * `4` &amp;mdash; 1.0E-9\n            * `5` &amp;mdash; 1.0E-10 (available only in Point to Point mode)\n            * `6` &amp;mdash; 1.0E-11 (available only in Point to Point mode)\n            * `7` &amp;mdash; Auto Gain Ranging (available only in Point to Point mode)\n\n    \"\"\"\n    self._send(\"set_gain\", scan_mode, gain_index)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.set_integration_time","title":"set_integration_time","text":"<pre><code>set_integration_time(\n    scan_mode: Literal[0, 1], scan_speed: int\n) -&gt; None\n</code></pre> <p>Sets the index of the scan speed used.</p> <p>Applies to both quick scan and point to point scans. In quick scan, the speed will vary based on the scan range and increments.</p> <p>Parameters:</p> Name Type Description Default <code>scan_mode</code> <code>Literal[0, 1]</code> <p>The scan mode.</p> <ul> <li><code>0</code> \u2014 Point to Point</li> <li><code>1</code> \u2014 Quick Scan</li> </ul> required <code>scan_speed</code> <code>int</code> <p>Index to the integration time array.</p> <p>Point to Point mode.</p> <ul> <li><code>0</code> \u2014 1.000 sec</li> <li><code>1</code> \u2014 0.500 sec</li> <li><code>2</code> \u2014 0.200 sec</li> <li><code>3</code> \u2014 0.100 sec</li> <li><code>4</code> \u2014 0.050 sec</li> <li><code>5</code> \u2014 0.020 sec</li> <li><code>6</code> \u2014 0.010 sec</li> <li><code>7</code> \u2014 0.005 sec</li> <li><code>8</code> \u2014 0.002 sec</li> <li><code>9</code> \u2014 0.001 sec</li> <li><code>10</code> \u2014 Adaptive (Point To Point mode only)</li> <li><code>11</code> \u2014 User defined (Point To Point mode only)</li> </ul> <p>Quick Scan mode.</p> <ul> <li><code>0</code> \u2014 slowest</li> <li><code>10</code> \u2014 fastest</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def set_integration_time(self, scan_mode: Literal[0, 1], scan_speed: int) -&gt; None:\n    \"\"\"Sets the index of the scan speed used.\n\n    Applies to both quick scan and point to point scans.\n    In quick scan, the speed will vary based on the scan range and increments.\n\n    Args:\n        scan_mode: The scan mode.\n\n            * `0` &amp;mdash; Point to Point\n            * `1` &amp;mdash; Quick Scan\n\n        scan_speed: Index to the integration time array.\n\n            Point to Point mode.\n\n            * `0` &amp;mdash; 1.000 sec\n            * `1` &amp;mdash; 0.500 sec\n            * `2` &amp;mdash; 0.200 sec\n            * `3` &amp;mdash; 0.100 sec\n            * `4` &amp;mdash; 0.050 sec\n            * `5` &amp;mdash; 0.020 sec\n            * `6` &amp;mdash; 0.010 sec\n            * `7` &amp;mdash; 0.005 sec\n            * `8` &amp;mdash; 0.002 sec\n            * `9` &amp;mdash; 0.001 sec\n            * `10` &amp;mdash; Adaptive\t(Point To Point mode only)\n            * `11` &amp;mdash; User defined (Point To Point mode only)\n\n            Quick Scan mode.\n\n            * `0` &amp;mdash; slowest\n            * `10` &amp;mdash; fastest\n\n    \"\"\"\n    self._send(\"set_integration_time\", scan_mode, scan_speed)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.set_pmt_flux_overload_voltage","title":"set_pmt_flux_overload_voltage","text":"<pre><code>set_pmt_flux_overload_voltage(voltage: float) -&gt; None\n</code></pre> <p>Sets the value to use for the photomultiplier tube flux overload.</p> <p>Parameters:</p> Name Type Description Default <code>voltage</code> <code>float</code> <p>Voltage that the PMT will determine to be at the overload point. Software only, because PMT has built-in protection also.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def set_pmt_flux_overload_voltage(self, voltage: float) -&gt; None:\n    \"\"\"Sets the value to use for the photomultiplier tube flux overload.\n\n    Args:\n        voltage: Voltage that the PMT will determine to be at the overload point.\n            Software only, because PMT has built-in protection also.\n    \"\"\"\n    self._send(\"set_pmt_flux_overload_voltage\", voltage)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.set_pmt_high_voltage","title":"set_pmt_high_voltage","text":"<pre><code>set_pmt_high_voltage(voltage: float) -&gt; None\n</code></pre> <p>Sets the value to be determined to be a flux overload by the software.</p> <p>Parameters:</p> Name Type Description Default <code>voltage</code> <code>float</code> <p>Voltage, in volts, that the PMT will determine to be overload point.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def set_pmt_high_voltage(self, voltage: float) -&gt; None:\n    \"\"\"Sets the value to be determined to be a flux overload by the software.\n\n    Args:\n        voltage: Voltage, in volts, that the PMT will determine to be overload point.\n    \"\"\"\n    self._send(\"set_pmt_high_voltage\", voltage)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.set_reference_white_point","title":"set_reference_white_point","text":"<pre><code>set_reference_white_point(\n    white: Literal[0, 1, 2, 3, 4, 5], x: float, y: float\n) -&gt; None\n</code></pre> <p>Sets the value of the reference illuminant.</p> <p>Parameters:</p> Name Type Description Default <code>white</code> <code>Literal[0, 1, 2, 3, 4, 5]</code> <p>The reference white point.</p> <ul> <li><code>0</code> \u2014 Incandescent (A)</li> <li><code>1</code> \u2014 Direct Sunlight (B)</li> <li><code>2</code> \u2014 Indirect Sunlight (C)</li> <li><code>3</code> \u2014 Natural Daylight (D65)</li> <li><code>4</code> \u2014 Normalized Reference (E)</li> <li><code>5</code> \u2014 User Defined</li> </ul> required <code>x</code> <code>float</code> <p>User defined x value on CIE chart.</p> required <code>y</code> <code>float</code> <p>User defined y value on CIE chart.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def set_reference_white_point(self, white: Literal[0, 1, 2, 3, 4, 5], x: float, y: float) -&gt; None:\n    \"\"\"Sets the value of the reference illuminant.\n\n    Args:\n        white: The reference white point.\n\n            * `0` &amp;mdash; Incandescent (A)\n            * `1` &amp;mdash; Direct Sunlight (B)\n            * `2` &amp;mdash; Indirect Sunlight (C)\n            * `3` &amp;mdash; Natural Daylight (D65)\n            * `4` &amp;mdash; Normalized Reference (E)\n            * `5` &amp;mdash; User Defined\n\n        x: User defined x value on CIE chart.\n        y: User defined y value on CIE chart.\n    \"\"\"\n    self._send(\"set_reference_white_point\", white, x, y)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.set_scan_range","title":"set_scan_range","text":"<pre><code>set_scan_range(\n    start: float, end: float, increment_index: int\n) -&gt; None\n</code></pre> <p>Sets the wavelength scan range.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>Starting wavelength, in nm.</p> required <code>end</code> <code>float</code> <p>Ending wavelength, in nm.</p> required <code>increment_index</code> <code>int</code> <p>Increment index, see get_increment_index.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def set_scan_range(self, start: float, end: float, increment_index: int) -&gt; None:\n    \"\"\"Sets the wavelength scan range.\n\n    Args:\n        start: Starting wavelength, in nm.\n        end: Ending wavelength, in nm.\n        increment_index: Increment index, see\n            [get_increment_index][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.get_increment_index].\n    \"\"\"\n    self._send(\"set_scan_range\", start, end, increment_index)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.set_settling_time","title":"set_settling_time","text":"<pre><code>set_settling_time(time: float) -&gt; None\n</code></pre> <p>Set the settling time.</p> <p>Settling time is the time that the wavelength drive pauses once it reaches its target wavelength.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>Settling Time in seconds to be sent down or has already been sent to the system.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def set_settling_time(self, time: float) -&gt; None:\n    \"\"\"Set the settling time.\n\n    Settling time is the time that the wavelength drive pauses once\n    it reaches its target wavelength.\n\n    Args:\n        time: Settling Time in seconds to be sent down or has already been sent to the system.\n    \"\"\"\n    self._send(\"set_settling_time\", time)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.set_tab_delimited_mode","title":"set_tab_delimited_mode","text":"<pre><code>set_tab_delimited_mode(*, enable: bool) -&gt; None\n</code></pre> <p>Purpose of function is to set what mode to write the data files as.</p> <p>Setting the tab delimited to true will write the data in a tab delimited format, else a false will write in a comma delimited format. Tab delimited files will not be compatible with some versions of the software. If you want data files to be compatible with v1.32 software and below, leave the mode to <code>False</code>.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>Whether to use the new file format using TABs as a delimited or the old file format compatible with v1.32 and below.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def set_tab_delimited_mode(self, *, enable: bool) -&gt; None:\n    \"\"\"Purpose of function is to set what mode to write the data files as.\n\n    Setting the tab delimited to true will write the data in a tab\n    delimited format, else a false will write in a comma delimited format.\n    Tab delimited files will not be compatible with some versions of the\n    software. If you want data files to be compatible with v1.32 software\n    and below, leave the mode to `False`.\n\n    Args:\n        enable: Whether to use the new file format using TABs as a delimited or\n            the old file format compatible with v1.32 and below.\n    \"\"\"\n    self._send(\"set_tab_delimited_mode\", enable)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.set_user_defined_integration_time","title":"set_user_defined_integration_time","text":"<pre><code>set_user_defined_integration_time(time: float) -&gt; None\n</code></pre> <p>Sets the user defined integration time.</p> <p>Used only in point to point scans and only if the user sets the integration time mode.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>Integration time in seconds.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def set_user_defined_integration_time(self, time: float) -&gt; None:\n    \"\"\"Sets the user defined integration time.\n\n    Used only in point to point scans and only if the user sets the integration time mode.\n\n    Args:\n        time: Integration time in seconds.\n    \"\"\"\n    self._send(\"set_user_defined_integration_time\", time)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.stop_measurement","title":"stop_measurement","text":"<pre><code>stop_measurement() -&gt; None\n</code></pre> <p>Stops a measurement.</p> <p>Applies only to Point to Point measurements. Quick scans are done so quickly that there is no need to stop a measurement once it starts.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def stop_measurement(self) -&gt; None:\n    \"\"\"Stops a measurement.\n\n    Applies only to Point to Point measurements. Quick scans are done\n    so quickly that there is no need to stop a measurement once it starts.\n    \"\"\"\n    self._send(\"stop_measurement\")\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.take_point_to_point_calibration","title":"take_point_to_point_calibration","text":"<pre><code>take_point_to_point_calibration(\n    meas_type: Literal[3, 4, 5],\n) -&gt; None\n</code></pre> <p>Takes a calibration in point to point mode.</p> <p>Need to have called send_down_parameters at least once before calling any of the measurement functions or data acquisition functions.</p> <p>Parameters:</p> Name Type Description Default <code>meas_type</code> <code>Literal[3, 4, 5]</code> <p>The calibration measurement type.</p> <ul> <li><code>3</code> \u2014 Irradiance Calibration</li> <li><code>4</code> \u2014 Radiance Calibration</li> <li><code>5</code> \u2014 Transmittance Calibration</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def take_point_to_point_calibration(self, meas_type: Literal[3, 4, 5]) -&gt; None:\n    \"\"\"Takes a calibration in point to point mode.\n\n    Need to have called\n    [send_down_parameters][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.send_down_parameters]\n    at least once before calling any of the measurement functions or data acquisition functions.\n\n    Args:\n        meas_type: The calibration measurement type.\n\n            * `3` &amp;mdash; Irradiance Calibration\n            * `4` &amp;mdash; Radiance Calibration\n            * `5` &amp;mdash; Transmittance Calibration\n\n    \"\"\"\n    self._send(\"take_point_to_point_calibration\", meas_type)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.take_point_to_point_measurement","title":"take_point_to_point_measurement","text":"<pre><code>take_point_to_point_measurement(\n    meas_type: Literal[0, 1, 2],\n) -&gt; None\n</code></pre> <p>Takes a measurement in point to point mode.</p> <p>Need to have called send_down_parameters at least once before calling any of the measurement functions or data acquisition functions.</p> <p>Parameters:</p> Name Type Description Default <code>meas_type</code> <code>Literal[0, 1, 2]</code> <p>The measurement type.</p> <ul> <li><code>0</code> \u2014 Irradiance</li> <li><code>1</code> \u2014 Radiance</li> <li><code>2</code> \u2014 Transmittance</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def take_point_to_point_measurement(self, meas_type: Literal[0, 1, 2]) -&gt; None:\n    \"\"\"Takes a measurement in point to point mode.\n\n    Need to have called\n    [send_down_parameters][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.send_down_parameters]\n    at least once before calling any of the measurement functions or data acquisition functions.\n\n    Args:\n        meas_type: The measurement type.\n\n            * `0` &amp;mdash; Irradiance\n            * `1` &amp;mdash; Radiance\n            * `2` &amp;mdash; Transmittance\n\n    \"\"\"\n    self._send(\"take_point_to_point_measurement\", meas_type)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.take_quick_scan_calibration","title":"take_quick_scan_calibration","text":"<pre><code>take_quick_scan_calibration(\n    meas_type: Literal[3, 4, 5],\n) -&gt; None\n</code></pre> <p>Takes a calibration in quick scan mode.</p> <p>Need to have called send_down_parameters at least once before calling any of the measurement functions or data acquisition functions.</p> <p>Parameters:</p> Name Type Description Default <code>meas_type</code> <code>Literal[3, 4, 5]</code> <p>The calibration measurement type.</p> <ul> <li><code>3</code> \u2014 Irradiance Calibration</li> <li><code>4</code> \u2014 Radiance Calibration</li> <li><code>5</code> \u2014 Transmittance Calibration</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def take_quick_scan_calibration(self, meas_type: Literal[3, 4, 5]) -&gt; None:\n    \"\"\"Takes a calibration in quick scan mode.\n\n    Need to have called\n    [send_down_parameters][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.send_down_parameters]\n    at least once before calling any of the measurement functions or data acquisition functions.\n\n    Args:\n        meas_type: The calibration measurement type.\n\n            * `3` &amp;mdash; Irradiance Calibration\n            * `4` &amp;mdash; Radiance Calibration\n            * `5` &amp;mdash; Transmittance Calibration\n\n    \"\"\"\n    self._send(\"take_quick_scan_calibration\", meas_type)\n</code></pre>"},{"location":"resources/optronic_labs/ol756/#msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.take_quick_scan_measurement","title":"take_quick_scan_measurement","text":"<pre><code>take_quick_scan_measurement(\n    meas_type: Literal[0, 1, 2],\n) -&gt; None\n</code></pre> <p>Takes a measurement in quick scan mode.</p> <p>Need to have called send_down_parameters at least once before calling any of the measurement functions or data acquisition functions.</p> <p>Parameters:</p> Name Type Description Default <code>meas_type</code> <code>Literal[0, 1, 2]</code> <p>The measurement type.</p> <ul> <li><code>0</code> \u2014 Irradiance</li> <li><code>1</code> \u2014 Radiance</li> <li><code>2</code> \u2014 Transmittance</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/ol756ocx_64.py</code> <pre><code>def take_quick_scan_measurement(self, meas_type: Literal[0, 1, 2]) -&gt; None:\n    \"\"\"Takes a measurement in quick scan mode.\n\n    Need to have called\n    [send_down_parameters][msl.equipment_resources.optronic_labs.ol756ocx_64.OL756.send_down_parameters]\n    at least once before calling any of the measurement functions or data acquisition functions.\n\n    Args:\n        meas_type: The measurement type.\n\n            * `0` &amp;mdash; Irradiance\n            * `1` &amp;mdash; Radiance\n            * `2` &amp;mdash; Transmittance\n\n    \"\"\"\n    self._send(\"take_quick_scan_measurement\", meas_type)\n</code></pre>"},{"location":"resources/optronic_labs/olxxa/","title":"OL 16A, 65A, 83A","text":"<p>Communicate with a DC current source from Optronic Laboratories.</p> <p>Compatible models are OL 16A, 65A and 83A.</p>"},{"location":"resources/optronic_labs/olxxa/#msl.equipment_resources.optronic_labs.olxxa.LampInfo","title":"LampInfo  <code>dataclass</code>","text":"<pre><code>LampInfo(number: int, value: float, unit: str)\n</code></pre> <p>Information about the currently-selected lamp.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>The lamp number (between 0 and 9, inclusive).</p> required <code>value</code> <code>float</code> <p>The target value.</p> required <code>unit</code> <code>str</code> <p>The unit of <code>value</code>.</p> required"},{"location":"resources/optronic_labs/olxxa/#msl.equipment_resources.optronic_labs.olxxa.OLxxA","title":"OLxxA","text":"<pre><code>OLxxA(equipment: Equipment)\n</code></pre> <p>               Bases: <code>MultiMessageBased</code></p> <p>Communicate with a DC current source from Optronic Laboratories.</p> <p>Warning</p> <p>The connection interface must be selected (using the buttons on the front panel) to be either RS-232 or IEEE-488 after the Current Source is initially powered on. Even if this is the default power-on interface, it must be manually re-selected before communication will work.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for an Optronic Current Source, as well as the properties for Serial if using RS-232 as the interface or GPIB if using IEEE-488 as the interface.</p> <p>Connection Properties:</p> Name Type Description <code>address</code> <code>int</code> <p>Internal address of the device (RS-232 only). Default: <code>1</code></p> <code>delay</code> <code>float</code> <p>Number of seconds to wait between a write-read transaction (RS-232 only). Default: <code>0.1</code></p> <code>use_ack_nak</code> <code>bool</code> <p>Whether to force ACK/NAK for checksum verification. The default value depends on the type of interface that is used. It is <code>True</code> if the interface is detected as serial and <code>False</code> otherwise.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/olxxa.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Communicate with a DC current source from Optronic Laboratories.\n\n    !!! warning\n        The connection interface must be selected (using the buttons on the\n        front panel) to be either RS-232 or IEEE-488 after the Current Source\n        is initially powered on. Even if this is the default power-on interface,\n        it must be manually re-selected before communication will work.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following\n    _properties_ for an Optronic Current Source, as well as the _properties_ for\n    [Serial][msl.equipment.interfaces.serial.Serial] if using RS-232 as the interface\n    or [GPIB][msl.equipment.interfaces.gpib.GPIB] if using IEEE-488 as the interface.\n\n    Attributes: Connection Properties:\n        address (int): Internal address of the device (RS-232 only). _Default: `1`_\n        delay (float): Number of seconds to wait between a write-read transaction (RS-232 only). _Default: `0.1`_\n        use_ack_nak (bool): Whether to force ACK/NAK for checksum verification. The default value\n            depends on the type of interface that is used. It is `True` if the interface is\n            detected as serial and `False` otherwise.\n    \"\"\"\n    super().__init__(equipment)\n\n    self._system_status_byte: int = 0\n    self._options: tuple[int, ...] = (40, 50, 60, 70, 80, 90, 95)\n    self._str_options: tuple[int, ...] = (60, 90, 95)\n\n    assert equipment.connection is not None  # noqa: S101\n    p = equipment.connection.properties\n    self._address: int = int(p.get(\"address\", 1))\n    self._delay: float = float(p.get(\"delay\", 0.1))\n    self._use_ack_nak: bool = p.get(\"use_ack_nak\", hasattr(self._interface, \"serial\"))\n\n    if self._use_ack_nak:\n        self.read_termination = struct.pack(\"B\", ETX)  # pyright: ignore[reportUnannotatedClassAttribute]\n        self.write_termination = None  # pyright: ignore[reportUnannotatedClassAttribute]\n</code></pre>"},{"location":"resources/optronic_labs/olxxa/#msl.equipment_resources.optronic_labs.olxxa.OLxxA.system_status_byte","title":"system_status_byte  <code>property</code>","text":"<pre><code>system_status_byte: int\n</code></pre> <p>The system status byte that is returned in every reply.</p> <p>It is constructed as follows:</p> <ul> <li>bit 7: Busy flag (the device is performing a function)</li> <li>bit 6: Reserved</li> <li>bit 5: Reserved</li> <li>bit 4: Lamp status (0=off, 1=on)</li> <li>bit 3: Reserved</li> <li>bit 2: Reserved</li> <li>bit 1: Seeking current (1=current is ramping)</li> <li>bit 0: Reserved</li> </ul>"},{"location":"resources/optronic_labs/olxxa/#msl.equipment_resources.optronic_labs.olxxa.OLxxA.get_current","title":"get_current","text":"<pre><code>get_current() -&gt; float\n</code></pre> <p>Get the output current.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/olxxa.py</code> <pre><code>def get_current(self) -&gt; float:\n    \"\"\"Get the output current.\"\"\"\n    self._send(b\"c\")\n    reply = self._receive(b\"c\")\n    return float(reply[0])\n</code></pre>"},{"location":"resources/optronic_labs/olxxa/#msl.equipment_resources.optronic_labs.olxxa.OLxxA.get_option","title":"get_option","text":"<pre><code>get_option(\n    lamp: int, option: Literal[40, 50, 70, 80]\n) -&gt; float\n</code></pre><pre><code>get_option(lamp: int, option: Literal[60, 90, 95]) -&gt; str\n</code></pre> <pre><code>get_option(\n    lamp: int, option: Literal[40, 50, 60, 70, 80, 90, 95]\n) -&gt; str | float\n</code></pre> <p>Get the value of a lamp configuration option.</p> <p>Parameters:</p> Name Type Description Default <code>lamp</code> <code>int</code> <p>The lamp number (between 0 and 9, inclusive).</p> required <code>option</code> <code>Literal[40, 50, 60, 70, 80, 90, 95]</code> <p>The option type to read. Must be one of the following values</p> <ul> <li><code>40</code>: Lamp Hours</li> <li><code>50</code>: Recalibration interval (hours)</li> <li><code>60</code>: Target units \u2192 <code>\"A\"</code>, <code>\"V\"</code> or <code>\"W\"</code></li> <li><code>70</code>: Target value</li> <li><code>80</code>: Current limit</li> <li><code>90</code>: Lamp description text</li> <li><code>95</code>: Wattage \u2192 <code>\"L\"</code> or <code>\"H\"</code></li> </ul> required <p>Returns:</p> Type Description <code>str | float</code> <p>The value of the <code>option</code> that was requested. The return type depends on the <code>option</code> value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/olxxa.py</code> <pre><code>def get_option(self, lamp: int, option: Literal[40, 50, 60, 70, 80, 90, 95]) -&gt; str | float:\n    \"\"\"Get the value of a lamp configuration option.\n\n    Args:\n        lamp: The lamp number (between 0 and 9, inclusive).\n        option: The option type to read. Must be one of the following values\n\n            * `40`: Lamp Hours\n            * `50`: Recalibration interval (hours)\n            * `60`: Target units &amp;#8594; `\"A\"`, `\"V\"` or `\"W\"`\n            * `70`: Target value\n            * `80`: Current limit\n            * `90`: Lamp description text\n            * `95`: Wattage &amp;#8594; `\"L\"` or `\"H\"`\n\n    Returns:\n        The value of the `option` that was requested. The return type depends on the `option` value.\n    \"\"\"\n    self._check_lamp_number(lamp)\n\n    if option not in self._options:\n        msg = f\"Invalid option value {option}\"\n        raise ValueError(msg)\n\n    msg = f\"Y {lamp:.0f} {option:.0f}\"\n    self._send(msg.encode(\"ascii\"))\n    reply = self._receive(b\"Y\")\n\n    if len(reply) == 3:  # noqa: PLR2004\n        num, dt, dv = reply\n    else:\n        num, dt = reply[:2]\n        dv = b\"\".join(reply[2:])\n\n    n = int(num)\n    if n != lamp:\n        msg = f\"Lamp number mismatch, {n} != {lamp}\"\n        raise MSLConnectionError(self, msg)\n\n    t = int(dt)\n    if t != option:\n        msg = f\"Data type mismatch, {t} != {option}\"\n        raise MSLConnectionError(self, msg)\n\n    if t in self._str_options:\n        return dv.decode(\"ascii\").strip(\"|\")\n    return float(dv)\n</code></pre>"},{"location":"resources/optronic_labs/olxxa/#msl.equipment_resources.optronic_labs.olxxa.OLxxA.get_voltage","title":"get_voltage","text":"<pre><code>get_voltage() -&gt; float\n</code></pre> <p>Get the output voltage.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/olxxa.py</code> <pre><code>def get_voltage(self) -&gt; float:\n    \"\"\"Get the output voltage.\"\"\"\n    self._send(b\"v\")\n    reply = self._receive(b\"v\")\n    return float(reply[0])\n</code></pre>"},{"location":"resources/optronic_labs/olxxa/#msl.equipment_resources.optronic_labs.olxxa.OLxxA.get_wattage","title":"get_wattage","text":"<pre><code>get_wattage() -&gt; float\n</code></pre> <p>Get the output wattage.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/olxxa.py</code> <pre><code>def get_wattage(self) -&gt; float:\n    \"\"\"Get the output wattage.\"\"\"\n    self._send(b\"w\")\n    reply = self._receive(b\"w\")\n    return float(reply[0])\n</code></pre>"},{"location":"resources/optronic_labs/olxxa/#msl.equipment_resources.optronic_labs.olxxa.OLxxA.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset the communication buffers.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/olxxa.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset the communication buffers.\"\"\"\n    self._send(b\"Z\")\n    _ = self._receive(b\"Z\")\n</code></pre>"},{"location":"resources/optronic_labs/olxxa/#msl.equipment_resources.optronic_labs.olxxa.OLxxA.select_lamp","title":"select_lamp","text":"<pre><code>select_lamp(lamp: int) -&gt; None\n</code></pre> <p>Select a lamp.</p> <p>Parameters:</p> Name Type Description Default <code>lamp</code> <code>int</code> <p>The lamp number (between 0 and 9, inclusive).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/olxxa.py</code> <pre><code>def select_lamp(self, lamp: int) -&gt; None:\n    \"\"\"Select a lamp.\n\n    Args:\n        lamp: The lamp number (between 0 and 9, inclusive).\n    \"\"\"\n    self._check_lamp_number(lamp)\n    msg = f\"S {lamp:.0f}\".encode(\"ascii\")\n\n    # selecting a lamp is buggy, so try to do it twice\n    try:\n        self._send(msg)\n        _ = self._receive(b\"S\")\n    except MSLConnectionError:\n        self._send(msg)\n        _ = self._receive(b\"S\")\n</code></pre>"},{"location":"resources/optronic_labs/olxxa/#msl.equipment_resources.optronic_labs.olxxa.OLxxA.set_current","title":"set_current","text":"<pre><code>set_current(amps: float) -&gt; float\n</code></pre> <p>Set the target output current.</p> <p>Parameters:</p> Name Type Description Default <code>amps</code> <code>float</code> <p>The target current, in Amps. If the value is above the target current limit for the presently selected lamp setup or if the value is less than the minimum supported current, the target current will not change.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The actual value of the output current after it was set.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/olxxa.py</code> <pre><code>def set_current(self, amps: float) -&gt; float:\n    \"\"\"Set the target output current.\n\n    Args:\n        amps: The target current, in Amps. If the value is above the target current limit for\n            the presently selected lamp setup or if the value is less than the minimum\n            supported current, the target current will not change.\n\n    Returns:\n        The actual value of the output current after it was set.\n    \"\"\"\n    msg = f\"C {amps:.5f}\"\n    self._send(msg.encode(\"ascii\"))\n    reply = self._receive(b\"C\")\n    return float(reply[0])\n</code></pre>"},{"location":"resources/optronic_labs/olxxa/#msl.equipment_resources.optronic_labs.olxxa.OLxxA.set_option","title":"set_option","text":"<pre><code>set_option(\n    lamp: int, option: int, value: str | float\n) -&gt; None\n</code></pre> <p>Set a value for one of the lamp configuration options.</p> <p>Parameters:</p> Name Type Description Default <code>lamp</code> <code>int</code> <p>The lamp number (between 0 and 9, inclusive).</p> required <code>option</code> <code>int</code> <p>The option type to update. Must be one of the following values.</p> <ul> <li><code>40</code>: Lamp Hours</li> <li><code>50</code>: Recalibration interval (hours)</li> <li><code>60</code>: Target units, <code>value</code> must be <code>\"A\"</code>, <code>\"V\"</code> or <code>\"W\"</code></li> <li><code>70</code>: Target value</li> <li><code>80</code>: Current limit</li> <li><code>90</code>: Lamp description text</li> <li><code>95</code>: Wattage, <code>value</code> must be <code>\"L\"</code> or <code>\"H\"</code></li> </ul> required <code>value</code> <code>str | float</code> <p>The value to write for <code>option</code>.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/olxxa.py</code> <pre><code>def set_option(self, lamp: int, option: int, value: str | float) -&gt; None:\n    \"\"\"Set a value for one of the lamp configuration options.\n\n    Args:\n        lamp: The lamp number (between 0 and 9, inclusive).\n        option: The option type to update. Must be one of the following values.\n\n            * `40`: Lamp Hours\n            * `50`: Recalibration interval (hours)\n            * `60`: Target units, `value` must be `\"A\"`, `\"V\"` or `\"W\"`\n            * `70`: Target value\n            * `80`: Current limit\n            * `90`: Lamp description text\n            * `95`: Wattage, `value` must be `\"L\"` or `\"H\"`\n\n        value: The value to write for `option`.\n    \"\"\"\n    self._check_lamp_number(lamp)\n    if option not in self._options:\n        msg = f\"Invalid option value {option}\"\n        raise ValueError(msg)\n\n    msg = f\"X {lamp:.0f} {option:.0f} {value}\"\n    self._send(msg.encode(\"ascii\"))\n    _ = self._receive(b\"X\")\n</code></pre>"},{"location":"resources/optronic_labs/olxxa/#msl.equipment_resources.optronic_labs.olxxa.OLxxA.set_voltage","title":"set_voltage","text":"<pre><code>set_voltage(volts: float) -&gt; float\n</code></pre> <p>Set the target output voltage.</p> <p>Parameters:</p> Name Type Description Default <code>volts</code> <code>float</code> <p>The target voltage, in Volts. If the value is above the target voltage limit for the presently selected lamp setup or if the value is less than the minimum supported voltage, the target voltage will not change.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The actual value of the output voltage after it was set.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/olxxa.py</code> <pre><code>def set_voltage(self, volts: float) -&gt; float:\n    \"\"\"Set the target output voltage.\n\n    Args:\n        volts: The target voltage, in Volts. If the value is above the\n            target voltage limit for the presently selected lamp setup or if\n            the value is less than the minimum supported voltage, the target\n            voltage will not change.\n\n    Returns:\n        The actual value of the output voltage after it was set.\n    \"\"\"\n    msg = f\"V {volts:.5f}\"\n    self._send(msg.encode(\"ascii\"))\n    reply = self._receive(b\"V\")\n    return float(reply[0])\n</code></pre>"},{"location":"resources/optronic_labs/olxxa/#msl.equipment_resources.optronic_labs.olxxa.OLxxA.set_wattage","title":"set_wattage","text":"<pre><code>set_wattage(watts: float) -&gt; float\n</code></pre> <p>Set the target output wattage.</p> <p>Parameters:</p> Name Type Description Default <code>watts</code> <code>float</code> <p>The target wattage, in Watts. If the value is above the target wattage limit for the presently selected lamp setup or if the value is less than the minimum supported wattage, the target wattage will not change.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The actual value of the output wattage after it was set.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/olxxa.py</code> <pre><code>def set_wattage(self, watts: float) -&gt; float:\n    \"\"\"Set the target output wattage.\n\n    Args:\n        watts: The target wattage, in Watts. If the value is above the\n            target wattage limit for the presently selected lamp setup or if\n            the value is less than the minimum supported wattage, the target\n            wattage will not change.\n\n    Returns:\n        The actual value of the output wattage after it was set.\n    \"\"\"\n    msg = f\"W {watts:.5f}\"\n    self._send(msg.encode(\"ascii\"))\n    reply = self._receive(b\"W\")\n    return float(reply[0])\n</code></pre>"},{"location":"resources/optronic_labs/olxxa/#msl.equipment_resources.optronic_labs.olxxa.OLxxA.state","title":"state","text":"<pre><code>state() -&gt; bool\n</code></pre> <p>Returns whether the output is on or off.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/olxxa.py</code> <pre><code>def state(self) -&gt; bool:\n    \"\"\"Returns whether the output is on or off.\"\"\"\n    self._send(b\"b\")\n    reply = self._receive(b\"b\")\n    return reply[0] == b\"1\"\n</code></pre>"},{"location":"resources/optronic_labs/olxxa/#msl.equipment_resources.optronic_labs.olxxa.OLxxA.target_info","title":"target_info","text":"<pre><code>target_info() -&gt; LampInfo\n</code></pre> <p>Get the target information of the currently-selected lamp.</p> <p>Returns:</p> Type Description <code>LampInfo</code> <p>The target information.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/olxxa.py</code> <pre><code>def target_info(self) -&gt; LampInfo:\n    \"\"\"Get the target information of the currently-selected lamp.\n\n    Returns:\n        The target information.\n    \"\"\"\n    self._send(b\"t\")\n    number, value, unit = self._receive(b\"t\")\n    return LampInfo(number=int(number), value=float(value), unit=unit.decode(\"ascii\"))\n</code></pre>"},{"location":"resources/optronic_labs/olxxa/#msl.equipment_resources.optronic_labs.olxxa.OLxxA.turn_off","title":"turn_off","text":"<pre><code>turn_off() -&gt; None\n</code></pre> <p>Turn the output off.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/olxxa.py</code> <pre><code>def turn_off(self) -&gt; None:\n    \"\"\"Turn the output off.\"\"\"\n    self._send(b\"B 0\")\n    _ = self._receive(b\"B\")\n</code></pre>"},{"location":"resources/optronic_labs/olxxa/#msl.equipment_resources.optronic_labs.olxxa.OLxxA.turn_on","title":"turn_on","text":"<pre><code>turn_on() -&gt; None\n</code></pre> <p>Turn the output on.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/olxxa.py</code> <pre><code>def turn_on(self) -&gt; None:\n    \"\"\"Turn the output on.\"\"\"\n    self._send(b\"B 1\")\n    _ = self._receive(b\"B\")\n</code></pre>"},{"location":"resources/optronic_labs/olxxa/#msl.equipment_resources.optronic_labs.olxxa.OLxxA.zero_voltage_monitor","title":"zero_voltage_monitor","text":"<pre><code>zero_voltage_monitor() -&gt; None\n</code></pre> <p>Zero the voltage monitor.</p> Source code in <code>packages/resources/src/msl/equipment_resources/optronic_labs/olxxa.py</code> <pre><code>def zero_voltage_monitor(self) -&gt; None:\n    \"\"\"Zero the voltage monitor.\"\"\"\n    self._send(b\"D\")\n    _ = self._receive(b\"D\")\n</code></pre>"},{"location":"resources/picotech/picoscope/","title":"PicoScope","text":"<p>A wrapper around the PicoScope SDK.</p> <p>The main class is PicoScope. The other classes are enumerations and structs from the SDK. Version 11.1.0.418 of the SDK was used as a reference.</p> <p>Warning</p> <p>This class was written for the ps5000a SDK. Different SDKs (e.g., ps4000a) have similar function signatures and may or may not work with this class. Note that Pico Technology have their own repository to support their products.</p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.BandwidthLimiter","title":"BandwidthLimiter","text":"<p>               Bases: <code>IntEnum</code></p> <p>The hardware bandwidth limiter fitted to each analogue input channel.</p> <p>Attributes:</p> Name Type Description <code>BW_FULL</code> <code>int</code> <p>Use the scope's full specified bandwidth. <code>0</code></p> <code>BW_20MHZ</code> <code>int</code> <p>Enable the hardware 20 MHz bandwidth limiter. <code>1</code></p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.Channel","title":"Channel","text":"<p>               Bases: <code>IntEnum</code></p> <p>An analogue input channel, 8-bit digital port or other input.</p> <p>Attributes:</p> Name Type Description <code>A</code> <code>int</code> <p>Analogue channel A. <code>0</code></p> <code>B</code> <code>int</code> <p>Analogue channel B. <code>1</code></p> <code>C</code> <code>int</code> <p>Analogue channel C. <code>2</code></p> <code>D</code> <code>int</code> <p>Analogue channel D. <code>3</code></p> <code>EXT</code> <code>int</code> <p>External trigger input; not on MSOs. <code>4</code></p> <code>MAX_CHANNELS</code> <code>int</code> <p><code>4</code></p> <code>TRIGGER_AUX</code> <code>int</code> <p>Reserved. <code>5</code></p> <code>MAX_TRIGGER_SOURCES</code> <code>int</code> <p><code>6</code></p> <code>PORT0</code> <code>int</code> <p>Digital port 0, inputs D0-D7, MSO models only. <code>0x80</code></p> <code>PORT1</code> <code>int</code> <p>Digital port 1, inputs D8-D15, MSO models only. <code>0x81</code></p> <code>PORT2</code> <code>int</code> <p>Reserved. <code>0x82</code></p> <code>PORT3</code> <code>int</code> <p>Reserved. <code>0x83</code></p> <code>PULSE_WIDTH_SOURCE</code> <code>int</code> <p>Pulse width qualifier. <code>0x10000000</code></p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.ChannelFlags","title":"ChannelFlags","text":"<p>               Bases: <code>IntFlag</code></p> <p>Channel flags enum.</p> <p>Attributes:</p> Name Type Description <code>A</code> <code>int</code> <p>Analogue channel A. <code>1</code></p> <code>B</code> <code>int</code> <p>Analogue channel B. <code>2</code></p> <code>C</code> <code>int</code> <p>Analogue channel C. <code>4</code></p> <code>D</code> <code>int</code> <p>Analogue channel D. <code>8</code></p> <code>PORT0</code> <code>int</code> <p>Digital port 0, inputs D0-D7, MSO models only. <code>0x10000</code></p> <code>PORT1</code> <code>int</code> <p>Digital port 1, inputs D8-D15, MSO models only. <code>0x20000</code></p> <code>PORT2</code> <code>int</code> <p>Reserved. <code>0x40000</code></p> <code>PORT3</code> <code>int</code> <p>Reserved. <code>0x80000</code></p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.ChannelInfo","title":"ChannelInfo","text":"<p>               Bases: <code>IntEnum</code></p> <p>Channel info enum.</p> <p>Attributes:</p> Name Type Description <code>RANGES</code> <code>int</code> <p>Supported channel ranges. <code>0</code></p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.ChannelSettings","title":"ChannelSettings","text":"<pre><code>ChannelSettings(\n    *,\n    bandwidth: BandwidthLimiter,\n    channel: Channel,\n    enabled: bool,\n    coupling: Coupling,\n    voltage_range: float,\n    voltage_offset: float,\n    max_adu_value: int\n)\n</code></pre> <p>The settings for a channel.</p> <p>Do not instantiate this class directly. Created when set_channel is called.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel</code> <p>The channel.</p> required <code>bandwidth</code> <code>BandwidthLimiter</code> <p>The bandwidth limiter that is used.</p> required <code>enabled</code> <code>bool</code> <p>Whether the channel is enabled.</p> required <code>coupling</code> <code>Coupling</code> <p>The impedance and coupling type.</p> required <code>voltage_range</code> <code>float</code> <p>The voltage range, in Volts.</p> required <code>voltage_offset</code> <code>float</code> <p>The voltage offset, in Volts.</p> required <code>max_adu_value</code> <code>int</code> <p>The maximum analogue-to-digital value.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def __init__(\n    self,\n    *,\n    bandwidth: BandwidthLimiter,\n    channel: Channel,\n    enabled: bool,\n    coupling: Coupling,\n    voltage_range: float,\n    voltage_offset: float,\n    max_adu_value: int,\n) -&gt; None:\n    \"\"\"Information about a PicoScope channel.\n\n    Do not instantiate this class directly. Created when\n    [set_channel][msl.equipment_resources.picotech.picoscope.PicoScope.set_channel]\n    is called.\n\n    Args:\n        channel: The channel.\n        bandwidth: The bandwidth limiter that is used.\n        enabled: Whether the channel is enabled.\n        coupling: The impedance and coupling type.\n        voltage_range: The voltage range, in Volts.\n        voltage_offset: The voltage offset, in Volts.\n        max_adu_value: The maximum analogue-to-digital value.\n    \"\"\"\n    self.channel: Channel = channel\n    \"\"\"The channel.\"\"\"\n\n    self.enabled: bool = enabled\n    \"\"\"Whether the channel is enabled.\"\"\"\n\n    self.bandwidth: BandwidthLimiter = bandwidth\n    \"\"\"The bandwidth limiter that is used.\"\"\"\n\n    self.coupling: Coupling = coupling\n    \"\"\"The impedance and coupling type.\"\"\"\n\n    self.voltage_range: float = voltage_range\n    \"\"\"The voltage range, in Volts.\"\"\"\n\n    self.voltage_offset: float = voltage_offset\n    \"\"\"The voltage offset, in Volts.\"\"\"\n\n    self.volts_per_adu: float = voltage_range / float(max_adu_value)\n    \"\"\"The voltage/ADU factor.\"\"\"\n\n    # the raw data in analogue-to-digital units\n    self._adu_values: NDArray[np.int16] = np.empty((0, 0), dtype=np.int16)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.ChannelSettings.adu","title":"adu  <code>property</code>","text":"<pre><code>adu: NDArray[int16]\n</code></pre> <p>The samples in ADU counts.</p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.ChannelSettings.bandwidth","title":"bandwidth  <code>instance-attribute</code>","text":"<pre><code>bandwidth: BandwidthLimiter = bandwidth\n</code></pre> <p>The bandwidth limiter that is used.</p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.ChannelSettings.buffer","title":"buffer  <code>property</code>","text":"<pre><code>buffer: NDArray[int16]\n</code></pre> <p>An alias for the samples in ADU counts.</p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.ChannelSettings.channel","title":"channel  <code>instance-attribute</code>","text":"<pre><code>channel: Channel = channel\n</code></pre> <p>The channel.</p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.ChannelSettings.coupling","title":"coupling  <code>instance-attribute</code>","text":"<pre><code>coupling: Coupling = coupling\n</code></pre> <p>The impedance and coupling type.</p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.ChannelSettings.enabled","title":"enabled  <code>instance-attribute</code>","text":"<pre><code>enabled: bool = enabled\n</code></pre> <p>Whether the channel is enabled.</p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.ChannelSettings.num_samples","title":"num_samples  <code>property</code>","text":"<pre><code>num_samples: int\n</code></pre> <p>The number of samples to acquire for this channel.</p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.ChannelSettings.voltage_offset","title":"voltage_offset  <code>instance-attribute</code>","text":"<pre><code>voltage_offset: float = voltage_offset\n</code></pre> <p>The voltage offset, in Volts.</p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.ChannelSettings.voltage_range","title":"voltage_range  <code>instance-attribute</code>","text":"<pre><code>voltage_range: float = voltage_range\n</code></pre> <p>The voltage range, in Volts.</p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.ChannelSettings.volts","title":"volts  <code>property</code>","text":"<pre><code>volts: NDArray[floating]\n</code></pre> <p>The samples in volts.</p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.ChannelSettings.volts_per_adu","title":"volts_per_adu  <code>instance-attribute</code>","text":"<pre><code>volts_per_adu: float = voltage_range / float(max_adu_value)\n</code></pre> <p>The voltage/ADU factor.</p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.ChannelSettings.allocate","title":"allocate","text":"<pre><code>allocate(num_samples: int, num_captures: int = 1) -&gt; None\n</code></pre> <p>Maybe allocate memory to save the samples (if the array needs to be resized).</p> <p>Parameters:</p> Name Type Description Default <code>num_samples</code> <code>int</code> <p>The number of samples.</p> required <code>num_captures</code> <code>int</code> <p>The number of captures.</p> <code>1</code> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def allocate(self, num_samples: int, num_captures: int = 1) -&gt; None:\n    \"\"\"Maybe allocate memory to save the samples (if the array needs to be resized).\n\n    Args:\n        num_samples: The number of samples.\n        num_captures: The number of captures.\n    \"\"\"\n    if self._adu_values.size != num_captures * num_samples:\n        if num_captures == 1:\n            self._adu_values = np.empty(num_samples, dtype=np.int16)\n        else:\n            self._adu_values = np.empty((num_captures, num_samples), dtype=np.int16)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.Condition","title":"Condition","text":"<pre><code>Condition(\n    source: Channel | str | int,\n    condition: TriggerState | str | int = \"DONT_CARE\",\n)\n</code></pre> <p>               Bases: <code>Structure</code></p> <p>Trigger condition.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Channel | str | int</code> <p>The channel to use for the condition. Can be an enum member name (case insensitive) or value.</p> required <code>condition</code> <code>TriggerState | str | int</code> <p>The trigger state of the <code>source</code>. Can be an enum member name (case insensitive) or value.</p> <code>'DONT_CARE'</code> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def __init__(self, source: Channel | str | int, condition: TriggerState | str | int = \"DONT_CARE\") -&gt; None:\n    \"\"\"Trigger condition.\n\n    Args:\n        source: The channel to use for the condition. Can be an enum member name (case insensitive) or value.\n        condition: The trigger state of the `source`. Can be an enum member name (case insensitive) or value.\n    \"\"\"\n    self.source: int = to_enum(source, Channel, to_upper=True)\n    self.condition: int = to_enum(condition, TriggerState, to_upper=True)\n    super().__init__(source=self.source, condition=self.condition)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.ConditionsInfo","title":"ConditionsInfo","text":"<p>               Bases: <code>IntEnum</code></p> <p>Specify what to do with any existing trigger conditions that you have previously set up.</p> <p>Attributes:</p> Name Type Description <code>CLEAR</code> <code>int</code> <p>Clear existing trigger logic and replace with the new condition. <code>1</code></p> <code>ADD</code> <code>int</code> <p>Add the new condition, using Boolean OR, to the existing trigger logic. <code>2</code></p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.Coupling","title":"Coupling","text":"<p>               Bases: <code>IntEnum</code></p> <p>Input coupling modes for each analogue channel.</p> <p>Attributes:</p> Name Type Description <code>AC</code> <code>int</code> <p>AC coupling. <code>0</code></p> <code>DC</code> <code>int</code> <p>DC coupling. <code>1</code></p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.DeviceResolution","title":"DeviceResolution","text":"<p>               Bases: <code>IntEnum</code></p> <p>Resolution of the sampling hardware in the oscilloscope.</p> <p>Attributes:</p> Name Type Description <code>DR_8BIT</code> <code>int</code> <p><code>0</code></p> <code>DR_12BIT</code> <code>int</code> <p><code>1</code></p> <code>DR_14BIT</code> <code>int</code> <p><code>2</code></p> <code>DR_15BIT</code> <code>int</code> <p><code>3</code></p> <code>DR_16BIT</code> <code>int</code> <p><code>4</code></p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.DigitalChannelDirections","title":"DigitalChannelDirections","text":"<pre><code>DigitalChannelDirections(\n    channel: int, direction: DigitalDirection | str | int\n)\n</code></pre> <p>               Bases: <code>Structure</code></p> <p>The trigger direction for the specified digital channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The digital channel number.</p> required <code>direction</code> <code>DigitalDirection | str | int</code> <p>The direction in which the digital input must cross the threshold(s) to cause a trigger event. Can be an enum member name (case insensitive) or value.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def __init__(\n    self,\n    channel: int,\n    direction: DigitalDirection | str | int,\n) -&gt; None:\n    \"\"\"The trigger direction for the specified digital channel.\n\n    Args:\n        channel: The digital channel number.\n        direction: The direction in which the digital input must cross the threshold(s) to cause a trigger event.\n            Can be an enum member name (case insensitive) or value.\n    \"\"\"\n    self.channel: int = channel\n    self.direction: int = to_enum(direction, DigitalDirection, to_upper=True)\n    super().__init__(channel=channel, direction=self.direction)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.DigitalDirection","title":"DigitalDirection","text":"<p>               Bases: <code>IntEnum</code></p> <p>The polarity of a digital channel used as a trigger source.</p> <p>Attributes:</p> Name Type Description <code>DONT_CARE</code> <code>int</code> <p>Ignore input. <code>0</code></p> <code>LOW</code> <code>int</code> <p>Input must be low. <code>1</code></p> <code>HIGH</code> <code>int</code> <p>Input must be high. <code>2</code></p> <code>RISING</code> <code>int</code> <p>Input must have a rising edge. <code>3</code></p> <code>FALLING</code> <code>int</code> <p>Input must have a falling edge. <code>4</code></p> <code>RISING_OR_FALLING</code> <code>int</code> <p>Input must have an edge of either polarity. <code>5</code></p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.Direction","title":"Direction","text":"<pre><code>Direction(\n    source: Channel | str | int,\n    direction: ThresholdDirection | str | int = \"rising\",\n    mode: ThresholdMode | str | int = \"level\",\n)\n</code></pre> <p>               Bases: <code>Structure</code></p> <p>The direction in which the specified source signal must cross the threshold(s) to produce a trigger event.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Channel | str | int</code> <p>The channel to use for the trigger source. Can be an enum member name (case insensitive) or value.</p> required <code>direction</code> <code>ThresholdDirection | str | int</code> <p>The direction in which the signal must cross the threshold. Can be an enum member name (case insensitive) or value.</p> <code>'rising'</code> <code>mode</code> <code>ThresholdMode | str | int</code> <p>Whether to use a level trigger (a single threshold) or a window trigger (two thresholds defining a range).</p> <code>'level'</code> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def __init__(\n    self,\n    source: Channel | str | int,\n    direction: ThresholdDirection | str | int = \"rising\",\n    mode: ThresholdMode | str | int = \"level\",\n) -&gt; None:\n    \"\"\"The direction in which the specified source signal must cross the threshold(s) to produce a trigger event.\n\n    Args:\n        source: The channel to use for the trigger source. Can be an enum member name (case insensitive) or value.\n        direction: The direction in which the signal must cross the threshold. Can be an enum member name\n            (case insensitive) or value.\n        mode: Whether to use a level trigger (a single threshold) or a window trigger\n            (two thresholds defining a range).\n    \"\"\"\n    self.source: int = to_enum(source, Channel, to_upper=True)\n    self.direction: int = to_enum(direction, ThresholdDirection, to_upper=True)\n    self.mode: int = to_enum(mode, ThresholdMode, to_upper=True)\n    super().__init__(source=self.source, direction=self.direction, mode=self.mode)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.ETSMode","title":"ETSMode","text":"<p>               Bases: <code>IntEnum</code></p> <p>ETS (equivalent-time sampling) mode.</p> <p>Attributes:</p> Name Type Description <code>OFF</code> <code>int</code> <p>ETS disabled. <code>0</code></p> <code>FAST</code> <code>int</code> <p>Return ready as soon as requested number of interleaves is available. <code>1</code></p> <code>SLOW</code> <code>int</code> <p>Return ready every time a new set of <code>no_of_cycles</code> is collected. <code>2</code></p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.ExtraOperations","title":"ExtraOperations","text":"<p>               Bases: <code>IntEnum</code></p> <p>Additional signal types for the signal generator.</p> <p>Attributes:</p> Name Type Description <code>OFF</code> <code>int</code> <p>Normal signal generator operation. <code>0</code></p> <code>WHITENOISE</code> <code>int</code> <p>Produces white noise. <code>1</code></p> <code>PRBS</code> <code>int</code> <p>Produces a pseudo-random binary sequence. <code>2</code></p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.IndexMode","title":"IndexMode","text":"<p>               Bases: <code>IntEnum</code></p> <p>Index mode used by the arbitrary waveform generator.</p> <p>Attributes:</p> Name Type Description <code>SINGLE</code> <code>int</code> <p>The generator outputs the raw contents of the buffer repeatedly. This mode is the only one that can generate asymmetrical waveforms. You can also use this mode for symmetrical waveforms, but the <code>DUAL</code> mode makes more efficient use of the buffer memory. <code>0</code></p> <code>DUAL</code> <code>int</code> <p>The generator outputs the contents of the buffer from beginning to end, and then does a second pass in the reverse direction through the buffer. This allows you to specify only the first half of a waveform with twofold symmetry, such as a Gaussian function, and let the generator fill in the other half. <code>1</code></p> <code>QUAD</code> <code>int</code> <p>Not used. <code>2</code></p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope","title":"PicoScope","text":"<pre><code>PicoScope(equipment: Equipment)\n</code></pre> <p>               Bases: <code>SDK</code></p> <p>A wrapper around the PicoScope API Series SDK.</p> <p>Warning</p> <p>This class was written for the ps5000a SDK. Different SDKs (e.g., ps4000a) have similar function signatures and may or may not work with this class. Note that Pico Technology have their own repository to support their products.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for a PicoScope.</p> <p>Connection Properties:</p> Name Type Description <code>auto_select_power</code> <code>bool</code> <p>PicoScopes that can be powered by either DC power or by USB power may raise an exception if the DC power supply is not connected. Setting <code>auto_select_power</code> to <code>True</code> will automatically switch to the USB power source. Default: <code>True</code></p> <code>resolution</code> <code>str</code> <p>The device resolution (bit depth). Possible values are <code>8bit</code>, <code>12bit</code>, <code>14bit</code>, <code>15bit</code> or <code>16bit</code>. Default: <code>12bit</code></p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"A wrapper around the PicoScope API Series SDK.\n\n    !!! warning\n        This class was written for the ps5000a SDK. Different SDKs (e.g., ps4000a) have\n        similar function signatures and may or may not work with this class. Note that Pico\n        Technology have their own [repository](https://github.com/picotech){:target=\"_blank\"}\n        to support their products.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for a PicoScope.\n\n    Attributes: Connection Properties:\n        auto_select_power (bool): PicoScopes that can be powered by either DC power or by USB power\n            may raise an exception if the DC power supply is not connected. Setting `auto_select_power`\n            to `True` will automatically switch to the USB power source. _Default: `True`_\n        resolution (str): The device resolution (bit depth).\n            Possible values are `8bit`, `12bit`, `14bit`, `15bit` or `16bit`. _Default: `12bit`_\n    \"\"\"\n    self._handle: int = -1\n    super().__init__(equipment, libtype=\"windll\" if IS_WINDOWS else \"cdll\")\n    self._prefix: str = Path(self.path).stem.lower()\n    _configure(self._prefix, self.sdk, self._errcheck_api)\n\n    assert equipment.connection is not None  # noqa: S101\n    props = equipment.connection.properties\n    dr = props.get(\"resolution\", DeviceResolution.DR_12BIT)\n    resolution = to_enum(dr, DeviceResolution, to_upper=True, prefix=\"DR_\")\n\n    handle = c_int16()\n    serial = create_string_buffer(self.equipment.serial.encode())\n    if self._prefix in {\"ps5000a\", \"ps6000a\"}:\n        power_state = self._f(\"OpenUnit\", byref(handle), serial, resolution)\n    else:\n        power_state = self._f(\"OpenUnit\", byref(handle), serial)\n    self._handle = handle.value\n\n    # Check for PICO_POWER_SUPPLY_NOT_CONNECTED, PICO_USB3_0_DEVICE_NON_USB3_0_PORT\n    if power_state in {0x11A, 0x11E}:\n        if not props.get(\"auto_select_power\", True):\n            raise MSLConnectionError(self, Error[power_state])\n        self._f(\"ChangePowerSource\", self._handle, power_state)\n    elif power_state != PICO_OK:\n        raise MSLConnectionError(self, Error[power_state])\n\n    self._channels: dict[str, ChannelSettings] = {}\n    self._num_captures: int = 1\n    self._pre_trigger: float = 0.0\n    self._buffer_size: int = -1\n    self._error_code: int = 0\n\n    # the following are re-defined by calling set_timebase()\n    self._sampling_interval: float = -1.0\n    self._streaming_sampling_interval: int = -1\n    self._num_samples: int = -1\n    self._timebase_index: int = -1\n    self._streaming_time_units: _TimeUnits = _TimeUnits.S\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.channel","title":"channel  <code>property</code>","text":"<pre><code>channel: dict[str, ChannelSettings]\n</code></pre> <p>The configuration settings of each channel.</p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.dt","title":"dt  <code>property</code>","text":"<pre><code>dt: float\n</code></pre> <p>The time interval between samples (i.e., \u0394t).</p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.pre_trigger","title":"pre_trigger  <code>property</code>","text":"<pre><code>pre_trigger: float\n</code></pre> <p>The number of seconds that samples were acquired for before the trigger event.</p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.streaming_done","title":"streaming_done  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>streaming_done: bool = False\n</code></pre> <p>Whether streaming mode has finished acquiring the samples.</p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.channel_combinations_stateless","title":"channel_combinations_stateless","text":"<pre><code>channel_combinations_stateless(\n    *,\n    dt: float,\n    resolution: DeviceResolution | str | int,\n    ac_adaptor: bool = False\n) -&gt; ChannelFlags\n</code></pre> <p>Get the channel and port combination flags for a proposed device configuration.</p> <p>It does not write the configuration to the device.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>float</code> <p>The proposed sampling interval, in seconds.</p> required <code>resolution</code> <code>DeviceResolution | str | int</code> <p>The resolution mode in which you propose to operate the oscilloscope. Can be an enum member name (case insensitive, with or without the \"DR_\" prefix) or value.</p> required <code>ac_adaptor</code> <code>bool</code> <p>Whether the proposed configuration uses the external AC adaptor or not.</p> <code>False</code> <p>Returns:</p> Type Description <code>ChannelFlags</code> <p>The channel and port combination flags.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def channel_combinations_stateless(\n    self, *, dt: float, resolution: DeviceResolution | str | int, ac_adaptor: bool = False\n) -&gt; ChannelFlags:\n    \"\"\"Get the channel and port combination flags for a proposed device configuration.\n\n    It does not write the configuration to the device.\n\n    Args:\n        dt: The proposed sampling interval, in seconds.\n        resolution: The resolution mode in which you propose to operate the oscilloscope.\n            Can be an enum member name (case insensitive, with or without the \"DR_\" prefix) or value.\n        ac_adaptor: Whether the proposed configuration uses the external AC adaptor or not.\n\n    Returns:\n        The channel and port combination flags.\n    \"\"\"\n    n_combos = c_uint32()\n    resolution = to_enum(resolution, DeviceResolution, prefix=\"DR_\", to_upper=True)\n    timebase = round(self._get_timebase_index(float(dt), resolution))\n    ac = int(ac_adaptor)\n\n    self._f(\"ChannelCombinationsStateless\", self._handle, None, byref(n_combos), resolution, timebase, ac)\n\n    c_flags = (c_uint32 * n_combos.value)()\n    self._f(\"ChannelCombinationsStateless\", self._handle, c_flags, byref(n_combos), resolution, timebase, ac)\n\n    flags = [ChannelFlags(flag) for flag in sorted(c_flags)]\n    if not flags:  # ideally, the SDK would return a non-zero PICO_STATUS value before this check\n        msg = \"No channel combinations for the proposed settings\"\n        raise MSLConnectionError(self, msg)\n\n    combo = flags[0]\n    for f in flags[1:]:\n        combo |= f\n    return combo\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.check_for_update","title":"check_for_update","text":"<pre><code>check_for_update() -&gt; tuple[str, str, bool]\n</code></pre> <p>Check if the firmware version requires an update.</p> <p>Returns:</p> Type Description <code>tuple[str, str, bool]</code> <p>The current version, the latest version and whether an update is required, i.e., <code>(current, latest, is_required)</code>.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def check_for_update(self) -&gt; tuple[str, str, bool]:\n    \"\"\"Check if the firmware version requires an update.\n\n    Returns:\n        The current version, the latest version and whether an update is required,\n            i.e., `(current, latest, is_required)`.\n    \"\"\"\n    current = (c_uint16 * 4)()\n    latest = (c_uint16 * 4)()\n    required = c_uint16()\n    self._f(\"CheckForUpdate\", self._handle, byref(current), byref(latest), byref(required))\n    current_str = \".\".join(str(x) for x in current)\n    latest_str = \".\".join(str(x) for x in latest)\n    return current_str, latest_str, bool(required.value)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the PicoScope.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Disconnect from the PicoScope.\"\"\"\n    if self._handle &gt;= 0:\n        self._f(\"CloseUnit\", self._handle)\n        self._handle = -1\n        super().disconnect()\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.enumerate_units","title":"enumerate_units  <code>staticmethod</code>","text":"<pre><code>enumerate_units(path: PathLike) -&gt; list[str]\n</code></pre> <p>Find PicoScopes that are connected to the computer.</p> <p>Note</p> <p>You cannot call this function after you have opened a connection to a PicoScope.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>PathLike</code> <p>The path to the Pico Technology SDK of the scope models to find. You may specify the filename (e.g., <code>ps5000a</code>) if the parent directory is available on the PATH environment variable.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of serial numbers of the PicoScopes that were found.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>@staticmethod\ndef enumerate_units(path: PathLike) -&gt; list[str]:\n    \"\"\"Find PicoScopes that are connected to the computer.\n\n    !!! note\n        You cannot call this function after you have opened a connection to a PicoScope.\n\n    Args:\n        path: The path to the Pico Technology SDK of the scope models to find.\n            You may specify the filename (e.g., `ps5000a`) if the parent directory\n            is available on the PATH environment variable.\n\n    Returns:\n        A list of serial numbers of the PicoScopes that were found.\n    \"\"\"\n    count = c_int16()\n    serials = create_string_buffer(1024)\n    size = c_int16(len(serials))\n    sdk = LoadLibrary(path, libtype=\"windll\" if IS_WINDOWS else \"cdll\")\n    prefix = Path(sdk.path).stem.lower()\n    result = getattr(sdk.lib, prefix + \"EnumerateUnits\")(byref(count), serials, byref(size))\n    if result == PICO_OK:\n        return serials.value.decode(\"utf-8\").split(\",\")\n\n    msg = Error.get(result, f\"UnknownPicoTechError: Error code 0x{result:08x}\")\n    raise OSError(msg)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.flash_led","title":"flash_led","text":"<pre><code>flash_led(start: int) -&gt; None\n</code></pre> <p>Flashes the LED on the front of the scope without blocking the calling thread.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>int</code> <p>The action required:</p> <ul> <li>&lt; 0: flash the LED indefinitely</li> <li>= 0: stop the LED flashing</li> <li>&gt; 0: flash the LED <code>start</code> times. If the LED is already flashing, the     count will reset to <code>start</code>.</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def flash_led(self, start: int) -&gt; None:\n    \"\"\"Flashes the LED on the front of the scope without blocking the calling thread.\n\n    Args:\n        start: The action required:\n\n            * &amp;lt; 0: flash the LED indefinitely\n            * = 0: stop the LED flashing\n            * &amp;gt; 0: flash the LED `start` times. If the LED is already flashing, the\n                count will reset to `start`.\n\n    \"\"\"\n    self._f(\"FlashLed\", self._handle, start)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.get_analogue_offset","title":"get_analogue_offset","text":"<pre><code>get_analogue_offset(\n    range: Range | str | int,\n    coupling: Coupling | str | int = \"dc\",\n) -&gt; tuple[float, float]\n</code></pre> <p>Get the minimum and maximum allowable analogue offset for a specific voltage range.</p> <p>Parameters:</p> Name Type Description Default <code>range</code> <code>Range | str | int</code> <p>The input voltage range. Can be an enum member name (with or without the <code>\"R_\"</code> prefix) or value.</p> required <code>coupling</code> <code>Coupling | str | int</code> <p>The impedance and coupling type. Can be an enum member name (case insensitive) or value.</p> <code>'dc'</code> <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>The <code>(minimum, maximum)</code> offset values.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def get_analogue_offset(\n    self,\n    range: Range | str | int,  # noqa: A002\n    coupling: Coupling | str | int = \"dc\",\n) -&gt; tuple[float, float]:\n    \"\"\"Get the minimum and maximum allowable analogue offset for a specific voltage range.\n\n    Args:\n        range: The input voltage range. Can be an enum member name (with or without the `\"R_\"` prefix) or value.\n        coupling: The impedance and coupling type. Can be an enum member name (case insensitive) or value.\n\n    Returns:\n        The `(minimum, maximum)` offset values.\n    \"\"\"\n    _range = to_enum(range, Range, prefix=\"R_\")\n    _coupling = to_enum(coupling, Coupling, to_upper=True)\n    maximum = c_float()\n    minimum = c_float()\n    self._f(\"GetAnalogueOffset\", self._handle, _range, _coupling, byref(maximum), byref(minimum))\n    return minimum.value, maximum.value\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.get_channel_information","title":"get_channel_information","text":"<pre><code>get_channel_information(\n    channel: Channel | str | int,\n    info: ChannelInfo | str | int = \"ranges\",\n) -&gt; list[int]\n</code></pre> <p>Get information about a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel | str | int</code> <p>The channel to get the ranges of. Can be an enum member name (case insensitive) or value.</p> required <code>info</code> <code>ChannelInfo | str | int</code> <p>The information to get for the <code>channel</code>. Can be an enum member name (case insensitive) or value.</p> <code>'ranges'</code> <p>Returns:</p> Type Description <code>list[int]</code> <p>The information that was requested.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def get_channel_information(\n    self, channel: Channel | str | int, info: ChannelInfo | str | int = \"ranges\"\n) -&gt; list[int]:\n    \"\"\"Get information about a channel.\n\n    Args:\n        channel: The channel to get the ranges of. Can be an enum member name (case insensitive) or value.\n        info: The information to get for the `channel`. Can be an enum member name (case insensitive) or value.\n\n    Returns:\n        The information that was requested.\n    \"\"\"\n    ch = to_enum(channel, Channel, to_upper=True)\n    info = to_enum(info, ChannelInfo, to_upper=True)\n    c_array = (c_int32 * 50)()\n    length = c_int32(len(c_array))\n    self._f(\"GetChannelInformation\", self._handle, info, 0, c_array, byref(length), ch)\n    return [c_array[i] for i in range(length.value)]\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.get_device_resolution","title":"get_device_resolution","text":"<pre><code>get_device_resolution() -&gt; DeviceResolution\n</code></pre> <p>Get the device resolution.</p> <p>Returns:</p> Type Description <code>DeviceResolution</code> <p>The resolution (bit depth).</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def get_device_resolution(self) -&gt; DeviceResolution:\n    \"\"\"Get the device resolution.\n\n    Returns:\n        The resolution (bit depth).\n    \"\"\"\n    resolution = c_uint32()\n    self._f(\"GetDeviceResolution\", self._handle, byref(resolution))\n    return DeviceResolution(resolution.value)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.get_max_down_sample_ratio","title":"get_max_down_sample_ratio","text":"<pre><code>get_max_down_sample_ratio(\n    n: int,\n    mode: RatioMode | str | int = \"none\",\n    segment: int = 0,\n) -&gt; int\n</code></pre> <p>Get the maximum down-sampling ratio.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of unprocessed samples to be downsampled.</p> required <code>mode</code> <code>RatioMode | str | int</code> <p>The down-sampling mode. Can be an enum member name (case insensitive) or value.</p> <code>'none'</code> <code>segment</code> <code>int</code> <p>The index of the memory segment to use.</p> <code>0</code> <p>Returns:</p> Type Description <code>int</code> <p>The maximum down-sampling ratio that can be used for a given number of samples in a given down-sampling mode.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def get_max_down_sample_ratio(self, n: int, mode: RatioMode | str | int = \"none\", segment: int = 0) -&gt; int:\n    \"\"\"Get the maximum down-sampling ratio.\n\n    Args:\n        n: The number of unprocessed samples to be downsampled.\n        mode: The down-sampling mode. Can be an enum member name (case insensitive) or value.\n        segment: The index of the memory segment to use.\n\n    Returns:\n        The maximum down-sampling ratio that can be used for a given number of samples\n            in a given down-sampling mode.\n    \"\"\"\n    mode = to_enum(mode, RatioMode, to_upper=True)\n    ratio = c_uint32()\n    self._f(\"GetMaxDownSampleRatio\", self._handle, n, byref(ratio), mode, segment)\n    return ratio.value\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.get_max_segments","title":"get_max_segments","text":"<pre><code>get_max_segments() -&gt; int\n</code></pre> <p>Get the maximum number of segments allowed for the opened device.</p> <p>Returns:</p> Type Description <code>int</code> <p>This function returns the maximum number of segments allowed for the opened device. This number is the maximum value of <code>num_segments</code> that can be passed to memory_segments.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def get_max_segments(self) -&gt; int:\n    \"\"\"Get the maximum number of segments allowed for the opened device.\n\n    Returns:\n        This function returns the maximum number of segments allowed for the opened device.\n            This number is the maximum value of `num_segments` that can be passed to\n            [memory_segments][msl.equipment_resources.picotech.picoscope.PicoScope.memory_segments].\n    \"\"\"\n    max_segments = c_uint32()\n    self._f(\"GetMaxSegments\", self._handle, byref(max_segments))\n    return max_segments.value\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.get_minimum_timebase_stateless","title":"get_minimum_timebase_stateless","text":"<pre><code>get_minimum_timebase_stateless(\n    *,\n    flags: ChannelFlags,\n    resolution: DeviceResolution | str | int\n) -&gt; float\n</code></pre> <p>Get the fastest available sample interval for the proposed configuration.</p> <p>It does not write the configuration to the device.</p> <p>Parameters:</p> Name Type Description Default <code>flags</code> <code>ChannelFlags</code> <p>The proposed combination of enabled channels and ports. To specify multiple channels and ports, use the bitwise-OR of the relevant ChannelFlags.</p> required <code>resolution</code> <code>DeviceResolution | str | int</code> <p>The resolution mode in which you propose to operate the oscilloscope. Can be an enum member name (case insensitive, with or without the \"DR_\" prefix) or value.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The fastest sampling interval, in seconds, corresponding to the proposed configuration.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def get_minimum_timebase_stateless(self, *, flags: ChannelFlags, resolution: DeviceResolution | str | int) -&gt; float:\n    \"\"\"Get the fastest available sample interval for the proposed configuration.\n\n    It does not write the configuration to the device.\n\n    Args:\n        flags: The proposed combination of enabled channels and ports. To specify multiple\n            channels and ports, use the bitwise-OR of the relevant\n            [ChannelFlags][msl.equipment_resources.picotech.picoscope.ChannelFlags].\n        resolution: The resolution mode in which you propose to operate the oscilloscope.\n            Can be an enum member name (case insensitive, with or without the \"DR_\" prefix) or value.\n\n    Returns:\n        The fastest sampling interval, in seconds, corresponding to the proposed configuration.\n    \"\"\"\n    timebase = c_uint32()\n    dt = c_double()\n    resolution = to_enum(resolution, DeviceResolution, prefix=\"DR_\", to_upper=True)\n    self._f(\"GetMinimumTimebaseStateless\", self._handle, flags, byref(timebase), byref(dt), resolution)\n    return dt.value\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.get_no_of_captures","title":"get_no_of_captures","text":"<pre><code>get_no_of_captures(*, pre_allocate: bool = True) -&gt; int\n</code></pre> <p>Get the number of captures available.</p> <p>Parameters:</p> Name Type Description Default <code>pre_allocate</code> <code>bool</code> <p>Whether to pre-allocate a numpy array to hold the samples for each channel that is enabled. Allocation happens only once per run.</p> <code>True</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of captures the device has made in rapid-block mode, since run_block was called.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def get_no_of_captures(self, *, pre_allocate: bool = True) -&gt; int:\n    \"\"\"Get the number of captures available.\n\n    Args:\n        pre_allocate: Whether to pre-allocate a numpy array to hold the samples for each channel that is enabled.\n            Allocation happens only once per run.\n\n    Returns:\n        The number of captures the device has made in rapid-block mode,\n            since [run_block][msl.equipment_resources.picotech.picoscope.PicoScope.run_block] was called.\n    \"\"\"\n    n_captures = c_uint32()\n    self._f(\"GetNoOfCaptures\", self._handle, byref(n_captures))\n    n = n_captures.value\n    if pre_allocate:\n        if not self._channels:\n            msg = \"Must call set_channel() to configure all channels before get_no_of_captures()\"\n            raise MSLConnectionError(self, msg)\n\n        if self._num_samples &lt; 0:\n            msg = \"Must call set_timebase() before get_no_of_captures()\"\n            raise MSLConnectionError(self, msg)\n\n        for channel in self._channels.values():\n            if channel.enabled:\n                channel.allocate(num_samples=self._num_samples, num_captures=n)\n\n    return n\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.get_num_of_processed_captures","title":"get_num_of_processed_captures","text":"<pre><code>get_num_of_processed_captures() -&gt; int\n</code></pre> <p>Get the number of captures in rapid block mode that have been processed.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of available captures that have been collected after calling run_block.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def get_num_of_processed_captures(self) -&gt; int:\n    \"\"\"Get the number of captures in rapid block mode that have been processed.\n\n    Returns:\n        The number of available captures that have been collected after calling\n            [run_block][msl.equipment_resources.picotech.picoscope.PicoScope.run_block].\n    \"\"\"\n    n_processed_captures = c_uint32()\n    self._f(\"GetNoOfProcessedCaptures\", self._handle, byref(n_processed_captures))\n    return n_processed_captures.value\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.get_streaming_latest_values","title":"get_streaming_latest_values","text":"<pre><code>get_streaming_latest_values(\n    callback: PicoTechStreamingReadyCallback,\n    *,\n    strict: bool = False\n) -&gt; None\n</code></pre> <p>Instructs the driver to return the next block of values to your callback function.</p> <p>You must have previously called run_streaming beforehand to set up streaming.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>PicoTechStreamingReadyCallback</code> <p>The callback function to be called when the latest streaming samples have been acquired (see also, wait_until_ready and is_ready).</p> required <code>strict</code> <code>bool</code> <p>Whether to raise an exception if the device is busy so data cannot be acquired yet when this method is called.</p> <code>False</code> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def get_streaming_latest_values(self, callback: PicoTechStreamingReadyCallback, *, strict: bool = False) -&gt; None:\n    \"\"\"Instructs the driver to return the next block of values to your callback function.\n\n    You must have previously called\n    [run_streaming][msl.equipment_resources.picotech.picoscope.PicoScope.run_streaming]\n    beforehand to set up streaming.\n\n    Args:\n        callback: The callback function to be called when the latest streaming samples\n            have been acquired (see also,\n            [wait_until_ready][msl.equipment_resources.picotech.picoscope.PicoScope.wait_until_ready] and\n            [is_ready][msl.equipment_resources.picotech.picoscope.PicoScope.is_ready]).\n        strict: Whether to raise an exception if the device is busy so data cannot be\n            acquired yet when this method is called.\n    \"\"\"\n    try:\n        self._f(\"GetStreamingLatestValues\", self._handle, callback, None)\n    except MSLConnectionError:\n        if self._error_code == PICO_BUSY and not strict:\n            return\n        raise\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.get_timebase2","title":"get_timebase2","text":"<pre><code>get_timebase2(\n    timebase: int, num_samples: int = 0, segment: int = 0\n) -&gt; tuple[float, int]\n</code></pre> <p>Get the timebase.</p> <p>This function calculates the sampling interval and maximum number of samples for a given timebase under the specified conditions. The result will depend on the number of channels enabled.</p> <p>Parameters:</p> Name Type Description Default <code>timebase</code> <code>int</code> <p>The timebase.</p> required <code>num_samples</code> <code>int</code> <p>The number of samples required.</p> <code>0</code> <code>segment</code> <code>int</code> <p>The index of the memory segment to use.</p> <code>0</code> <p>Returns:</p> Type Description <code>tuple[float, int]</code> <p>The sampling interval, in seconds, and the maximum number of samples available.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def get_timebase2(self, timebase: int, num_samples: int = 0, segment: int = 0) -&gt; tuple[float, int]:\n    \"\"\"Get the timebase.\n\n    This function calculates the sampling interval and maximum number of samples for a given timebase under\n    the specified conditions. The result will depend on the number of channels enabled.\n\n    Args:\n        timebase: The timebase.\n        num_samples: The number of samples required.\n        segment: The index of the memory segment to use.\n\n    Returns:\n        The sampling interval, in seconds, and the maximum number of samples available.\n    \"\"\"\n    dt = c_float()\n    max_samples = c_int32()\n    self._f(\"GetTimebase2\", self._handle, timebase, num_samples, byref(dt), byref(max_samples), segment)\n    return dt.value * 1e-9, max_samples.value\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.get_trigger_info_bulk","title":"get_trigger_info_bulk","text":"<pre><code>get_trigger_info_bulk(\n    from_segment: int = 0, to_segment: int | None = None\n) -&gt; TriggerInfo\n</code></pre> <p>Get information about the trigger point in one or more segments of captured data.</p> <p>If <code>from_segment</code> &gt; <code>to_segment</code>, the segment index will wrap from the last segment back to 0.</p> <p>Parameters:</p> Name Type Description Default <code>from_segment</code> <code>int</code> <p>The zero-based number of the first segment of interest.</p> <code>0</code> <code>to_segment</code> <code>int | None</code> <p>The zero-based number of the last segment of interest. If <code>None</code>, the last segment is determined from the number of captures.</p> <code>None</code> <p>Returns:</p> Type Description <code>TriggerInfo</code> <p>The trigger-information struct.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def get_trigger_info_bulk(self, from_segment: int = 0, to_segment: int | None = None) -&gt; TriggerInfo:\n    \"\"\"Get information about the trigger point in one or more segments of captured data.\n\n    If `from_segment` &gt; `to_segment`, the segment index will wrap from the last segment back to 0.\n\n    Args:\n        from_segment: The zero-based number of the first segment of interest.\n        to_segment: The zero-based number of the last segment of interest. If `None`,\n            the last segment is determined from the number of captures.\n\n    Returns:\n        The trigger-information struct.\n    \"\"\"\n    n = self.get_no_of_captures()\n    if to_segment is None:\n        to_segment = n - 1\n\n    ti = _TriggerInfo()\n    self._f(\"GetTriggerInfoBulk\", self._handle, byref(ti), from_segment, to_segment)\n    if ti.status != PICO_OK:\n        msg = Error.get(ti.status, f\"UnknownPicoTechError: Error code 0x{ti.status:08x}\")\n        raise MSLConnectionError(self, msg)\n\n    return TriggerInfo(\n        segment_index=ti.segmentIndex,\n        trigger_time=ti.triggerTime * _TimeUnits.to_float(ti.timeUnits),\n        trigger_index=ti.triggerIndex,\n        timestamp_counter=ti.timeStampCounter,\n    )\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.get_trigger_time_offset64","title":"get_trigger_time_offset64","text":"<pre><code>get_trigger_time_offset64(segment: int = 0) -&gt; float\n</code></pre> <p>Gets the time at which the trigger occurred.</p> <p>Call it after block-mode data has been captured or when data has been retrieved from a previous block-mode capture.</p> <p>Parameters:</p> Name Type Description Default <code>segment</code> <code>int</code> <p>The index of the memory segment for which the information is required.</p> <code>0</code> <p>Returns:</p> Type Description <code>float</code> <p>The offset time, in seconds.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def get_trigger_time_offset64(self, segment: int = 0) -&gt; float:\n    \"\"\"Gets the time at which the trigger occurred.\n\n    Call it after block-mode data has been captured or when data has been retrieved from a\n    previous block-mode capture.\n\n    Args:\n        segment: The index of the memory segment for which the information is required.\n\n    Returns:\n        The offset time, in seconds.\n    \"\"\"\n    time = c_int64()\n    time_units = c_uint32()\n    self._f(\"GetTriggerTimeOffset64\", self._handle, byref(time), byref(time_units), segment)\n    return time.value * _TimeUnits.to_float(time_units.value)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.get_unit_info","title":"get_unit_info","text":"<pre><code>get_unit_info(\n    info: PicoInfo | str | int | None = None,\n    *,\n    prefix: bool = True\n) -&gt; str\n</code></pre> <p>Retrieves information about the PicoScope.</p> <p>Parameters:</p> Name Type Description Default <code>info</code> <code>PicoInfo | str | int | None</code> <p>The info to get. Can be an enum member name (case insensitive) or value. If <code>None</code>, retrieves all available information.</p> <code>None</code> <code>prefix</code> <code>bool</code> <p>If <code>True</code>, includes the enum member name as a prefix. For example, returns <code>\"CAL_DATE: 09Aug16\"</code> if <code>prefix</code> is <code>True</code> else <code>\"09Aug16\"</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The requested information from the PicoScope.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def get_unit_info(self, info: PicoInfo | str | int | None = None, *, prefix: bool = True) -&gt; str:\n    \"\"\"Retrieves information about the PicoScope.\n\n    Args:\n        info: The info to get. Can be an enum member name (case insensitive) or value.\n            If `None`, retrieves all available information.\n        prefix: If `True`, includes the enum member name as a prefix.\n            For example, returns `\"CAL_DATE: 09Aug16\"` if `prefix` is `True` else `\"09Aug16\"`.\n\n    Returns:\n        The requested information from the PicoScope.\n    \"\"\"\n    values = [PicoInfo(i) for i in range(11)] if info is None else [to_enum(info, PicoInfo, to_upper=True)]\n    if info is None:\n        values.append(PicoInfo.IPP_VERSION)\n\n    string = create_string_buffer(32)\n    required_size = c_int16()\n\n    out: list[str] = []\n    for value in values:\n        name = f\"{value.name}: \" if prefix else \"\"\n        self._f(\"GetUnitInfo\", self._handle, string, len(string), byref(required_size), value)\n        out.append(f\"{name}{string.value.decode()}\")\n    return \"\\n\".join(out)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.get_values","title":"get_values","text":"<pre><code>get_values(\n    num_samples: int | None = None,\n    start: int = 0,\n    factor: int = 1,\n    mode: RatioMode | str | int = \"none\",\n    segment: int = 0,\n) -&gt; tuple[int, int]\n</code></pre> <p>Get the block-mode data, with or without down sampling, starting at the specified sample number.</p> <p>It is used to get the stored data from the driver after data collection has stopped.</p> <p>Parameters:</p> Name Type Description Default <code>num_samples</code> <code>int | None</code> <p>The number of samples required. If <code>None</code>, automatically determine the number of samples to retrieve.</p> <code>None</code> <code>start</code> <code>int</code> <p>A zero-based index that indicates the start point for data collection. It is measured in sample intervals from the start of the buffer.</p> <code>0</code> <code>factor</code> <code>int</code> <p>The down-sampling factor that will be applied to the raw data.</p> <code>1</code> <code>mode</code> <code>RatioMode | str | int</code> <p>Which down-sampling mode to use. Can be an enum member name (case insensitive) or value.</p> <code>'none'</code> <code>segment</code> <code>int</code> <p>The index of the memory segment where the data is stored.</p> <code>0</code> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>The actual number of samples retrieved and a flag that indicate whether an over-voltage has occurred on any of the channels. It is a bit field with bit 0 denoting Channel A (i.e., <code>(num_samples, overflow)</code>).</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def get_values(\n    self,\n    num_samples: int | None = None,\n    start: int = 0,\n    factor: int = 1,\n    mode: RatioMode | str | int = \"none\",\n    segment: int = 0,\n) -&gt; tuple[int, int]:\n    \"\"\"Get the block-mode data, with or without down sampling, starting at the specified sample number.\n\n    It is used to get the stored data from the driver after data collection has stopped.\n\n    Args:\n        num_samples: The number of samples required. If `None`, automatically determine\n            the number of samples to retrieve.\n        start: A zero-based index that indicates the start point for data collection.\n            It is measured in sample intervals from the start of the buffer.\n        factor: The down-sampling factor that will be applied to the raw data.\n        mode: Which down-sampling mode to use. Can be an enum member name (case insensitive) or value.\n        segment: The index of the memory segment where the data is stored.\n\n    Returns:\n        The actual number of samples retrieved and a flag that indicate whether\n            an over-voltage has occurred on any of the channels. It is a bit field\n            with bit 0 denoting Channel A (i.e., `(num_samples, overflow)`).\n    \"\"\"\n    overflow = c_int16()\n    if num_samples is None:\n        if self._num_samples &lt; 0:\n            msg = \"Must call set_timebase() before get_values() or explicitly specify `num_samples`\"\n            raise MSLConnectionError(self, msg)\n        num_samples = self._num_samples\n    n_samples = c_uint32(num_samples)\n    mode = to_enum(mode, RatioMode, to_upper=True)\n    self._f(\"GetValues\", self._handle, start, byref(n_samples), factor, mode, segment, byref(overflow))\n    return n_samples.value, overflow.value\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.get_values_async","title":"get_values_async","text":"<pre><code>get_values_async(\n    callback: PicoTechDataReadyCallback,\n    num_samples: int | None = None,\n    start: int = 0,\n    factor: int = 1,\n    mode: RatioMode | str | int = \"none\",\n    segment: int = 0,\n) -&gt; None\n</code></pre> <p>Get data either with or without down sampling, starting at the specified sample number.</p> <p>It is used to get the stored data from the scope after data collection has stopped. It returns the data to the callback.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>PicoTechDataReadyCallback</code> <p>A callback function to call when data is ready.</p> required <code>num_samples</code> <code>int | None</code> <p>The number of samples required. If <code>None</code>, automatically determine the number of samples to retrieve.</p> <code>None</code> <code>start</code> <code>int</code> <p>A zero-based index that indicates the start point for data collection. It is measured in sample intervals from the start of the buffer.</p> <code>0</code> <code>factor</code> <code>int</code> <p>The down-sampling factor that will be applied to the raw data.</p> <code>1</code> <code>mode</code> <code>RatioMode | str | int</code> <p>Which down-sampling mode to use. Can be an enum member name (case insensitive) or value.</p> <code>'none'</code> <code>segment</code> <code>int</code> <p>The index of the memory segment where the data is stored.</p> <code>0</code> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def get_values_async(\n    self,\n    callback: PicoTechDataReadyCallback,\n    num_samples: int | None = None,\n    start: int = 0,\n    factor: int = 1,\n    mode: RatioMode | str | int = \"none\",\n    segment: int = 0,\n) -&gt; None:\n    \"\"\"Get data either with or without down sampling, starting at the specified sample number.\n\n    It is used to get the stored data from the scope after data collection has stopped.\n    It returns the data to the callback.\n\n    Args:\n        callback: A callback function to call when data is ready.\n        num_samples: The number of samples required. If `None`, automatically determine the\n            number of samples to retrieve.\n        start: A zero-based index that indicates the start point for data collection.\n            It is measured in sample intervals from the start of the buffer.\n        factor: The down-sampling factor that will be applied to the raw data.\n        mode: Which down-sampling mode to use. Can be an enum member name (case insensitive) or value.\n        segment: The index of the memory segment where the data is stored.\n    \"\"\"\n    if num_samples is None:\n        if self._num_samples &lt; 0:\n            msg = \"Must call set_timebase() before get_values_async() or explicitly specify `num_samples`\"\n            raise MSLConnectionError(self, msg)\n        num_samples = self._num_samples\n    mode = to_enum(mode, RatioMode, to_upper=True)\n    self._f(\"GetValuesAsync\", self._handle, start, num_samples, factor, mode, segment, callback, None)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.get_values_bulk","title":"get_values_bulk","text":"<pre><code>get_values_bulk(\n    from_segment: int = 0,\n    to_segment: int | None = None,\n    factor: int = 1,\n    mode: RatioMode | str | int = \"none\",\n    num_samples: int | None = None,\n) -&gt; tuple[int, list[int]]\n</code></pre> <p>Get waveforms captured using rapid block mode.</p> <p>The waveforms must have been collected sequentially and in the same run.</p> <p>Parameters:</p> Name Type Description Default <code>from_segment</code> <code>int</code> <p>The first segment from which the waveform should be retrieved.</p> <code>0</code> <code>to_segment</code> <code>int | None</code> <p>The last segment from which the waveform should be retrieved. If <code>None</code>, the last segment is determined from the number of captures.</p> <code>None</code> <code>factor</code> <code>int</code> <p>The down-sampling factor that will be applied to the raw data.</p> <code>1</code> <code>mode</code> <code>RatioMode | str | int</code> <p>Which down-sampling mode to use. Can be an enum member name (case insensitive) or value.</p> <code>'none'</code> <code>num_samples</code> <code>int | None</code> <p>The number of samples required. If <code>None</code>, automatically determine the number of samples to retrieve.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[int, list[int]]</code> <p>The actual number samples retrieved per capture and a list of overflow bit-mask flags for each capture.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def get_values_bulk(\n    self,\n    from_segment: int = 0,\n    to_segment: int | None = None,\n    factor: int = 1,\n    mode: RatioMode | str | int = \"none\",\n    num_samples: int | None = None,\n) -&gt; tuple[int, list[int]]:\n    \"\"\"Get waveforms captured using rapid block mode.\n\n    The waveforms must have been collected sequentially and in the same run.\n\n    Args:\n        from_segment: The first segment from which the waveform should be retrieved.\n        to_segment: The last segment from which the waveform should be retrieved. If `None`,\n            the last segment is determined from the number of captures.\n        factor: The down-sampling factor that will be applied to the raw data.\n        mode: Which down-sampling mode to use. Can be an enum member name (case insensitive) or value.\n        num_samples: The number of samples required. If `None`, automatically determine the\n            number of samples to retrieve.\n\n    Returns:\n        The actual number samples retrieved per capture and a list of overflow bit-mask flags for each capture.\n    \"\"\"\n    if num_samples is None:\n        if self._num_samples &lt; 0:\n            msg = \"Must call set_timebase() before get_values_bulk() or explicitly specify `num_samples`\"\n            raise MSLConnectionError(self, msg)\n        num_samples = self._num_samples\n\n    n = self.get_no_of_captures()\n    if to_segment is None:\n        to_segment = n - 1\n\n    num_segments = to_segment - from_segment + 1\n    no_of_samples = c_uint32(num_samples * n)\n    overflow = (c_int16 * num_segments)()\n    mode = to_enum(mode, RatioMode, to_upper=True)\n    self._f(\"GetValuesBulk\", self._handle, byref(no_of_samples), from_segment, to_segment, factor, mode, overflow)\n    overflows: list[int] = list(overflow)\n    return no_of_samples.value, overflows\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.get_values_overlapped","title":"get_values_overlapped","text":"<pre><code>get_values_overlapped(\n    start: int = 0,\n    factor: int = 1,\n    mode: RatioMode | str | int = \"none\",\n    segment: int = 0,\n) -&gt; tuple[int, int]\n</code></pre> <p>Allows you to make a deferred data-collection request in block mode.</p> <p>The advantage of this function is that the driver makes contact with the scope only once, when you call run_block, compared with the two contacts that occur when you use the conventional run_block, get_values calling sequence. This slightly reduces the dead time between successive captures in block mode.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>int</code> <p>A zero-based index that indicates the start point for data collection. It is measured in sample intervals from the start of the buffer.</p> <code>0</code> <code>factor</code> <code>int</code> <p>The down-sampling factor that will be applied to the raw data.</p> <code>1</code> <code>mode</code> <code>RatioMode | str | int</code> <p>Which down-sampling mode to use. Can be an enum member name (case insensitive) or value.</p> <code>'none'</code> <code>segment</code> <code>int</code> <p>The index of the memory segment where the data is stored.</p> <code>0</code> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>The actual number of samples retrieved and a flag that indicate whether an over-voltage has occurred on any of the channels. It is a bit field with bit 0 denoting Channel A (i.e., <code>(num_samples, overflow)</code>).</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def get_values_overlapped(\n    self, start: int = 0, factor: int = 1, mode: RatioMode | str | int = \"none\", segment: int = 0\n) -&gt; tuple[int, int]:\n    \"\"\"Allows you to make a deferred data-collection request in block mode.\n\n    The advantage of this function is that the driver makes contact with the scope only once,\n    when you call [run_block][msl.equipment_resources.picotech.picoscope.PicoScope.run_block], compared\n    with the two contacts that occur when you use the conventional\n    [run_block][msl.equipment_resources.picotech.picoscope.PicoScope.run_block],\n    [get_values][msl.equipment_resources.picotech.picoscope.PicoScope.get_values] calling sequence.\n    This slightly reduces the dead time between successive captures in block mode.\n\n    Args:\n        start: A zero-based index that indicates the start point for data collection.\n            It is measured in sample intervals from the start of the buffer.\n        factor: The down-sampling factor that will be applied to the raw data.\n        mode: Which down-sampling mode to use. Can be an enum member name (case insensitive) or value.\n        segment: The index of the memory segment where the data is stored.\n\n    Returns:\n        The actual number of samples retrieved and a flag that indicate whether\n            an over-voltage has occurred on any of the channels. It is a bit field\n            with bit 0 denoting Channel A (i.e., `(num_samples, overflow)`).\n    \"\"\"\n    no_of_samples = c_uint32()\n    overflow = c_int16()\n    mode = to_enum(mode, RatioMode, to_upper=True)\n    self._f(\n        \"GetValuesOverlapped\", self._handle, start, byref(no_of_samples), factor, mode, segment, byref(overflow)\n    )\n    return no_of_samples.value, overflow.value\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.get_values_overlapped_bulk","title":"get_values_overlapped_bulk","text":"<pre><code>get_values_overlapped_bulk(\n    start: int = 0,\n    factor: int = 1,\n    mode: RatioMode | str | int = \"none\",\n    from_segment: int = 0,\n    to_segment: int | None = None,\n    num_samples: int | None = None,\n) -&gt; tuple[int, list[int]]\n</code></pre> <p>Allows you to make a deferred data-collection request in block mode.</p> <p>The advantage of this function is that the driver makes contact with the scope only once, when you call run_block, compared with the two contacts that occur when you use the conventional run_block, get_values_bulk calling sequence. This slightly reduces the dead time between successive captures in rapid block mode.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>int</code> <p>A zero-based index that indicates the start point for data collection. It is measured in sample intervals from the start of the buffer.</p> <code>0</code> <code>factor</code> <code>int</code> <p>The down-sampling factor that will be applied to the raw data.</p> <code>1</code> <code>mode</code> <code>RatioMode | str | int</code> <p>Which down-sampling mode to use. Can be an enum member name (case insensitive) or value.</p> <code>'none'</code> <code>from_segment</code> <code>int</code> <p>The first segment from which the waveform should be retrieved.</p> <code>0</code> <code>to_segment</code> <code>int | None</code> <p>The last segment from which the waveform should be retrieved. If <code>None</code>, the last segment is determined from the number of captures.</p> <code>None</code> <code>num_samples</code> <code>int | None</code> <p>The number of samples required. If <code>None</code>, automatically determine the number of samples to retrieve.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[int, list[int]]</code> <p>The actual number samples retrieved per capture and a list of overflow bit-mask flags for each capture.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def get_values_overlapped_bulk(\n    self,\n    start: int = 0,\n    factor: int = 1,\n    mode: RatioMode | str | int = \"none\",\n    from_segment: int = 0,\n    to_segment: int | None = None,\n    num_samples: int | None = None,\n) -&gt; tuple[int, list[int]]:\n    \"\"\"Allows you to make a deferred data-collection request in block mode.\n\n    The advantage of this function is that the driver makes contact with the scope only once,\n    when you call [run_block][msl.equipment_resources.picotech.picoscope.PicoScope.run_block], compared\n    with the two contacts that occur when you use the conventional\n    [run_block][msl.equipment_resources.picotech.picoscope.PicoScope.run_block],\n    [get_values_bulk][msl.equipment_resources.picotech.picoscope.PicoScope.get_values_bulk] calling sequence.\n    This slightly reduces the dead time between successive captures in rapid block mode.\n\n    Args:\n        start: A zero-based index that indicates the start point for data collection.\n            It is measured in sample intervals from the start of the buffer.\n        factor: The down-sampling factor that will be applied to the raw data.\n        mode: Which down-sampling mode to use. Can be an enum member name (case insensitive) or value.\n        from_segment: The first segment from which the waveform should be retrieved.\n        to_segment: The last segment from which the waveform should be retrieved. If `None`,\n            the last segment is determined from the number of captures.\n        num_samples: The number of samples required. If `None`, automatically determine the\n            number of samples to retrieve.\n\n    Returns:\n        The actual number samples retrieved per capture and a list of overflow bit-mask flags for each capture.\n    \"\"\"\n    if num_samples is None:\n        if self._num_samples &lt; 0:\n            msg = \"Must call set_timebase() before get_values_overlapped_bulk() or explicitly specify `num_samples`\"\n            raise MSLConnectionError(self, msg)\n        num_samples = self._num_samples\n\n    n = self.get_no_of_captures()\n    if to_segment is None:\n        to_segment = n - 1\n\n    num_segments = to_segment - from_segment + 1\n    no_of_samples = c_uint32(num_samples * n)\n    overflow = (c_int16 * num_segments)()\n    mode = to_enum(mode, RatioMode, to_upper=True)\n    self._f(\n        \"GetValuesOverlappedBulk\",\n        self._handle,\n        start,\n        byref(no_of_samples),\n        factor,\n        mode,\n        from_segment,\n        to_segment,\n        byref(overflow),\n    )\n\n    overflows: list[int] = list(overflow)\n    return no_of_samples.value, overflows\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.get_values_trigger_time_offset_bulk64","title":"get_values_trigger_time_offset_bulk64","text":"<pre><code>get_values_trigger_time_offset_bulk64(\n    from_segment: int = 0, to_segment: int | None = None\n) -&gt; list[float]\n</code></pre> <p>Get the 64-bit time offsets for waveforms captured in rapid block mode.</p> <p>If <code>from_segment</code> &gt; <code>to_segment</code>, the segment index will wrap from the last segment back to 0.</p> <p>Parameters:</p> Name Type Description Default <code>from_segment</code> <code>int</code> <p>The zero-based number of the first segment of interest.</p> <code>0</code> <code>to_segment</code> <code>int | None</code> <p>The zero-based number of the last segment of interest. If <code>None</code>, the last segment is determined from the number of captures.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[float]</code> <p>The trigger time offset, in seconds, for each requested segment index.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def get_values_trigger_time_offset_bulk64(\n    self, from_segment: int = 0, to_segment: int | None = None\n) -&gt; list[float]:\n    \"\"\"Get the 64-bit time offsets for waveforms captured in rapid block mode.\n\n    If `from_segment` &gt; `to_segment`, the segment index will wrap from the last segment back to 0.\n\n    Args:\n        from_segment: The zero-based number of the first segment of interest.\n        to_segment: The zero-based number of the last segment of interest. If `None`,\n            the last segment is determined from the number of captures.\n\n    Returns:\n        The trigger time offset, in seconds, for each requested segment index.\n    \"\"\"\n    if to_segment is None:\n        to_segment = self.get_no_of_captures() - 1\n    n = to_segment - from_segment + 1\n    times = (c_int64 * n)()\n    units = (c_uint32 * n)()\n    self._f(\"GetValuesTriggerTimeOffsetBulk64\", self._handle, times, units, from_segment, to_segment)\n    tu = [_TimeUnits(u) for u in units]\n    return [t * _TimeUnits.to_float(u) for t, u in zip(times, tu)]\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.is_led_flashing","title":"is_led_flashing","text":"<pre><code>is_led_flashing() -&gt; int\n</code></pre> <p>This function reports whether or not the LED is flashing.</p> <p>Returns:</p> Type Description <code>int</code> <p>Whether the LED is flashing.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def is_led_flashing(self) -&gt; int:\n    \"\"\"This function reports whether or not the LED is flashing.\n\n    Returns:\n        Whether the LED is flashing.\n    \"\"\"\n    status = c_int16()\n    self._f(\"IsLedFlashing\", self._handle, byref(status))\n    return bool(status.value)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.is_ready","title":"is_ready","text":"<pre><code>is_ready() -&gt; bool\n</code></pre> <p>Check if the PicoScope has collected the requested number of samples.</p> <p>This function may be used instead of a callback function to receive data from run_block. To use this method, pass <code>None</code> as the callback parameter in run_block. You must then poll the driver to see if it has finished collecting the requested samples.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the PicoScope has collected the requested number of samples.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def is_ready(self) -&gt; bool:\n    \"\"\"Check if the PicoScope has collected the requested number of samples.\n\n    This function may be used instead of a callback function to receive data from\n    [run_block][msl.equipment_resources.picotech.picoscope.PicoScope.run_block].\n    To use this method, pass `None` as the callback parameter in\n    [run_block][msl.equipment_resources.picotech.picoscope.PicoScope.run_block].\n    You must then poll the driver to see if it has finished collecting the requested samples.\n\n    Returns:\n        Whether the PicoScope has collected the requested number of samples.\n    \"\"\"\n    ready = c_int16()\n    self._f(\"IsReady\", self._handle, byref(ready))\n    return bool(ready.value)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.is_trigger_or_pulse_width_qualifier_enabled","title":"is_trigger_or_pulse_width_qualifier_enabled","text":"<pre><code>is_trigger_or_pulse_width_qualifier_enabled() -&gt; (\n    tuple[bool, bool]\n)\n</code></pre> <p>This function discovers whether a trigger, or pulse width triggering, is enabled.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the trigger is enabled and the pulse-width qualifier is enabled,</p> <code>bool</code> <p>i.e., <code>(trigger, pwq)</code>.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def is_trigger_or_pulse_width_qualifier_enabled(self) -&gt; tuple[bool, bool]:\n    \"\"\"This function discovers whether a trigger, or pulse width triggering, is enabled.\n\n    Returns:\n        Whether the trigger is enabled and the pulse-width qualifier is enabled,\n        i.e., `(trigger, pwq)`.\n    \"\"\"\n    trigger_enabled = c_int16()\n    pulse_width_qualifier_enabled = c_int16()\n    self._f(\n        \"IsTriggerOrPulseWidthQualifierEnabled\",\n        self._handle,\n        byref(trigger_enabled),\n        byref(pulse_width_qualifier_enabled),\n    )\n    return bool(trigger_enabled.value), bool(pulse_width_qualifier_enabled.value)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.maximum_value","title":"maximum_value","text":"<pre><code>maximum_value() -&gt; int\n</code></pre> <p>Get the maximum ADC value.</p> <p>Returns:</p> Type Description <code>int</code> <p>The maximum ADC value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def maximum_value(self) -&gt; int:\n    \"\"\"Get the maximum ADC value.\n\n    Returns:\n        The maximum ADC value.\n    \"\"\"\n    value = c_int16()\n    self._f(\"MaximumValue\", self._handle, byref(value))\n    return value.value\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.memory_segments","title":"memory_segments","text":"<pre><code>memory_segments(num_segments: int) -&gt; int\n</code></pre> <p>Sets the number of memory segments that the scope will use.</p> <p>When the scope is opened, the number of segments defaults to 1, meaning that each capture fills the scopes available memory. This function allows you to divide the memory into a number of segments so that the scope can store several waveforms sequentially.</p> <p>Parameters:</p> Name Type Description Default <code>num_segments</code> <code>int</code> <p>The number of memory segments.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of samples available in each segment. This is the total number over all channels, so if two channels or 8-bit digital ports are in use, the number of samples available to each channel is divided by 2.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def memory_segments(self, num_segments: int) -&gt; int:\n    \"\"\"Sets the number of memory segments that the scope will use.\n\n    When the scope is opened, the number of segments defaults to 1, meaning that each\n    capture fills the scopes available memory. This function allows you to divide the\n    memory into a number of segments so that the scope can store several waveforms\n    sequentially.\n\n    Args:\n        num_segments: The number of memory segments.\n\n    Returns:\n        The number of samples available in each segment. This is the total number over\n            all channels, so if two channels or 8-bit digital ports are in use, the number\n            of samples available to each channel is divided by 2.\n    \"\"\"\n    num_max_samples = c_int32()\n    self._f(\"MemorySegments\", self._handle, num_segments, byref(num_max_samples))\n    return num_max_samples.value\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.minimum_value","title":"minimum_value","text":"<pre><code>minimum_value() -&gt; int\n</code></pre> <p>Get the minimum ADC value.</p> <p>Returns:</p> Type Description <code>int</code> <p>The minimum ADC value.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def minimum_value(self) -&gt; int:\n    \"\"\"Get the minimum ADC value.\n\n    Returns:\n        The minimum ADC value.\n    \"\"\"\n    value = c_int16()\n    self._f(\"MinimumValue\", self._handle, byref(value))\n    return value.value\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.nearest_sample_interval_stateless","title":"nearest_sample_interval_stateless","text":"<pre><code>nearest_sample_interval_stateless(\n    *,\n    flags: ChannelFlags,\n    dt: float,\n    resolution: DeviceResolution | str | int,\n    use_ets: bool = False\n) -&gt; tuple[int, float]\n</code></pre> <p>Get the nearest timebase index and sample interval for the proposed configuration.</p> <p>It does not write the configuration to the device.</p> <p>Parameters:</p> Name Type Description Default <code>flags</code> <code>ChannelFlags</code> <p>The proposed combination of enabled channels and ports. To specify multiple channels and ports, use the bitwise-OR of the relevant ChannelFlags.</p> required <code>dt</code> <code>float</code> <p>The proposed sampling interval, in seconds.</p> required <code>resolution</code> <code>DeviceResolution | str | int</code> <p>The resolution mode in which you propose to operate the oscilloscope. Can be an enum member name (case insensitive, with or without the \"DR_\" prefix) or value.</p> required <code>use_ets</code> <code>bool</code> <p>The proposed state of ETS (disabled or enabled).</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[int, float]</code> <p>The nearest (rounded up) timebase index and sampling interval, in seconds, corresponding to the proposed configuration.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def nearest_sample_interval_stateless(\n    self, *, flags: ChannelFlags, dt: float, resolution: DeviceResolution | str | int, use_ets: bool = False\n) -&gt; tuple[int, float]:\n    \"\"\"Get the nearest timebase index and sample interval for the proposed configuration.\n\n    It does not write the configuration to the device.\n\n    Args:\n        flags: The proposed combination of enabled channels and ports. To specify multiple\n            channels and ports, use the bitwise-OR of the relevant\n            [ChannelFlags][msl.equipment_resources.picotech.picoscope.ChannelFlags].\n        dt: The proposed sampling interval, in seconds.\n        resolution: The resolution mode in which you propose to operate the oscilloscope.\n            Can be an enum member name (case insensitive, with or without the \"DR_\" prefix) or value.\n        use_ets: The proposed state of ETS (disabled or enabled).\n\n    Returns:\n        The nearest (rounded up) timebase index and sampling interval, in seconds,\n            corresponding to the proposed configuration.\n    \"\"\"\n    timebase = c_uint32()\n    t = c_double()\n    r = to_enum(resolution, DeviceResolution, prefix=\"DR_\", to_upper=True)\n    self._f(\"NearestSampleIntervalStateless\", self._handle, flags, dt, r, int(use_ets), byref(timebase), byref(t))\n    return timebase.value, t.value\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.no_of_streaming_values","title":"no_of_streaming_values","text":"<pre><code>no_of_streaming_values() -&gt; int\n</code></pre> <p>Gets the number of samples available after data collection in streaming mode.</p> <p>Call it after calling stop.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of samples.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def no_of_streaming_values(self) -&gt; int:\n    \"\"\"Gets the number of samples available after data collection in streaming mode.\n\n    Call it after calling [stop][msl.equipment_resources.picotech.picoscope.PicoScope.stop].\n\n    Returns:\n        The number of samples.\n    \"\"\"\n    no_of_values = c_uint32()\n    self._f(\"NoOfStreamingValues\", self._handle, byref(no_of_values))\n    return no_of_values.value\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.ping_unit","title":"ping_unit","text":"<pre><code>ping_unit() -&gt; None\n</code></pre> <p>Ping the PicoScope.</p> <p>This function can be used to check that the already opened device is still connected to the USB port and communication is successful.</p> <p>Raises MSLConnectionError if pinging was not successful.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def ping_unit(self) -&gt; None:\n    \"\"\"Ping the PicoScope.\n\n    This function can be used to check that the already opened device is still\n    connected to the USB port and communication is successful.\n\n    Raises [MSLConnectionError][msl.equipment.interfaces.message_based.MSLConnectionError]\n    if pinging was not successful.\n    \"\"\"\n    self._f(\"PingUnit\", self._handle)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.query_output_edge_detect","title":"query_output_edge_detect","text":"<pre><code>query_output_edge_detect() -&gt; bool\n</code></pre> <p>Whether output edge detection mode is currently enabled.</p> <p>The default state is enabled.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether edge detection is enabled.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def query_output_edge_detect(self) -&gt; bool:\n    \"\"\"Whether output edge detection mode is currently enabled.\n\n    The default state is enabled.\n\n    Returns:\n        Whether edge detection is enabled.\n    \"\"\"\n    state = c_int16()\n    self._f(\"QueryOutputEdgeDetect\", self._handle, byref(state))\n    return bool(state)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.run_block","title":"run_block","text":"<pre><code>run_block(\n    pre_trigger: float = 0.0,\n    callback: PicoTechBlockReadyCallback | None = None,\n    segment: int = 0,\n) -&gt; float\n</code></pre> <p>Start acquiring samples in block mode.</p> <p>Parameters:</p> Name Type Description Default <code>pre_trigger</code> <code>float</code> <p>The number of seconds before the trigger event to start acquiring samples. The value must be \u2265 0.</p> <code>0.0</code> <code>callback</code> <code>PicoTechBlockReadyCallback | None</code> <p>An optional callback function to be called when all samples have been acquired. (see also, wait_until_ready and is_ready).</p> <code>None</code> <code>segment</code> <code>int</code> <p>The index of the memory segment to save the samples to.</p> <code>0</code> <p>Returns:</p> Type Description <code>float</code> <p>The approximate time, in seconds, that the scope will spend acquiring samples. This does not include any auto trigger timeout</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def run_block(\n    self,\n    pre_trigger: float = 0.0,\n    callback: PicoTechBlockReadyCallback | None = None,\n    segment: int = 0,\n) -&gt; float:\n    \"\"\"Start acquiring samples in block mode.\n\n    Args:\n        pre_trigger: The number of seconds before the trigger event to start acquiring samples.\n            The value must be &amp;ge; 0.\n        callback: An optional callback function to be called when all samples have been acquired.\n            (see also, [wait_until_ready][msl.equipment_resources.picotech.picoscope.PicoScope.wait_until_ready]\n            and [is_ready][msl.equipment_resources.picotech.picoscope.PicoScope.is_ready]).\n        segment: The index of the memory segment to save the samples to.\n\n    Returns:\n        The approximate time, in seconds, that the scope will spend acquiring samples.\n            This does not include any auto trigger timeout\n    \"\"\"\n    if not self._channels:\n        msg = \"Must call set_channel() to configure all channels before starting a run block\"\n        raise MSLConnectionError(self, msg)\n\n    if self._sampling_interval &lt; 0 or self._num_samples &lt; 0:\n        msg = \"Must call set_timebase() before starting a run block\"\n        raise MSLConnectionError(self, msg)\n\n    if pre_trigger &lt; 0:\n        msg = \"The pre-trigger value cannot be negative.\"\n        raise ValueError(msg)\n\n    self._pre_trigger = pre_trigger\n    n_pre = round(pre_trigger / self._sampling_interval)\n    n_post = self._num_samples - n_pre\n\n    if callback is None:  # a dummy callback\n        callback = _BlockReady(0, \"\", None)\n\n    time_ms = c_int32()\n    self._f(\"RunBlock\", self._handle, n_pre, n_post, self._timebase_index, byref(time_ms), segment, callback, None)\n    return round(time_ms.value * 1e-3, 3)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.run_streaming","title":"run_streaming","text":"<pre><code>run_streaming(\n    pre_trigger: float = 0.0,\n    factor: int = 1,\n    mode: RatioMode | str | int = \"none\",\n    *,\n    auto_stop: bool = True,\n    strict: bool = True\n) -&gt; float\n</code></pre> <p>Start collecting samples in streaming mode.</p> <p>This function tells the oscilloscope to start collecting data in streaming mode. When data has been collected from the device it is down sampled if necessary and then delivered to the application. Call get_streaming_latest_values to retrieve the data.</p> <p>Parameters:</p> Name Type Description Default <code>pre_trigger</code> <code>float</code> <p>The number of seconds before the trigger event to start acquiring data.</p> <code>0.0</code> <code>factor</code> <code>int</code> <p>The down-sampling factor that will be applied to the raw data.</p> <code>1</code> <code>mode</code> <code>RatioMode | str | int</code> <p>Which down-sampling mode to use. Can be an enum member name (case insensitive) or value.</p> <code>'none'</code> <code>auto_stop</code> <code>bool</code> <p>Whether streaming should stop when all of samples have been captured.</p> <code>True</code> <code>strict</code> <code>bool</code> <p>Whether to force the requested and the actual sampling intervals to be equal.</p> <code>True</code> <p>Returns:</p> Type Description <code>float</code> <p>The actual time interval, in seconds, between samples.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def run_streaming(\n    self,\n    pre_trigger: float = 0.0,\n    factor: int = 1,\n    mode: RatioMode | str | int = \"none\",\n    *,\n    auto_stop: bool = True,\n    strict: bool = True,\n) -&gt; float:\n    \"\"\"Start collecting samples in streaming mode.\n\n    This function tells the oscilloscope to start collecting data in streaming mode. When\n    data has been collected from the device it is down sampled if necessary and then\n    delivered to the application. Call\n    [get_streaming_latest_values][msl.equipment_resources.picotech.picoscope.PicoScope.get_streaming_latest_values]\n    to retrieve the data.\n\n    Args:\n        pre_trigger: The number of seconds before the trigger event to start acquiring data.\n        factor: The down-sampling factor that will be applied to the raw data.\n        mode: Which down-sampling mode to use. Can be an enum member name (case insensitive) or value.\n        auto_stop: Whether streaming should stop when all of samples have been captured.\n        strict: Whether to force the requested and the actual sampling intervals to be equal.\n\n    Returns:\n        The actual time interval, in seconds, between samples.\n    \"\"\"\n    self.streaming_done = False\n\n    if not self._channels:\n        msg = \"Must call set_channel() to configure all channels before starting a run streaming\"\n        raise MSLConnectionError(self, msg)\n\n    if self._sampling_interval &lt; 0 or self._num_samples &lt; 0:\n        msg = \"Must call set_timebase() before starting a run streaming\"\n        raise MSLConnectionError(self, msg)\n\n    if pre_trigger &lt; 0:\n        msg = \"The pre-trigger value cannot be negative.\"\n        raise ValueError(msg)\n\n    self._pre_trigger = pre_trigger\n\n    n_pre = round(pre_trigger / self._sampling_interval)  # don't use self._streaming_sampling_interval\n    n_post = self._num_samples - n_pre\n\n    mode = to_enum(mode, RatioMode, to_upper=True)\n    interval = c_uint32(self._streaming_sampling_interval)\n    self._f(\n        \"RunStreaming\",\n        self._handle,\n        byref(interval),\n        self._streaming_time_units,\n        n_pre,\n        n_post,\n        auto_stop,\n        factor,\n        mode,\n        self._buffer_size,\n    )\n\n    time_factor = _TimeUnits.to_float(self._streaming_time_units)\n    dt = interval.value * time_factor\n    if strict and (interval.value != self._streaming_sampling_interval):\n        msg = (\n            f\"The actual streaming sampling interval is {dt:.6e} seconds, \"\n            f\"requested {self._streaming_sampling_interval * time_factor:.6e} seconds\"\n        )\n        raise MSLConnectionError(self, msg)\n\n    return dt\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.set_auto_trigger","title":"set_auto_trigger","text":"<pre><code>set_auto_trigger(wait: float) -&gt; None\n</code></pre> <p>Sets up the auto-trigger function.</p> <p>The auto-trigger function starts a capture if no trigger event occurs within a specified time after a run command has been issued.</p> <p>Parameters:</p> Name Type Description Default <code>wait</code> <code>float</code> <p>The number of seconds to wait for a trigger before timing out. If this argument is zero, the scope will wait indefinitely for a trigger. Rounds to the nearest microsecond.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def set_auto_trigger(self, wait: float) -&gt; None:\n    \"\"\"Sets up the auto-trigger function.\n\n    The auto-trigger function starts a capture if no trigger event occurs within a\n    specified time after a run command has been issued.\n\n    Args:\n        wait: The number of seconds to wait for a trigger before timing out.\n            If this argument is zero, the scope will wait indefinitely for a trigger.\n            Rounds to the nearest microsecond.\n    \"\"\"\n    self._f(\"SetAutoTriggerMicroSeconds\", self._handle, round(wait * 1e6))\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.set_channel","title":"set_channel","text":"<pre><code>set_channel(\n    channel: Channel | str | int,\n    *,\n    bandwidth: BandwidthLimiter | str | int = \"full\",\n    coupling: Coupling | str | int = \"dc\",\n    enabled: bool = True,\n    offset: float = 0.0,\n    range: Range | str | int = \"10V\"\n) -&gt; None\n</code></pre> <p>Configure a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel | str | int</code> <p>The channel to configure. Can be an enum member name (case insensitive) or value.</p> required <code>bandwidth</code> <code>BandwidthLimiter | str | int</code> <p>The bandwidth limiter to use. Can be an enum member name (case insensitive, with or without the <code>\"BW_\"</code> prefix) or value.</p> <code>'full'</code> <code>coupling</code> <code>Coupling | str | int</code> <p>The impedance and coupling type. Can be an enum member name (case insensitive) or value.</p> <code>'dc'</code> <code>enabled</code> <code>bool</code> <p>Whether to enable the channel.</p> <code>True</code> <code>offset</code> <code>float</code> <p>A voltage to add to the input channel before digitization. The allowable range of offsets depends on the input range selected for the channel, as obtained from get_analogue_offset.</p> <code>0.0</code> <code>range</code> <code>Range | str | int</code> <p>The input voltage range. Can be an enum member name (with or without the <code>\"R_\"</code> prefix) or value.</p> <code>'10V'</code> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def set_channel(\n    self,\n    channel: Channel | str | int,\n    *,\n    bandwidth: BandwidthLimiter | str | int = \"full\",\n    coupling: Coupling | str | int = \"dc\",\n    enabled: bool = True,\n    offset: float = 0.0,\n    range: Range | str | int = \"10V\",  # noqa: A002\n) -&gt; None:\n    \"\"\"Configure a channel.\n\n    Args:\n        channel: The channel to configure. Can be an enum member name (case insensitive) or value.\n        bandwidth: The bandwidth limiter to use. Can be an enum member name (case insensitive, with\n            or without the `\"BW_\"` prefix) or value.\n        coupling: The impedance and coupling type. Can be an enum member name (case insensitive) or value.\n        enabled: Whether to enable the channel.\n        offset: A voltage to add to the input channel before digitization. The allowable range of\n            offsets depends on the input range selected for the channel, as obtained from\n            [get_analogue_offset][msl.equipment_resources.picotech.picoscope.PicoScope.get_analogue_offset].\n        range: The input voltage range. Can be an enum member name (with or without the `\"R_\"` prefix) or value.\n    \"\"\"\n    channel = to_enum(channel, Channel, to_upper=True)\n    bandwidth = to_enum(bandwidth, BandwidthLimiter, prefix=\"BW_\", to_upper=True)\n    coupling = to_enum(coupling, Coupling, to_upper=True)\n    _range = to_enum(range, Range, prefix=\"R_\")\n\n    # If range=MAX, the SDK uses the maximum enum value and not the maximum range that\n    # the PicoScope supports. Here, we choose the maximum supported range.\n    if _range == Range.R_MAX:\n        _range = Range(self.get_channel_information(channel, info=ChannelInfo.RANGES)[-1])\n\n    self._f(\"SetChannel\", self._handle, channel, enabled, coupling, _range, offset)\n    self._f(\"SetBandwidthFilter\", self._handle, channel, bandwidth)\n\n    # Get the voltage range as a floating-point number\n    match = re.search(r\"(?P&lt;value&gt;\\d+)\", _range.name)\n    assert match is not None  # noqa: S101\n    voltage_range = float(match[\"value\"])\n    if _range.name.endswith(\"mV\"):\n        voltage_range *= 1e-3\n\n    self._channels[channel.name] = ChannelSettings(\n        channel=channel,\n        enabled=bool(enabled),\n        coupling=coupling,\n        voltage_range=_range,\n        voltage_offset=offset,\n        bandwidth=bandwidth,\n        max_adu_value=self.maximum_value(),\n    )\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.set_data_buffer","title":"set_data_buffer","text":"<pre><code>set_data_buffer(\n    channel: Channel | str | int,\n    buffer: NDArray[int16] | None = None,\n    mode: RatioMode | str | int = \"none\",\n    segment: int = 0,\n) -&gt; None\n</code></pre> <p>Set the data buffer for the specified channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel | str | int</code> <p>The channel. Can be an enum member name (case insensitive) or value.</p> required <code>buffer</code> <code>NDArray[int16] | None</code> <p>A numpy array of dtype int16. If <code>None</code> then use a pre-allocated array.</p> <code>None</code> <code>mode</code> <code>RatioMode | str | int</code> <p>The ratio mode. Can be an enum member name (case insensitive) or value.</p> <code>'none'</code> <code>segment</code> <code>int</code> <p>The index of the memory segment where the data is stored.</p> <code>0</code> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def set_data_buffer(\n    self,\n    channel: Channel | str | int,\n    buffer: NDArray[np.int16] | None = None,\n    mode: RatioMode | str | int = \"none\",\n    segment: int = 0,\n) -&gt; None:\n    \"\"\"Set the data buffer for the specified channel.\n\n    Args:\n        channel: The channel. Can be an enum member name (case insensitive) or value.\n        buffer: A numpy array of dtype [int16][numpy.int16]. If `None` then use a pre-allocated array.\n        mode: The ratio mode. Can be an enum member name (case insensitive) or value.\n        segment: The index of the memory segment where the data is stored.\n    \"\"\"\n    ch = to_enum(channel, Channel, to_upper=True)\n    mode = to_enum(mode, RatioMode, to_upper=True)\n    if buffer is None:\n        if ch.name not in self._channels:\n            msg = (\n                f\"Must call set_channel(channel='{ch.name}', ...) before setting the data buffer \"\n                f\"or specify which buffer to use\"\n            )\n            raise MSLConnectionError(self, msg)\n\n        if self._num_samples &lt; 0:\n            msg = \"Must call set_timebase() before setting the data buffer or specify which buffer to use\"\n            raise MSLConnectionError(self, msg)\n\n        self.channel[ch.name].allocate(num_samples=self._num_samples, num_captures=self._num_captures)\n        buffer = self.channel[ch.name].buffer\n        self._buffer_size = buffer.size\n\n    self._f(\"SetDataBuffer\", self._handle, ch, buffer, buffer.size, segment, mode)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.set_data_buffers","title":"set_data_buffers","text":"<pre><code>set_data_buffers(\n    channel: Channel | str | int,\n    buffer_max: NDArray[int16] | None = None,\n    buffer_min: NDArray[int16] | None = None,\n    mode: RatioMode | str | int = \"none\",\n    segment: int = 0,\n) -&gt; None\n</code></pre> <p>Set the location of one or two buffers for receiving data.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel | str | int</code> <p>The channel. Can be an enum member name (case insensitive) or value.</p> required <code>buffer_max</code> <code>NDArray[int16] | None</code> <p>A user-allocated buffer to receive the maximum data values in aggregation mode, or the non-aggregated values otherwise. Each value is a 16-bit ADC count scaled according to the selected voltage range for the <code>channel</code>.</p> <code>None</code> <code>buffer_min</code> <code>NDArray[int16] | None</code> <p>A user-allocated buffer to receive the minimum data values in aggregation mode. Not normally used in other modes, but you can direct the driver to write non-aggregated values to this buffer by setting <code>buffer_max</code> to <code>None</code>.</p> <code>None</code> <code>mode</code> <code>RatioMode | str | int</code> <p>The ratio mode. Can be an enum member name (case insensitive) or value.</p> <code>'none'</code> <code>segment</code> <code>int</code> <p>The index of the memory segment where the data is stored.</p> <code>0</code> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def set_data_buffers(\n    self,\n    channel: Channel | str | int,\n    buffer_max: NDArray[np.int16] | None = None,\n    buffer_min: NDArray[np.int16] | None = None,\n    mode: RatioMode | str | int = \"none\",\n    segment: int = 0,\n) -&gt; None:\n    \"\"\"Set the location of one or two buffers for receiving data.\n\n    Args:\n        channel: The channel. Can be an enum member name (case insensitive) or value.\n        buffer_max: A user-allocated buffer to receive the maximum data values in aggregation mode,\n            or the non-aggregated values otherwise. Each value is a 16-bit ADC count scaled\n            according to the selected voltage range for the `channel`.\n        buffer_min: A user-allocated buffer to receive the minimum data values in aggregation mode.\n            Not normally used in other modes, but you can direct the driver to write non-aggregated\n            values to this buffer by setting `buffer_max` to `None`.\n        mode: The ratio mode. Can be an enum member name (case insensitive) or value.\n        segment: The index of the memory segment where the data is stored.\n    \"\"\"\n    ch = to_enum(channel, Channel, to_upper=True)\n    mode = to_enum(mode, RatioMode, to_upper=True)\n    if buffer_min is None:\n        if ch.name not in self._channels:\n            msg = f\"Must call set_channel(channel='{ch.name}', ...) before setting the data buffers\"\n            raise MSLConnectionError(self, msg)\n        buffer_min = self.channel[ch.name].buffer\n\n    if buffer_max is not None and buffer_max.size != buffer_min.size:\n        msg = f\"The size of buffer_max, {buffer_max.size}, and buffer_min, {buffer_min.size} are not equal\"\n        raise ValueError(msg)\n\n    self._buffer_size = buffer_min.size\n    self._f(\"SetDataBuffers\", self._handle, ch, buffer_max, buffer_min, buffer_min.size, segment, mode)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.set_device_resolution","title":"set_device_resolution","text":"<pre><code>set_device_resolution(\n    bit_depth: DeviceResolution | str | int,\n) -&gt; None\n</code></pre> <p>Set the device resolution.</p> <p>Parameters:</p> Name Type Description Default <code>bit_depth</code> <code>DeviceResolution | str | int</code> <p>The resolution. Can be an enum member name (case insensitive, with or without the <code>\"DR_\"</code> prefix) or value.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def set_device_resolution(self, bit_depth: DeviceResolution | str | int) -&gt; None:\n    \"\"\"Set the device resolution.\n\n    Args:\n        bit_depth: The resolution. Can be an enum member name (case insensitive,\n            with or without the `\"DR_\"` prefix) or value.\n    \"\"\"\n    resolution = to_enum(bit_depth, DeviceResolution, prefix=\"DR_\", to_upper=True)\n    self._f(\"SetDeviceResolution\", self._handle, resolution)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.set_digital_port","title":"set_digital_port","text":"<pre><code>set_digital_port(\n    port: Channel | str | int,\n    logic_level: int,\n    *,\n    enabled: bool = True\n) -&gt; None\n</code></pre> <p>Enable the digital port and set the logic level.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>Channel | str | int</code> <p>A digital channel. Can be an enum member name (case insensitive) or value.</p> required <code>logic_level</code> <code>int</code> <p>The voltage at which the state transitions from 0 to 1.</p> required <code>enabled</code> <code>bool</code> <p>Whether to enable or disable the <code>port</code>.</p> <code>True</code> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def set_digital_port(self, port: Channel | str | int, logic_level: int, *, enabled: bool = True) -&gt; None:\n    \"\"\"Enable the digital port and set the logic level.\n\n    Args:\n        port: A digital channel. Can be an enum member name (case insensitive) or value.\n        logic_level: The voltage at which the state transitions from 0 to 1.\n        enabled: Whether to enable or disable the `port`.\n    \"\"\"\n    self._f(\"SetDigitalPort\", self._handle, port, enabled, logic_level)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.set_ets","title":"set_ets","text":"<pre><code>set_ets(\n    mode: ETSMode | str | int, cycles: int, interleave: int\n) -&gt; float\n</code></pre> <p>Enable or disable ETS (equivalent-time sampling) and set the ETS parameters.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>ETSMode | str | int</code> <p>The ETS mode. Can be an enum member name (case insensitive) or value.</p> required <code>cycles</code> <code>int</code> <p>The number of ETS cycles to store.</p> required <code>interleave</code> <code>int</code> <p>The number of waveforms to combine into a single ETS capture.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The effective sampling interval, in seconds, of the ETS data.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def set_ets(self, mode: ETSMode | str | int, cycles: int, interleave: int) -&gt; float:\n    \"\"\"Enable or disable ETS (equivalent-time sampling) and set the ETS parameters.\n\n    Args:\n        mode: The ETS mode. Can be an enum member name (case insensitive) or value.\n        cycles: The number of ETS cycles to store.\n        interleave: The number of waveforms to combine into a single ETS capture.\n\n    Returns:\n        The effective sampling interval, in seconds, of the ETS data.\n    \"\"\"\n    mode = to_enum(mode, ETSMode, to_upper=True)\n    sample_time_picoseconds = c_int32()\n    self._f(\"SetEts\", self._handle, mode, cycles, interleave, byref(sample_time_picoseconds))\n    dt = sample_time_picoseconds.value * 1e-12\n    self._sampling_interval = dt\n    return dt\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.set_ets_time_buffer","title":"set_ets_time_buffer","text":"<pre><code>set_ets_time_buffer(buffer: NDArray[int64]) -&gt; None\n</code></pre> <p>Set the ETS time buffers.</p> <p>This function tells the driver where to find your applications ETS time buffers. These buffers contain the timing information for each ETS sample after you run a block-mode ETS capture.</p> <p>Parameters:</p> Name Type Description Default <code>buffer</code> <code>NDArray[int64]</code> <p>A numpy array of dtype int64 where each element represents the time, in femtoseconds, at which the samples were captured.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def set_ets_time_buffer(self, buffer: NDArray[np.int64]) -&gt; None:\n    \"\"\"Set the ETS time buffers.\n\n    This function tells the driver where to find your applications ETS time buffers. These\n    buffers contain the timing information for each ETS sample after you run a block-mode\n    ETS capture.\n\n    Args:\n        buffer: A numpy array of dtype [int64][numpy.int64] where each element represents the\n            time, in femtoseconds, at which the samples were captured.\n    \"\"\"\n    self._f(\"SetEtsTimeBuffer\", self._handle, buffer, len(buffer))\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.set_no_of_captures","title":"set_no_of_captures","text":"<pre><code>set_no_of_captures(n: int) -&gt; None\n</code></pre> <p>Sets the number of captures to be collected in one run of rapid block mode.</p> <p>If you do not call this function before a run, the driver will capture only one waveform. Once a value has been set, the value remains constant unless changed.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of captures.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def set_no_of_captures(self, n: int) -&gt; None:\n    \"\"\"Sets the number of captures to be collected in one run of rapid block mode.\n\n    If you do not call this function before a run, the driver will capture only one\n    waveform. Once a value has been set, the value remains constant unless changed.\n\n    Args:\n        n: The number of captures.\n    \"\"\"\n    self._num_captures = n\n    self._f(\"SetNoOfCaptures\", self._handle, n)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.set_output_edge_detect","title":"set_output_edge_detect","text":"<pre><code>set_output_edge_detect(*, enable: bool) -&gt; None\n</code></pre> <p>Enables or disables output edge detection mode for the logic trigger.</p> <p>Output edge detection is enabled by default and should be left enabled for normal operation.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>Whether to enable or disable output edge detection mode.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def set_output_edge_detect(self, *, enable: bool) -&gt; None:\n    \"\"\"Enables or disables output edge detection mode for the logic trigger.\n\n    Output edge detection is enabled by default and should be left enabled for normal operation.\n\n    Args:\n        enable: Whether to enable or disable output edge detection mode.\n    \"\"\"\n    self._f(\"SetOutputEdgeDetect\", self._handle, int(enable))\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.set_pulse_width_digital_port_properties","title":"set_pulse_width_digital_port_properties","text":"<pre><code>set_pulse_width_digital_port_properties(\n    directions: Sequence[DigitalChannelDirections],\n) -&gt; None\n</code></pre> <p>Set the individual digital channels' pulse-width trigger directions.</p> <p>Parameters:</p> Name Type Description Default <code>directions</code> <code>Sequence[DigitalChannelDirections]</code> <p>The digital-port properties. The sequence can contain a single element describing the properties of one digital channel, or a number of elements describing several digital channels. If empty, digital pulse width triggering is switched off. A digital channel that is not included in the array will be set to <code>DONT_CARE</code>.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def set_pulse_width_digital_port_properties(self, directions: Sequence[DigitalChannelDirections]) -&gt; None:\n    \"\"\"Set the individual digital channels' pulse-width trigger directions.\n\n    Args:\n        directions: The digital-port properties. The sequence can contain a single element describing\n            the properties of one digital channel, or a number of elements describing several digital\n            channels. If empty, digital pulse width triggering is switched off. A digital channel that\n            is not included in the array will be set to `DONT_CARE`.\n    \"\"\"\n    c_array = (DigitalChannelDirections * len(directions))(*directions)\n    self._f(\"SetPulseWidthDigitalPortProperties\", self._handle, c_array, len(directions))\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.set_pulse_width_qualifier_conditions","title":"set_pulse_width_qualifier_conditions","text":"<pre><code>set_pulse_width_qualifier_conditions(\n    conditions: Sequence[Condition],\n    info: ConditionsInfo | str | int,\n) -&gt; None\n</code></pre> <p>Set the condition to the pulse-width qualifier.</p> <p>It can either add the new condition to the existing qualifier, or clear the existing qualifier and replace it with the new condition.</p> <p>Parameters:</p> Name Type Description Default <code>conditions</code> <code>Sequence[Condition]</code> <p>A sequence of conditions.</p> required <code>info</code> <code>ConditionsInfo | str | int</code> <p>Whether to add this condition to the existing definition or clear the definition and start a new one. Can be an enum member name (case insensitive) or value.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def set_pulse_width_qualifier_conditions(\n    self, conditions: Sequence[Condition], info: ConditionsInfo | str | int\n) -&gt; None:\n    \"\"\"Set the condition to the pulse-width qualifier.\n\n    It can either add the new condition to the existing qualifier, or clear the\n    existing qualifier and replace it with the new condition.\n\n    Args:\n        conditions: A sequence of conditions.\n        info: Whether to add this condition to the existing definition or clear the definition\n            and start a new one. Can be an enum member name (case insensitive) or value.\n    \"\"\"\n    c_array = (Condition * len(conditions))(*conditions)\n    info = to_enum(info, ConditionsInfo, to_upper=True)\n    self._f(\"SetPulseWidthQualifierConditions\", self._handle, c_array, len(conditions), info)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.set_pulse_width_qualifier_directions","title":"set_pulse_width_qualifier_directions","text":"<pre><code>set_pulse_width_qualifier_directions(\n    directions: Sequence[Direction],\n) -&gt; None\n</code></pre> <p>Set the directions for all the trigger sources used with the pulse-width qualifier.</p> <p>Parameters:</p> Name Type Description Default <code>directions</code> <code>Sequence[Direction]</code> <p>Specifies which direction to apply to each trigger source.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def set_pulse_width_qualifier_directions(self, directions: Sequence[Direction]) -&gt; None:\n    \"\"\"Set the directions for all the trigger sources used with the pulse-width qualifier.\n\n    Args:\n        directions: Specifies which direction to apply to each trigger source.\n    \"\"\"\n    c_array = (Direction * len(directions))(*directions)\n    self._f(\"SetPulseWidthQualifierDirections\", self._handle, c_array, len(directions))\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.set_pulse_width_qualifier_properties","title":"set_pulse_width_qualifier_properties","text":"<pre><code>set_pulse_width_qualifier_properties(\n    lower: int,\n    upper: int = 0,\n    type: PulseWidthType | str | int = \"none\",\n) -&gt; None\n</code></pre> <p>Set the pulse width timings and logic type of the pulse-width trigger qualifier.</p> <p>Parameters:</p> Name Type Description Default <code>lower</code> <code>int</code> <p>The lower limit of the pulse-width counter, in samples. This argument is required for all pulse width types.</p> required <code>upper</code> <code>int</code> <p>The upper limit of the pulse-width counter, in samples. This argument is used only when the type is <code>IN_RANGE</code> or <code>OUT_OF_RANGE</code>.</p> <code>0</code> <code>type</code> <code>PulseWidthType | str | int</code> <p>The type of pulse width trigger. Can be an enum member name (case insensitive) or value.</p> <code>'none'</code> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def set_pulse_width_qualifier_properties(\n    self,\n    lower: int,\n    upper: int = 0,\n    type: PulseWidthType | str | int = \"none\",  # noqa: A002\n) -&gt; None:\n    \"\"\"Set the pulse width timings and logic type of the pulse-width trigger qualifier.\n\n    Args:\n        lower: The lower limit of the pulse-width counter, in samples. This argument is\n            required for all pulse width types.\n        upper: The upper limit of the pulse-width counter, in samples. This argument is\n            used only when the type is `IN_RANGE` or `OUT_OF_RANGE`.\n        type: The type of pulse width trigger. Can be an enum member name (case insensitive) or value.\n    \"\"\"\n    typ = to_enum(type, PulseWidthType, to_upper=True)\n    self._f(\"SetPulseWidthQualifierProperties\", self._handle, lower, upper, typ)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.set_sig_gen_arbitrary","title":"set_sig_gen_arbitrary","text":"<pre><code>set_sig_gen_arbitrary(\n    waveform: NDArray[float64],\n    repetition_rate: float | None = None,\n    offset_voltage: float = 0.0,\n    peak_to_peak: float | None = None,\n    start_delta_phase: int | None = None,\n    stop_delta_phase: int | None = None,\n    delta_phase_increment: int = 0,\n    dwell_count: int | None = None,\n    sweep_type: SweepType | str | int = \"up\",\n    operation: ExtraOperations | str | int = \"off\",\n    index_mode: IndexMode | str | int = \"single\",\n    shots: int = 0,\n    sweeps: int = 0,\n    trigger_type: SigGenTrigType | str | int = \"rising\",\n    trigger_source: SigGenTrigSource | str | int = \"none\",\n    ext_in_threshold: int = 0,\n) -&gt; NDArray[int16]\n</code></pre> <p>Set the signal generator to produce an arbitrary waveform.</p> <p>Parameters:</p> Name Type Description Default <code>waveform</code> <code>NDArray[float64]</code> <p>The arbitrary waveform, in volts. Must be 1D array.</p> required <code>repetition_rate</code> <code>float | None</code> <p>The requested repetition rate (frequency in Hz) of the entire arbitrary waveform. The actual repetition rate that is used may be different based on the specifications of the AWG. If specified then the sig_gen_frequency_to_phase method is called (with the <code>mode</code> value) to determine the value of <code>start_delta_phase</code>.</p> <code>None</code> <code>offset_voltage</code> <code>float</code> <p>The offset, in volts, to be applied to the waveform.</p> <code>0.0</code> <code>peak_to_peak</code> <code>float | None</code> <p>The peak-to-peak voltage of the waveform signal. If <code>None</code>, uses the maximum value of the <code>waveform</code> to determine the peak-to-peak voltage.</p> <code>None</code> <code>start_delta_phase</code> <code>int | None</code> <p>The initial value added to the phase accumulator as the generator begins to step through the waveform buffer. If <code>None</code> then <code>repetition_rate</code> must be specified.</p> <code>None</code> <code>stop_delta_phase</code> <code>int | None</code> <p>The final value added to the phase accumulator before the generator restarts or reverses the sweep. When frequency sweeping is not required, set equal to <code>start_delta_phase</code> (which is what it is set to if <code>None</code>).</p> <code>None</code> <code>delta_phase_increment</code> <code>int</code> <p>The amount added to the delta phase value every time the <code>dwell_count</code> period expires. This determines the amount by which the generator sweeps the output frequency in each dwell period. When frequency sweeping is not required, set to zero.</p> <code>0</code> <code>dwell_count</code> <code>int | None</code> <p>The time, in 50 ns steps, between successive additions of <code>delta_phase_increment</code> to the delta phase accumulator. This determines the rate at which the generator sweeps the output frequency. If <code>None</code>, the minimum dwell count value is used.</p> <code>None</code> <code>sweep_type</code> <code>SweepType | str | int</code> <p>How the frequency will sweep from <code>start_delta_phase</code> to <code>stop_delta_phase</code> or in the opposite direction. Can be an enum member name (case insensitive) or value.</p> <code>'up'</code> <code>operation</code> <code>ExtraOperations | str | int</code> <p>The type of waveform to be produced. Can be an enum member name (case insensitive) or value.</p> <code>'off'</code> <code>index_mode</code> <code>IndexMode | str | int</code> <p>Specifies how the signal will be formed from the arbitrary waveform data. Can be an enum member name (case insensitive) or value.</p> <code>'single'</code> <code>shots</code> <code>int</code> <p>See the manual.</p> <code>0</code> <code>sweeps</code> <code>int</code> <p>See the manual.</p> <code>0</code> <code>trigger_type</code> <code>SigGenTrigType | str | int</code> <p>The type of trigger that will be applied to the signal generator. Can be an enum member name (case insensitive) or value.</p> <code>'rising'</code> <code>trigger_source</code> <code>SigGenTrigSource | str | int</code> <p>The source that will trigger the signal generator. Can be an enum member name (case insensitive) or value.</p> <code>'none'</code> <code>ext_in_threshold</code> <code>int</code> <p>Used to set trigger level for an external trigger.</p> <code>0</code> <p>Returns:</p> Type Description <code>NDArray[int16]</code> <p>The arbitrary waveform in ADU counts.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def set_sig_gen_arbitrary(  # noqa: PLR0913\n    self,\n    waveform: NDArray[np.float64],\n    repetition_rate: float | None = None,\n    offset_voltage: float = 0.0,\n    peak_to_peak: float | None = None,\n    start_delta_phase: int | None = None,\n    stop_delta_phase: int | None = None,\n    delta_phase_increment: int = 0,\n    dwell_count: int | None = None,\n    sweep_type: SweepType | str | int = \"up\",\n    operation: ExtraOperations | str | int = \"off\",\n    index_mode: IndexMode | str | int = \"single\",\n    shots: int = 0,\n    sweeps: int = 0,\n    trigger_type: SigGenTrigType | str | int = \"rising\",\n    trigger_source: SigGenTrigSource | str | int = \"none\",\n    ext_in_threshold: int = 0,\n) -&gt; NDArray[np.int16]:\n    \"\"\"Set the signal generator to produce an arbitrary waveform.\n\n    Args:\n        waveform: The arbitrary waveform, in volts. Must be 1D array.\n        repetition_rate: The requested repetition rate (frequency in Hz) of the entire arbitrary waveform.\n            The actual repetition rate that is used may be different based on the specifications of\n            the AWG. If specified then the\n            [sig_gen_frequency_to_phase][msl.equipment_resources.picotech.picoscope.PicoScope.sig_gen_frequency_to_phase]\n            method is called (with the `mode` value) to determine the value of `start_delta_phase`.\n        offset_voltage: The offset, in volts, to be applied to the waveform.\n        peak_to_peak: The peak-to-peak voltage of the waveform signal. If `None`, uses\n            the maximum value of the `waveform` to determine the peak-to-peak voltage.\n        start_delta_phase: The initial value added to the phase accumulator as the generator begins\n            to step through the waveform buffer. If `None` then `repetition_rate` must be specified.\n        stop_delta_phase: The final value added to the phase accumulator before the generator restarts or\n            reverses the sweep. When frequency sweeping is not required, set equal to `start_delta_phase`\n            (which is what it is set to if `None`).\n        delta_phase_increment: The amount added to the delta phase value every time the `dwell_count`\n            period expires. This determines the amount by which the generator sweeps the output frequency\n            in each dwell period. When frequency sweeping is not required, set to zero.\n        dwell_count: The time, in 50 ns steps, between successive additions of `delta_phase_increment` to the\n            delta phase accumulator. This determines the rate at which the generator sweeps the output frequency.\n            If `None`, the minimum dwell count value is used.\n        sweep_type: How the frequency will sweep from `start_delta_phase` to `stop_delta_phase`\n            or in the opposite direction. Can be an enum member name (case insensitive) or value.\n        operation: The type of waveform to be produced. Can be an enum member name (case insensitive) or value.\n        index_mode: Specifies how the signal will be formed from the arbitrary waveform data.\n            Can be an enum member name (case insensitive) or value.\n        shots: See the manual.\n        sweeps: See the manual.\n        trigger_type: The type of trigger that will be applied to the signal generator.\n            Can be an enum member name (case insensitive) or value.\n        trigger_source: The source that will trigger the signal generator.\n            Can be an enum member name (case insensitive) or value.\n        ext_in_threshold: Used to set trigger level for an external trigger.\n\n    Returns:\n        The arbitrary waveform in ADU counts.\n    \"\"\"\n    _, max_value, min_size, max_size = self.sig_gen_arbitrary_min_max_values()\n    if waveform.size &lt; min_size:\n        msg = f\"The waveform size is {waveform.size}, must be &gt;= {min_size}\"\n        raise ValueError(msg)\n    if waveform.size &gt; max_size:\n        msg = f\"The waveform size is {waveform.size}, must be &lt;= {max_size}\"\n        raise ValueError(msg)\n\n    sweep_typ = to_enum(sweep_type, SweepType, to_upper=True)\n    extra_ops = to_enum(operation, ExtraOperations, to_upper=True)\n    index_mode = to_enum(index_mode, IndexMode, to_upper=True)\n    trig_typ = to_enum(trigger_type, SigGenTrigType, to_upper=True)\n    trig_source = to_enum(trigger_source, SigGenTrigSource, to_upper=True)\n\n    if start_delta_phase is None and repetition_rate is None:\n        msg = \"Must specify either 'start_delta_phase' or 'repetition_rate'\"\n        raise ValueError(msg)\n\n    if start_delta_phase is None:\n        assert repetition_rate is not None  # noqa: S101\n        start_delta_phase = self.sig_gen_frequency_to_phase(repetition_rate, index_mode, waveform.size)\n\n    if stop_delta_phase is None:\n        stop_delta_phase = start_delta_phase\n\n    if dwell_count is None:\n        dwell_count = to_enum(\"MIN_DWELL_COUNT\", _Constants, prefix=f\"{self._prefix}_\", to_upper=True)\n\n    # convert the waveform from volts to analogue-to-digital units\n    _waveform = waveform.copy()\n    max_waveform_value: float = np.max(np.absolute(_waveform))\n    _waveform /= max_waveform_value  # the waveform must be within the range -1.0 to 1.0\n    _waveform *= max_value\n    waveform_adu: NDArray[np.int16] = _waveform.round(out=_waveform).astype(np.int16)\n\n    if peak_to_peak is None:\n        peak_to_peak = max_waveform_value / 2.0\n\n    offset = round(offset_voltage * 1e6)\n    pk2pk = round(peak_to_peak * 1e6)\n\n    self._f(\n        \"SetSigGenArbitrary\",\n        self._handle,\n        offset,\n        pk2pk,\n        start_delta_phase,\n        stop_delta_phase,\n        delta_phase_increment,\n        dwell_count,\n        waveform_adu,\n        waveform_adu.size,\n        sweep_typ,\n        extra_ops,\n        index_mode,\n        shots,\n        sweeps,\n        trig_typ,\n        trig_source,\n        ext_in_threshold,\n    )\n    return waveform_adu\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.set_sig_gen_builtin_v2","title":"set_sig_gen_builtin_v2","text":"<pre><code>set_sig_gen_builtin_v2(\n    offset_voltage: float = 0.0,\n    peak_to_peak: float = 1.0,\n    wave_type: WaveType | str | int = \"sine\",\n    start_frequency: float = 1.0,\n    stop_frequency: float | None = None,\n    increment: float = 0.1,\n    dwell_time: float = 1.0,\n    sweep_type: SweepType | str | int = \"up\",\n    operation: ExtraOperations | str | int = \"off\",\n    shots: int = 0,\n    sweeps: int = 0,\n    trigger_type: SigGenTrigType | str | int = \"rising\",\n    trigger_source: SigGenTrigSource | str | int = \"none\",\n    ext_in_threshold: int = 0,\n) -&gt; None\n</code></pre> <p>Set up the signal generator to produce a signal from a list of built-in waveforms.</p> <p>Parameters:</p> Name Type Description Default <code>offset_voltage</code> <code>float</code> <p>The voltage offset, in volts, to be applied to the waveform.</p> <code>0.0</code> <code>peak_to_peak</code> <code>float</code> <p>The peak-to-peak voltage, in volts, of the waveform signal.</p> <code>1.0</code> <code>wave_type</code> <code>WaveType | str | int</code> <p>The type of waveform to be generated. Can be an enum member name (case insensitive) or value.</p> <code>'sine'</code> <code>start_frequency</code> <code>float</code> <p>The frequency that the signal generator will initially produce.</p> <code>1.0</code> <code>stop_frequency</code> <code>float | None</code> <p>The frequency at which the sweep reverses direction or returns to the initial frequency. If <code>None</code>, it is set equal to <code>start_frequency</code>.</p> <code>None</code> <code>increment</code> <code>float</code> <p>The amount of frequency increase or decrease in sweep mode.</p> <code>0.1</code> <code>dwell_time</code> <code>float</code> <p>The time, in seconds, for which the sweep stays at each frequency.</p> <code>1.0</code> <code>sweep_type</code> <code>SweepType | str | int</code> <p>How the frequency will sweep from <code>start_frequency</code> to <code>stop_frequency</code> or in the opposite direction. Can be an enum member name (case insensitive) or value.</p> <code>'up'</code> <code>operation</code> <code>ExtraOperations | str | int</code> <p>The type of waveform to be produced (not used by 5000A models). Can be an enum member name (case insensitive) or value.</p> <code>'off'</code> <code>shots</code> <code>int</code> <p>See the manual.</p> <code>0</code> <code>sweeps</code> <code>int</code> <p>See the manual.</p> <code>0</code> <code>trigger_type</code> <code>SigGenTrigType | str | int</code> <p>The type of trigger that will be applied to the signal generator. Can be an enum member name (case insensitive) or value.</p> <code>'rising'</code> <code>trigger_source</code> <code>SigGenTrigSource | str | int</code> <p>The source that will trigger the signal generator. Can be an enum member name (case insensitive) or value.</p> <code>'none'</code> <code>ext_in_threshold</code> <code>int</code> <p>Used to set trigger level for an external trigger.</p> <code>0</code> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def set_sig_gen_builtin_v2(  # noqa: PLR0913\n    self,\n    offset_voltage: float = 0.0,\n    peak_to_peak: float = 1.0,\n    wave_type: WaveType | str | int = \"sine\",\n    start_frequency: float = 1.0,\n    stop_frequency: float | None = None,\n    increment: float = 0.1,\n    dwell_time: float = 1.0,\n    sweep_type: SweepType | str | int = \"up\",\n    operation: ExtraOperations | str | int = \"off\",\n    shots: int = 0,\n    sweeps: int = 0,\n    trigger_type: SigGenTrigType | str | int = \"rising\",\n    trigger_source: SigGenTrigSource | str | int = \"none\",\n    ext_in_threshold: int = 0,\n) -&gt; None:\n    \"\"\"Set up the signal generator to produce a signal from a list of built-in waveforms.\n\n    Args:\n        offset_voltage: The voltage offset, in volts, to be applied to the waveform.\n        peak_to_peak: The peak-to-peak voltage, in volts, of the waveform signal.\n        wave_type: The type of waveform to be generated.\n            Can be an enum member name (case insensitive) or value.\n        start_frequency: The frequency that the signal generator will initially produce.\n        stop_frequency: The frequency at which the sweep reverses direction or returns\n            to the initial frequency. If `None`, it is set equal to `start_frequency`.\n        increment: The amount of frequency increase or decrease in sweep mode.\n        dwell_time: The time, in seconds, for which the sweep stays at each frequency.\n        sweep_type: How the frequency will sweep from `start_frequency` to `stop_frequency`\n            or in the opposite direction. Can be an enum member name (case insensitive) or value.\n        operation: The type of waveform to be produced (not used by 5000A models).\n            Can be an enum member name (case insensitive) or value.\n        shots: See the manual.\n        sweeps: See the manual.\n        trigger_type: The type of trigger that will be applied to the signal generator.\n            Can be an enum member name (case insensitive) or value.\n        trigger_source: The source that will trigger the signal generator.\n            Can be an enum member name (case insensitive) or value.\n        ext_in_threshold: Used to set trigger level for an external trigger.\n    \"\"\"\n    wave_typ = to_enum(wave_type, WaveType, to_upper=True)\n    sweep_typ = to_enum(sweep_type, SweepType, to_upper=True)\n    extra_ops = to_enum(operation, ExtraOperations, to_upper=True)\n    trig_typ = to_enum(trigger_type, SigGenTrigType, to_upper=True)\n    trig_source = to_enum(trigger_source, SigGenTrigSource, to_upper=True)\n\n    if stop_frequency is None:\n        stop_frequency = start_frequency\n\n    self._f(\n        \"SetSigGenBuiltInV2\",\n        self._handle,\n        round(offset_voltage * 1e6),\n        round(peak_to_peak * 1e6),\n        wave_typ,\n        start_frequency,\n        stop_frequency,\n        increment,\n        dwell_time,\n        sweep_typ,\n        extra_ops,\n        shots,\n        sweeps,\n        trig_typ,\n        trig_source,\n        ext_in_threshold,\n    )\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.set_timebase","title":"set_timebase","text":"<pre><code>set_timebase(\n    dt: float, duration: float, segment: int = 0\n) -&gt; tuple[float, int]\n</code></pre> <p>Set the timebase information.</p> <p>This method does not consider ETS (equivalent-time sampling). If using ETS, consider using set_ets. See also, nearest_sample_interval_stateless.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>float</code> <p>The requested sampling interval, in seconds.</p> required <code>duration</code> <code>float</code> <p>The number of seconds to acquire samples for.</p> required <code>segment</code> <code>int</code> <p>The index of the memory segment to use.</p> <code>0</code> <p>Returns:</p> Type Description <code>tuple[float, int]</code> <p>The actual sampling interval (i.e., actual \u0394t) and the number of samples that will be acquired.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def set_timebase(self, dt: float, duration: float, segment: int = 0) -&gt; tuple[float, int]:\n    \"\"\"Set the timebase information.\n\n    This method does not consider ETS (equivalent-time sampling). If using ETS, consider using\n    [set_ets][msl.equipment_resources.picotech.picoscope.PicoScope.set_ets]. See also,\n    [nearest_sample_interval_stateless][msl.equipment_resources.picotech.picoscope.PicoScope.nearest_sample_interval_stateless].\n\n    Args:\n        dt: The requested sampling interval, in seconds.\n        duration: The number of seconds to acquire samples for.\n        segment: The index of the memory segment to use.\n\n    Returns:\n        The actual sampling interval (i.e., actual &amp;Delta;t) and the number of samples\n            that will be acquired.\n    \"\"\"\n    self._timebase_index = round(self._get_timebase_index(float(dt)))\n    num_samples_requested = round(duration / dt)\n    self._sampling_interval, _ = self.get_timebase2(self._timebase_index, num_samples_requested, segment)\n\n    self._num_samples = round(duration / self._sampling_interval)\n\n    # determine the TimeUnits enum from the sample interval\n    for unit in _TimeUnits:\n        num_seconds_float = self._sampling_interval / _TimeUnits.to_float(unit)\n        if num_seconds_float &lt; 1e9:  # use &lt;9 digits to specify the streaming sampling interval  # noqa: PLR2004\n            self._streaming_sampling_interval = round(num_seconds_float)\n            self._streaming_time_units = unit\n            break\n\n    return self._sampling_interval, self._num_samples\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.set_trigger","title":"set_trigger","text":"<pre><code>set_trigger(\n    channel: Channel | str | int,\n    threshold: float,\n    *,\n    delay: float = 0.0,\n    direction: ThresholdDirection | str | int = \"RISING\",\n    timeout: float | None = None,\n    enable: bool = True\n) -&gt; None\n</code></pre> <p>Set up the trigger.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel | str | int</code> <p>The trigger channel. Can be an enum member name (case insensitive) or value.</p> required <code>threshold</code> <code>float</code> <p>The threshold voltage to signal a trigger event.</p> required <code>delay</code> <code>float</code> <p>The time, in seconds, between the trigger occurring and the first sample.</p> <code>0.0</code> <code>direction</code> <code>ThresholdDirection | str | int</code> <p>The direction in which the signal must move to cause a trigger. Can be an enum member name (case insensitive) or value.</p> <code>'RISING'</code> <code>timeout</code> <code>float | None</code> <p>The time, in seconds, to wait to automatically create a trigger event if no trigger event occurs. If <code>timeout</code> \u2264 0 or <code>None</code>, then wait indefinitely for a trigger. Only accurate to the nearest millisecond.</p> <code>None</code> <code>enable</code> <code>bool</code> <p>Set to <code>False</code> to disable the trigger for this channel.</p> <code>True</code> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def set_trigger(\n    self,\n    channel: Channel | str | int,\n    threshold: float,\n    *,\n    delay: float = 0.0,\n    direction: ThresholdDirection | str | int = \"RISING\",\n    timeout: float | None = None,\n    enable: bool = True,\n) -&gt; None:\n    \"\"\"Set up the trigger.\n\n    Args:\n        channel: The trigger channel. Can be an enum member name (case insensitive) or value.\n        threshold: The threshold voltage to signal a trigger event.\n        delay: The time, in seconds, between the trigger occurring and the first sample.\n        direction: The direction in which the signal must move to cause a trigger.\n            Can be an enum member name (case insensitive) or value.\n        timeout: The time, in seconds, to wait to automatically create a trigger event if no\n            trigger event occurs. If `timeout` &amp;le; 0 or `None`, then wait indefinitely for a trigger.\n            Only accurate to the nearest millisecond.\n        enable: Set to `False` to disable the trigger for this channel.\n    \"\"\"\n    ch = to_enum(channel, Channel, to_upper=True)\n    if ch.name not in self._channels:\n        msg = f\"Must call set_channel(channel='{ch.name}', ...) before enabling a trigger with channel {ch.name}\"\n        raise MSLConnectionError(self, msg)\n\n    if self._sampling_interval &lt; 0:\n        msg = \"Must call set_timebase() before setting the trigger\"\n        raise MSLConnectionError(self, msg)\n\n    if delay &lt; 0:\n        msg = f\"The trigger delay must be &gt;=0 seconds, requested a delay of {delay} seconds\"\n        raise ValueError(msg)\n\n    delay_ = round(delay / self._sampling_interval)\n    max_delay_count = to_enum(\"MAX_DELAY_COUNT\", _Constants, prefix=f\"{self._prefix}_\", to_upper=True)\n    if delay_ &gt; max_delay_count:\n        msg = (\n            f\"The maximum allowed trigger delay is {max_delay_count * self._sampling_interval} seconds, \"\n            f\"requested a delay of {delay} seconds\"\n        )\n        raise ValueError(msg)\n\n    if ch == Channel.EXT:\n        max_value = to_enum(\"EXT_MAX_VALUE\", _Constants, prefix=f\"{self._prefix}_\", to_upper=True)\n        max_volts = to_enum(\"EXT_MAX_VOLTAGE\", _Constants, prefix=f\"{self._prefix}_\", to_upper=True)\n        threshold_adu = round(max_value * threshold / float(max_volts))\n    else:\n        voltage_offset = self._channels[ch.name].voltage_offset\n        adu_per_volt = 1.0 / self._channels[ch.name].volts_per_adu\n        threshold_adu = round(adu_per_volt * (threshold + voltage_offset))\n\n    trig_dir = to_enum(direction, ThresholdDirection, to_upper=True)\n    auto_trigger_ms = round(max(0, timeout * 1e3)) if timeout is not None else 0\n    self._f(\"SetSimpleTrigger\", self._handle, enable, ch, threshold_adu, trig_dir, delay_, auto_trigger_ms)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.set_trigger_channel_conditions_v2","title":"set_trigger_channel_conditions_v2","text":"<pre><code>set_trigger_channel_conditions_v2(\n    conditions: Sequence[Condition],\n    info: ConditionsInfo | str | int,\n) -&gt; None\n</code></pre> <p>Sets up trigger conditions on the scope's inputs.</p> <p>Parameters:</p> Name Type Description Default <code>conditions</code> <code>Sequence[Condition]</code> <p>The conditions that should be applied to each channel. In the simplest case, the sequence consists of a single element. When there is more than one element, the overall trigger condition is the logical OR of all the elements.</p> required <code>info</code> <code>ConditionsInfo | str | int</code> <p>Specifies whether to clear the existing conditions or add the current condition to them using logical OR. Can be an enum member name (case insensitive) or value.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def set_trigger_channel_conditions_v2(\n    self, conditions: Sequence[Condition], info: ConditionsInfo | str | int\n) -&gt; None:\n    \"\"\"Sets up trigger conditions on the scope's inputs.\n\n    Args:\n        conditions: The conditions that should be applied to each channel. In the simplest case,\n            the sequence consists of a single element. When there is more than one element, the\n            overall trigger condition is the logical OR of all the elements.\n        info: Specifies whether to clear the existing conditions or add the current condition to\n            them using logical OR. Can be an enum member name (case insensitive) or value.\n    \"\"\"\n    c_array = (Condition * len(conditions))(*conditions)\n    info = to_enum(info, ConditionsInfo, to_upper=True)\n    self._f(\"SetTriggerChannelConditionsV2\", self._handle, c_array, len(conditions), info)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.set_trigger_channel_directions_v2","title":"set_trigger_channel_directions_v2","text":"<pre><code>set_trigger_channel_directions_v2(\n    directions: Sequence[Direction],\n) -&gt; None\n</code></pre> <p>Sets the direction of the trigger for each channel.</p> <p>Parameters:</p> Name Type Description Default <code>directions</code> <code>Sequence[Direction]</code> <p>A sequence of directions in which the signal must pass through the threshold to activate the trigger.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def set_trigger_channel_directions_v2(self, directions: Sequence[Direction]) -&gt; None:\n    \"\"\"Sets the direction of the trigger for each channel.\n\n    Args:\n        directions: A sequence of directions in which the signal must pass through\n            the threshold to activate the trigger.\n    \"\"\"\n    c_array = (Direction * len(directions))(*directions)\n    self._f(\"SetTriggerChannelDirectionsV2\", self._handle, c_array, len(directions))\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.set_trigger_channel_properties_v2","title":"set_trigger_channel_properties_v2","text":"<pre><code>set_trigger_channel_properties_v2(\n    properties: Sequence[TriggerChannelPropertiesV2],\n) -&gt; None\n</code></pre> <p>Enable or disable triggering and set its parameters.</p> <p>Parameters:</p> Name Type Description Default <code>properties</code> <code>Sequence[TriggerChannelPropertiesV2]</code> <p>The requested properties. The sequence can contain a single element describing the properties of one channel, or a number of elements describing several channels. If empty, triggering is switched off.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def set_trigger_channel_properties_v2(self, properties: Sequence[TriggerChannelPropertiesV2]) -&gt; None:\n    \"\"\"Enable or disable triggering and set its parameters.\n\n    Args:\n        properties: The requested properties. The sequence can contain a single element describing the\n            properties of one channel, or a number of elements describing several channels. If empty,\n            triggering is switched off.\n    \"\"\"\n    c_array = (TriggerChannelPropertiesV2 * len(properties))(*properties)\n    self._f(\"SetTriggerChannelPropertiesV2\", self._handle, c_array, len(properties), 0)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.set_trigger_delay","title":"set_trigger_delay","text":"<pre><code>set_trigger_delay(delay: float) -&gt; None\n</code></pre> <p>Sets the post-trigger delay, which causes capture to start a defined time after the trigger event.</p> <p>Parameters:</p> Name Type Description Default <code>delay</code> <code>float</code> <p>The time, in seconds, between the trigger occurring and the first sample</p> required Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def set_trigger_delay(self, delay: float) -&gt; None:\n    \"\"\"Sets the post-trigger delay, which causes capture to start a defined time after the trigger event.\n\n    Args:\n        delay: The time, in seconds, between the trigger occurring and the first sample\n    \"\"\"\n    if self._sampling_interval &lt; 0:\n        msg = \"Must call set_timebase() before setting the trigger delay\"\n        raise MSLConnectionError(self, msg)\n\n    delay_ = round(delay / self._sampling_interval)\n    max_delay_count = to_enum(\"MAX_DELAY_COUNT\", _Constants, prefix=f\"{self._prefix}_\", to_upper=True)\n    if delay_ &gt; max_delay_count:\n        msg = (\n            f\"The maximum allowed trigger delay is {max_delay_count * self._sampling_interval} seconds, \"\n            f\"requested a delay of {delay} seconds\"\n        )\n        raise ValueError(msg)\n\n    self._f(\"SetTriggerDelay\", self._handle, delay_)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.set_trigger_digital_port_properties","title":"set_trigger_digital_port_properties","text":"<pre><code>set_trigger_digital_port_properties(\n    directions: Sequence[DigitalChannelDirections],\n) -&gt; None\n</code></pre> <p>Set the individual digital channel's trigger directions.</p> <p>Parameters:</p> Name Type Description Default <code>directions</code> <code>Sequence[DigitalChannelDirections]</code> <p>The digital-port properties. The sequence can contain a single element describing the properties of one digital channel, or a number of elements describing several digital channels. If empty, digital pulse width triggering is switched off. A digital channel that is not included in the array will be set to <code>DONT_CARE</code>. The outcomes of all the <code>directions</code> in the sequence are bitwise-OR'ed together to produce the final trigger signal.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def set_trigger_digital_port_properties(self, directions: Sequence[DigitalChannelDirections]) -&gt; None:\n    \"\"\"Set the individual digital channel's trigger directions.\n\n    Args:\n        directions: The digital-port properties. The sequence can contain a single element describing\n            the properties of one digital channel, or a number of elements describing several digital\n            channels. If empty, digital pulse width triggering is switched off. A digital channel that\n            is not included in the array will be set to `DONT_CARE`. The outcomes of all the `directions`\n            in the sequence are bitwise-OR'ed together to produce the final trigger signal.\n    \"\"\"\n    c_array = (DigitalChannelDirections * len(directions))(*directions)\n    self._f(\"SetTriggerDigitalPortProperties\", self._handle, c_array, len(directions))\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.sig_gen_arbitrary_min_max_values","title":"sig_gen_arbitrary_min_max_values","text":"<pre><code>sig_gen_arbitrary_min_max_values() -&gt; (\n    tuple[int, int, int, int]\n)\n</code></pre> <p>Get the range of possible sample values and waveform buffer sizes.</p> <p>Returns:</p> Type Description <code>tuple[int, int, int, int]</code> <p>The range of possible sample values and waveform buffer sizes that can be supplied to set_sig_gen_arbitrary for setting up the arbitrary waveform generator (i.e., <code>(min_value, max_value, min_size, max_size)</code>).</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def sig_gen_arbitrary_min_max_values(self) -&gt; tuple[int, int, int, int]:\n    \"\"\"Get the range of possible sample values and waveform buffer sizes.\n\n    Returns:\n        The range of possible sample values and waveform buffer sizes that can be supplied to\n            [set_sig_gen_arbitrary][msl.equipment_resources.picotech.picoscope.PicoScope.set_sig_gen_arbitrary]\n            for setting up the arbitrary waveform generator (i.e., `(min_value, max_value, min_size, max_size)`).\n    \"\"\"\n    min_value = c_int16()\n    max_value = c_int16()\n    min_size = c_uint32()\n    max_size = c_uint32()\n    self._f(\n        \"SigGenArbitraryMinMaxValues\",\n        self._handle,\n        byref(min_value),\n        byref(max_value),\n        byref(min_size),\n        byref(max_size),\n    )\n    return min_value.value, max_value.value, min_size.value, max_size.value\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.sig_gen_frequency_to_phase","title":"sig_gen_frequency_to_phase","text":"<pre><code>sig_gen_frequency_to_phase(\n    repetition_rate: float,\n    index_mode: IndexMode | str | int,\n    size: int,\n) -&gt; int\n</code></pre> <p>Converts a frequency to a phase count for use with the arbitrary waveform generator (AWG).</p> <p>Parameters:</p> Name Type Description Default <code>repetition_rate</code> <code>float</code> <p>The requested repetition rate (frequency in Hz) of the entire arbitrary waveform.</p> required <code>index_mode</code> <code>IndexMode | str | int</code> <p>Specifies how the signal will be formed from the arbitrary waveform data. Can be an enum member name (case insensitive) or value.</p> required <code>size</code> <code>int</code> <p>The size (number of samples) of the waveform.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The phase count. The phase count can then be sent to the driver through set_sig_gen_arbitrary.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def sig_gen_frequency_to_phase(self, repetition_rate: float, index_mode: IndexMode | str | int, size: int) -&gt; int:\n    \"\"\"Converts a frequency to a phase count for use with the arbitrary waveform generator (AWG).\n\n    Args:\n        repetition_rate: The requested repetition rate (frequency in Hz) of the entire arbitrary waveform.\n        index_mode: Specifies how the signal will be formed from the arbitrary waveform data.\n            Can be an enum member name (case insensitive) or value.\n        size: The size (number of samples) of the waveform.\n\n    Returns:\n        The phase count. The phase count can then be sent to the driver through\n            [set_sig_gen_arbitrary][msl.equipment_resources.picotech.picoscope.PicoScope.set_sig_gen_arbitrary].\n    \"\"\"\n    mode = to_enum(index_mode, IndexMode, to_upper=True)\n\n    phase = c_uint32()\n    self._f(\"SigGenFrequencyToPhase\", self._handle, repetition_rate, mode, size, byref(phase))\n    if phase.value &lt; 1:\n        msg = \"The delta phase value is &lt; 1, increase the repetition rate value\"\n        raise ValueError(msg)\n    return phase.value\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.sig_gen_software_control","title":"sig_gen_software_control","text":"<pre><code>sig_gen_software_control(*, state: bool) -&gt; None\n</code></pre> <p>Send a software trigger event, or starts and stops gating.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>Specifies the new state of the gate signal.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def sig_gen_software_control(self, *, state: bool) -&gt; None:\n    \"\"\"Send a software trigger event, or starts and stops gating.\n\n    Args:\n        state: Specifies the new state of the gate signal.\n    \"\"\"\n    self._f(\"SigGenSoftwareControl\", self._handle, int(state))\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.stop","title":"stop","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop the oscilloscope from sampling data.</p> <p>If this function is called before a trigger event occurs, then the oscilloscope may not contain valid data.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop the oscilloscope from sampling data.\n\n    If this function is called before a trigger event occurs, then the\n    oscilloscope may not contain valid data.\n    \"\"\"\n    self._f(\"Stop\", self._handle)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.trigger_within_pre_trigger_samples","title":"trigger_within_pre_trigger_samples","text":"<pre><code>trigger_within_pre_trigger_samples(\n    state: TriggerWithinPreTrigger | str | int,\n) -&gt; None\n</code></pre> <p>Allow a trigger anywhere within the pre-trigger samples.</p> <p>This function selects a mode in which the scope can be triggered anywhere within the pre-trigger samples, as opposed to the normal operation of only arming the trigger after all the pre-trigger samples have been collected.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>TriggerWithinPreTrigger | str | int</code> <p>Can be an enum member name (case insensitive) or value.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def trigger_within_pre_trigger_samples(self, state: TriggerWithinPreTrigger | str | int) -&gt; None:\n    \"\"\"Allow a trigger anywhere within the pre-trigger samples.\n\n    This function selects a mode in which the scope can be triggered anywhere within the pre-trigger\n    samples, as opposed to the normal operation of only arming the trigger after all the pre-trigger\n    samples have been collected.\n\n    Args:\n        state: Can be an enum member name (case insensitive) or value.\n    \"\"\"\n    state = to_enum(state, TriggerWithinPreTrigger, to_upper=True)\n    self._f(\"TriggerWithinPreTriggerSamples\", self._handle, state)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PicoScope.wait_until_ready","title":"wait_until_ready","text":"<pre><code>wait_until_ready() -&gt; None\n</code></pre> <p>Blocking function to wait for the scope to finish acquiring samples.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def wait_until_ready(self) -&gt; None:\n    \"\"\"Blocking function to wait for the scope to finish acquiring samples.\"\"\"\n    while not self.is_ready():\n        time.sleep(0.01)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.PulseWidthType","title":"PulseWidthType","text":"<p>               Bases: <code>IntEnum</code></p> <p>The type of pulse-width trigger.</p> <p>Attributes:</p> Name Type Description <code>NONE</code> <code>int</code> <p>Do not use the pulse width qualifier. <code>0</code></p> <code>LESS_THAN</code> <code>int</code> <p>Pulse width less than lower. <code>1</code></p> <code>GREATER_THAN</code> <code>int</code> <p>Pulse width greater than lower. <code>2</code></p> <code>IN_RANGE</code> <code>int</code> <p>Pulse width between lower and upper. <code>3</code></p> <code>OUT_OF_RANGE</code> <code>int</code> <p>Pulse width not between lower and upper. <code>4</code></p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.Range","title":"Range","text":"<p>               Bases: <code>IntEnum</code></p> <p>The possible voltage ranges to which an analogue input channel can be set.</p> <p>Each range is bipolar, so the <code>R_10mV</code> range spans from -10 mV to +10 mV.</p> <p>Attributes:</p> Name Type Description <code>R_10mV</code> <code>int</code> <p><code>0</code></p> <code>R_20mV</code> <code>int</code> <p><code>1</code></p> <code>R_50mV</code> <code>int</code> <p><code>2</code></p> <code>R_100mV</code> <code>int</code> <p><code>3</code></p> <code>R_200mV</code> <code>int</code> <p><code>4</code></p> <code>R_500mV</code> <code>int</code> <p><code>5</code></p> <code>R_1V</code> <code>int</code> <p><code>6</code></p> <code>R_2V</code> <code>int</code> <p><code>7</code></p> <code>R_5V</code> <code>int</code> <p><code>8</code></p> <code>R_10V</code> <code>int</code> <p><code>9</code></p> <code>R_20V</code> <code>int</code> <p><code>10</code></p> <code>R_50V</code> <code>int</code> <p><code>11</code></p> <code>R_MAX</code> <code>int</code> <p><code>12</code></p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.RatioMode","title":"RatioMode","text":"<p>               Bases: <code>IntEnum</code></p> <p>Various methods of data reduction (down sampling).</p> <p>Attributes:</p> Name Type Description <code>NONE</code> <code>int</code> <p>No down sampling. <code>0</code></p> <code>AGGREGATE</code> <code>int</code> <p>Reduces every block of n values to just two values: a minimum and a maximum. <code>1</code></p> <code>DECIMATE</code> <code>int</code> <p>Reduces every block of n values to just the first value in the block, discarding all the other values. <code>2</code></p> <code>AVERAGE</code> <code>int</code> <p>Reduces every block of n values to a single value representing the average (arithmetic mean) of all the values. <code>4</code></p> <code>DISTRIBUTION</code> <code>int</code> <p>Not used. <code>8</code></p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.SigGenTrigSource","title":"SigGenTrigSource","text":"<p>               Bases: <code>IntEnum</code></p> <p>How triggering of the signal generator or arbitrary waveform generator works.</p> <p>Attributes:</p> Name Type Description <code>NONE</code> <code>int</code> <p>Run without waiting for trigger. <code>0</code></p> <code>SCOPE_TRIG</code> <code>int</code> <p>Use scope trigger. <code>1</code></p> <code>AUX_IN</code> <code>int</code> <p>Use AUX input. <code>2</code></p> <code>EXT_IN</code> <code>int</code> <p>Use EXT input. <code>3</code></p> <code>SOFT_TRIG</code> <code>int</code> <p>Wait for software trigger from sig_gen_software_control. <code>4</code></p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.SigGenTrigType","title":"SigGenTrigType","text":"<p>               Bases: <code>IntEnum</code></p> <p>Trigger types used by the signal generator or arbitrary waveform generator.</p> <p>Attributes:</p> Name Type Description <code>RISING</code> <code>int</code> <p><code>0</code></p> <code>FALLING</code> <code>int</code> <p><code>1</code></p> <code>GATE_HIGH</code> <code>int</code> <p><code>2</code></p> <code>GATE_LOW</code> <code>int</code> <p><code>3</code></p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.SweepType","title":"SweepType","text":"<p>               Bases: <code>IntEnum</code></p> <p>The frequency sweep mode of the signal generator or arbitrary waveform generator.</p> <p>Attributes:</p> Name Type Description <code>UP</code> <code>int</code> <p>Sweep the frequency from lower limit up to upper limit. <code>0</code></p> <code>DOWN</code> <code>int</code> <p>Sweep the frequency from upper limit down to lower limit. <code>1</code></p> <code>UPDOWN</code> <code>int</code> <p>Sweep the frequency up and then down. <code>2</code></p> <code>DOWNUP</code> <code>int</code> <p>Sweep the frequency down and then up. <code>3</code></p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.ThresholdDirection","title":"ThresholdDirection","text":"<p>               Bases: <code>IntEnum</code></p> <p>The direction(s) in which the trigger source must cross the threshold(s) to cause a trigger event.</p> <p>Attributes:</p> Name Type Description <code>ABOVE</code> <code>int</code> <p>Using upper threshold. <code>0</code></p> <code>BELOW</code> <code>int</code> <p>Using upper threshold. <code>1</code></p> <code>RISING</code> <code>int</code> <p>Using upper threshold. <code>2</code></p> <code>FALLING</code> <code>int</code> <p>Using upper threshold. <code>3</code></p> <code>RISING_OR_FALLING</code> <code>int</code> <p>Using both thresholds. <code>4</code></p> <code>ABOVE_LOWER</code> <code>int</code> <p>Using lower threshold. <code>5</code></p> <code>BELOW_LOWER</code> <code>int</code> <p>Using lower threshold. <code>6</code></p> <code>RISING_LOWER</code> <code>int</code> <p>Using lower threshold. <code>7</code></p> <code>FALLING_LOWER</code> <code>int</code> <p>Using lower threshold. <code>8</code></p> <code>INSIDE</code> <code>int</code> <p>Windowing using both thresholds. <code>0</code></p> <code>OUTSIDE</code> <code>int</code> <p>Windowing using both thresholds. <code>1</code></p> <code>ENTER</code> <code>int</code> <p>Windowing using both thresholds. <code>2</code></p> <code>EXIT</code> <code>int</code> <p>Windowing using both thresholds. <code>3</code></p> <code>ENTER_OR_EXIT</code> <code>int</code> <p>Windowing using both thresholds. <code>4</code></p> <code>POSITIVE_RUNT</code> <code>int</code> <p>Windowing using both thresholds. <code>9</code></p> <code>NEGATIVE_RUNT</code> <code>int</code> <p>Windowing using both thresholds. <code>10</code></p> <code>NONE</code> <code>int</code> <p>No trigger set. <code>2</code></p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.ThresholdMode","title":"ThresholdMode","text":"<p>               Bases: <code>IntEnum</code></p> <p>The type of threshold used by a trigger condition.</p> <p>Attributes:</p> Name Type Description <code>LEVEL</code> <code>int</code> <p>An edge or level trigger with a single threshold. <code>0</code></p> <code>WINDOW</code> <code>int</code> <p>Two thresholds defining a range. <code>1</code></p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.TriggerChannelPropertiesV2","title":"TriggerChannelPropertiesV2","text":"<pre><code>TriggerChannelPropertiesV2(\n    threshold_upper: int,\n    threshold_upper_hysteresis: int,\n    threshold_lower: int,\n    threshold_lower_hysteresis: int,\n    channel: Channel | str | int,\n)\n</code></pre> <p>               Bases: <code>Structure</code></p> <p>The trigger thresholds for a given channel (version 2).</p> <p>Parameters:</p> Name Type Description Default <code>threshold_upper</code> <code>int</code> <p>The upper threshold at which the trigger must fire. This is scaled in 16-bit ADC counts at the currently selected range for that channel.</p> required <code>threshold_upper_hysteresis</code> <code>int</code> <p>The hysteresis by which the trigger must exceed the upper threshold before it will fire. It is scaled in 16-bit counts.</p> required <code>threshold_lower</code> <code>int</code> <p>The lower threshold at which the trigger must fire. This is scaled in 16-bit ADC counts at the currently selected range for that channel.</p> required <code>threshold_lower_hysteresis</code> <code>int</code> <p>The hysteresis by which the trigger must exceed the lower threshold before it will fire. It is scaled in 16-bit counts.</p> required <code>channel</code> <code>Channel | str | int</code> <p>The channel to which the properties apply. Can be an enum member name (case insensitive) or value.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def __init__(\n    self,\n    threshold_upper: int,\n    threshold_upper_hysteresis: int,\n    threshold_lower: int,\n    threshold_lower_hysteresis: int,\n    channel: Channel | str | int,\n) -&gt; None:\n    \"\"\"The trigger thresholds for a given channel (version 2).\n\n    Args:\n        threshold_upper: The upper threshold at which the trigger must fire. This is scaled\n            in 16-bit ADC counts at the currently selected range for that channel.\n        threshold_upper_hysteresis: The hysteresis by which the trigger must exceed\n            the upper threshold before it will fire. It is scaled in 16-bit counts.\n        threshold_lower: The lower threshold at which the trigger must fire. This\n            is scaled in 16-bit ADC counts at the currently selected range for that channel.\n        threshold_lower_hysteresis: The hysteresis by which the trigger must exceed\n            the lower threshold before it will fire. It is scaled in 16-bit counts.\n        channel: The channel to which the properties apply. Can be an enum member name\n            (case insensitive) or value.\n    \"\"\"\n    self.threshold_upper: int = threshold_upper\n    self.threshold_upper_hysteresis: int = threshold_upper_hysteresis\n    self.threshold_lower: int = threshold_lower\n    self.threshold_lower_hysteresis: int = threshold_lower_hysteresis\n    self.channel: int = to_enum(channel, Channel, to_upper=True)\n    super().__init__(\n        threshold_upper=threshold_upper,\n        threshold_upper_hysteresis=threshold_upper_hysteresis,\n        threshold_lower=threshold_lower,\n        threshold_lower_hysteresis=threshold_lower_hysteresis,\n        channel=self.channel,\n    )\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.TriggerInfo","title":"TriggerInfo  <code>dataclass</code>","text":"<pre><code>TriggerInfo(\n    segment_index: int,\n    trigger_index: int,\n    trigger_time: float,\n    timestamp_counter: int,\n)\n</code></pre> <p>The trigger timestamp information for the specified buffer segment.</p> <p>Attributes:</p> Name Type Description <code>segment_index</code> <code>int</code> <p>A zero-based index identifying the segment.</p> <code>trigger_index</code> <code>int</code> <p>The index of the trigger point measured in samples within the captured data, with the first sample being index 0.</p> <code>trigger_time</code> <code>float</code> <p>The trigger offset time, in seconds.</p> <code>timestamp_counter</code> <code>int</code> <p>The number of sample intervals between the trigger point of this segment and the previous segment. This allows you to determine the time interval between the trigger points of captures within a single rapid block run.</p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.TriggerState","title":"TriggerState","text":"<p>               Bases: <code>IntEnum</code></p> <p>How each trigger condition is combined with the overall trigger logic.</p> <p>Attributes:</p> Name Type Description <code>DONT_CARE</code> <code>int</code> <p>The source condition has no effect on the logic. <code>0</code></p> <code>TRUE</code> <code>int</code> <p>The source condition must be true. <code>1</code></p> <code>FALSE</code> <code>int</code> <p>The source condition must be false. <code>2</code></p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.TriggerWithinPreTrigger","title":"TriggerWithinPreTrigger","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enable or disable the trigger during the pre-trigger period.</p> <p>Attributes:</p> Name Type Description <code>DISABLE</code> <code>int</code> <p>Uses triggering in the normal way. <code>0</code></p> <code>ARM</code> <code>int</code> <p>Enables triggering anywhere within the pre-trigger samples. <code>1</code></p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.WaveType","title":"WaveType","text":"<p>               Bases: <code>IntEnum</code></p> <p>Standard waveform produced by the signal generator.</p> <p>Attributes:</p> Name Type Description <code>SINE</code> <code>int</code> <p><code>0</code></p> <code>SQUARE</code> <code>int</code> <p><code>1</code></p> <code>TRIANGLE</code> <code>int</code> <p><code>2</code></p> <code>RAMP_UP</code> <code>int</code> <p><code>3</code></p> <code>RAMP_DOWN</code> <code>int</code> <p><code>4</code></p> <code>SINC</code> <code>int</code> <p><code>5</code></p> <code>GAUSSIAN</code> <code>int</code> <p><code>6</code></p> <code>HALF_SINE</code> <code>int</code> <p><code>7</code></p> <code>DC_VOLTAGE</code> <code>int</code> <p><code>8</code></p> <code>WHITE_NOISE</code> <code>int</code> <p><code>9</code></p>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.block_ready","title":"block_ready","text":"<pre><code>block_ready(\n    f: PicoTechBlockReadyCallback,\n) -&gt; _CFunctionType\n</code></pre> <p>Use as a decorator for a callback function when the data block is ready.</p> <p>See ps5000a_block_ready_callback.py for an example usage.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def block_ready(f: PicoTechBlockReadyCallback) -&gt; _CFunctionType:\n    \"\"\"Use as a decorator for a callback function when the data block is ready.\n\n    See [ps5000a_block_ready_callback.py](https://github.com/MSLNZ/msl-equipment/blob/main/packages/resources/examples/picotech/ps5000a_block_ready_callback.py)\n    for an example usage.\n    \"\"\"\n    return _BlockReady(f)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.data_ready","title":"data_ready","text":"<pre><code>data_ready(f: PicoTechDataReadyCallback) -&gt; _CFunctionType\n</code></pre> <p>Use as a decorator for a callback function when the data is ready.</p> <p>See ps5000a_data_ready_callback.py for an example usage.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def data_ready(f: PicoTechDataReadyCallback) -&gt; _CFunctionType:\n    \"\"\"Use as a decorator for a callback function when the data is ready.\n\n    See [ps5000a_data_ready_callback.py](https://github.com/MSLNZ/msl-equipment/blob/main/packages/resources/examples/picotech/ps5000a_data_ready_callback.py)\n    for an example usage.\n    \"\"\"\n    return _DataReady(f)\n</code></pre>"},{"location":"resources/picotech/picoscope/#msl.equipment_resources.picotech.picoscope.streaming_ready","title":"streaming_ready","text":"<pre><code>streaming_ready(\n    f: PicoTechStreamingReadyCallback,\n) -&gt; _CFunctionType\n</code></pre> <p>Use as a decorator for a callback function when the data stream is ready.</p> <p>See ps5000a_streaming_ready_callback.py for an example usage.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/picoscope.py</code> <pre><code>def streaming_ready(f: PicoTechStreamingReadyCallback) -&gt; _CFunctionType:\n    \"\"\"Use as a decorator for a callback function when the data stream is ready.\n\n    See [ps5000a_streaming_ready_callback.py](https://github.com/MSLNZ/msl-equipment/blob/main/packages/resources/examples/picotech/ps5000a_streaming_ready_callback.py)\n    for an example usage.\n    \"\"\"\n    return _StreamingReady(f)\n</code></pre>"},{"location":"resources/picotech/pt104/","title":"PT-104","text":"<p>PT-104 Platinum Resistance Data Logger from Pico Technology.</p>"},{"location":"resources/picotech/pt104/#msl.equipment_resources.picotech.pt104.PT104","title":"PT104","text":"<pre><code>PT104(equipment: Equipment)\n</code></pre> <p>               Bases: <code>SDK</code></p> <p>PT-104 Platinum Resistance Data Logger from Pico Technology.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for a PT104 Data Logger.</p> <p>Connection Properties:</p> Name Type Description <code>ip_address</code> <code>str</code> <p>The IP address and port number, separated by a <code>:</code>, of the PT-104 (e.g., <code>\"192.168.1.201:1234\"</code>).</p> <code>open_via_ip</code> <code>bool</code> <p>Whether to connect to the PT-104 by Ethernet. Default is to connect by USB. If <code>True</code>, then <code>ip_address</code> must be specified.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/pt104.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"PT-104 Platinum Resistance Data Logger from Pico Technology.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for a PT104 Data Logger.\n\n    Attributes: Connection Properties:\n        ip_address (str): The IP address and port number, separated by a `:`, of the PT-104\n            (e.g., `\"192.168.1.201:1234\"`).\n        open_via_ip (bool): Whether to connect to the PT-104 by Ethernet. Default is to connect by USB.\n            If `True`, then `ip_address` must be specified.\n    \"\"\"\n    self._handle: int | None = None\n    libtype = \"windll\" if IS_WINDOWS else \"cdll\"\n    super().__init__(equipment, libtype=libtype)\n\n    sdk = self.sdk\n    sdk.UsbPt104OpenUnit.argtypes = [POINTER(c_int16), c_char_p]\n    sdk.UsbPt104OpenUnit.restype = PICO_STATUS\n    sdk.UsbPt104OpenUnit.errcheck = self._check\n    sdk.UsbPt104OpenUnitViaIp.argtypes = [POINTER(c_int16), c_char_p, c_char_p]\n    sdk.UsbPt104OpenUnitViaIp.restype = PICO_STATUS\n    sdk.UsbPt104OpenUnitViaIp.errcheck = self._check\n    sdk.UsbPt104CloseUnit.argtypes = [c_int16]\n    sdk.UsbPt104CloseUnit.restype = PICO_STATUS\n    sdk.UsbPt104CloseUnit.errcheck = self._check\n    sdk.UsbPt104GetUnitInfo.argtypes = [c_int16, c_char_p, c_int16, POINTER(c_int16), PICO_INFO]\n    sdk.UsbPt104GetUnitInfo.restype = PICO_STATUS\n    sdk.UsbPt104GetUnitInfo.errcheck = self._check\n    sdk.UsbPt104GetValue.argtypes = [c_int16, c_uint32, POINTER(c_int32), c_int16]\n    sdk.UsbPt104GetValue.restype = PICO_STATUS\n    sdk.UsbPt104GetValue.errcheck = self._check\n    sdk.UsbPt104IpDetails.argtypes = [\n        c_int16,\n        POINTER(c_int16),\n        c_char_p,\n        POINTER(c_uint16),\n        POINTER(c_uint16),\n        c_uint32,\n    ]\n    sdk.UsbPt104IpDetails.restype = PICO_STATUS\n    sdk.UsbPt104IpDetails.errcheck = self._check\n    sdk.UsbPt104SetChannel.argtypes = [c_int16, c_uint32, c_uint32, c_int16]\n    sdk.UsbPt104SetChannel.restype = PICO_STATUS\n    sdk.UsbPt104SetChannel.errcheck = self._check\n    sdk.UsbPt104SetMains.argtypes = [c_int16, c_uint16]\n    sdk.UsbPt104SetMains.restype = PICO_STATUS\n    sdk.UsbPt104SetMains.errcheck = self._check\n\n    assert equipment.connection is not None  # noqa: S101\n    p = equipment.connection.properties\n\n    if p.get(\"open_via_ip\", False):\n        self._open_via_ip(p.get(\"ip_address\", \"\"))\n    else:\n        self._open()\n\n    self._scaling: dict[int, float] = {}\n</code></pre>"},{"location":"resources/picotech/pt104/#msl.equipment_resources.picotech.pt104.PT104.Mode","title":"Mode","text":"<p>               Bases: <code>IntEnum</code></p> <p>The measurement mode for a PT-104 Data Logger channel.</p> <p>Attributes:</p> Name Type Description <code>OFF</code> <code>int</code> <p><code>0</code></p> <code>PT100</code> <code>int</code> <p><code>1</code></p> <code>PT1000</code> <code>int</code> <p><code>2</code></p> <code>RESISTANCE_TO_375R</code> <code>int</code> <p><code>3</code></p> <code>RESISTANCE_TO_10K</code> <code>int</code> <p><code>4</code></p> <code>DIFFERENTIAL_TO_115MV</code> <code>int</code> <p><code>5</code></p> <code>DIFFERENTIAL_TO_2500MV</code> <code>int</code> <p><code>6</code></p> <code>SINGLE_ENDED_TO_115MV</code> <code>int</code> <p><code>7</code></p> <code>SINGLE_ENDED_TO_2500MV</code> <code>int</code> <p><code>8</code></p>"},{"location":"resources/picotech/pt104/#msl.equipment_resources.picotech.pt104.PT104.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the PT-104 Data Logger.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/pt104.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Disconnect from the PT-104 Data Logger.\"\"\"\n    if self._handle is not None:\n        self.sdk.UsbPt104CloseUnit(self._handle)\n        self._handle = None\n        super().disconnect()\n</code></pre>"},{"location":"resources/picotech/pt104/#msl.equipment_resources.picotech.pt104.PT104.enumerate_units","title":"enumerate_units  <code>staticmethod</code>","text":"<pre><code>enumerate_units(\n    path: PathLike = \"usbpt104\",\n    communication: Literal[\n        \"both\", \"ethernet\", \"usb\"\n    ] = \"both\",\n) -&gt; list[str]\n</code></pre> <p>Find PT-104 Platinum Resistance Data Logger's.</p> <p>This routine returns a list of all the attached PT-104 devices for the specified communication type.</p> <p>Warning</p> <p>You cannot call this function after you have opened a connection to a Data Logger.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>PathLike</code> <p>The path to the Pico Technology SDK.</p> <code>'usbpt104'</code> <code>communication</code> <code>Literal['both', 'ethernet', 'usb']</code> <p>The communication type used by the PT-104.</p> <code>'both'</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of serial numbers of the PT-104 Data Logger's that were found.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/pt104.py</code> <pre><code>@staticmethod\ndef enumerate_units(\n    path: PathLike = \"usbpt104\",\n    communication: Literal[\"both\", \"ethernet\", \"usb\"] = \"both\",\n) -&gt; list[str]:\n    \"\"\"Find PT-104 Platinum Resistance Data Logger's.\n\n    This routine returns a list of all the attached PT-104 devices for the specified communication type.\n\n    !!! warning\n        You cannot call this function after you have opened a connection to a Data Logger.\n\n    Args:\n        path: The path to the Pico Technology SDK.\n        communication: The communication type used by the PT-104.\n\n    Returns:\n        A list of serial numbers of the PT-104 Data Logger's that were found.\n    \"\"\"\n    details = create_string_buffer(1024)\n\n    t = communication.lower()\n    if t == \"usb\":\n        t_val = 0x00000001\n    elif t == \"ethernet\":\n        t_val = 0x00000002\n    elif t == \"both\":\n        t_val = 0xFFFFFFFF\n    else:\n        msg = f\"Invalid communication type {communication}\"\n        raise ValueError(msg)\n\n    libtype = \"windll\" if IS_WINDOWS else \"cdll\"\n    sdk = LoadLibrary(path, libtype=libtype)\n    result = sdk.lib.UsbPt104Enumerate(byref(details), byref(c_int16(len(details))), t_val)\n    if result != PICO_OK:\n        msg = Error.get(result, f\"UnknownPicoTechError: Error code 0x{result:08x}\")\n        raise OSError(msg)\n\n    return details.value.decode().split(\",\")\n</code></pre>"},{"location":"resources/picotech/pt104/#msl.equipment_resources.picotech.pt104.PT104.get_ip_details","title":"get_ip_details","text":"<pre><code>get_ip_details() -&gt; tuple[bool, str, int]\n</code></pre> <p>Reads the ethernet details of the PT-104 Data Logger.</p> <p>Returns:</p> Type Description <code>tuple[bool, str, int]</code> <p>Whether connecting via ethernet is enabled, the IP address and the port number.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/pt104.py</code> <pre><code>def get_ip_details(self) -&gt; tuple[bool, str, int]:\n    \"\"\"Reads the ethernet details of the PT-104 Data Logger.\n\n    Returns:\n        Whether connecting via ethernet is enabled, the IP address and the port number.\n    \"\"\"\n    enabled = c_int16()\n    address = create_string_buffer(128)\n    port = c_uint16()\n    self.sdk.UsbPt104IpDetails(self._handle, byref(enabled), address, byref(c_uint16(len(address))), byref(port), 0)\n    return bool(enabled.value), address.value.decode(), port.value\n</code></pre>"},{"location":"resources/picotech/pt104/#msl.equipment_resources.picotech.pt104.PT104.get_unit_info","title":"get_unit_info","text":"<pre><code>get_unit_info(\n    info: PicoInfo | str | int | None = None,\n    *,\n    prefix: bool = True\n) -&gt; str\n</code></pre> <p>Retrieves information about the PT-104 Data Logger.</p> <p>If the device fails to open, or no device is opened only the driver version is available.</p> <p>Parameters:</p> Name Type Description Default <code>info</code> <code>PicoInfo | str | int | None</code> <p>An enum value or member name (case insensitive). If <code>None</code>, request all information from the PT-104.</p> <code>None</code> <code>prefix</code> <code>bool</code> <p>If <code>True</code>, includes the enum member name as a prefix. For example, returns <code>\"CAL_DATE: 09Aug16\"</code> if <code>prefix</code> is <code>True</code> else <code>\"09Aug16\"</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The requested information from the PT-104 Data Logger.</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/pt104.py</code> <pre><code>def get_unit_info(self, info: PicoInfo | str | int | None = None, *, prefix: bool = True) -&gt; str:\n    \"\"\"Retrieves information about the PT-104 Data Logger.\n\n    If the device fails to open, or no device is opened only the driver version is available.\n\n    Args:\n        info: An enum value or member name (case insensitive). If `None`, request all information from the PT-104.\n        prefix: If `True`, includes the enum member name as a prefix.\n            For example, returns `\"CAL_DATE: 09Aug16\"` if `prefix` is `True` else `\"09Aug16\"`.\n\n    Returns:\n        The requested information from the PT-104 Data Logger.\n    \"\"\"\n    values = [PicoInfo(i) for i in range(7)] if info is None else [to_enum(info, PicoInfo, to_upper=True)]\n    if info is None:\n        values.append(PicoInfo.MAC_ADDRESS)\n\n    string = create_string_buffer(32)\n    required_size = c_int16()\n\n    out: list[str] = []\n    for value in values:\n        name = f\"{value.name}: \" if prefix else \"\"\n        self.sdk.UsbPt104GetUnitInfo(self._handle, string, len(string), byref(required_size), value)\n        out.append(f\"{name}{string.value.decode()}\")\n    return \"\\n\".join(out)\n</code></pre>"},{"location":"resources/picotech/pt104/#msl.equipment_resources.picotech.pt104.PT104.get_value","title":"get_value","text":"<pre><code>get_value(channel: int, *, filtered: bool = False) -&gt; float\n</code></pre> <p>Get the most recent reading for the specified channel.</p> <p>Once you open the driver and define some channels, the driver begins to take continuous readings from the PT-104 Data Logger.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The channel number to read, from 1 to 4 in differential mode or 1 to 8 in single-ended mode.</p> required <code>filtered</code> <code>bool</code> <p>If <code>True</code>, the driver returns a low-pass filtered value of the temperature. The time constant of the filter depends on the channel parameters as set by set_channel and on how many channels are active.</p> <code>False</code> <p>Returns:</p> Type Description <code>float</code> <p>The latest reading for the specified channel. A voltage reading is in \\(\\text{V}\\), a temperature reading is in \\(^{\\circ}\\text{C}\\) and a resistance reading is in \\(\\Omega\\).</p> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/pt104.py</code> <pre><code>def get_value(self, channel: int, *, filtered: bool = False) -&gt; float:\n    r\"\"\"Get the most recent reading for the specified channel.\n\n    Once you open the driver and define some channels, the driver begins to take\n    continuous readings from the PT-104 Data Logger.\n\n    Args:\n        channel: The channel number to read, from 1 to 4 in differential mode or\n            1 to 8 in single-ended mode.\n        filtered: If `True`, the driver returns a low-pass filtered value of the temperature.\n            The time constant of the filter depends on the channel parameters as set by\n            [set_channel][msl.equipment_resources.picotech.pt104.PT104.set_channel]\n            and on how many channels are active.\n\n    Returns:\n        The latest reading for the specified channel. A voltage reading is in $\\text{V}$,\n            a temperature reading is in $^{\\circ}\\text{C}$ and a resistance reading is in $\\Omega$.\n    \"\"\"\n    value = c_int32()\n    self.sdk.UsbPt104GetValue(self._handle, channel, byref(value), int(filtered))\n    return value.value * self._scaling.get(channel, 1.0)\n</code></pre>"},{"location":"resources/picotech/pt104/#msl.equipment_resources.picotech.pt104.PT104.set_channel","title":"set_channel","text":"<pre><code>set_channel(\n    channel: int,\n    mode: Mode | str | int,\n    num_wires: Literal[2, 3, 4],\n) -&gt; None\n</code></pre> <p>Configure a single channel of the PT-104 Data Logger.</p> <p>The fewer channels configured, the more frequently they will be updated. A measurement takes about 1 second per active channel.</p> <p>If a call to the set_channel method has a measurement mode of single-ended, then the specified channel's sister channel is also enabled (i.e., enabling 3 also enables 7).</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The channel number to configure. It should be between 1 and 4 if using single-ended inputs in voltage mode.</p> required <code>mode</code> <code>Mode | str | int</code> <p>The measurement mode to configure the <code>channel</code> for. Can be an enum value or member name.</p> required <code>num_wires</code> <code>Literal[2, 3, 4]</code> <p>The number of wires that are used for the measurement.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/picotech/pt104.py</code> <pre><code>def set_channel(self, channel: int, mode: Mode | str | int, num_wires: Literal[2, 3, 4]) -&gt; None:\n    \"\"\"Configure a single channel of the PT-104 Data Logger.\n\n    The fewer channels configured, the more frequently they will be updated. A measurement\n    takes about 1 second per active channel.\n\n    If a call to the [set_channel][msl.equipment_resources.picotech.pt104.PT104.set_channel]\n    method has a measurement mode of *single-ended*, then the specified channel's *sister* channel is\n    also enabled (i.e., enabling 3 also enables 7).\n\n    Args:\n        channel: The channel number to configure. It should be between 1 and 4 if using\n            single-ended inputs in voltage mode.\n        mode: The measurement mode to configure the `channel` for. Can be an enum value or member name.\n        num_wires: The number of wires that are used for the measurement.\n    \"\"\"\n    _mode = to_enum(mode, PT104.Mode, to_upper=True)\n    if num_wires not in {2, 3, 4}:\n        msg = f\"The num_wires value is {num_wires}. It must be 2, 3 or 4.\"\n        raise ValueError(msg)\n    self.sdk.UsbPt104SetChannel(self._handle, channel, _mode, num_wires)\n\n    #    Measurement Type    |    Scaling factor\n    #  Temperature           | value * 1/1000 deg C\n    #  Resistance            | value * 1 mOhm\n    #  Voltage (0 to 2.5 V)  | value * 10 nV\n    #  Voltage (0 to 115 mV) | value * 1 nV\n    if _mode in {PT104.Mode.PT100, PT104.Mode.PT1000, PT104.Mode.RESISTANCE_TO_375R, PT104.Mode.RESISTANCE_TO_10K}:\n        self._scaling[channel] = 1e-3\n    elif _mode in {PT104.Mode.DIFFERENTIAL_TO_115MV, PT104.Mode.SINGLE_ENDED_TO_115MV}:\n        self._scaling[channel] = 1e-9\n        if _mode == PT104.Mode.SINGLE_ENDED_TO_115MV:\n            self._scaling[channel + 4] = 1e-9\n    elif _mode in {PT104.Mode.DIFFERENTIAL_TO_2500MV, PT104.Mode.SINGLE_ENDED_TO_2500MV}:\n        self._scaling[channel] = 10e-9\n        if _mode == PT104.Mode.SINGLE_ENDED_TO_2500MV:\n            self._scaling[channel + 4] = 10e-9\n    else:\n        self._scaling[channel] = 1.0\n</code></pre>"},{"location":"resources/picotech/pt104/#msl.equipment_resources.picotech.pt104.PT104.set_ip_details","title":"set_ip_details","text":"<pre><code>set_ip_details(\n    *,\n    enabled: bool,\n    ip_address: str | None = None,\n    port: int | None = None\n) -&gt; None\n</code></pre> <p>Set the IP details to the device.</p> <p>Parameters:</p> Name Type Description Default <code>enabled</code> <code>bool</code> <p>Whether to enable or disable ethernet communication for this device.</p> required <code>ip_address</code> <code>str | None</code> <p>The new IP address. If <code>None</code>, do not change the IP address.</p> <code>None</code> <code>port</code> <code>int | None</code> <p>The new port number. If <code>None</code>, do not change the port number.</p> <code>None</code> Source code in <code>packages/resources/src/msl/equipment_resources/picotech/pt104.py</code> <pre><code>def set_ip_details(self, *, enabled: bool, ip_address: str | None = None, port: int | None = None) -&gt; None:\n    \"\"\"Set the IP details to the device.\n\n    Args:\n        enabled: Whether to enable or disable ethernet communication for this device.\n        ip_address: The new IP address. If `None`, do not change the IP address.\n        port: The new port number. If `None`, do not change the port number.\n    \"\"\"\n    if ip_address is None or port is None:\n        _, _ip_address, _port = self.get_ip_details()\n        if ip_address is None:\n            ip_address = _ip_address\n        if port is None:\n            port = _port\n\n    c_address = (c_int8 * len(ip_address)).from_buffer_copy(ip_address.encode())\n    self.sdk.UsbPt104IpDetails(\n        self._handle, c_int16(enabled), c_address, c_uint16(len(ip_address)), c_uint16(port), 1\n    )\n</code></pre>"},{"location":"resources/picotech/pt104/#msl.equipment_resources.picotech.pt104.PT104.set_mains","title":"set_mains","text":"<pre><code>set_mains(hertz: Literal[50, 60]) -&gt; None\n</code></pre> <p>Inform the driver of the local mains (line) frequency.</p> <p>This helps the driver to filter out electrical noise.</p> <p>Parameters:</p> Name Type Description Default <code>hertz</code> <code>Literal[50, 60]</code> <p>Power-line frequency, 50 or 60 Hz.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/picotech/pt104.py</code> <pre><code>def set_mains(self, hertz: Literal[50, 60]) -&gt; None:\n    \"\"\"Inform the driver of the local mains (line) frequency.\n\n    This helps the driver to filter out electrical noise.\n\n    Args:\n        hertz: Power-line frequency, 50 or 60 Hz.\n    \"\"\"\n    if hertz not in {50, 60}:\n        msg = f\"The mains frequency must be 50 or 60. Got {hertz}\"\n        raise ValueError(msg)\n    self.sdk.UsbPt104SetMains(self._handle, 0 if hertz == 50 else 1)  # noqa: PLR2004\n</code></pre>"},{"location":"resources/picotech/types/","title":"Enums/Structs","text":""},{"location":"resources/picotech/types/#msl.equipment_resources.picotech.status.PicoInfo","title":"PicoInfo","text":"<p>               Bases: <code>IntEnum</code></p> <p>Unit information identifiers for querying Pico device details.</p> <p>Attributes:</p> Name Type Description <code>DRIVER_VERSION</code> <code>int</code> <p>PicoSDK driver version, <code>0</code>.</p> <code>USB_VERSION</code> <code>int</code> <p>USB version (e.g., USB 2.0 or USB 3.0), <code>1</code>.</p> <code>HARDWARE_VERSION</code> <code>int</code> <p>Hardware version of the PicoScope, <code>2</code>.</p> <code>VARIANT_INFO</code> <code>int</code> <p>Device model or variant identifier, <code>3</code>.</p> <code>BATCH_AND_SERIAL</code> <code>int</code> <p>Batch and serial number of the device, <code>4</code>.</p> <code>CAL_DATE</code> <code>int</code> <p>Device calibration date, <code>5</code>.</p> <code>KERNEL_VERSION</code> <code>int</code> <p>Kernel driver version, <code>6</code>.</p> <code>DIGITAL_HARDWARE_VERSION</code> <code>int</code> <p>Digital board hardware version, <code>7</code>.</p> <code>ANALOGUE_HARDWARE_VERSION</code> <code>int</code> <p>Analogue board hardware version, <code>8</code>.</p> <code>FIRMWARE_VERSION_1</code> <code>int</code> <p>First part of the firmware version, <code>9</code>.</p> <code>FIRMWARE_VERSION_2</code> <code>int</code> <p>Second part of the firmware version, <code>10</code>.</p> <code>MAC_ADDRESS</code> <code>int</code> <p>MAC address of device, <code>11</code>.</p> <code>SHADOW_CAL</code> <code>int</code> <p>Shadow calibration, <code>12</code>.</p> <code>IPP_VERSION</code> <code>int</code> <p>Version of picoipp library, <code>13</code>.</p> <code>DRIVER_PATH</code> <code>int</code> <p>The path to the library file, <code>14</code>.</p> <code>FIRMWARE_VERSION_3</code> <code>int</code> <p>Third part of the firmware version, <code>15</code>.</p> <code>FRONT_PANEL_FIRMWARE_VERSION</code> <code>int</code> <p>Front panel firmware version, <code>16</code>.</p> <code>BOOTLOADER_VERSION</code> <code>int</code> <p>Bootloader version, <code>0x10000001</code>.</p>"},{"location":"resources/princeton_instruments/arc_instrument/","title":"ARC Instrument SDK","text":"<p>Wrapper around the <code>ARC_Instrument.dll</code> SDK from Princeton Instruments.</p> <p>The wrapper was written using v2.0.3 of the SDK.</p> <p>Applicable for monochromator/spectrographs, filter wheels and readout systems (NCL/NCL-Lite) from Princeton Instruments.</p>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments","title":"PrincetonInstruments","text":"<pre><code>PrincetonInstruments(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Wrapper around the <code>ARC_Instrument.dll</code> SDK from Princeton Instruments.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required <p>A Connection instance supports the following properties for the <code>ARC_Instrument</code> wrapper.</p> <p>Connection Properties:</p> Name Type Description <code>sdk_path</code> <code>str</code> <p>The path to the SDK library. Default: <code>\"ARC_Instrument_x64.dll\"</code></p> <code>open</code> <code>bool</code> <p>Whether to automatically open the connection. Default: <code>True</code></p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Wrapper around the `ARC_Instrument.dll` SDK from Princeton Instruments.\n\n    Args:\n        equipment: An [Equipment][] instance.\n\n    A [Connection][msl.equipment.schema.Connection] instance supports the following _properties_\n    for the `ARC_Instrument` wrapper.\n\n    Attributes: Connection Properties:\n        sdk_path (str): The path to the SDK library. _Default: `\"ARC_Instrument_x64.dll\"`_\n        open (bool): Whether to automatically open the connection. _Default: `True`_\n    \"\"\"\n    self._mono_enum: int = -1\n    self._ncl_enum: int = -1\n    self._filter_enum: int = -1\n    super().__init__(equipment)\n\n    assert equipment.connection is not None  # noqa: S101\n    p = equipment.connection.properties\n\n    _load_sdk(p.get(\"sdk_path\", \"ARC_Instrument_x64.dll\"))\n    assert self._sdk is not None  # noqa: S101\n\n    self._sdk: CDLL = self._sdk\n    if p.get(\"open\", True):\n        num_found = self.get_num_found_inst_ports()\n        if num_found == 0:\n            num_found = self.search_for_inst()\n\n        for enum in range(num_found):\n            port = self.get_enum_preopen_com(enum)\n            if not equipment.connection.address.endswith(str(port)):\n                continue\n\n            try:\n                self.open_mono(enum)\n            except MSLConnectionError:\n                try:\n                    self.open_filter(enum)\n                except MSLConnectionError:\n                    try:\n                        _ = self.open_readout(enum)\n                    except MSLConnectionError:\n                        msg = \"Could not open port {port!r}\"\n                        raise MSLConnectionError(self, msg) from None\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.calc_mono_slit_bandpass","title":"calc_mono_slit_bandpass","text":"<pre><code>calc_mono_slit_bandpass(\n    slit_num: int, width: float\n) -&gt; float\n</code></pre> <p>Calculates the band pass for the provided slit width.</p> <p>Parameters:</p> Name Type Description Default <code>slit_num</code> <code>int</code> <p>The slit number.</p> <ul> <li><code>1</code> \u2014 Side entrance slit.</li> <li><code>2</code> \u2014 Front entrance slit.</li> <li><code>3</code> \u2014 Front exit slit.</li> <li><code>4</code> \u2014 Side exit slit.</li> <li><code>5</code> \u2014 Side entrance slit on a double slave unit.</li> <li><code>6</code> \u2014 Front entrance slit on a double slave unit.</li> <li><code>7</code> \u2014 Front exit slit on a double slave unit.</li> <li><code>8</code> \u2014 Side exit slit on a double slave unit.</li> </ul> required <code>width</code> <code>float</code> <p>The slit width that the band pass is being calculated for.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The calculated band pass for the slit, in nm.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def calc_mono_slit_bandpass(self, slit_num: int, width: float) -&gt; float:\n    \"\"\"Calculates the band pass for the provided slit width.\n\n    Args:\n        slit_num: The slit number.\n\n            * `1` &amp;mdash; Side entrance slit.\n            * `2` &amp;mdash; Front entrance slit.\n            * `3` &amp;mdash; Front exit slit.\n            * `4` &amp;mdash; Side exit slit.\n            * `5` &amp;mdash; Side entrance slit on a double slave unit.\n            * `6` &amp;mdash; Front entrance slit on a double slave unit.\n            * `7` &amp;mdash; Front exit slit on a double slave unit.\n            * `8` &amp;mdash; Side exit slit on a double slave unit.\n\n        width: The slit width that the band pass is being calculated for.\n\n    Returns:\n        The calculated band pass for the slit, in nm.\n    \"\"\"\n    bp = c_double()\n    error_code = c_long()\n    self._sdk.ARC_Calc_Mono_Slit_BandPass(self._mono_enum, slit_num, width, bp, error_code)\n    return bp.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.close_enum","title":"close_enum  <code>staticmethod</code>","text":"<pre><code>close_enum(enum: int) -&gt; None\n</code></pre> <p>Function to close an open enumeration.</p> <p>Parameters:</p> Name Type Description Default <code>enum</code> <code>int</code> <p>A handle defined in ARC_Open_xxxx by which the instrument is to be addressed.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>@staticmethod\ndef close_enum(enum: int) -&gt; None:\n    \"\"\"Function to close an open enumeration.\n\n    Args:\n        enum: A handle defined in *ARC_Open_xxxx* by which the instrument is to be addressed.\n    \"\"\"\n    if PrincetonInstruments._SDK is None:\n        msg = \"PrincetonInstrumentsError: You must first call PrincetonInstruments.init()\"\n        raise RuntimeError(msg)\n\n    if enum &gt; -1:\n        error_code = c_long()\n        PrincetonInstruments._SDK.ARC_Close_Enum(enum, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.det_nonblock_read_done","title":"det_nonblock_read_done","text":"<pre><code>det_nonblock_read_done(det_num: int) -&gt; float\n</code></pre> <p>Returns the detector value.</p> <p>Parameters:</p> Name Type Description Default <code>det_num</code> <code>int</code> <p>The detector to be addressed.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The value of the detector.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def det_nonblock_read_done(self, det_num: int) -&gt; float:\n    \"\"\"Returns the detector value.\n\n    Args:\n        det_num: The detector to be addressed.\n\n    Returns:\n        The value of the detector.\n    \"\"\"\n    value = c_double()\n    error_code = c_long()\n    self._sdk.ARC_Det_NonBlock_Read_Done(self._ncl_enum, det_num, value, error_code)\n    return value.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.det_read","title":"det_read","text":"<pre><code>det_read(det_num: int) -&gt; float\n</code></pre> <p>Readout a single detector.</p> <p>Parameters:</p> Name Type Description Default <code>det_num</code> <code>int</code> <p>The detector to be addressed.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Reading value for the selected detector.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def det_read(self, det_num: int) -&gt; float:\n    \"\"\"Readout a single detector.\n\n    Args:\n        det_num: The detector to be addressed.\n\n    Returns:\n        Reading value for the selected detector.\n    \"\"\"\n    read = c_double()\n    error_code = c_long()\n    self._sdk.ARC_Det_Read(self._ncl_enum, det_num, read, error_code)\n    return read.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.det_readall","title":"det_readall","text":"<pre><code>det_readall() -&gt; tuple[float, float, float]\n</code></pre> <p>Readout all detectors.</p> <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>The reading of each detector.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def det_readall(self) -&gt; tuple[float, float, float]:\n    \"\"\"Readout all detectors.\n\n    Returns:\n        The reading of each detector.\n    \"\"\"\n    det1 = c_double()\n    det2 = c_double()\n    det3 = c_double()\n    error_code = c_long()\n    self._sdk.ARC_Det_ReadAll(self._ncl_enum, det1, det2, det3, error_code)\n    return det1.value, det2.value, det3.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.det_start_nonblock_read","title":"det_start_nonblock_read","text":"<pre><code>det_start_nonblock_read(det_num: int) -&gt; None\n</code></pre> <p>Start to readout a single detector, but return immediately (non-blocking read).</p> <p>Parameters:</p> Name Type Description Default <code>det_num</code> <code>int</code> <p>The detector to be addressed.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def det_start_nonblock_read(self, det_num: int) -&gt; None:\n    \"\"\"Start to readout a single detector, but return immediately (non-blocking read).\n\n    Args:\n        det_num: The detector to be addressed.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_Det_Start_NonBlock_Read(self._ncl_enum, det_num, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.disconnect","title":"disconnect","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Close all open connections.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def disconnect(self) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Close all open connections.\"\"\"\n    if self._mono_enum &gt; -1:\n        self.close_enum(self._mono_enum)\n        super().disconnect()\n        self._mono_enum = -1\n    if self._ncl_enum &gt; -1:\n        self.close_enum(self._ncl_enum)\n        super().disconnect()\n        self._ncl_enum = -1\n    if self._filter_enum &gt; -1:\n        self.close_enum(self._filter_enum)\n        super().disconnect()\n        self._filter_enum = -1\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.error_to_english","title":"error_to_english  <code>staticmethod</code>","text":"<pre><code>error_to_english(error_code: int) -&gt; str\n</code></pre> <p>Convert an error code into a message.</p> <p>Parameters:</p> Name Type Description Default <code>error_code</code> <code>int</code> <p>An error code from the <code>ARC_Instrument</code> SDK.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The error message.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>@staticmethod\ndef error_to_english(error_code: int) -&gt; str:\n    \"\"\"Convert an error code into a message.\n\n    Args:\n        error_code: An error code from the `ARC_Instrument` SDK.\n\n    Returns:\n        The error message.\n    \"\"\"\n    if PrincetonInstruments._SDK is None:\n        msg = \"PrincetonInstrumentsError: You must first call PrincetonInstruments.init()\"\n        raise RuntimeError(msg)\n\n    buffer = create_string_buffer(255)\n    PrincetonInstruments._SDK.ARC_Error_To_English(error_code, buffer, len(buffer))\n    return buffer.value.decode()\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.filter_home","title":"filter_home","text":"<pre><code>filter_home() -&gt; None\n</code></pre> <p>Homes the filter wheel.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def filter_home(self) -&gt; None:\n    \"\"\"Homes the filter wheel.\"\"\"\n    error_code = c_long()\n    self._sdk.ARC_Filter_Home(self._filter_enum, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_det_bipolar","title":"get_det_bipolar","text":"<pre><code>get_det_bipolar(det_num: int) -&gt; bool\n</code></pre> <p>Return if a detector takes bipolar (+/-) readings.</p> <p>Parameters:</p> Name Type Description Default <code>det_num</code> <code>int</code> <p>The detector to be addressed.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the detector is bipolar (+/-), <code>False</code> if unipolar.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_det_bipolar(self, det_num: int) -&gt; bool:\n    \"\"\"Return if a detector takes bipolar (+/-) readings.\n\n    Args:\n        det_num: The detector to be addressed.\n\n    Returns:\n        `True` if the detector is bipolar (+/-), `False` if unipolar.\n    \"\"\"\n    error_code = c_long()\n    return bool(self._sdk.ARC_get_Det_BiPolar(self._ncl_enum, det_num, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_det_bipolar_str","title":"get_det_bipolar_str","text":"<pre><code>get_det_bipolar_str(det_num: int) -&gt; str\n</code></pre> <p>Return the description of the detector polarity.</p> <p>Parameters:</p> Name Type Description Default <code>det_num</code> <code>int</code> <p>The detector to be addressed.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A description of whether the detector is unipolar or bipolar.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_det_bipolar_str(self, det_num: int) -&gt; str:\n    \"\"\"Return the description of the detector polarity.\n\n    Args:\n        det_num: The detector to be addressed.\n\n    Returns:\n        A description of whether the detector is unipolar or bipolar.\n    \"\"\"\n    buffer = create_string_buffer(255)\n    error_code = c_long()\n    self._sdk.ARC_get_Det_BiPolar_CharStr(self._ncl_enum, det_num, buffer, len(buffer), error_code)\n    return bytes(buffer.value).decode()\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_det_hv_on","title":"get_det_hv_on","text":"<pre><code>get_det_hv_on(det_num: int) -&gt; bool\n</code></pre> <p>Return if the high voltage for a detector is turned on.</p> <p>Parameters:</p> Name Type Description Default <code>det_num</code> <code>int</code> <p>The detector to be addressed.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the high voltage is turned on.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_det_hv_on(self, det_num: int) -&gt; bool:\n    \"\"\"Return if the high voltage for a detector is turned on.\n\n    Args:\n        det_num: The detector to be addressed.\n\n    Returns:\n        Whether the high voltage is turned on.\n    \"\"\"\n    error_code = c_long()\n    return bool(self._sdk.ARC_get_Det_HV_on(self._ncl_enum, det_num, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_det_hv_volts","title":"get_det_hv_volts","text":"<pre><code>get_det_hv_volts(det_num: int) -&gt; int\n</code></pre> <p>Return the high voltage volts setting.</p> <p>Parameters:</p> Name Type Description Default <code>det_num</code> <code>int</code> <p>The detector to be addressed.</p> required <p>Returns:</p> Type Description <code>int</code> <p>High voltage volts that the detector is set to.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_det_hv_volts(self, det_num: int) -&gt; int:\n    \"\"\"Return the high voltage volts setting.\n\n    Args:\n        det_num: The detector to be addressed.\n\n    Returns:\n        High voltage volts that the detector is set to.\n    \"\"\"\n    error_code = c_long()\n    return int(self._sdk.ARC_get_Det_HV_Volts(self._ncl_enum, det_num, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_det_num_avg_read","title":"get_det_num_avg_read","text":"<pre><code>get_det_num_avg_read() -&gt; int\n</code></pre> <p>Return the number of readings that are averaged.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of readings averaged into a single reading.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_det_num_avg_read(self) -&gt; int:\n    \"\"\"Return the number of readings that are averaged.\n\n    Returns:\n        Number of readings averaged into a single reading.\n    \"\"\"\n    error_code = c_long()\n    return int(self._sdk.ARC_get_Det_NumAvgRead(self._ncl_enum, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_det_range","title":"get_det_range","text":"<pre><code>get_det_range(det_num: int) -&gt; int\n</code></pre> <p>Return the detector range factor.</p> <p>Parameters:</p> Name Type Description Default <code>det_num</code> <code>int</code> <p>The detector to be addressed.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The detector gain range.</p> <ul> <li><code>0</code> \u2014 1x</li> <li><code>1</code> \u2014 2x</li> <li><code>2</code> \u2014 4x</li> <li><code>3</code> \u2014 50x</li> <li><code>4</code> \u2014 200x</li> </ul> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_det_range(self, det_num: int) -&gt; int:\n    \"\"\"Return the detector range factor.\n\n    Args:\n        det_num: The detector to be addressed.\n\n    Returns:\n        The detector gain range.\n\n            * `0` &amp;mdash; 1x\n            * `1` &amp;mdash; 2x\n            * `2` &amp;mdash; 4x\n            * `3` &amp;mdash; 50x\n            * `4` &amp;mdash; 200x\n\n    \"\"\"\n    gain_range = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_Det_Range(self._ncl_enum, det_num, gain_range, error_code)\n    return gain_range.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_det_range_factor","title":"get_det_range_factor","text":"<pre><code>get_det_range_factor(det_num: int) -&gt; int\n</code></pre> <p>Return the detector range multiplier.</p> <p>Parameters:</p> Name Type Description Default <code>det_num</code> <code>int</code> <p>The detector to be addressed.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The detector range multiplier.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_det_range_factor(self, det_num: int) -&gt; int:\n    \"\"\"Return the detector range multiplier.\n\n    Args:\n        det_num: The detector to be addressed.\n\n    Returns:\n        The detector range multiplier.\n    \"\"\"\n    range_factor = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_Det_Range_Factor(self._ncl_enum, det_num, range_factor, error_code)\n    return range_factor.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_det_type","title":"get_det_type","text":"<pre><code>get_det_type(det_num: int) -&gt; int\n</code></pre> <p>Return the detector readout type (Current, Voltage, Photon Counting).</p> <p>Parameters:</p> Name Type Description Default <code>det_num</code> <code>int</code> <p>The detector to be addressed.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The detector readout type.</p> <ul> <li><code>1</code> \u2014 Current</li> <li><code>2</code> \u2014 Voltage</li> <li><code>3</code> \u2014 Photon Counting</li> </ul> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_det_type(self, det_num: int) -&gt; int:\n    \"\"\"Return the detector readout type (Current, Voltage, Photon Counting).\n\n    Args:\n        det_num: The detector to be addressed.\n\n    Returns:\n        The detector readout type.\n\n            * `1` &amp;mdash; Current\n            * `2` &amp;mdash; Voltage\n            * `3` &amp;mdash; Photon Counting\n\n    \"\"\"\n    det_type = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_Det_Type(self._ncl_enum, det_num, det_type, error_code)\n    return det_type.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_det_type_str","title":"get_det_type_str","text":"<pre><code>get_det_type_str(det_num: int) -&gt; str\n</code></pre> <p>Return a description of the detector readout type.</p> <p>Parameters:</p> Name Type Description Default <code>det_num</code> <code>int</code> <p>The detector to be addressed.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The detector readout type (Current, Voltage, Photon Counting).</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_det_type_str(self, det_num: int) -&gt; str:\n    \"\"\"Return a description of the detector readout type.\n\n    Args:\n        det_num: The detector to be addressed.\n\n    Returns:\n        The detector readout type (Current, Voltage, Photon Counting).\n    \"\"\"\n    buffer = create_string_buffer(255)\n    error_code = c_long()\n    self._sdk.ARC_get_Det_Type_CharStr(self._ncl_enum, det_num, buffer, len(buffer), error_code)\n    return bytes(buffer.value).decode()\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_enum_preopen_com","title":"get_enum_preopen_com  <code>staticmethod</code>","text":"<pre><code>get_enum_preopen_com(enum: int) -&gt; int\n</code></pre> <p>Returns the COM port number of an instrument not yet opened.</p> <p>Note, search_for_inst needs to be called prior to this call.</p> <p>Parameters:</p> Name Type Description Default <code>enum</code> <code>int</code> <p>The enumeration for the unopened instrument.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The COM port number.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>@staticmethod\ndef get_enum_preopen_com(enum: int) -&gt; int:\n    \"\"\"Returns the COM port number of an instrument not yet opened.\n\n    Note, [search_for_inst][msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.search_for_inst]\n    needs to be called prior to this call.\n\n    Args:\n        enum: The enumeration for the unopened instrument.\n\n    Returns:\n        The COM port number.\n    \"\"\"  # noqa: E501\n    if PrincetonInstruments._SDK is None:\n        msg = \"PrincetonInstrumentsError: You must first call PrincetonInstruments.init()\"\n        raise RuntimeError(msg)\n\n    com = c_long()\n    error_code = c_long()\n    PrincetonInstruments._SDK.ARC_get_Enum_preOpen_COM(enum, com, error_code)\n    return com.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_enum_preopen_model","title":"get_enum_preopen_model  <code>staticmethod</code>","text":"<pre><code>get_enum_preopen_model(enum: int) -&gt; str\n</code></pre> <p>Returns the model number of an instrument not yet opened.</p> <p>Note, search_for_inst needs to be called prior to this call.</p> <p>Parameters:</p> Name Type Description Default <code>enum</code> <code>int</code> <p>The enumeration for the unopened instrument.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The model number of the Princeton Instruments device.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>@staticmethod\ndef get_enum_preopen_model(enum: int) -&gt; str:\n    \"\"\"Returns the model number of an instrument not yet opened.\n\n    Note, [search_for_inst][msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.search_for_inst]\n    needs to be called prior to this call.\n\n    Args:\n        enum: The enumeration for the unopened instrument.\n\n    Returns:\n        The model number of the Princeton Instruments device.\n    \"\"\"  # noqa: E501\n    if PrincetonInstruments._SDK is None:\n        msg = \"PrincetonInstrumentsError: You must first call PrincetonInstruments.init()\"\n        raise RuntimeError(msg)\n\n    buffer = create_string_buffer(255)\n    error_code = c_long()\n    PrincetonInstruments._SDK.ARC_get_Enum_preOpen_Model(enum, buffer, len(buffer), error_code)\n    return bytes(buffer.value).decode()\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_enum_preopen_serial","title":"get_enum_preopen_serial  <code>staticmethod</code>","text":"<pre><code>get_enum_preopen_serial(enum: int) -&gt; str\n</code></pre> <p>Returns the serial number of an instrument not yet opened.</p> <p>Note, search_for_inst needs to be called prior to this call.</p> <p>Parameters:</p> Name Type Description Default <code>enum</code> <code>int</code> <p>The enumeration for the unopened instrument.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The serial number of the Princeton Instruments device.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>@staticmethod\ndef get_enum_preopen_serial(enum: int) -&gt; str:\n    \"\"\"Returns the serial number of an instrument not yet opened.\n\n    Note, [search_for_inst][msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.search_for_inst]\n    needs to be called prior to this call.\n\n    Args:\n        enum: The enumeration for the unopened instrument.\n\n    Returns:\n        The serial number of the Princeton Instruments device.\n    \"\"\"  # noqa: E501\n    if PrincetonInstruments._SDK is None:\n        msg = \"PrincetonInstrumentsError: You must first call PrincetonInstruments.init()\"\n        raise RuntimeError(msg)\n\n    serial = c_long()\n    error_code = c_long()\n    PrincetonInstruments._SDK.ARC_get_Enum_preOpen_Serial_int32(enum, serial, error_code)\n    return str(serial.value)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_filter_max_pos","title":"get_filter_max_pos","text":"<pre><code>get_filter_max_pos() -&gt; int\n</code></pre> <p>Returns the maximum filter position.</p> <p>Returns:</p> Type Description <code>int</code> <p>Returns the maximum position possible with the filter wheel.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_filter_max_pos(self) -&gt; int:\n    \"\"\"Returns the maximum filter position.\n\n    Returns:\n        Returns the maximum position possible with the filter wheel.\n    \"\"\"\n    position = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_Filter_Max_Pos(self._filter_enum, position, error_code)\n    return position.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_filter_min_pos","title":"get_filter_min_pos","text":"<pre><code>get_filter_min_pos() -&gt; int\n</code></pre> <p>Returns the minimum filter position.</p> <p>Returns:</p> Type Description <code>int</code> <p>Returns the minimum position possible with the filter wheel.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_filter_min_pos(self) -&gt; int:\n    \"\"\"Returns the minimum filter position.\n\n    Returns:\n        Returns the minimum position possible with the filter wheel.\n    \"\"\"\n    position = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_Filter_Min_Pos(self._filter_enum, position, error_code)\n    return position.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_filter_model","title":"get_filter_model","text":"<pre><code>get_filter_model() -&gt; str\n</code></pre> <p>Returns the model string from the instrument.</p> <p>Returns:</p> Type Description <code>str</code> <p>The model string of the instrument.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_filter_model(self) -&gt; str:\n    \"\"\"Returns the model string from the instrument.\n\n    Returns:\n        The model string of the instrument.\n    \"\"\"\n    buffer = create_string_buffer(255)\n    error_code = c_long()\n    self._sdk.ARC_get_Filter_Model_CharStr(self._filter_enum, buffer, len(buffer), error_code)\n    return bytes(buffer.value).decode()\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_filter_position","title":"get_filter_position","text":"<pre><code>get_filter_position() -&gt; int\n</code></pre> <p>Returns the current filter position.</p> <p>Returns:</p> Type Description <code>int</code> <p>The current filter wheel position.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_filter_position(self) -&gt; int:\n    \"\"\"Returns the current filter position.\n\n    Returns:\n        The current filter wheel position.\n    \"\"\"\n    position = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_Filter_Position(self._filter_enum, position, error_code)\n    return position.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_filter_preopen_model","title":"get_filter_preopen_model  <code>staticmethod</code>","text":"<pre><code>get_filter_preopen_model(filter_enum: int) -&gt; str\n</code></pre> <p>Returns the model string of an instrument not yet opened.</p> <p>Note, search_for_inst needs to be called prior to this call. In the case of multiple filter wheel/spectrographs attached, it allows the user to sort, which instruments are to be opened before opening them.</p> <p>Parameters:</p> Name Type Description Default <code>filter_enum</code> <code>int</code> <p>A filter enumeration value.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The model string of the unopened filter wheel.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>@staticmethod\ndef get_filter_preopen_model(filter_enum: int) -&gt; str:\n    \"\"\"Returns the model string of an instrument not yet opened.\n\n    Note, [search_for_inst][msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.search_for_inst]\n    needs to be called prior to this call. In the case of multiple filter wheel/spectrographs attached, it allows\n    the user to sort, which instruments are to be opened before opening them.\n\n    Args:\n        filter_enum: A filter enumeration value.\n\n    Returns:\n        The model string of the unopened filter wheel.\n    \"\"\"  # noqa: E501\n    if PrincetonInstruments._SDK is None:\n        msg = \"PrincetonInstrumentsError: You must first call PrincetonInstruments.init()\"\n        raise RuntimeError(msg)\n\n    buffer = create_string_buffer(255)\n    error_code = c_long()\n    PrincetonInstruments._SDK.ARC_get_Filter_preOpen_Model_CharStr(filter_enum, buffer, len(buffer), error_code)\n    return bytes(buffer.value).decode()\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_filter_present","title":"get_filter_present","text":"<pre><code>get_filter_present() -&gt; bool\n</code></pre> <p>Returns if the instrument has a filter wheel.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether an integrated filter wheel is present on the filter wheel.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_filter_present(self) -&gt; bool:\n    \"\"\"Returns if the instrument has a filter wheel.\n\n    Returns:\n        Whether an integrated filter wheel is present on the filter wheel.\n    \"\"\"\n    error_code = c_long()\n    return bool(self._sdk.ARC_get_Filter_Present(self._filter_enum, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_filter_serial","title":"get_filter_serial","text":"<pre><code>get_filter_serial() -&gt; str\n</code></pre> <p>Returns the serial number of the filter wheel.</p> <p>Returns:</p> Type Description <code>str</code> <p>The serial number of the filter wheel.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_filter_serial(self) -&gt; str:\n    \"\"\"Returns the serial number of the filter wheel.\n\n    Returns:\n        The serial number of the filter wheel.\n    \"\"\"\n    buffer = create_string_buffer(255)\n    error_code = c_long()\n    self._sdk.ARC_get_Filter_Serial_CharStr(self._filter_enum, buffer, len(buffer), error_code)\n    return bytes(buffer.value).decode()\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_backlash_steps","title":"get_mono_backlash_steps","text":"<pre><code>get_mono_backlash_steps() -&gt; int\n</code></pre> <p>Returns the number of backlash steps used when reversing the wavelength drive.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of steps the instrument backlash corrects. Not valid on older instruments.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_backlash_steps(self) -&gt; int:\n    \"\"\"Returns the number of backlash steps used when reversing the wavelength drive.\n\n    Returns:\n        The number of steps the instrument backlash corrects. Not valid on older instruments.\n    \"\"\"\n    backlash = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Backlash_Steps(self._mono_enum, backlash, error_code)\n    return backlash.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_detector_angle","title":"get_mono_detector_angle","text":"<pre><code>get_mono_detector_angle() -&gt; float\n</code></pre> <p>Returns the default detector angle of the instrument in radians.</p> <p>Returns:</p> Type Description <code>float</code> <p>The default detector angle of the instrument in radians.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_detector_angle(self) -&gt; float:\n    \"\"\"Returns the default detector angle of the instrument in radians.\n\n    Returns:\n        The default detector angle of the instrument in radians.\n    \"\"\"\n    angle = c_double()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_DetectorAngle(self._mono_enum, angle, error_code)\n    return angle.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_diverter_pos","title":"get_mono_diverter_pos","text":"<pre><code>get_mono_diverter_pos(diverter_num: int) -&gt; int\n</code></pre> <p>Returns the slit that the diverter mirror is pointing to.</p> <p>Parameters:</p> Name Type Description Default <code>diverter_num</code> <code>int</code> <p>The diverter to be queried.</p> <ul> <li><code>1</code> \u2014 Motorized entrance diverter mirror.</li> <li><code>2</code> \u2014 Motorized exit diverter mirror.</li> <li><code>3</code> \u2014 Motorized entrance diverter on a double slave unit.</li> <li><code>4</code> \u2014 Motorized exit diverter on a double slave unit.</li> </ul> required <p>Returns:</p> Type Description <code>int</code> <p>The slit port that the diverter mirror is currently pointing at.</p> <ul> <li><code>1</code> \u2014 Side entrance slit.</li> <li><code>2</code> \u2014 Front entrance slit.</li> <li><code>3</code> \u2014 Front exit slit.</li> <li><code>4</code> \u2014 Side exit slit.</li> <li><code>5</code> \u2014 Side entrance slit on a double slave unit.</li> <li><code>6</code> \u2014 Front entrance slit on a double slave unit.</li> <li><code>7</code> \u2014 Front exit slit on a double slave unit.</li> <li><code>8</code> \u2014 Side exit slit on a double slave unit.</li> </ul> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_diverter_pos(self, diverter_num: int) -&gt; int:\n    \"\"\"Returns the slit that the diverter mirror is pointing to.\n\n    Args:\n        diverter_num: The diverter to be queried.\n\n            * `1` &amp;mdash; Motorized entrance diverter mirror.\n            * `2` &amp;mdash; Motorized exit diverter mirror.\n            * `3` &amp;mdash; Motorized entrance diverter on a double slave unit.\n            * `4` &amp;mdash; Motorized exit diverter on a double slave unit.\n\n    Returns:\n        The slit port that the diverter mirror is currently pointing at.\n\n            * `1` &amp;mdash; Side entrance slit.\n            * `2` &amp;mdash; Front entrance slit.\n            * `3` &amp;mdash; Front exit slit.\n            * `4` &amp;mdash; Side exit slit.\n            * `5` &amp;mdash; Side entrance slit on a double slave unit.\n            * `6` &amp;mdash; Front entrance slit on a double slave unit.\n            * `7` &amp;mdash; Front exit slit on a double slave unit.\n            * `8` &amp;mdash; Side exit slit on a double slave unit.\n\n    \"\"\"\n    diverter_pos = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Diverter_Pos(self._mono_enum, diverter_num, diverter_pos, error_code)\n    return diverter_pos.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_diverter_pos_str","title":"get_mono_diverter_pos_str","text":"<pre><code>get_mono_diverter_pos_str(diverter_num: int) -&gt; str\n</code></pre> <p>Returns a string describing the port the mirror is pointing to.</p> <p>Parameters:</p> Name Type Description Default <code>diverter_num</code> <code>int</code> <p>The diverter to be queried.</p> <ul> <li><code>1</code> \u2014 Motorized entrance diverter mirror.</li> <li><code>2</code> \u2014 Motorized exit diverter mirror.</li> <li><code>3</code> \u2014 Motorized entrance diverter on a double slave unit.</li> <li><code>4</code> \u2014 Motorized exit diverter on a double slave unit.</li> </ul> required <p>Returns:</p> Type Description <code>str</code> <p>A string describing which port the diverter is pointing at.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_diverter_pos_str(self, diverter_num: int) -&gt; str:\n    \"\"\"Returns a string describing the port the mirror is pointing to.\n\n    Args:\n        diverter_num: The diverter to be queried.\n\n            * `1` &amp;mdash; Motorized entrance diverter mirror.\n            * `2` &amp;mdash; Motorized exit diverter mirror.\n            * `3` &amp;mdash; Motorized entrance diverter on a double slave unit.\n            * `4` &amp;mdash; Motorized exit diverter on a double slave unit.\n\n    Returns:\n        A string describing which port the diverter is pointing at.\n    \"\"\"\n    buffer = create_string_buffer(255)\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Diverter_Pos_CharStr(self._mono_enum, diverter_num, buffer, len(buffer), error_code)\n    return bytes(buffer.value).decode()\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_diverter_valid","title":"get_mono_diverter_valid","text":"<pre><code>get_mono_diverter_valid(diverter_num: int) -&gt; bool\n</code></pre> <p>Returns if a motorized diverter position is valid for an instrument.</p> <p>Parameters:</p> Name Type Description Default <code>diverter_num</code> <code>int</code> <p>The diverter to be queried.</p> <ul> <li><code>1</code> \u2014 Motorized entrance diverter mirror.</li> <li><code>2</code> \u2014 Motorized exit diverter mirror.</li> <li><code>3</code> \u2014 Motorized entrance diverter on a double slave unit.</li> <li><code>4</code> \u2014 Motorized exit diverter on a double slave unit.</li> </ul> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the diverter mirror is valid.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_diverter_valid(self, diverter_num: int) -&gt; bool:\n    \"\"\"Returns if a motorized diverter position is valid for an instrument.\n\n    Args:\n        diverter_num: The diverter to be queried.\n\n            * `1` &amp;mdash; Motorized entrance diverter mirror.\n            * `2` &amp;mdash; Motorized exit diverter mirror.\n            * `3` &amp;mdash; Motorized entrance diverter on a double slave unit.\n            * `4` &amp;mdash; Motorized exit diverter on a double slave unit.\n\n    Returns:\n        Whether the diverter mirror is valid.\n    \"\"\"\n    error_code = c_long()\n    return bool(self._sdk.ARC_get_Mono_Diverter_Valid(self._mono_enum, diverter_num, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_double","title":"get_mono_double","text":"<pre><code>get_mono_double() -&gt; bool\n</code></pre> <p>Returns if the instrument is a double monochromator.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the instrument is a double monochromator.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_double(self) -&gt; bool:\n    \"\"\"Returns if the instrument is a double monochromator.\n\n    Returns:\n        Whether the instrument is a double monochromator.\n    \"\"\"\n    double_present = c_bool()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Double(self._mono_enum, double_present, error_code)\n    return double_present.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_double_intermediate_slit","title":"get_mono_double_intermediate_slit","text":"<pre><code>get_mono_double_intermediate_slit() -&gt; int\n</code></pre> <p>If a monochromator is a double, return the intermediate slit position.</p> <p>Returns:</p> Type Description <code>int</code> <p>The intermediate slit of the double monochromator</p> <ul> <li><code>1</code> \u2014 Side entrance slit.</li> <li><code>2</code> \u2014 Front entrance slit.</li> <li><code>3</code> \u2014 Front exit slit.</li> <li><code>4</code> \u2014 Side exit slit.</li> <li><code>5</code> \u2014 Side entrance slit on a double slave unit.</li> <li><code>6</code> \u2014 Front entrance slit on a double slave unit.</li> <li><code>7</code> \u2014 Front exit slit on a double slave unit.</li> <li><code>8</code> \u2014 Side exit slit on a double slave unit.</li> </ul> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_double_intermediate_slit(self) -&gt; int:\n    \"\"\"If a monochromator is a double, return the intermediate slit position.\n\n    Returns:\n        The intermediate slit of the double monochromator\n\n            * `1` &amp;mdash; Side entrance slit.\n            * `2` &amp;mdash; Front entrance slit.\n            * `3` &amp;mdash; Front exit slit.\n            * `4` &amp;mdash; Side exit slit.\n            * `5` &amp;mdash; Side entrance slit on a double slave unit.\n            * `6` &amp;mdash; Front entrance slit on a double slave unit.\n            * `7` &amp;mdash; Front exit slit on a double slave unit.\n            * `8` &amp;mdash; Side exit slit on a double slave unit.\n\n    \"\"\"\n    slit_pos = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Double_Intermediate_Slit(self._mono_enum, slit_pos, error_code)\n    return slit_pos.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_double_subtractive","title":"get_mono_double_subtractive","text":"<pre><code>get_mono_double_subtractive() -&gt; bool\n</code></pre> <p>Returns if a double monochromator is subtractive instead of additive.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the double monochromator is subtractive.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_double_subtractive(self) -&gt; bool:\n    \"\"\"Returns if a double monochromator is subtractive instead of additive.\n\n    Returns:\n        Whether the double monochromator is subtractive.\n    \"\"\"\n    double_subtractive = c_bool()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Double_Subtractive(self._mono_enum, double_subtractive, error_code)\n    return double_subtractive.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_exit_slit","title":"get_mono_exit_slit","text":"<pre><code>get_mono_exit_slit() -&gt; int\n</code></pre> <p>Return the exit slit position for a monochromator.</p> <p>Function works with a single and double monochromator.</p> <p>Returns:</p> Type Description <code>int</code> <p>The intermediate slit of the double monochromator</p> <ul> <li><code>1</code> \u2014 Side entrance slit.</li> <li><code>2</code> \u2014 Front entrance slit.</li> <li><code>3</code> \u2014 Front exit slit.</li> <li><code>4</code> \u2014 Side exit slit.</li> <li><code>5</code> \u2014 Side entrance slit on a double slave unit.</li> <li><code>6</code> \u2014 Front entrance slit on a double slave unit.</li> <li><code>7</code> \u2014 Front exit slit on a double slave unit.</li> <li><code>8</code> \u2014 Side exit slit on a double slave unit.</li> </ul> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_exit_slit(self) -&gt; int:\n    \"\"\"Return the exit slit position for a monochromator.\n\n    Function works with a single and double monochromator.\n\n    Returns:\n        The intermediate slit of the double monochromator\n\n            * `1` &amp;mdash; Side entrance slit.\n            * `2` &amp;mdash; Front entrance slit.\n            * `3` &amp;mdash; Front exit slit.\n            * `4` &amp;mdash; Side exit slit.\n            * `5` &amp;mdash; Side entrance slit on a double slave unit.\n            * `6` &amp;mdash; Front entrance slit on a double slave unit.\n            * `7` &amp;mdash; Front exit slit on a double slave unit.\n            * `8` &amp;mdash; Side exit slit on a double slave unit.\n\n    \"\"\"\n    slit_pos = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Exit_Slit(self._mono_enum, slit_pos, error_code)\n    return slit_pos.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_filter_max_pos","title":"get_mono_filter_max_pos","text":"<pre><code>get_mono_filter_max_pos() -&gt; int\n</code></pre> <p>Returns the maximum filter position.</p> <p>Returns:</p> Type Description <code>int</code> <p>The maximum position possible with the filter wheel.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_filter_max_pos(self) -&gt; int:\n    \"\"\"Returns the maximum filter position.\n\n    Returns:\n        The maximum position possible with the filter wheel.\n    \"\"\"\n    position = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Filter_Max_Pos(self._mono_enum, position, error_code)\n    return position.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_filter_min_pos","title":"get_mono_filter_min_pos","text":"<pre><code>get_mono_filter_min_pos() -&gt; int\n</code></pre> <p>Returns the minimum filter position.</p> <p>Returns:</p> Type Description <code>int</code> <p>The minimum position possible with the filter wheel.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_filter_min_pos(self) -&gt; int:\n    \"\"\"Returns the minimum filter position.\n\n    Returns:\n        The minimum position possible with the filter wheel.\n    \"\"\"\n    position = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Filter_Min_Pos(self._mono_enum, position, error_code)\n    return position.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_filter_position","title":"get_mono_filter_position","text":"<pre><code>get_mono_filter_position() -&gt; int\n</code></pre> <p>Returns the current filter position.</p> <p>Returns:</p> Type Description <code>int</code> <p>The current filter wheel position.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_filter_position(self) -&gt; int:\n    \"\"\"Returns the current filter position.\n\n    Returns:\n        The current filter wheel position.\n    \"\"\"\n    position = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Filter_Position(self._mono_enum, position, error_code)\n    return position.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_filter_present","title":"get_mono_filter_present","text":"<pre><code>get_mono_filter_present() -&gt; bool\n</code></pre> <p>Returns if the instrument has an integrated filter wheel.</p> <p>Note, is a new option and not available on most instruments. All filter functions call this function before proceeding.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether an integrated filter wheel is present on the monochromator.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_filter_present(self) -&gt; bool:\n    \"\"\"Returns if the instrument has an integrated filter wheel.\n\n    Note, is a new option and not available on most instruments. All filter\n    functions call this function before proceeding.\n\n    Returns:\n        Whether an integrated filter wheel is present on the monochromator.\n    \"\"\"\n    error_code = c_long()\n    return bool(self._sdk.ARC_get_Mono_Filter_Present(self._mono_enum, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_focal_length","title":"get_mono_focal_length","text":"<pre><code>get_mono_focal_length() -&gt; float\n</code></pre> <p>Returns the default focal length of the instrument.</p> <p>Returns:</p> Type Description <code>float</code> <p>The focal length of the instrument in millimetres.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_focal_length(self) -&gt; float:\n    \"\"\"Returns the default focal length of the instrument.\n\n    Returns:\n        The focal length of the instrument in millimetres.\n    \"\"\"\n    focal_length = c_double()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Focallength(self._mono_enum, focal_length, error_code)\n    return focal_length.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_gear_steps","title":"get_mono_gear_steps","text":"<pre><code>get_mono_gear_steps() -&gt; tuple[int, int]\n</code></pre> <p>Returns the number of steps in a set of sine drive gears.</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>The number of steps per rev on the <code>(minor, major)</code> gear of a sine wavelength drive.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_gear_steps(self) -&gt; tuple[int, int]:\n    \"\"\"Returns the number of steps in a set of sine drive gears.\n\n    Returns:\n        The number of steps per rev on the `(minor, major)` gear of a sine wavelength drive.\n    \"\"\"\n    minor = c_long()\n    major = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Gear_Steps(self._mono_enum, minor, major, error_code)\n    return minor.value, major.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_grating","title":"get_mono_grating","text":"<pre><code>get_mono_grating() -&gt; int\n</code></pre> <p>Returns the current grating.</p> <p>Returns:</p> Type Description <code>int</code> <p>The current grating. This assumes the correct turret has been inserted in the instrument.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_grating(self) -&gt; int:\n    \"\"\"Returns the current grating.\n\n    Returns:\n        The current grating. This assumes the correct turret has been inserted in the instrument.\n    \"\"\"\n    grating = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Grating(self._mono_enum, grating, error_code)\n    return grating.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_grating_blaze","title":"get_mono_grating_blaze","text":"<pre><code>get_mono_grating_blaze(grating: int) -&gt; str\n</code></pre> <p>Returns the blaze of a given grating.</p> <p>Parameters:</p> Name Type Description Default <code>grating</code> <code>int</code> <p>Which grating to request the information about. Validates the request by calling get_mono_grating_installed.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The blaze of the grating.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_grating_blaze(self, grating: int) -&gt; str:\n    \"\"\"Returns the blaze of a given grating.\n\n    Args:\n        grating: Which grating to request the information about. Validates the request by calling\n            [get_mono_grating_installed][msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_grating_installed].\n\n    Returns:\n        The blaze of the grating.\n    \"\"\"\n    buffer = create_string_buffer(255)\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Grating_Blaze_CharStr(self._mono_enum, grating, buffer, len(buffer), error_code)\n    return bytes(buffer.value).decode()\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_grating_density","title":"get_mono_grating_density","text":"<pre><code>get_mono_grating_density(grating: int) -&gt; int\n</code></pre> <p>Returns the groove density (grooves per millimetre) of a given grating.</p> <p>Parameters:</p> Name Type Description Default <code>grating</code> <code>int</code> <p>Which grating to request the information about. Validates the request by calling get_mono_grating_installed.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The groove density of the grating in grooves per millimetre. For a mirror, this function will return 1200 grooves per millimetre.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_grating_density(self, grating: int) -&gt; int:\n    \"\"\"Returns the groove density (grooves per millimetre) of a given grating.\n\n    Args:\n        grating: Which grating to request the information about. Validates the request by calling\n            [get_mono_grating_installed][msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_grating_installed].\n\n    Returns:\n        The groove density of the grating in grooves per millimetre. For a mirror,\n            this function will return 1200 grooves per millimetre.\n    \"\"\"\n    groove_mm = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Grating_Density(self._mono_enum, grating, groove_mm, error_code)\n    return groove_mm.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_grating_gadjust","title":"get_mono_grating_gadjust","text":"<pre><code>get_mono_grating_gadjust(grating: int) -&gt; int\n</code></pre> <p>Returns the GAdjust of a grating.</p> <p>Parameters:</p> Name Type Description Default <code>grating</code> <code>int</code> <p>Which grating to request the information about.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The grating GAdjust. Note, this value is specific to a specific instrument grating combination and not transferable between instruments.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_grating_gadjust(self, grating: int) -&gt; int:\n    \"\"\"Returns the GAdjust of a grating.\n\n    Args:\n        grating: Which grating to request the information about.\n\n    Returns:\n        The grating GAdjust. Note, this value is specific to a specific instrument\n            grating combination and not transferable between instruments.\n    \"\"\"\n    g_adjust = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Grating_Gadjust(self._mono_enum, grating, g_adjust, error_code)\n    return g_adjust.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_grating_installed","title":"get_mono_grating_installed","text":"<pre><code>get_mono_grating_installed(grating: int) -&gt; bool\n</code></pre> <p>Returns if a grating is installed.</p> <p>Parameters:</p> Name Type Description Default <code>grating</code> <code>int</code> <p>Which grating we are requesting the information about.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the grating requested is installed.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_grating_installed(self, grating: int) -&gt; bool:\n    \"\"\"Returns if a grating is installed.\n\n    Args:\n        grating: Which grating we are requesting the information about.\n\n    Returns:\n        Whether the grating requested is installed.\n    \"\"\"\n    error_code = c_long()\n    return bool(self._sdk.ARC_get_Mono_Grating_Installed(self._mono_enum, grating, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_grating_max","title":"get_mono_grating_max","text":"<pre><code>get_mono_grating_max() -&gt; int\n</code></pre> <p>Get the maximum grating position installed.</p> <p>This is usually the number of gratings installed.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of gratings installed.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_grating_max(self) -&gt; int:\n    \"\"\"Get the maximum grating position installed.\n\n    This is usually the number of gratings installed.\n\n    Returns:\n        The number of gratings installed.\n    \"\"\"\n    num = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Grating_Max(self._mono_enum, num, error_code)\n    return num.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_grating_offset","title":"get_mono_grating_offset","text":"<pre><code>get_mono_grating_offset(grating: int) -&gt; int\n</code></pre> <p>Returns the offset of a grating.</p> <p>Parameters:</p> Name Type Description Default <code>grating</code> <code>int</code> <p>The number of the grating that is to be addressed.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The grating offset. Note, this value is specific to a specific instrument grating combination and not transferable between instruments.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_grating_offset(self, grating: int) -&gt; int:\n    \"\"\"Returns the offset of a grating.\n\n    Args:\n        grating: The number of the grating that is to be addressed.\n\n    Returns:\n        The grating offset. Note, this value is specific to a specific instrument\n            grating combination and not transferable between instruments.\n    \"\"\"\n    offset = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Grating_Offset(self._mono_enum, grating, offset, error_code)\n    return offset.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_half_angle","title":"get_mono_half_angle","text":"<pre><code>get_mono_half_angle() -&gt; float\n</code></pre> <p>Returns the default half angle of the instrument in radians.</p> <p>Returns:</p> Type Description <code>float</code> <p>The half angle of the instrument in radians.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_half_angle(self) -&gt; float:\n    \"\"\"Returns the default half angle of the instrument in radians.\n\n    Returns:\n        The half angle of the instrument in radians.\n    \"\"\"\n    half_angle = c_double()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_HalfAngle(self._mono_enum, half_angle, error_code)\n    return half_angle.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_init_grating","title":"get_mono_init_grating","text":"<pre><code>get_mono_init_grating() -&gt; int\n</code></pre> <p>Returns the initial grating (on instrument reboot).</p> <p>Returns:</p> Type Description <code>int</code> <p>The power-up grating number.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_init_grating(self) -&gt; int:\n    \"\"\"Returns the initial grating (on instrument reboot).\n\n    Returns:\n        The power-up grating number.\n    \"\"\"\n    init_grating = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Init_Grating(self._mono_enum, init_grating, error_code)\n    return init_grating.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_init_scan_rate_nm","title":"get_mono_init_scan_rate_nm","text":"<pre><code>get_mono_init_scan_rate_nm() -&gt; float\n</code></pre> <p>Returns the initial wavelength scan rate (on instrument reboot).</p> <p>Returns:</p> Type Description <code>float</code> <p>The power-up scan rate in nm / minute.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_init_scan_rate_nm(self) -&gt; float:\n    \"\"\"Returns the initial wavelength scan rate (on instrument reboot).\n\n    Returns:\n        The power-up scan rate in nm / minute.\n    \"\"\"\n    init_scan_rate = c_double()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Init_ScanRate_nm(self._mono_enum, init_scan_rate, error_code)\n    return init_scan_rate.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_init_wave_nm","title":"get_mono_init_wave_nm","text":"<pre><code>get_mono_init_wave_nm() -&gt; float\n</code></pre> <p>Returns the initial wavelength (on instrument reboot).</p> <p>Returns:</p> Type Description <code>float</code> <p>The power-up wavelength in nm.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_init_wave_nm(self) -&gt; float:\n    \"\"\"Returns the initial wavelength (on instrument reboot).\n\n    Returns:\n        The power-up wavelength in nm.\n    \"\"\"\n    init_wave = c_double()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Init_Wave_nm(self._mono_enum, init_wave, error_code)\n    return init_wave.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_int_led_on","title":"get_mono_int_led_on","text":"<pre><code>get_mono_int_led_on() -&gt; bool\n</code></pre> <p>Checks if the interrupter LED is on.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the interrupter LED is on.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_int_led_on(self) -&gt; bool:\n    \"\"\"Checks if the interrupter LED is on.\n\n    Returns:\n        Whether the interrupter LED is on.\n    \"\"\"\n    error_code = c_long()\n    return bool(self._sdk.ARC_get_Mono_Int_Led_On(self._mono_enum, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_model","title":"get_mono_model","text":"<pre><code>get_mono_model() -&gt; str\n</code></pre> <p>Returns the model number of the monochromator.</p> <p>Returns:</p> Type Description <code>str</code> <p>The model number of the monochromator.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_model(self) -&gt; str:\n    \"\"\"Returns the model number of the monochromator.\n\n    Returns:\n        The model number of the monochromator.\n    \"\"\"\n    buffer = create_string_buffer(255)\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Model_CharStr(self._mono_enum, buffer, len(buffer), error_code)\n    return bytes(buffer.value).decode()\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_motor_int","title":"get_mono_motor_int","text":"<pre><code>get_mono_motor_int() -&gt; bool\n</code></pre> <p>Read the motor gear interrupter.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the motor gear was interrupted.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_motor_int(self) -&gt; bool:\n    \"\"\"Read the motor gear interrupter.\n\n    Returns:\n        Whether the motor gear was interrupted.\n    \"\"\"\n    error_code = c_long()\n    return bool(self._sdk.ARC_get_Mono_Motor_Int(self._mono_enum, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_nm_rev_ratio","title":"get_mono_nm_rev_ratio","text":"<pre><code>get_mono_nm_rev_ratio() -&gt; float\n</code></pre> <p>Returns the number of stepper steps per rev of the wavelength drive motor.</p> <p>Returns:</p> Type Description <code>float</code> <p>The ratio of nm per rev in a linear wavelength drive.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_nm_rev_ratio(self) -&gt; float:\n    \"\"\"Returns the number of stepper steps per rev of the wavelength drive motor.\n\n    Returns:\n        The ratio of nm per rev in a linear wavelength drive.\n    \"\"\"\n    ratio = c_double()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_nmRev_Ratio(self._mono_enum, ratio, error_code)\n    return ratio.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_precision","title":"get_mono_precision","text":"<pre><code>get_mono_precision() -&gt; int\n</code></pre> <p>Returns the nm-decimal precision of the wavelength drive.</p> <p>Note, this is independent of the wavelength step resolution whose coarseness is defined by the grating being used.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of digits after the decimal point the instrument uses. Note, the true precision is limited by the density of the grating and can be much less than the instruments wavelength precision.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_precision(self) -&gt; int:\n    \"\"\"Returns the nm-decimal precision of the wavelength drive.\n\n    Note, this is independent of the wavelength step resolution whose coarseness\n    is defined by the grating being used.\n\n    Returns:\n        The number of digits after the decimal point the instrument uses.\n            Note, the true precision is limited by the density of the grating and can\n            be much less than the instruments wavelength precision.\n    \"\"\"\n    error_code = c_long()\n    return int(self._sdk.ARC_get_Mono_Precision(self._mono_enum, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_preopen_model","title":"get_mono_preopen_model  <code>staticmethod</code>","text":"<pre><code>get_mono_preopen_model(mono_enum: int) -&gt; str\n</code></pre> <p>Returns the model of an instrument not yet opened.</p> <p>Note, search_for_inst needs to be called prior to this call. In the case of multiple Monochromator/Spectrographs attached, it allows the user to sort, which instruments are to be opened before opening them.</p> <p>Parameters:</p> Name Type Description Default <code>mono_enum</code> <code>int</code> <p>A monochromator enumeration.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The model of the unopened monochromator.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>@staticmethod\ndef get_mono_preopen_model(mono_enum: int) -&gt; str:\n    \"\"\"Returns the model of an instrument not yet opened.\n\n    Note, [search_for_inst][msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.search_for_inst]\n    needs to be called prior to this call. In the case of multiple Monochromator/Spectrographs attached, it allows\n    the user to sort, which instruments are to be opened before opening them.\n\n    Args:\n        mono_enum: A monochromator enumeration.\n\n    Returns:\n        The model of the unopened monochromator.\n    \"\"\"  # noqa: E501\n    if PrincetonInstruments._SDK is None:\n        msg = \"PrincetonInstrumentsError: You must first call PrincetonInstruments.init()\"\n        raise RuntimeError(msg)\n\n    buffer = create_string_buffer(255)\n    error_code = c_long()\n    PrincetonInstruments._SDK.ARC_get_Mono_preOpen_Model_CharStr(mono_enum, buffer, len(buffer), error_code)\n    return bytes(buffer.value).decode()\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_scan_rate_nm_min","title":"get_mono_scan_rate_nm_min","text":"<pre><code>get_mono_scan_rate_nm_min() -&gt; float\n</code></pre> <p>Return the current wavelength scan rate.</p> <p>Returns:</p> Type Description <code>float</code> <p>Scan rate in nm per minute.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_scan_rate_nm_min(self) -&gt; float:\n    \"\"\"Return the current wavelength scan rate.\n\n    Returns:\n        Scan rate in nm per minute.\n    \"\"\"\n    scan_rate = c_double()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Scan_Rate_nm_min(self._mono_enum, scan_rate, error_code)\n    return scan_rate.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_serial","title":"get_mono_serial","text":"<pre><code>get_mono_serial() -&gt; str\n</code></pre> <p>Returns the serial number of the instrument.</p> <p>Returns:</p> Type Description <code>str</code> <p>The serial number of the instrument as a string.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_serial(self) -&gt; str:\n    \"\"\"Returns the serial number of the instrument.\n\n    Returns:\n        The serial number of the instrument as a string.\n    \"\"\"\n    buffer = create_string_buffer(255)\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Serial_CharStr(self._mono_enum, buffer, len(buffer), error_code)\n    return bytes(buffer.value).decode()\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_shutter_open","title":"get_mono_shutter_open","text":"<pre><code>get_mono_shutter_open() -&gt; bool\n</code></pre> <p>Returns if the integrated shutter is open.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the shutter is open.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_shutter_open(self) -&gt; bool:\n    \"\"\"Returns if the integrated shutter is open.\n\n    Returns:\n        Whether the shutter is open.\n    \"\"\"\n    error_code = c_long()\n    return bool(self._sdk.ARC_get_Mono_Shutter_Open(self._mono_enum, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_shutter_valid","title":"get_mono_shutter_valid","text":"<pre><code>get_mono_shutter_valid() -&gt; bool\n</code></pre> <p>Returns if the instrument has an integrated shutter.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether a shutter is present.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_shutter_valid(self) -&gt; bool:\n    \"\"\"Returns if the instrument has an integrated shutter.\n\n    Returns:\n        Whether a shutter is present.\n    \"\"\"\n    error_code = c_long()\n    return bool(self._sdk.ARC_get_Mono_Shutter_Valid(self._mono_enum, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_sine_drive","title":"get_mono_sine_drive","text":"<pre><code>get_mono_sine_drive() -&gt; bool\n</code></pre> <p>Returns if the gearing system has sine instead of a linear drive system.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the gearing is sine based verses linear gearing.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_sine_drive(self) -&gt; bool:\n    \"\"\"Returns if the gearing system has sine instead of a linear drive system.\n\n    Returns:\n        Whether the gearing is sine based verses linear gearing.\n    \"\"\"\n    error_code = c_long()\n    return bool(self._sdk.ARC_get_Mono_Sine_Drive(self._mono_enum, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_slit_type","title":"get_mono_slit_type","text":"<pre><code>get_mono_slit_type(slit_pos: int) -&gt; int\n</code></pre> <p>Returns the slit type for a given slit.</p> <p>Parameters:</p> Name Type Description Default <code>slit_pos</code> <code>int</code> <p>The slit to be addressed.</p> <ul> <li><code>1</code> \u2014 Side entrance slit.</li> <li><code>2</code> \u2014 Front entrance slit.</li> <li><code>3</code> \u2014 Front exit slit.</li> <li><code>4</code> \u2014 Side exit slit.</li> <li><code>5</code> \u2014 Side entrance slit on a double slave unit.</li> <li><code>6</code> \u2014 Front entrance slit on a double slave unit.</li> <li><code>7</code> \u2014 Front exit slit on a double slave unit.</li> <li><code>8</code> \u2014 Side exit slit on a double slave unit.</li> </ul> required <p>Returns:</p> Type Description <code>int</code> <p>The type of slit attached.</p> <ul> <li><code>0</code> \u2014 No slit, older instruments that do will only return a slit type of zero.</li> <li><code>1</code> \u2014 Manual Slit.</li> <li><code>2</code> \u2014 Fixed Slit Width.</li> <li><code>3</code> \u2014 Focal Plane adapter.</li> <li><code>4</code> \u2014 Continuous Motor.</li> <li><code>5</code> \u2014 Fibre Optic.</li> <li><code>6</code> \u2014 Index able Slit.</li> </ul> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_slit_type(self, slit_pos: int) -&gt; int:\n    \"\"\"Returns the slit type for a given slit.\n\n    Args:\n        slit_pos: The slit to be addressed.\n\n            * `1` &amp;mdash; Side entrance slit.\n            * `2` &amp;mdash; Front entrance slit.\n            * `3` &amp;mdash; Front exit slit.\n            * `4` &amp;mdash; Side exit slit.\n            * `5` &amp;mdash; Side entrance slit on a double slave unit.\n            * `6` &amp;mdash; Front entrance slit on a double slave unit.\n            * `7` &amp;mdash; Front exit slit on a double slave unit.\n            * `8` &amp;mdash; Side exit slit on a double slave unit.\n\n    Returns:\n        The type of slit attached.\n\n            * `0` &amp;mdash; No slit, older instruments that do will only return a slit type of zero.\n            * `1` &amp;mdash; Manual Slit.\n            * `2` &amp;mdash; Fixed Slit Width.\n            * `3` &amp;mdash; Focal Plane adapter.\n            * `4` &amp;mdash; Continuous Motor.\n            * `5` &amp;mdash; Fibre Optic.\n            * `6` &amp;mdash; Index able Slit.\n\n    \"\"\"\n    slit_type = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Slit_Type(self._mono_enum, slit_pos, slit_type, error_code)\n    return slit_type.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_slit_type_str","title":"get_mono_slit_type_str","text":"<pre><code>get_mono_slit_type_str(slit_pos: int) -&gt; str\n</code></pre> <p>Returns a string descriptor of a given slit.</p> <p>Parameters:</p> Name Type Description Default <code>slit_pos</code> <code>int</code> <p>The slit to be addressed.</p> <ul> <li><code>1</code> \u2014 Side entrance slit.</li> <li><code>2</code> \u2014 Front entrance slit.</li> <li><code>3</code> \u2014 Front exit slit.</li> <li><code>4</code> \u2014 Side exit slit.</li> <li><code>5</code> \u2014 Side entrance slit on a double slave unit.</li> <li><code>6</code> \u2014 Front entrance slit on a double slave unit.</li> <li><code>7</code> \u2014 Front exit slit on a double slave unit.</li> <li><code>8</code> \u2014 Side exit slit on a double slave unit.</li> </ul> required <p>Returns:</p> Type Description <code>str</code> <p>The description of the slit.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_slit_type_str(self, slit_pos: int) -&gt; str:\n    \"\"\"Returns a string descriptor of a given slit.\n\n    Args:\n        slit_pos: The slit to be addressed.\n\n            * `1` &amp;mdash; Side entrance slit.\n            * `2` &amp;mdash; Front entrance slit.\n            * `3` &amp;mdash; Front exit slit.\n            * `4` &amp;mdash; Side exit slit.\n            * `5` &amp;mdash; Side entrance slit on a double slave unit.\n            * `6` &amp;mdash; Front entrance slit on a double slave unit.\n            * `7` &amp;mdash; Front exit slit on a double slave unit.\n            * `8` &amp;mdash; Side exit slit on a double slave unit.\n\n    Returns:\n        The description of the slit.\n    \"\"\"\n    buffer = create_string_buffer(255)\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Slit_Type_CharStr(self._mono_enum, slit_pos, buffer, len(buffer), error_code)\n    return bytes(buffer.value).decode()\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_slit_width","title":"get_mono_slit_width","text":"<pre><code>get_mono_slit_width(slit_pos: int) -&gt; int\n</code></pre> <p>Returns the slit width of a motorized slit.</p> <p>Parameters:</p> Name Type Description Default <code>slit_pos</code> <code>int</code> <p>The slit to be addressed.</p> <ul> <li><code>1</code> \u2014 Side entrance slit.</li> <li><code>2</code> \u2014 Front entrance slit.</li> <li><code>3</code> \u2014 Front exit slit.</li> <li><code>4</code> \u2014 Side exit slit.</li> <li><code>5</code> \u2014 Side entrance slit on a double slave unit.</li> <li><code>6</code> \u2014 Front entrance slit on a double slave unit.</li> <li><code>7</code> \u2014 Front exit slit on a double slave unit.</li> <li><code>8</code> \u2014 Side exit slit on a double slave unit.</li> </ul> required <p>Returns:</p> Type Description <code>int</code> <p>The width of the slit, if the slit is motorized.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_slit_width(self, slit_pos: int) -&gt; int:\n    \"\"\"Returns the slit width of a motorized slit.\n\n    Args:\n        slit_pos: The slit to be addressed.\n\n            * `1` &amp;mdash; Side entrance slit.\n            * `2` &amp;mdash; Front entrance slit.\n            * `3` &amp;mdash; Front exit slit.\n            * `4` &amp;mdash; Side exit slit.\n            * `5` &amp;mdash; Side entrance slit on a double slave unit.\n            * `6` &amp;mdash; Front entrance slit on a double slave unit.\n            * `7` &amp;mdash; Front exit slit on a double slave unit.\n            * `8` &amp;mdash; Side exit slit on a double slave unit.\n\n    Returns:\n        The width of the slit, if the slit is motorized.\n    \"\"\"\n    slit_width = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Slit_Width(self._mono_enum, slit_pos, slit_width, error_code)\n    return slit_width.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_slit_width_max","title":"get_mono_slit_width_max","text":"<pre><code>get_mono_slit_width_max(slit_pos: int) -&gt; int\n</code></pre> <p>Returns the maximum width of a motorized slit.</p> <p>Parameters:</p> Name Type Description Default <code>slit_pos</code> <code>int</code> <p>The slit to be addressed.</p> <ul> <li><code>1</code> \u2014 Side entrance slit.</li> <li><code>2</code> \u2014 Front entrance slit.</li> <li><code>3</code> \u2014 Front exit slit.</li> <li><code>4</code> \u2014 Side exit slit.</li> <li><code>5</code> \u2014 Side entrance slit on a double slave unit.</li> <li><code>6</code> \u2014 Front entrance slit on a double slave unit.</li> <li><code>7</code> \u2014 Front exit slit on a double slave unit.</li> <li><code>8</code> \u2014 Side exit slit on a double slave unit.</li> </ul> required <p>Returns:</p> Type Description <code>int</code> <p>The maximum width of the slit, if the slit is motorized.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_slit_width_max(self, slit_pos: int) -&gt; int:\n    \"\"\"Returns the maximum width of a motorized slit.\n\n    Args:\n        slit_pos: The slit to be addressed.\n\n            * `1` &amp;mdash; Side entrance slit.\n            * `2` &amp;mdash; Front entrance slit.\n            * `3` &amp;mdash; Front exit slit.\n            * `4` &amp;mdash; Side exit slit.\n            * `5` &amp;mdash; Side entrance slit on a double slave unit.\n            * `6` &amp;mdash; Front entrance slit on a double slave unit.\n            * `7` &amp;mdash; Front exit slit on a double slave unit.\n            * `8` &amp;mdash; Side exit slit on a double slave unit.\n\n    Returns:\n        The maximum width of the slit, if the slit is motorized.\n    \"\"\"\n    slit_width = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Slit_Max(self._mono_enum, slit_pos, slit_width, error_code)\n    return slit_width.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_turret","title":"get_mono_turret","text":"<pre><code>get_mono_turret() -&gt; int\n</code></pre> <p>Returns the current grating turret number.</p> <p>Returns:</p> Type Description <code>int</code> <p>The current turret number.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_turret(self) -&gt; int:\n    \"\"\"Returns the current grating turret number.\n\n    Returns:\n        The current turret number.\n    \"\"\"\n    turret = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Turret(self._mono_enum, turret, error_code)\n    return turret.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_turret_gratings","title":"get_mono_turret_gratings","text":"<pre><code>get_mono_turret_gratings() -&gt; int\n</code></pre> <p>Returns the number of gratings per turret.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of gratings that can be placed on a single turret. This number can be one, two or three depending on the monochromator model.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_turret_gratings(self) -&gt; int:\n    \"\"\"Returns the number of gratings per turret.\n\n    Returns:\n        The number of gratings that can be placed on a single turret. This number can be one,\n            two or three depending on the monochromator model.\n    \"\"\"\n    gratings_per_turret = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Turret_Gratings(self._mono_enum, gratings_per_turret, error_code)\n    return gratings_per_turret.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_turret_max","title":"get_mono_turret_max","text":"<pre><code>get_mono_turret_max() -&gt; int\n</code></pre> <p>Returns the number of turrets installed.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of turrets installed.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_turret_max(self) -&gt; int:\n    \"\"\"Returns the number of turrets installed.\n\n    Returns:\n        The number of turrets installed.\n    \"\"\"\n    turret = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Turret_Max(self._mono_enum, turret, error_code)\n    return turret.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_wavelength_abs_cm","title":"get_mono_wavelength_abs_cm","text":"<pre><code>get_mono_wavelength_abs_cm() -&gt; float\n</code></pre> <p>Returns the current center wavelength of instrument in absolute wavenumber.</p> <p>Returns:</p> Type Description <code>float</code> <p>The current wavelength of the instrument in absolute wavenumber.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_wavelength_abs_cm(self) -&gt; float:\n    \"\"\"Returns the current center wavelength of instrument in absolute wavenumber.\n\n    Returns:\n        The current wavelength of the instrument in absolute wavenumber.\n    \"\"\"\n    wavelength = c_double()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Wavelength_absCM(self._mono_enum, wavelength, error_code)\n    return wavelength.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_wavelength_ang","title":"get_mono_wavelength_ang","text":"<pre><code>get_mono_wavelength_ang() -&gt; float\n</code></pre> <p>Returns the current center wavelength of instrument in Angstroms.</p> <p>Returns:</p> Type Description <code>float</code> <p>The current wavelength of the instrument in Angstroms.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_wavelength_ang(self) -&gt; float:\n    \"\"\"Returns the current center wavelength of instrument in Angstroms.\n\n    Returns:\n        The current wavelength of the instrument in Angstroms.\n    \"\"\"\n    wavelength = c_double()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Wavelength_ang(self._mono_enum, wavelength, error_code)\n    return wavelength.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_wavelength_cutoff_nm","title":"get_mono_wavelength_cutoff_nm","text":"<pre><code>get_mono_wavelength_cutoff_nm() -&gt; float\n</code></pre> <p>Returns, in nm, the max wavelength achievable by the instrument using the current grating.</p> <p>Returns:</p> Type Description <code>float</code> <p>The maximum center wavelength in nanometres for the current grating. On SpectraPro's this value equals 1400 nm * grating density / 1200 g/mm. On AM/VM products, this value is limited by the sine bar and will vary.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_wavelength_cutoff_nm(self) -&gt; float:\n    \"\"\"Returns, in nm, the max wavelength achievable by the instrument using the current grating.\n\n    Returns:\n        The maximum center wavelength in nanometres for the current grating.\n            On SpectraPro's this value equals 1400 nm * grating density / 1200 g/mm.\n            On AM/VM products, this value is limited by the sine bar and will vary.\n    \"\"\"\n    wavelength = c_double()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Wavelength_Cutoff_nm(self._mono_enum, wavelength, error_code)\n    return wavelength.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_wavelength_ev","title":"get_mono_wavelength_ev","text":"<pre><code>get_mono_wavelength_ev() -&gt; float\n</code></pre> <p>Returns the current center wavelength of instrument in electron volts.</p> <p>Returns:</p> Type Description <code>float</code> <p>The current wavelength of the instrument in electron volts.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_wavelength_ev(self) -&gt; float:\n    \"\"\"Returns the current center wavelength of instrument in electron volts.\n\n    Returns:\n        The current wavelength of the instrument in electron volts.\n    \"\"\"\n    wavelength = c_double()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Wavelength_eV(self._mono_enum, wavelength, error_code)\n    return wavelength.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_wavelength_micron","title":"get_mono_wavelength_micron","text":"<pre><code>get_mono_wavelength_micron() -&gt; float\n</code></pre> <p>Returns the current center wavelength of instrument in microns.</p> <p>Returns:</p> Type Description <code>float</code> <p>The current wavelength of the instrument in microns.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_wavelength_micron(self) -&gt; float:\n    \"\"\"Returns the current center wavelength of instrument in microns.\n\n    Returns:\n        The current wavelength of the instrument in microns.\n    \"\"\"\n    wavelength = c_double()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Wavelength_micron(self._mono_enum, wavelength, error_code)\n    return wavelength.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_wavelength_min_nm","title":"get_mono_wavelength_min_nm","text":"<pre><code>get_mono_wavelength_min_nm() -&gt; float\n</code></pre> <p>Returns, in nm, the min wavelength achievable by the instrument using the current grating.</p> <p>Returns:</p> Type Description <code>float</code> <p>The minimum center wavelength in nanometres for the current grating. On SpectraPro's it is usually -10 nm, on linear AM/VM instruments this value will vary.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_wavelength_min_nm(self) -&gt; float:\n    \"\"\"Returns, in nm, the min wavelength achievable by the instrument using the current grating.\n\n    Returns:\n        The minimum center wavelength in nanometres for the current grating.\n            On SpectraPro's it is usually -10 nm, on linear AM/VM instruments this value will vary.\n    \"\"\"\n    wavelength = c_double()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Wavelength_Min_nm(self._mono_enum, wavelength, error_code)\n    return wavelength.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_wavelength_nm","title":"get_mono_wavelength_nm","text":"<pre><code>get_mono_wavelength_nm() -&gt; float\n</code></pre> <p>Returns the current center wavelength of instrument in nm.</p> <p>Returns:</p> Type Description <code>float</code> <p>The current wavelength of the instrument.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_wavelength_nm(self) -&gt; float:\n    \"\"\"Returns the current center wavelength of instrument in nm.\n\n    Returns:\n        The current wavelength of the instrument.\n    \"\"\"\n    wavelength = c_double()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Wavelength_nm(self._mono_enum, wavelength, error_code)\n    return wavelength.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_wavelength_rel_cm","title":"get_mono_wavelength_rel_cm","text":"<pre><code>get_mono_wavelength_rel_cm(center_nm: int) -&gt; float\n</code></pre> <p>Returns the current center wavelength of instrument in relative wavenumber.</p> <p>Parameters:</p> Name Type Description Default <code>center_nm</code> <code>int</code> <p>The wavelength, in nm, that the relative wavenumber is centred around.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The current wavelength of the instrument in relative wavenumber.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_wavelength_rel_cm(self, center_nm: int) -&gt; float:\n    \"\"\"Returns the current center wavelength of instrument in relative wavenumber.\n\n    Args:\n        center_nm: The wavelength, in nm, that the relative wavenumber is centred around.\n\n    Returns:\n        The current wavelength of the instrument in relative wavenumber.\n    \"\"\"\n    wavelength = c_double()\n    error_code = c_long()\n    self._sdk.ARC_get_Mono_Wavelength_relCM(self._mono_enum, center_nm, wavelength, error_code)\n    return wavelength.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_mono_wheel_int","title":"get_mono_wheel_int","text":"<pre><code>get_mono_wheel_int() -&gt; bool\n</code></pre> <p>Read the wheel gear interrupter.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the wheel gear was interrupted.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_mono_wheel_int(self) -&gt; bool:\n    \"\"\"Read the wheel gear interrupter.\n\n    Returns:\n        Whether the wheel gear was interrupted.\n    \"\"\"\n    error_code = c_long()\n    return bool(self._sdk.ARC_get_Mono_Wheel_Int(self._mono_enum, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_ncl_filter_max_pos","title":"get_ncl_filter_max_pos","text":"<pre><code>get_ncl_filter_max_pos() -&gt; int\n</code></pre> <p>Returns the maximum filter position.</p> <p>Returns:</p> Type Description <code>int</code> <p>The maximum filter position.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_ncl_filter_max_pos(self) -&gt; int:\n    \"\"\"Returns the maximum filter position.\n\n    Returns:\n        The maximum filter position.\n    \"\"\"\n    position = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_NCL_Filter_Max_Pos(self._ncl_enum, position, error_code)\n    return position.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_ncl_filter_min_pos","title":"get_ncl_filter_min_pos","text":"<pre><code>get_ncl_filter_min_pos() -&gt; int\n</code></pre> <p>Returns the minimum filter position.</p> <p>Returns:</p> Type Description <code>int</code> <p>The minimum filter position.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_ncl_filter_min_pos(self) -&gt; int:\n    \"\"\"Returns the minimum filter position.\n\n    Returns:\n        The minimum filter position.\n    \"\"\"\n    position = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_NCL_Filter_Min_Pos(self._ncl_enum, position, error_code)\n    return position.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_ncl_filter_position","title":"get_ncl_filter_position","text":"<pre><code>get_ncl_filter_position() -&gt; int\n</code></pre> <p>Return the current filter position.</p> <p>Returns:</p> Type Description <code>int</code> <p>The current filter position.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_ncl_filter_position(self) -&gt; int:\n    \"\"\"Return the current filter position.\n\n    Returns:\n        The current filter position.\n    \"\"\"\n    position = c_long()\n    error_code = c_long()\n    self._sdk.ARC_get_NCL_Filter_Position(self._ncl_enum, position, error_code)\n    return position.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_ncl_filter_present","title":"get_ncl_filter_present","text":"<pre><code>get_ncl_filter_present() -&gt; bool\n</code></pre> <p>Returns if the instrument has an integrated filter wheel setup.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether a NCL filter wheel is setup and present.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_ncl_filter_present(self) -&gt; bool:\n    \"\"\"Returns if the instrument has an integrated filter wheel setup.\n\n    Returns:\n        Whether a NCL filter wheel is setup and present.\n    \"\"\"\n    error_code = c_long()\n    return bool(self._sdk.ARC_get_NCL_Filter_Present(self._ncl_enum, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_ncl_mono_enum","title":"get_ncl_mono_enum","text":"<pre><code>get_ncl_mono_enum(mono_num: int) -&gt; int\n</code></pre> <p>Return the enumeration of the attached monochromator.</p> <p>Parameters:</p> Name Type Description Default <code>mono_num</code> <code>int</code> <p>The readout system monochromator port being addressed.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The enumeration of the monochromator. Check the value returned with valid_mono_enum.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_ncl_mono_enum(self, mono_num: int) -&gt; int:\n    \"\"\"Return the enumeration of the attached monochromator.\n\n    Args:\n        mono_num: The readout system monochromator port being addressed.\n\n    Returns:\n        The enumeration of the monochromator. Check the value returned with\n            [valid_mono_enum][msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.valid_mono_enum].\n    \"\"\"\n    error_code = c_long()\n    return int(self._sdk.ARC_get_NCL_Mono_Enum(self._ncl_enum, mono_num, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_ncl_mono_setup","title":"get_ncl_mono_setup","text":"<pre><code>get_ncl_mono_setup(mono_num: int) -&gt; bool\n</code></pre> <p>Return if the open NCL port has a Monochromator attached.</p> <p>Parameters:</p> Name Type Description Default <code>mono_num</code> <code>int</code> <p>The readout system monochromator port being addressed.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether a monochromator is attached to the port and it is set up.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_ncl_mono_setup(self, mono_num: int) -&gt; bool:\n    \"\"\"Return if the open NCL port has a Monochromator attached.\n\n    Args:\n        mono_num: The readout system monochromator port being addressed.\n\n    Returns:\n        Whether a monochromator is attached to the port and it is set up.\n    \"\"\"\n    error_code = c_long()\n    return bool(self._sdk.ARC_get_NCL_Mono_Setup(self._ncl_enum, mono_num, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_ncl_shutter_open","title":"get_ncl_shutter_open","text":"<pre><code>get_ncl_shutter_open(shutter_num: int) -&gt; bool\n</code></pre> <p>Return if an NCL Readout shutter is open.</p> <p>Parameters:</p> Name Type Description Default <code>shutter_num</code> <code>int</code> <p>The shutter being addressed (1 or 2 on an NCL).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the shutter is in the open position.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_ncl_shutter_open(self, shutter_num: int) -&gt; bool:\n    \"\"\"Return if an NCL Readout shutter is open.\n\n    Args:\n        shutter_num: The shutter being addressed (1 or 2 on an NCL).\n\n    Returns:\n        Whether the shutter is in the open position.\n    \"\"\"\n    error_code = c_long()\n    return bool(self._sdk.ARC_get_NCL_Shutter_Open(self._ncl_enum, shutter_num, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_ncl_shutter_valid","title":"get_ncl_shutter_valid","text":"<pre><code>get_ncl_shutter_valid(shutter_num: int) -&gt; bool\n</code></pre> <p>Return if a NCL Readout shutter number is valid.</p> <p>Parameters:</p> Name Type Description Default <code>shutter_num</code> <code>int</code> <p>The shutter being addressed (1 or 2 on an NCL).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the shutter number is valid.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_ncl_shutter_valid(self, shutter_num: int) -&gt; bool:\n    \"\"\"Return if a NCL Readout shutter number is valid.\n\n    Args:\n        shutter_num: The shutter being addressed (1 or 2 on an NCL).\n\n    Returns:\n        Whether the shutter number is valid.\n    \"\"\"\n    error_code = c_long()\n    return bool(self._sdk.ARC_get_NCL_Shutter_Valid(self._ncl_enum, shutter_num, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_ncl_ttl_in","title":"get_ncl_ttl_in","text":"<pre><code>get_ncl_ttl_in(ttl_line: int) -&gt; bool\n</code></pre> <p>Return if an input TTL line is being pulled on by an outside connection.</p> <p>Parameters:</p> Name Type Description Default <code>ttl_line</code> <code>int</code> <p>The TTL line number being addressed.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>ttl_line</code> is being pulled to TTL high.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_ncl_ttl_in(self, ttl_line: int) -&gt; bool:\n    \"\"\"Return if an input TTL line is being pulled on by an outside connection.\n\n    Args:\n        ttl_line: The TTL line number being addressed.\n\n    Returns:\n        Whether `ttl_line` is being pulled to TTL high.\n    \"\"\"\n    error_code = c_long()\n    return bool(self._sdk.ARC_get_NCL_TTL_In(self._ncl_enum, ttl_line, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_ncl_ttl_out","title":"get_ncl_ttl_out","text":"<pre><code>get_ncl_ttl_out(ttl_line: int) -&gt; bool\n</code></pre> <p>Return if an output TTL line is on.</p> <p>Parameters:</p> Name Type Description Default <code>ttl_line</code> <code>int</code> <p>The TTL line number being addressed.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the output <code>ttl_line</code> is set to TTL high.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_ncl_ttl_out(self, ttl_line: int) -&gt; bool:\n    \"\"\"Return if an output TTL line is on.\n\n    Args:\n        ttl_line: The TTL line number being addressed.\n\n    Returns:\n        Whether the output `ttl_line` is set to TTL high.\n    \"\"\"\n    error_code = c_long()\n    return bool(self._sdk.ARC_get_NCL_TTL_Out(self._ncl_enum, ttl_line, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_ncl_ttl_valid","title":"get_ncl_ttl_valid","text":"<pre><code>get_ncl_ttl_valid(ttl_line: int) -&gt; bool\n</code></pre> <p>Return if a TTL line is a valid line.</p> <p>Parameters:</p> Name Type Description Default <code>ttl_line</code> <code>int</code> <p>The TTL line number being addressed.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether <code>ttl_line</code> is a valid line number.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_ncl_ttl_valid(self, ttl_line: int) -&gt; bool:\n    \"\"\"Return if a TTL line is a valid line.\n\n    Args:\n        ttl_line: The TTL line number being addressed.\n\n    Returns:\n        Whether `ttl_line` is a valid line number.\n    \"\"\"\n    error_code = c_long()\n    return bool(self._sdk.ARC_get_NCL_TTL_Valid(self._ncl_enum, ttl_line, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_num_det","title":"get_num_det","text":"<pre><code>get_num_det() -&gt; int\n</code></pre> <p>Return the number of single point detectors in the Readout System.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of single point detectors the readout system supports. (1 NCL-Lite, 2,3 NCL).</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_num_det(self) -&gt; int:\n    \"\"\"Return the number of single point detectors in the Readout System.\n\n    Returns:\n        Number of single point detectors the readout system supports. (1 NCL-Lite, 2,3 NCL).\n    \"\"\"\n    error_code = c_long()\n    return int(self._sdk.ARC_get_Num_Det(self._ncl_enum, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_num_found_inst_ports","title":"get_num_found_inst_ports  <code>staticmethod</code>","text":"<pre><code>get_num_found_inst_ports() -&gt; int\n</code></pre> <p>Returns the value last returned by search_for_inst.</p> <p>Can be called multiple times.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of instruments found.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>@staticmethod\ndef get_num_found_inst_ports() -&gt; int:\n    \"\"\"Returns the value last returned by [search_for_inst][msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.search_for_inst].\n\n    Can be called multiple times.\n\n    Returns:\n        The number of instruments found.\n    \"\"\"  # noqa: E501\n    if PrincetonInstruments._SDK is None:\n        msg = \"PrincetonInstrumentsError: You must first call PrincetonInstruments.init()\"\n        raise RuntimeError(msg)\n\n    return int(PrincetonInstruments._SDK.ARC_get_Num_Found_Inst_Ports())\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_readout_itime_ms","title":"get_readout_itime_ms","text":"<pre><code>get_readout_itime_ms() -&gt; int\n</code></pre> <p>Return the integration time used for taking a reading.</p> <p>Returns:</p> Type Description <code>int</code> <p>The integration time used for taking a reading, in milliseconds.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_readout_itime_ms(self) -&gt; int:\n    \"\"\"Return the integration time used for taking a reading.\n\n    Returns:\n        The integration time used for taking a reading, in milliseconds.\n    \"\"\"\n    error_code = c_long()\n    return int(self._sdk.ARC_get_ReadOut_ITime_ms(self._ncl_enum, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_readout_model","title":"get_readout_model","text":"<pre><code>get_readout_model() -&gt; str\n</code></pre> <p>Returns the model string from the instrument.</p> <p>Returns:</p> Type Description <code>str</code> <p>The model string of the instrument.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_readout_model(self) -&gt; str:\n    \"\"\"Returns the model string from the instrument.\n\n    Returns:\n        The model string of the instrument.\n    \"\"\"\n    buffer = create_string_buffer(255)\n    error_code = c_long()\n    self._sdk.ARC_get_ReadOut_Model_CharStr(self._ncl_enum, buffer, len(buffer), error_code)\n    return bytes(buffer.value).decode()\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_readout_preopen_model","title":"get_readout_preopen_model  <code>staticmethod</code>","text":"<pre><code>get_readout_preopen_model(enum: int) -&gt; str\n</code></pre> <p>Returns the model string of an instrument not yet opened.</p> <p>Note, search_for_inst needs to be called prior to this call. In the case of multiple Readout Systems attached, it allows the user to sort, which instruments are to be opened before opening them.</p> <p>Parameters:</p> Name Type Description Default <code>enum</code> <code>int</code> <p>The instrument enumeration.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The model string of the unopened instrument.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>@staticmethod\ndef get_readout_preopen_model(enum: int) -&gt; str:\n    \"\"\"Returns the model string of an instrument not yet opened.\n\n    Note, [search_for_inst][msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.search_for_inst]\n    needs to be called prior to this call. In the case of multiple Readout Systems attached, it allows the user\n    to sort, which instruments are to be opened before opening them.\n\n    Args:\n        enum: The instrument enumeration.\n\n    Returns:\n        The model string of the unopened instrument.\n    \"\"\"  # noqa: E501\n    if PrincetonInstruments._SDK is None:\n        msg = \"PrincetonInstrumentsError: You must first call PrincetonInstruments.init()\"\n        raise RuntimeError(msg)\n\n    buffer = create_string_buffer(255)\n    error_code = c_long()\n    PrincetonInstruments._SDK.ARC_get_ReadOut_preOpen_Model_CharStr(enum, buffer, len(buffer), error_code)\n    return bytes(buffer.value).decode()\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.get_readout_serial","title":"get_readout_serial","text":"<pre><code>get_readout_serial() -&gt; str\n</code></pre> <p>Returns the serial number from the instrument.</p> <p>Returns:</p> Type Description <code>str</code> <p>The serial number of the instrument as a string.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def get_readout_serial(self) -&gt; str:\n    \"\"\"Returns the serial number from the instrument.\n\n    Returns:\n        The serial number of the instrument as a string.\n    \"\"\"\n    buffer = create_string_buffer(255)\n    error_code = c_long()\n    self._sdk.ARC_get_ReadOut_Serial_CharStr(self._ncl_enum, buffer, len(buffer), error_code)\n    return bytes(buffer.value).decode()\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.init","title":"init  <code>staticmethod</code>","text":"<pre><code>init(path: PathLike = 'ARC_Instrument_x64.dll') -&gt; None\n</code></pre> <p>Initialize the SDK.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>PathLike</code> <p>The path to the SDK.</p> <code>'ARC_Instrument_x64.dll'</code> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>@staticmethod\ndef init(path: PathLike = \"ARC_Instrument_x64.dll\") -&gt; None:\n    \"\"\"Initialize the SDK.\n\n    Args:\n        path: The path to the SDK.\n    \"\"\"\n    _load_sdk(os.fsdecode(path))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.is_inited","title":"is_inited  <code>staticmethod</code>","text":"<pre><code>is_inited() -&gt; bool\n</code></pre> <p>Check if the init method was called.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the method was called.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>@staticmethod\ndef is_inited() -&gt; bool:\n    \"\"\"Check if the [init][msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.init] method was called.\n\n    Returns:\n        Whether the method was called.\n    \"\"\"  # noqa: E501\n    if PrincetonInstruments._SDK is None:\n        msg = \"PrincetonInstrumentsError: You must first call PrincetonInstruments.init()\"\n        raise RuntimeError(msg)\n\n    return bool(PrincetonInstruments._SDK.ARC_IsInited())\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.mono_filter_home","title":"mono_filter_home","text":"<pre><code>mono_filter_home() -&gt; None\n</code></pre> <p>Homes the filter wheel.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def mono_filter_home(self) -&gt; None:\n    \"\"\"Homes the filter wheel.\"\"\"\n    error_code = c_long()\n    self._sdk.ARC_Mono_Filter_Home(self._mono_enum, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.mono_grating_calc_gadjust","title":"mono_grating_calc_gadjust","text":"<pre><code>mono_grating_calc_gadjust(\n    grating: int, wave: float, ref_wave: float\n) -&gt; int\n</code></pre> <p>Calculate a new grating GAdjust.</p> <p>Parameters:</p> Name Type Description Default <code>grating</code> <code>int</code> <p>The number of the grating that is to be addressed.</p> required <code>wave</code> <code>float</code> <p>The wavelength, in nm, on which a peak is currently falling.</p> required <code>ref_wave</code> <code>float</code> <p>The wavelength, in nm, on which the peak should fall.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The calculated grating GAdjust. Note, this value is specific to a specific instrument-grating combination and not transferable between instruments.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def mono_grating_calc_gadjust(self, grating: int, wave: float, ref_wave: float) -&gt; int:\n    \"\"\"Calculate a new grating GAdjust.\n\n    Args:\n        grating: The number of the grating that is to be addressed.\n        wave: The wavelength, in nm, on which a peak is currently falling.\n        ref_wave: The wavelength, in nm, on which the peak should fall.\n\n    Returns:\n        The calculated grating GAdjust. Note, this value is specific to a specific\n            instrument-grating combination and not transferable between instruments.\n    \"\"\"\n    new_gadjust = c_long()\n    error_code = c_long()\n    self._sdk.ARC_Mono_Grating_Calc_Gadjust(self._mono_enum, grating, wave, ref_wave, new_gadjust, error_code)\n    return new_gadjust.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.mono_grating_calc_offset","title":"mono_grating_calc_offset","text":"<pre><code>mono_grating_calc_offset(\n    grating: int, wave: float, ref_wave: float\n) -&gt; int\n</code></pre> <p>Calculate a new grating offset.</p> <p>Parameters:</p> Name Type Description Default <code>grating</code> <code>int</code> <p>The number of the grating that is to be addressed.</p> required <code>wave</code> <code>float</code> <p>The wavelength, in nm, on which a peak is currently falling.</p> required <code>ref_wave</code> <code>float</code> <p>The wavelength, in nm, on which the peak should fall.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The calculated grating offset. Note, this value is specific to a specific instrument-grating combination and not transferable between instruments.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def mono_grating_calc_offset(self, grating: int, wave: float, ref_wave: float) -&gt; int:\n    \"\"\"Calculate a new grating offset.\n\n    Args:\n        grating: The number of the grating that is to be addressed.\n        wave: The wavelength, in nm, on which a peak is currently falling.\n        ref_wave: The wavelength, in nm, on which the peak should fall.\n\n    Returns:\n        The calculated grating offset. Note, this value is specific to a specific\n            instrument-grating combination and not transferable between instruments.\n    \"\"\"\n    new_offset = c_long()\n    error_code = c_long()\n    self._sdk.ARC_Mono_Grating_Calc_Offset(self._mono_enum, grating, wave, ref_wave, new_offset, error_code)\n    return new_offset.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.mono_grating_install","title":"mono_grating_install","text":"<pre><code>mono_grating_install(\n    *,\n    grating: int,\n    density: int,\n    blaze: str,\n    nm_blaze: bool,\n    um_blaze: bool,\n    hol_blaze: bool,\n    mirror: bool,\n    reboot: bool\n) -&gt; None\n</code></pre> <p>Install a new grating.</p> <p>Parameters:</p> Name Type Description Default <code>grating</code> <code>int</code> <p>The number of the grating that is to be addressed.</p> required <code>density</code> <code>int</code> <p>The groove density in grooves per mm of the grating.</p> required <code>blaze</code> <code>str</code> <p>The Blaze string.</p> required <code>nm_blaze</code> <code>bool</code> <p>Whether the grating has a nm blaze.</p> required <code>um_blaze</code> <code>bool</code> <p>Whether the grating has a um blaze.</p> required <code>hol_blaze</code> <code>bool</code> <p>Whether the grating has a holographic blaze.</p> required <code>mirror</code> <code>bool</code> <p>Whether the grating position is a mirror.</p> required <code>reboot</code> <code>bool</code> <p>Whether to reboot the monochromator after installing.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def mono_grating_install(  # noqa: PLR0913\n    self,\n    *,\n    grating: int,\n    density: int,\n    blaze: str,\n    nm_blaze: bool,\n    um_blaze: bool,\n    hol_blaze: bool,\n    mirror: bool,\n    reboot: bool,\n) -&gt; None:\n    \"\"\"Install a new grating.\n\n    Args:\n        grating: The number of the grating that is to be addressed.\n        density: The groove density in grooves per mm of the grating.\n        blaze: The Blaze string.\n        nm_blaze: Whether the grating has a nm blaze.\n        um_blaze: Whether the grating has a um blaze.\n        hol_blaze: Whether the grating has a holographic blaze.\n        mirror: Whether the grating position is a mirror.\n        reboot: Whether to reboot the monochromator after installing.\n    \"\"\"\n    bb = create_string_buffer(blaze.encode())\n    error_code = c_long()\n    self._sdk.ARC_Mono_Grating_Install_CharStr(\n        self._mono_enum, grating, density, bb, len(bb), nm_blaze, um_blaze, hol_blaze, mirror, reboot, error_code\n    )\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.mono_grating_uninstall","title":"mono_grating_uninstall","text":"<pre><code>mono_grating_uninstall(\n    grating: int, *, reboot: bool\n) -&gt; None\n</code></pre> <p>Uninstall a grating.</p> <p>Parameters:</p> Name Type Description Default <code>grating</code> <code>int</code> <p>The number of the grating that is to be uninstalled.</p> required <code>reboot</code> <code>bool</code> <p>Whether to reboot the monochromator after uninstalling.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def mono_grating_uninstall(self, grating: int, *, reboot: bool) -&gt; None:\n    \"\"\"Uninstall a grating.\n\n    Args:\n        grating: The number of the grating that is to be uninstalled.\n        reboot: Whether to reboot the monochromator after uninstalling.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_Mono_Grating_UnInstall(self._mono_enum, grating, reboot, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.mono_move_steps","title":"mono_move_steps","text":"<pre><code>mono_move_steps(num_steps: int) -&gt; None\n</code></pre> <p>Move the grating a set number of steps.</p> <p>Parameters:</p> Name Type Description Default <code>num_steps</code> <code>int</code> <p>Number of steps to move the wavelength drive.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def mono_move_steps(self, num_steps: int) -&gt; None:\n    \"\"\"Move the grating a set number of steps.\n\n    Args:\n        num_steps: Number of steps to move the wavelength drive.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_Mono_Move_Steps(self._mono_enum, num_steps, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.mono_reset","title":"mono_reset","text":"<pre><code>mono_reset() -&gt; None\n</code></pre> <p>Reset the monochromator.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def mono_reset(self) -&gt; None:\n    \"\"\"Reset the monochromator.\"\"\"\n    error_code = c_long()\n    self._sdk.ARC_Mono_Reset(self._mono_enum, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.mono_restore_factory_settings","title":"mono_restore_factory_settings","text":"<pre><code>mono_restore_factory_settings() -&gt; None\n</code></pre> <p>Restore the instrument factory settings.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def mono_restore_factory_settings(self) -&gt; None:\n    \"\"\"Restore the instrument factory settings.\"\"\"\n    error_code = c_long()\n    self._sdk.ARC_Mono_Restore_Factory_Settings(self._mono_enum, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.mono_scan_done","title":"mono_scan_done","text":"<pre><code>mono_scan_done() -&gt; tuple[bool, float]\n</code></pre> <p>Check if a scan has completed.</p> <p>Returns:</p> Type Description <code>tuple[bool, float]</code> <p>Whether the scan finished (the scan ended or the grating wavelength limit was reached) and the current wavelength, in nm, of the grating.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def mono_scan_done(self) -&gt; tuple[bool, float]:\n    \"\"\"Check if a scan has completed.\n\n    Returns:\n        Whether the scan finished (the scan ended or the grating wavelength limit was reached) and\n            the current wavelength, in nm, of the grating.\n    \"\"\"\n    done = c_bool()\n    nm = c_double()\n    error_code = c_long()\n    self._sdk.ARC_Mono_Scan_Done(self._mono_enum, done, nm, error_code)\n    return done.value, nm.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.mono_slit_home","title":"mono_slit_home","text":"<pre><code>mono_slit_home(slit_num: int) -&gt; None\n</code></pre> <p>Homes a motorized slit.</p> <p>Parameters:</p> Name Type Description Default <code>slit_num</code> <code>int</code> <p>The slit to be homed.</p> <ul> <li><code>1</code> \u2014 Side entrance slit.</li> <li><code>2</code> \u2014 Front entrance slit.</li> <li><code>3</code> \u2014 Front exit slit.</li> <li><code>4</code> \u2014 Side exit slit.</li> <li><code>5</code> \u2014 Side entrance slit on a double slave unit.</li> <li><code>6</code> \u2014 Front entrance slit on a double slave unit.</li> <li><code>7</code> \u2014 Front exit slit on a double slave unit.</li> <li><code>8</code> \u2014 Side exit slit on a double slave unit.</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def mono_slit_home(self, slit_num: int) -&gt; None:\n    \"\"\"Homes a motorized slit.\n\n    Args:\n        slit_num: The slit to be homed.\n\n            * `1` &amp;mdash; Side entrance slit.\n            * `2` &amp;mdash; Front entrance slit.\n            * `3` &amp;mdash; Front exit slit.\n            * `4` &amp;mdash; Side exit slit.\n            * `5` &amp;mdash; Side entrance slit on a double slave unit.\n            * `6` &amp;mdash; Front entrance slit on a double slave unit.\n            * `7` &amp;mdash; Front exit slit on a double slave unit.\n            * `8` &amp;mdash; Side exit slit on a double slave unit.\n\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_Mono_Slit_Home(self._mono_enum, slit_num, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.mono_slit_name","title":"mono_slit_name  <code>staticmethod</code>","text":"<pre><code>mono_slit_name(slit_num: int) -&gt; str\n</code></pre> <p>Returns a text description of a slit position.</p> <p>Parameters:</p> Name Type Description Default <code>slit_num</code> <code>int</code> <p>The slit to be addressed.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The description of the slit port location.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>@staticmethod\ndef mono_slit_name(slit_num: int) -&gt; str:\n    \"\"\"Returns a text description of a slit position.\n\n    Args:\n        slit_num: The slit to be addressed.\n\n    Returns:\n        The description of the slit port location.\n    \"\"\"\n    if PrincetonInstruments._SDK is None:\n        msg = \"PrincetonInstrumentsError: You must first call PrincetonInstruments.init()\"\n        raise RuntimeError(msg)\n\n    buffer = create_string_buffer(255)\n    error_code = c_long()\n    PrincetonInstruments._SDK.ARC_Mono_Slit_Name_CharStr(slit_num, buffer, len(buffer), error_code)\n    return bytes(buffer.value).decode()\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.mono_start_jog","title":"mono_start_jog","text":"<pre><code>mono_start_jog(\n    *, jog_max_rate: bool, jog_forwards: bool\n) -&gt; None\n</code></pre> <p>Start jogging the wavelength of the monochromator.</p> <p>Parameters:</p> Name Type Description Default <code>jog_max_rate</code> <code>bool</code> <p>Whether to jog at the max scan rate or at the current scan rate.</p> <ul> <li><code>False</code> \u2014 Current Scan Rate.</li> <li><code>True</code> \u2014 Max Scan Rate.</li> </ul> required <code>jog_forwards</code> <code>bool</code> <p>Whether to jog forward (increasing nm) or backwards (decreasing nm).</p> <ul> <li><code>False</code> \u2014 Jog Backwards (decreasing nm).</li> <li><code>True</code> \u2014 Jog Forwards (increasing nm).</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def mono_start_jog(self, *, jog_max_rate: bool, jog_forwards: bool) -&gt; None:\n    \"\"\"Start jogging the wavelength of the monochromator.\n\n    Args:\n        jog_max_rate: Whether to jog at the max scan rate or at the current scan rate.\n\n            * `False` &amp;mdash; Current Scan Rate.\n            * `True` &amp;mdash; Max Scan Rate.\n\n        jog_forwards: Whether to jog forward (increasing nm) or backwards (decreasing nm).\n\n            * `False` &amp;mdash; Jog Backwards (decreasing nm).\n            * `True` &amp;mdash; Jog Forwards (increasing nm).\n\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_Mono_Start_Jog(self._mono_enum, jog_max_rate, jog_forwards, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.mono_start_scan_to_nm","title":"mono_start_scan_to_nm","text":"<pre><code>mono_start_scan_to_nm(wavelength_nm: float) -&gt; None\n</code></pre> <p>Start a wavelength scan.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength_nm</code> <code>float</code> <p>Wavelength in nm we are to scan to. Note, the value should not be lower than the current wavelength and should not exceed the current grating wavelength limit.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def mono_start_scan_to_nm(self, wavelength_nm: float) -&gt; None:\n    \"\"\"Start a wavelength scan.\n\n    Args:\n        wavelength_nm: Wavelength in nm we are to scan to. Note, the value should not be lower than the\n            current wavelength and should not exceed the current grating wavelength limit.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_Mono_Start_Scan_To_nm(self._mono_enum, wavelength_nm, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.mono_stop_jog","title":"mono_stop_jog","text":"<pre><code>mono_stop_jog() -&gt; None\n</code></pre> <p>End a wavelength jog.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def mono_stop_jog(self) -&gt; None:\n    \"\"\"End a wavelength jog.\"\"\"\n    error_code = c_long()\n    self._sdk.ARC_Mono_Stop_Jog(self._mono_enum, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.ncl_filter_home","title":"ncl_filter_home","text":"<pre><code>ncl_filter_home() -&gt; None\n</code></pre> <p>Home the filter wheel.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def ncl_filter_home(self) -&gt; None:\n    \"\"\"Home the filter wheel.\"\"\"\n    error_code = c_long()\n    self._sdk.ARC_NCL_Filter_Home(self._ncl_enum, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.open_filter","title":"open_filter","text":"<pre><code>open_filter(enum: int) -&gt; None\n</code></pre> <p>Function to open a filter wheel.</p> <p>Parameters:</p> Name Type Description Default <code>enum</code> <code>int</code> <p>Number in the enumeration list to open.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def open_filter(self, enum: int) -&gt; None:\n    \"\"\"Function to open a filter wheel.\n\n    Args:\n        enum: Number in the enumeration list to open.\n    \"\"\"\n    handle = c_long()\n    error_code = c_long()\n    self._sdk.ARC_Open_Filter(enum, handle, error_code)\n    self._filter_enum = handle.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.open_filter_port","title":"open_filter_port","text":"<pre><code>open_filter_port(port: str) -&gt; None\n</code></pre> <p>Function to open a filter wheel on a specific COM Port.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>The COM port (e.g., <code>\"COM5\"</code>).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def open_filter_port(self, port: str) -&gt; None:\n    \"\"\"Function to open a filter wheel on a specific COM Port.\n\n    Args:\n        port: The COM port (e.g., `\"COM5\"`).\n    \"\"\"\n    handle = c_long()\n    error_code = c_long()\n    self._sdk.ARC_Open_Filter_Port(int(port[3:]), handle, error_code)\n    self._filter_enum = handle.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.open_filter_serial","title":"open_filter_serial","text":"<pre><code>open_filter_serial(serial: str) -&gt; None\n</code></pre> <p>Function to open a filter wheel with a specific serial number.</p> <p>Parameters:</p> Name Type Description Default <code>serial</code> <code>str</code> <p>The serial number of the filter wheel.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def open_filter_serial(self, serial: str) -&gt; None:\n    \"\"\"Function to open a filter wheel with a specific serial number.\n\n    Args:\n       serial: The serial number of the filter wheel.\n    \"\"\"\n    handle = c_long()\n    model = c_long()\n    error_code = c_long()\n    self._sdk.ARC_Open_Filter_Serial(int(serial), handle, model, error_code)\n    self._filter_enum = handle.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.open_mono","title":"open_mono","text":"<pre><code>open_mono(enum: int) -&gt; None\n</code></pre> <p>Function to open a Monochromator.</p> <p>Parameters:</p> Name Type Description Default <code>enum</code> <code>int</code> <p>Number in the enumeration list to open.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def open_mono(self, enum: int) -&gt; None:\n    \"\"\"Function to open a Monochromator.\n\n    Args:\n        enum: Number in the enumeration list to open.\n    \"\"\"\n    handle = c_long()\n    error_code = c_long()\n    self._sdk.ARC_Open_Mono(enum, handle, error_code)\n    self._mono_enum = handle.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.open_mono_port","title":"open_mono_port","text":"<pre><code>open_mono_port(port: str) -&gt; None\n</code></pre> <p>Function to open a Monochromator on a specific COM Port.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>The COM port (e.g., <code>\"COM5\"</code>).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def open_mono_port(self, port: str) -&gt; None:\n    \"\"\"Function to open a Monochromator on a specific COM Port.\n\n    Args:\n        port: The COM port (e.g., `\"COM5\"`).\n    \"\"\"\n    handle = c_long()\n    error_code = c_long()\n    self._sdk.ARC_Open_Mono_Port(int(port[3:]), handle, error_code)\n    self._mono_enum = handle.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.open_mono_serial","title":"open_mono_serial","text":"<pre><code>open_mono_serial(serial: str) -&gt; None\n</code></pre> <p>Function to open a Monochromator with a specific serial number.</p> <p>Parameters:</p> Name Type Description Default <code>serial</code> <code>str</code> <p>The serial number of the Monochromator.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def open_mono_serial(self, serial: str) -&gt; None:\n    \"\"\"Function to open a Monochromator with a specific serial number.\n\n    Args:\n        serial: The serial number of the Monochromator.\n    \"\"\"\n    handle = c_long()\n    model = c_long()\n    error_code = c_long()\n    self._sdk.ARC_Open_Mono_Serial(int(serial), handle, model, error_code)\n    self._mono_enum = handle.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.open_readout","title":"open_readout","text":"<pre><code>open_readout(port: int) -&gt; tuple[int, int]\n</code></pre> <p>Function to open a Readout System (NCL/NCL-Lite).</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Number in the enumeration list to open.</p> required <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>The first int is the enum by which to address the first mono attached to an NCL on port 1. The second int is the enum by which to address the second mono attached to an NCL on port 2.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def open_readout(self, port: int) -&gt; tuple[int, int]:\n    \"\"\"Function to open a Readout System (NCL/NCL-Lite).\n\n    Args:\n        port: Number in the enumeration list to open.\n\n    Returns:\n        The first [int][] is the enum by which to address the first mono attached to an NCL on port 1.\n            The second [int][] is the enum by which to address the second mono attached to an NCL on port 2.\n    \"\"\"\n    handle = c_long()\n    mono1 = c_long()\n    mono2 = c_long()\n    error_code = c_long()\n    self._sdk.ARC_Open_ReadOut(port, handle, mono1, mono2, error_code)\n    self._ncl_enum = handle.value\n    return mono1.value, mono2.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.open_readout_port","title":"open_readout_port","text":"<pre><code>open_readout_port(port: str) -&gt; tuple[int, int]\n</code></pre> <p>Function to open a Readout System (NCL/NCL-Lite) on a specific COM Port.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>The COM port (e.g., <code>\"COM5\"</code>).</p> required <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>The first int is the enum by which to address the first mono attached to an NCL on port 1. The second int is the enum by which to address the second mono attached to an NCL on port 2.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def open_readout_port(self, port: str) -&gt; tuple[int, int]:\n    \"\"\"Function to open a Readout System (NCL/NCL-Lite) on a specific COM Port.\n\n    Args:\n        port: The COM port (e.g., `\"COM5\"`).\n\n    Returns:\n        The first [int][] is the enum by which to address the first mono attached to an NCL on port 1.\n            The second [int][] is the enum by which to address the second mono attached to an NCL on port 2.\n    \"\"\"\n    handle = c_long()\n    mono1 = c_long()\n    mono2 = c_long()\n    error_code = c_long()\n    self._sdk.ARC_Open_ReadOut_Port(int(port[3:]), handle, mono1, mono2, error_code)\n    self._ncl_enum = handle.value\n    return mono1.value, mono2.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.search_for_inst","title":"search_for_inst  <code>staticmethod</code>","text":"<pre><code>search_for_inst() -&gt; int\n</code></pre> <p>Search for all attached Princeton Instruments.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of Princeton Instruments found and enumerated. Enumeration list starts with zero and ends with the number found minus one.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>@staticmethod\ndef search_for_inst() -&gt; int:\n    \"\"\"Search for all attached Princeton Instruments.\n\n    Returns:\n        The number of Princeton Instruments found and enumerated.\n            Enumeration list starts with zero and ends with the *number found* minus one.\n    \"\"\"\n    if PrincetonInstruments._SDK is None:\n        msg = \"PrincetonInstrumentsError: You must first call PrincetonInstruments.init()\"\n        raise RuntimeError(msg)\n\n    num_found = c_long()\n    PrincetonInstruments._SDK.ARC_Search_For_Inst(num_found)\n    return num_found.value\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_det_bipolar","title":"set_det_bipolar","text":"<pre><code>set_det_bipolar(det_num: int) -&gt; None\n</code></pre> <p>Set the detector readout to bipolar (+/-).</p> <p>Parameters:</p> Name Type Description Default <code>det_num</code> <code>int</code> <p>The detector to be addressed.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_det_bipolar(self, det_num: int) -&gt; None:\n    \"\"\"Set the detector readout to bipolar (+/-).\n\n    Args:\n        det_num: The detector to be addressed.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Det_BiPolar(self._ncl_enum, det_num, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_det_current","title":"set_det_current","text":"<pre><code>set_det_current(det_num: int) -&gt; None\n</code></pre> <p>Set the detector readout type to Current.</p> <p>Parameters:</p> Name Type Description Default <code>det_num</code> <code>int</code> <p>The detector to be addressed.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_det_current(self, det_num: int) -&gt; None:\n    \"\"\"Set the detector readout type to Current.\n\n    Args:\n        det_num: The detector to be addressed.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Det_Current(self._ncl_enum, det_num, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_det_hv_off","title":"set_det_hv_off","text":"<pre><code>set_det_hv_off(det_num: int) -&gt; bool\n</code></pre> <p>Set the detector high voltage to off.</p> <p>Parameters:</p> Name Type Description Default <code>det_num</code> <code>int</code> <p>The detector to be addressed.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the high voltage has been turned off.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_det_hv_off(self, det_num: int) -&gt; bool:\n    \"\"\"Set the detector high voltage to off.\n\n    Args:\n        det_num: The detector to be addressed.\n\n    Returns:\n        Whether the high voltage has been turned off.\n    \"\"\"\n    error_code = c_long()\n    return bool(self._sdk.ARC_set_Det_HV_off(self._ncl_enum, det_num, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_det_hv_on","title":"set_det_hv_on","text":"<pre><code>set_det_hv_on(det_num: int) -&gt; bool\n</code></pre> <p>Set the detector high voltage to on.</p> <p>Parameters:</p> Name Type Description Default <code>det_num</code> <code>int</code> <p>The detector to be addressed.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the high voltage has been turned on.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_det_hv_on(self, det_num: int) -&gt; bool:\n    \"\"\"Set the detector high voltage to on.\n\n    Args:\n        det_num: The detector to be addressed.\n\n    Returns:\n        Whether the high voltage has been turned on.\n    \"\"\"\n    error_code = c_long()\n    return bool(self._sdk.ARC_set_Det_HV_on(self._ncl_enum, det_num, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_det_hv_volts","title":"set_det_hv_volts","text":"<pre><code>set_det_hv_volts(det_num: int, hv_volts: int) -&gt; None\n</code></pre> <p>Set the value of the high voltage.</p> <p>Parameters:</p> Name Type Description Default <code>det_num</code> <code>int</code> <p>The detector to be addressed.</p> required <code>hv_volts</code> <code>int</code> <p>The high-voltage value.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_det_hv_volts(self, det_num: int, hv_volts: int) -&gt; None:\n    \"\"\"Set the value of the high voltage.\n\n    Args:\n        det_num: The detector to be addressed.\n        hv_volts: The high-voltage value.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Det_HV_Volts(self._ncl_enum, det_num, hv_volts, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_det_num_avg_read","title":"set_det_num_avg_read","text":"<pre><code>set_det_num_avg_read(num_reads_avg: int) -&gt; None\n</code></pre> <p>Set the number of readings to average.</p> <p>Parameters:</p> Name Type Description Default <code>num_reads_avg</code> <code>int</code> <p>The number reads that will be required to acquire a single read.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_det_num_avg_read(self, num_reads_avg: int) -&gt; None:\n    \"\"\"Set the number of readings to average.\n\n    Args:\n        num_reads_avg: The number reads that will be required to acquire a single read.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Det_NumAvgRead(self._ncl_enum, num_reads_avg, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_det_photon","title":"set_det_photon","text":"<pre><code>set_det_photon(det_num: int) -&gt; None\n</code></pre> <p>Set the detector readout type to Photon Counter.</p> <p>Parameters:</p> Name Type Description Default <code>det_num</code> <code>int</code> <p>The detector to be addressed.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_det_photon(self, det_num: int) -&gt; None:\n    \"\"\"Set the detector readout type to Photon Counter.\n\n    Args:\n        det_num: The detector to be addressed.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Det_Photon(self._ncl_enum, det_num, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_det_range","title":"set_det_range","text":"<pre><code>set_det_range(det_num: int, gain_range: int) -&gt; None\n</code></pre> <p>Set the detector gain-range factor.</p> <p>Parameters:</p> Name Type Description Default <code>det_num</code> <code>int</code> <p>The detector to be addressed.</p> required <code>gain_range</code> <code>int</code> <p>The detector gain range.</p> <ul> <li><code>0</code> \u2014 1x</li> <li><code>1</code> \u2014 2x</li> <li><code>2</code> \u2014 4x</li> <li><code>3</code> \u2014 50x</li> <li><code>4</code> \u2014 200x</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_det_range(self, det_num: int, gain_range: int) -&gt; None:\n    \"\"\"Set the detector gain-range factor.\n\n    Args:\n        det_num: The detector to be addressed.\n        gain_range: The detector gain range.\n\n            * `0` &amp;mdash; 1x\n            * `1` &amp;mdash; 2x\n            * `2` &amp;mdash; 4x\n            * `3` &amp;mdash; 50x\n            * `4` &amp;mdash; 200x\n\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Det_Range(self._ncl_enum, det_num, gain_range, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_det_type","title":"set_det_type","text":"<pre><code>set_det_type(det_num: int, det_type: int) -&gt; None\n</code></pre> <p>Set the detector readout type.</p> <p>Parameters:</p> Name Type Description Default <code>det_num</code> <code>int</code> <p>The detector to be addressed.</p> required <code>det_type</code> <code>int</code> <p>The detector readout type.</p> <ul> <li><code>1</code> \u2014 Current</li> <li><code>2</code> \u2014 Voltage</li> <li><code>3</code> \u2014 Photon Counting</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_det_type(self, det_num: int, det_type: int) -&gt; None:\n    \"\"\"Set the detector readout type.\n\n    Args:\n        det_num: The detector to be addressed.\n        det_type: The detector readout type.\n\n            * `1` &amp;mdash; Current\n            * `2` &amp;mdash; Voltage\n            * `3` &amp;mdash; Photon Counting\n\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Det_Type(self._ncl_enum, det_num, det_type, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_det_unipolar","title":"set_det_unipolar","text":"<pre><code>set_det_unipolar(det_num: int) -&gt; None\n</code></pre> <p>Set the detector readout to unipolar (-).</p> <p>Parameters:</p> Name Type Description Default <code>det_num</code> <code>int</code> <p>The detector to be addressed.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_det_unipolar(self, det_num: int) -&gt; None:\n    \"\"\"Set the detector readout to unipolar (-).\n\n    Args:\n        det_num: The detector to be addressed.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Det_UniPolar(self._ncl_enum, det_num, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_det_voltage","title":"set_det_voltage","text":"<pre><code>set_det_voltage(det_num: int) -&gt; None\n</code></pre> <p>Set the detector readout type to voltage.</p> <p>Parameters:</p> Name Type Description Default <code>det_num</code> <code>int</code> <p>The detector to be addressed.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_det_voltage(self, det_num: int) -&gt; None:\n    \"\"\"Set the detector readout type to voltage.\n\n    Args:\n        det_num: The detector to be addressed.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Det_Voltage(self._ncl_enum, det_num, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_filter_position","title":"set_filter_position","text":"<pre><code>set_filter_position(position: int) -&gt; None\n</code></pre> <p>Sets the current filter position.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int</code> <p>Position the filter is to be set to.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_filter_position(self, position: int) -&gt; None:\n    \"\"\"Sets the current filter position.\n\n    Args:\n        position: Position the filter is to be set to.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Filter_Position(self._filter_enum, position, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_mono_diverter_pos","title":"set_mono_diverter_pos","text":"<pre><code>set_mono_diverter_pos(\n    diverter_num: int, diverter_pos: int\n) -&gt; None\n</code></pre> <p>Sets the port that the unit is to point to.</p> <p>Parameters:</p> Name Type Description Default <code>diverter_num</code> <code>int</code> <p>The diverter to be modified.</p> <ul> <li><code>1</code> \u2014 Motorized entrance diverter mirror.</li> <li><code>2</code> \u2014 Motorized exit diverter mirror.</li> <li><code>3</code> \u2014 Motorized entrance diverter on a double slave unit.</li> <li><code>4</code> \u2014 Motorized exit diverter on a double slave unit.</li> </ul> required <code>diverter_pos</code> <code>int</code> <p>The slit port that the diverter mirror is to be set to. Not all ports are valid for all diverter's.</p> <ul> <li><code>1</code> \u2014 Side entrance slit.</li> <li><code>2</code> \u2014 Front entrance slit.</li> <li><code>3</code> \u2014 Front exit slit.</li> <li><code>4</code> \u2014 Side exit slit.</li> <li><code>5</code> \u2014 Side entrance slit on a double slave unit.</li> <li><code>6</code> \u2014 Front entrance slit on a double slave unit.</li> <li><code>7</code> \u2014 Front exit slit on a double slave unit.</li> <li><code>8</code> \u2014 Side exit slit on a double slave unit.</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_mono_diverter_pos(self, diverter_num: int, diverter_pos: int) -&gt; None:\n    \"\"\"Sets the port that the unit is to point to.\n\n    Args:\n        diverter_num: The diverter to be modified.\n\n            * `1` &amp;mdash; Motorized entrance diverter mirror.\n            * `2` &amp;mdash; Motorized exit diverter mirror.\n            * `3` &amp;mdash; Motorized entrance diverter on a double slave unit.\n            * `4` &amp;mdash; Motorized exit diverter on a double slave unit.\n\n        diverter_pos: The slit port that the diverter mirror is to be set to. Not all ports are valid\n            for all diverter's.\n\n            * `1` &amp;mdash; Side entrance slit.\n            * `2` &amp;mdash; Front entrance slit.\n            * `3` &amp;mdash; Front exit slit.\n            * `4` &amp;mdash; Side exit slit.\n            * `5` &amp;mdash; Side entrance slit on a double slave unit.\n            * `6` &amp;mdash; Front entrance slit on a double slave unit.\n            * `7` &amp;mdash; Front exit slit on a double slave unit.\n            * `8` &amp;mdash; Side exit slit on a double slave unit.\n\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Mono_Diverter_Pos(self._mono_enum, diverter_num, diverter_pos, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_mono_filter_position","title":"set_mono_filter_position","text":"<pre><code>set_mono_filter_position(position: int) -&gt; None\n</code></pre> <p>Sets the current filter position.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int</code> <p>Position the filter is to be set to.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_mono_filter_position(self, position: int) -&gt; None:\n    \"\"\"Sets the current filter position.\n\n    Args:\n        position: Position the filter is to be set to.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Mono_Filter_Position(self._mono_enum, position, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_mono_grating","title":"set_mono_grating","text":"<pre><code>set_mono_grating(grating: int) -&gt; None\n</code></pre> <p>Sets the current grating.</p> <p>Parameters:</p> Name Type Description Default <code>grating</code> <code>int</code> <p>Set the current grating. This assumes the correct turret is inserted in the instrument and grating selected is a valid grating. This function will change to current turret in the firmware, but needs user interaction to install the correct turret.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_mono_grating(self, grating: int) -&gt; None:\n    \"\"\"Sets the current grating.\n\n    Args:\n        grating: Set the current grating. This assumes the correct turret is inserted in the\n            instrument and grating selected is a valid grating. This function will change to\n            current turret in the firmware, but needs user interaction to install the correct turret.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Mono_Grating(self._mono_enum, grating, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_mono_grating_gadjust","title":"set_mono_grating_gadjust","text":"<pre><code>set_mono_grating_gadjust(\n    grating: int, gadjust: int\n) -&gt; None\n</code></pre> <p>Sets the grating GAdjust.</p> <p>Parameters:</p> Name Type Description Default <code>grating</code> <code>int</code> <p>The number of the grating that is to be addressed.</p> required <code>gadjust</code> <code>int</code> <p>The grating GAdjust. Note, this value is specific to a specific instrument-grating combination and not transferable between instruments.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_mono_grating_gadjust(self, grating: int, gadjust: int) -&gt; None:\n    \"\"\"Sets the grating GAdjust.\n\n    Args:\n        grating: The number of the grating that is to be addressed.\n        gadjust: The grating GAdjust. Note, this value is specific to a specific\n            instrument-grating combination and not transferable between instruments.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Mono_Grating_Gadjust(self._mono_enum, grating, gadjust, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_mono_grating_offset","title":"set_mono_grating_offset","text":"<pre><code>set_mono_grating_offset(grating: int, offset: int) -&gt; None\n</code></pre> <p>Sets the grating offset.</p> <p>Parameters:</p> Name Type Description Default <code>grating</code> <code>int</code> <p>The number of the grating that is to be addressed.</p> required <code>offset</code> <code>int</code> <p>The grating offset. Note, this value is specific to a specific instrument-grating combination and not transferable between instruments.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_mono_grating_offset(self, grating: int, offset: int) -&gt; None:\n    \"\"\"Sets the grating offset.\n\n    Args:\n        grating: The number of the grating that is to be addressed.\n        offset: The grating offset. Note, this value is specific to a specific\n            instrument-grating combination and not transferable between instruments.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Mono_Grating_Offset(self._mono_enum, grating, offset, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_mono_init_grating","title":"set_mono_init_grating","text":"<pre><code>set_mono_init_grating(init_grating: int) -&gt; None\n</code></pre> <p>Sets the initial grating (on instrument reboot).</p> <p>Parameters:</p> Name Type Description Default <code>init_grating</code> <code>int</code> <p>The power-up grating number.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_mono_init_grating(self, init_grating: int) -&gt; None:\n    \"\"\"Sets the initial grating (on instrument reboot).\n\n    Args:\n        init_grating: The power-up grating number.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Mono_Init_Grating(self._mono_enum, init_grating, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_mono_init_scan_rate_nm","title":"set_mono_init_scan_rate_nm","text":"<pre><code>set_mono_init_scan_rate_nm(init_scan_rate: float) -&gt; None\n</code></pre> <p>Sets the initial wavelength scan rate (on instrument reboot).</p> <p>Parameters:</p> Name Type Description Default <code>init_scan_rate</code> <code>float</code> <p>The power-up scan rate in nm / minute.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_mono_init_scan_rate_nm(self, init_scan_rate: float) -&gt; None:\n    \"\"\"Sets the initial wavelength scan rate (on instrument reboot).\n\n    Args:\n        init_scan_rate: The power-up scan rate in nm / minute.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Mono_Init_ScanRate_nm(self._mono_enum, init_scan_rate, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_mono_init_wave_nm","title":"set_mono_init_wave_nm","text":"<pre><code>set_mono_init_wave_nm(init_wave: float) -&gt; None\n</code></pre> <p>Sets the initial wavelength (on instrument reboot).</p> <p>Parameters:</p> Name Type Description Default <code>init_wave</code> <code>float</code> <p>The power-up wavelength in nm.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_mono_init_wave_nm(self, init_wave: float) -&gt; None:\n    \"\"\"Sets the initial wavelength (on instrument reboot).\n\n    Args:\n        init_wave: The power-up wavelength in nm.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Mono_Init_Wave_nm(self._mono_enum, init_wave, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_mono_int_led","title":"set_mono_int_led","text":"<pre><code>set_mono_int_led(*, enable: bool) -&gt; None\n</code></pre> <p>Turns on and off the interrupter LED.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>Indicates whether the LED should be on or off.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_mono_int_led(self, *, enable: bool) -&gt; None:\n    \"\"\"Turns on and off the interrupter LED.\n\n    Args:\n        enable: Indicates whether the LED should be on or off.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Mono_Int_Led(self._mono_enum, bool(enable), error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_mono_scan_rate_nm_min","title":"set_mono_scan_rate_nm_min","text":"<pre><code>set_mono_scan_rate_nm_min(scan_rate: float) -&gt; None\n</code></pre> <p>Set the wavelength scan rate.</p> <p>Parameters:</p> Name Type Description Default <code>scan_rate</code> <code>float</code> <p>The rate to scan the wavelength in nm/minute.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_mono_scan_rate_nm_min(self, scan_rate: float) -&gt; None:\n    \"\"\"Set the wavelength scan rate.\n\n    Args:\n        scan_rate: The rate to scan the wavelength in nm/minute.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Mono_Scan_Rate_nm_min(self._mono_enum, scan_rate, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_mono_shutter_closed","title":"set_mono_shutter_closed","text":"<pre><code>set_mono_shutter_closed() -&gt; bool\n</code></pre> <p>Sets the integrated shutter position to closed.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the shutter has been closed.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_mono_shutter_closed(self) -&gt; bool:\n    \"\"\"Sets the integrated shutter position to closed.\n\n    Returns:\n        Whether the shutter has been closed.\n    \"\"\"\n    error_code = c_long()\n    return bool(self._sdk.ARC_set_Mono_Shutter_Closed(self._mono_enum, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_mono_shutter_open","title":"set_mono_shutter_open","text":"<pre><code>set_mono_shutter_open() -&gt; bool\n</code></pre> <p>Sets the integrated shutter position to open.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the shutter has been opened.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_mono_shutter_open(self) -&gt; bool:\n    \"\"\"Sets the integrated shutter position to open.\n\n    Returns:\n        Whether the shutter has been opened.\n    \"\"\"\n    error_code = c_long()\n    return bool(self._sdk.ARC_set_Mono_Shutter_Open(self._mono_enum, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_mono_slit_width","title":"set_mono_slit_width","text":"<pre><code>set_mono_slit_width(slit_pos: int, slit_width: int) -&gt; None\n</code></pre> <p>Sets the slit width of a motorized slit (Types 4, 6 and 9).</p> <p>Parameters:</p> Name Type Description Default <code>slit_pos</code> <code>int</code> <p>The slit to be addressed.</p> <ul> <li><code>1</code> \u2014 Side entrance slit.</li> <li><code>2</code> \u2014 Front entrance slit.</li> <li><code>3</code> \u2014 Front exit slit.</li> <li><code>4</code> \u2014 Side exit slit.</li> <li><code>5</code> \u2014 Side entrance slit on a double slave unit.</li> <li><code>6</code> \u2014 Front entrance slit on a double slave unit.</li> <li><code>7</code> \u2014 Front exit slit on a double slave unit.</li> <li><code>8</code> \u2014 Side exit slit on a double slave unit.</li> </ul> required <code>slit_width</code> <code>int</code> <p>The width to which the slit is to be set to. Note valid ranges are 10 to 3000 microns in one-micron increments for normal continuous motor slits (type 4 and 9), 10 to 12000 microns in five-micron increments for large continuous motor slits (type 4) and 25, 50, 100, 250, 500, 1000 microns for indexable slits (Type 6).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_mono_slit_width(self, slit_pos: int, slit_width: int) -&gt; None:\n    \"\"\"Sets the slit width of a motorized slit (Types 4, 6 and 9).\n\n    Args:\n        slit_pos: The slit to be addressed.\n\n            * `1` &amp;mdash; Side entrance slit.\n            * `2` &amp;mdash; Front entrance slit.\n            * `3` &amp;mdash; Front exit slit.\n            * `4` &amp;mdash; Side exit slit.\n            * `5` &amp;mdash; Side entrance slit on a double slave unit.\n            * `6` &amp;mdash; Front entrance slit on a double slave unit.\n            * `7` &amp;mdash; Front exit slit on a double slave unit.\n            * `8` &amp;mdash; Side exit slit on a double slave unit.\n\n        slit_width: The width to which the slit is to be set to. Note valid ranges are\n            10 to 3000 microns in one-micron increments for normal continuous\n            motor slits (type 4 and 9), 10 to 12000 microns in five-micron\n            increments for large continuous motor slits (type 4) and\n            25, 50, 100, 250, 500, 1000 microns for indexable slits (Type 6).\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Mono_Slit_Width(self._mono_enum, slit_pos, slit_width, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_mono_turret","title":"set_mono_turret","text":"<pre><code>set_mono_turret(turret: int) -&gt; None\n</code></pre> <p>Sets the current grating turret.</p> <p>Parameters:</p> Name Type Description Default <code>turret</code> <code>int</code> <p>Set the current turret. This will change the grating to Turret number minus one times gratings per turret plus the one plus the current grating number minus one mod gratings per turret. The user must insert the correct turret into the instrument when using this function.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_mono_turret(self, turret: int) -&gt; None:\n    \"\"\"Sets the current grating turret.\n\n    Args:\n        turret: Set the current turret. This will change the grating to Turret number\n            minus one times gratings per turret plus the one plus the current grating\n            number minus one mod gratings per turret. The user must insert the correct\n            turret into the instrument when using this function.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Mono_Turret(self._mono_enum, turret, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_mono_wavelength_abs_cm","title":"set_mono_wavelength_abs_cm","text":"<pre><code>set_mono_wavelength_abs_cm(wavelength: float) -&gt; None\n</code></pre> <p>Sets the center wavelength of the instrument in absolute wavenumber's.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float</code> <p>The wavelength in absolute wavenumber that the instrument is to be moved to.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_mono_wavelength_abs_cm(self, wavelength: float) -&gt; None:\n    \"\"\"Sets the center wavelength of the instrument in absolute wavenumber's.\n\n    Args:\n        wavelength: The wavelength in absolute wavenumber that the instrument is to be moved to.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Mono_Wavelength_absCM(self._mono_enum, wavelength, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_mono_wavelength_ang","title":"set_mono_wavelength_ang","text":"<pre><code>set_mono_wavelength_ang(wavelength: float) -&gt; None\n</code></pre> <p>Sets the center wavelength of the instrument in angstroms.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float</code> <p>The wavelength in Angstroms that the instrument is to be moved to.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_mono_wavelength_ang(self, wavelength: float) -&gt; None:\n    \"\"\"Sets the center wavelength of the instrument in angstroms.\n\n    Args:\n        wavelength: The wavelength in Angstroms that the instrument is to be moved to.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Mono_Wavelength_ang(self._mono_enum, wavelength, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_mono_wavelength_ev","title":"set_mono_wavelength_ev","text":"<pre><code>set_mono_wavelength_ev(wavelength: float) -&gt; None\n</code></pre> <p>Sets the center wavelength of the instrument in Electron Volts.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float</code> <p>The wavelength in Electron Volts that the instrument is to be moved to.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_mono_wavelength_ev(self, wavelength: float) -&gt; None:\n    \"\"\"Sets the center wavelength of the instrument in Electron Volts.\n\n    Args:\n        wavelength: The wavelength in Electron Volts that the instrument is to be moved to.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Mono_Wavelength_eV(self._mono_enum, wavelength, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_mono_wavelength_micron","title":"set_mono_wavelength_micron","text":"<pre><code>set_mono_wavelength_micron(wavelength: float) -&gt; None\n</code></pre> <p>Sets the center wavelength of the instrument in microns.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float</code> <p>The wavelength in microns that the instrument is to be moved to.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_mono_wavelength_micron(self, wavelength: float) -&gt; None:\n    \"\"\"Sets the center wavelength of the instrument in microns.\n\n    Args:\n        wavelength: The wavelength in microns that the instrument is to be moved to.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Mono_Wavelength_micron(self._mono_enum, wavelength, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_mono_wavelength_nm","title":"set_mono_wavelength_nm","text":"<pre><code>set_mono_wavelength_nm(wavelength: float) -&gt; None\n</code></pre> <p>Sets the center wavelength of the instrument in nm.</p> <p>Parameters:</p> Name Type Description Default <code>wavelength</code> <code>float</code> <p>The wavelength in nm that the instrument is to be moved to.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_mono_wavelength_nm(self, wavelength: float) -&gt; None:\n    \"\"\"Sets the center wavelength of the instrument in nm.\n\n    Args:\n        wavelength: The wavelength in nm that the instrument is to be moved to.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Mono_Wavelength_nm(self._mono_enum, wavelength, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_mono_wavelength_rel_cm","title":"set_mono_wavelength_rel_cm","text":"<pre><code>set_mono_wavelength_rel_cm(\n    center_nm: float, wavelength: float\n) -&gt; None\n</code></pre> <p>Sets the center wavelength of the instrument in relative wavenumber's.</p> <p>Parameters:</p> Name Type Description Default <code>center_nm</code> <code>float</code> <p>The wavelength in nanometres that 0 relative Wavenumber is centred around.</p> required <code>wavelength</code> <code>float</code> <p>The wavelength in relative Wavenumber that the instrument is to be moved to.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_mono_wavelength_rel_cm(self, center_nm: float, wavelength: float) -&gt; None:\n    \"\"\"Sets the center wavelength of the instrument in relative wavenumber's.\n\n    Args:\n        center_nm: The wavelength in nanometres that 0 relative Wavenumber is centred around.\n        wavelength: The wavelength in relative Wavenumber that the instrument is to be moved to.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_Mono_Wavelength_relCM(self._mono_enum, center_nm, wavelength, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_ncl_filter_position","title":"set_ncl_filter_position","text":"<pre><code>set_ncl_filter_position(position: int) -&gt; None\n</code></pre> <p>Set the current filter position.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int</code> <p>The current filter position.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_ncl_filter_position(self, position: int) -&gt; None:\n    \"\"\"Set the current filter position.\n\n    Args:\n        position: The current filter position.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_NCL_Filter_Position(self._ncl_enum, position, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_ncl_filter_present","title":"set_ncl_filter_present","text":"<pre><code>set_ncl_filter_present(\n    min_filter: int, max_filter: int\n) -&gt; None\n</code></pre> <p>Set the instrument filter wheel to active (NCL only).</p> <p>Parameters:</p> Name Type Description Default <code>min_filter</code> <code>int</code> <p>Minimum filter position (on an NCL with the standard filter wheel 1).</p> required <code>max_filter</code> <code>int</code> <p>Maximum filter position (on an NCL with the standard filter wheel 6).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_ncl_filter_present(self, min_filter: int, max_filter: int) -&gt; None:\n    \"\"\"Set the instrument filter wheel to active (NCL only).\n\n    Args:\n        min_filter: Minimum filter position (on an NCL with the standard filter wheel 1).\n        max_filter: Maximum filter position (on an NCL with the standard filter wheel 6).\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_NCL_Filter_Present(self._ncl_enum, min_filter, max_filter, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_ncl_shutter_closed","title":"set_ncl_shutter_closed","text":"<pre><code>set_ncl_shutter_closed(shutter_num: int) -&gt; None\n</code></pre> <p>Set a NCL Readout shutter to a closed state.</p> <p>Parameters:</p> Name Type Description Default <code>shutter_num</code> <code>int</code> <p>The shutter being addressed (1 or 2 on an NCL).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_ncl_shutter_closed(self, shutter_num: int) -&gt; None:\n    \"\"\"Set a NCL Readout shutter to a closed state.\n\n    Args:\n        shutter_num: The shutter being addressed (1 or 2 on an NCL).\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_NCL_Shutter_Closed(self._ncl_enum, shutter_num, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_ncl_shutter_open","title":"set_ncl_shutter_open","text":"<pre><code>set_ncl_shutter_open(shutter_num: int) -&gt; None\n</code></pre> <p>Set a NCL Readout shutter to a closed state.</p> <p>Parameters:</p> Name Type Description Default <code>shutter_num</code> <code>int</code> <p>The shutter being addressed (1 or 2 on an NCL).</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_ncl_shutter_open(self, shutter_num: int) -&gt; None:\n    \"\"\"Set a NCL Readout shutter to a closed state.\n\n    Args:\n        shutter_num: The shutter being addressed (1 or 2 on an NCL).\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_NCL_Shutter_Open(self._ncl_enum, shutter_num, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_ncl_ttl_out_off","title":"set_ncl_ttl_out_off","text":"<pre><code>set_ncl_ttl_out_off(ttl_line: int) -&gt; None\n</code></pre> <p>Turn a TTL line off.</p> <p>Parameters:</p> Name Type Description Default <code>ttl_line</code> <code>int</code> <p>The TTL line number being addressed.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_ncl_ttl_out_off(self, ttl_line: int) -&gt; None:\n    \"\"\"Turn a TTL line off.\n\n    Args:\n        ttl_line: The TTL line number being addressed.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_NCL_TTL_Out_Off(self._ncl_enum, ttl_line, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_ncl_ttl_out_on","title":"set_ncl_ttl_out_on","text":"<pre><code>set_ncl_ttl_out_on(ttl_line: int) -&gt; None\n</code></pre> <p>Turn a TTL line on.</p> <p>Parameters:</p> Name Type Description Default <code>ttl_line</code> <code>int</code> <p>The TTL line number being addressed.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_ncl_ttl_out_on(self, ttl_line: int) -&gt; None:\n    \"\"\"Turn a TTL line on.\n\n    Args:\n        ttl_line: The TTL line number being addressed.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_NCL_TTL_Out_On(self._ncl_enum, ttl_line, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.set_readout_itime_ms","title":"set_readout_itime_ms","text":"<pre><code>set_readout_itime_ms(itime_ms: int) -&gt; None\n</code></pre> <p>Set the integration time used for taking a reading.</p> <p>Parameters:</p> Name Type Description Default <code>itime_ms</code> <code>int</code> <p>The integration time in milliseconds to be used when reading out a detector.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def set_readout_itime_ms(self, itime_ms: int) -&gt; None:\n    \"\"\"Set the integration time used for taking a reading.\n\n    Args:\n        itime_ms: The integration time in milliseconds to be used when reading out a detector.\n    \"\"\"\n    error_code = c_long()\n    self._sdk.ARC_set_ReadOut_ITime_ms(self._ncl_enum, itime_ms, error_code)\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.valid_det_num","title":"valid_det_num","text":"<pre><code>valid_det_num(det_num: int) -&gt; bool\n</code></pre> <p>Check if the detector number is valid on the Readout System.</p> <p>Parameters:</p> Name Type Description Default <code>det_num</code> <code>int</code> <p>The detector number to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the detector number is valid on the Readout System.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>def valid_det_num(self, det_num: int) -&gt; bool:\n    \"\"\"Check if the detector number is valid on the Readout System.\n\n    Args:\n        det_num: The detector number to check.\n\n    Returns:\n        Whether the detector number is valid on the Readout System.\n    \"\"\"\n    error_code = c_long()\n    return bool(self._sdk.ARC_Valid_Det_Num(self._ncl_enum, det_num, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.valid_enum","title":"valid_enum  <code>staticmethod</code>","text":"<pre><code>valid_enum(enum: int) -&gt; bool\n</code></pre> <p>Check if an enumeration (handle) is valid and the instrument is open.</p> <p>Parameters:</p> Name Type Description Default <code>enum</code> <code>int</code> <p>The enumeration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the enumeration is valid and the instrument is open.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>@staticmethod\ndef valid_enum(enum: int) -&gt; bool:\n    \"\"\"Check if an enumeration (handle) is valid and the instrument is open.\n\n    Args:\n        enum: The enumeration to check.\n\n    Returns:\n        Whether the enumeration is valid and the instrument is open.\n    \"\"\"\n    if PrincetonInstruments._SDK is None:\n        msg = \"PrincetonInstrumentsError: You must first call PrincetonInstruments.init()\"\n        raise RuntimeError(msg)\n\n    error_code = c_long()\n    return bool(PrincetonInstruments._SDK.ARC_Valid_Enum(enum, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.valid_filter_enum","title":"valid_filter_enum  <code>staticmethod</code>","text":"<pre><code>valid_filter_enum(filter_enum: int) -&gt; bool\n</code></pre> <p>Check if a filter wheel enumeration (handle) is valid and the instrument is open.</p> <p>Parameters:</p> Name Type Description Default <code>filter_enum</code> <code>int</code> <p>The enumeration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the enumeration is valid and the instrument is open.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>@staticmethod\ndef valid_filter_enum(filter_enum: int) -&gt; bool:\n    \"\"\"Check if a filter wheel enumeration (handle) is valid and the instrument is open.\n\n    Args:\n        filter_enum: The enumeration to check.\n\n    Returns:\n        Whether the enumeration is valid and the instrument is open.\n    \"\"\"\n    if PrincetonInstruments._SDK is None:\n        msg = \"PrincetonInstrumentsError: You must first call PrincetonInstruments.init()\"\n        raise RuntimeError(msg)\n\n    error_code = c_long()\n    return bool(PrincetonInstruments._SDK.ARC_Valid_Filter_Enum(filter_enum, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.valid_mono_enum","title":"valid_mono_enum  <code>staticmethod</code>","text":"<pre><code>valid_mono_enum(mono_enum: int) -&gt; bool\n</code></pre> <p>Check if a monochromator enumeration (handle) is valid and the instrument is open.</p> <p>All functions call this function to verify that the requested action is valid.</p> <p>Parameters:</p> Name Type Description Default <code>mono_enum</code> <code>int</code> <p>The enumeration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the enumeration is valid and the instrument is open.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>@staticmethod\ndef valid_mono_enum(mono_enum: int) -&gt; bool:\n    \"\"\"Check if a monochromator enumeration (handle) is valid and the instrument is open.\n\n    All functions call this function to verify that the requested action is valid.\n\n    Args:\n        mono_enum: The enumeration to check.\n\n    Returns:\n        Whether the enumeration is valid and the instrument is open.\n    \"\"\"\n    if PrincetonInstruments._SDK is None:\n        msg = \"PrincetonInstrumentsError: You must first call PrincetonInstruments.init()\"\n        raise RuntimeError(msg)\n\n    error_code = c_long()\n    return bool(PrincetonInstruments._SDK.ARC_Valid_Mono_Enum(mono_enum, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.valid_readout_enum","title":"valid_readout_enum  <code>staticmethod</code>","text":"<pre><code>valid_readout_enum(readout_enum: int) -&gt; bool\n</code></pre> <p>Check if a Readout System (NCL/NCL-Lite) enumeration (handle) is valid and the instrument is open.</p> <p>Args: readout_enum: The enumeration to check.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the enumeration is valid and the instrument is open.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>@staticmethod\ndef valid_readout_enum(readout_enum: int) -&gt; bool:\n    \"\"\"Check if a Readout System (NCL/NCL-Lite) enumeration (handle) is valid and the instrument is open.\n\n    Args:\n    readout_enum: The enumeration to check.\n\n    Returns:\n        Whether the enumeration is valid and the instrument is open.\n    \"\"\"\n    if PrincetonInstruments._SDK is None:\n        msg = \"PrincetonInstrumentsError: You must first call PrincetonInstruments.init()\"\n        raise RuntimeError(msg)\n\n    error_code = c_long()\n    return bool(PrincetonInstruments._SDK.ARC_Valid_ReadOut_Enum(readout_enum, error_code))\n</code></pre>"},{"location":"resources/princeton_instruments/arc_instrument/#msl.equipment_resources.princeton_instruments.arc_instrument.PrincetonInstruments.ver","title":"ver  <code>staticmethod</code>","text":"<pre><code>ver() -&gt; tuple[int, int, int]\n</code></pre> <p>Get the DLL version number.</p> <p>It is the only function that can be called at any time.</p> <p>Returns:</p> Type Description <code>tuple[int, int, int]</code> <p>The <code>(major, minor, build)</code> version number.</p> Source code in <code>packages/resources/src/msl/equipment_resources/princeton_instruments/arc_instrument.py</code> <pre><code>@staticmethod\ndef ver() -&gt; tuple[int, int, int]:\n    \"\"\"Get the DLL version number.\n\n    It is the only function that can be called at any time.\n\n    Returns:\n        The `(major, minor, build)` version number.\n    \"\"\"\n    if PrincetonInstruments._SDK is None:\n        msg = \"PrincetonInstrumentsError: You must first call PrincetonInstruments.init()\"\n        raise RuntimeError(msg)\n\n    major = c_long()\n    minor = c_long()\n    build = c_long()\n    if not PrincetonInstruments._SDK.ARC_Ver(major, minor, build):\n        msg = \"PrincetonInstrumentsError: Cannot get the DLL version number\"\n        raise RuntimeError(msg)\n\n    return major.value, minor.value, build.value\n</code></pre>"},{"location":"resources/raicol/tec/","title":"TEC Oven","text":"<p>Control a TEC (Peltier-based) oven from Raicol Crystals.</p>"},{"location":"resources/raicol/tec/#msl.equipment_resources.raicol.tec.RaicolTEC","title":"RaicolTEC","text":"<pre><code>RaicolTEC(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Serial</code></p> <p>Control a TEC (Peltier-based) oven from Raicol Crystals.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/raicol/tec.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Control a TEC (Peltier-based) oven from Raicol Crystals.\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"\n    super().__init__(equipment)\n    self.write_termination: bytes = b\"\\n\"\n</code></pre>"},{"location":"resources/raicol/tec/#msl.equipment_resources.raicol.tec.RaicolTEC.get_setpoint","title":"get_setpoint","text":"<pre><code>get_setpoint() -&gt; float\n</code></pre> <p>Get the setpoint temperature.</p> <p>Returns:</p> Type Description <code>float</code> <p>The setpoint temperature, in Celsius.</p> Source code in <code>packages/resources/src/msl/equipment_resources/raicol/tec.py</code> <pre><code>def get_setpoint(self) -&gt; float:\n    \"\"\"Get the setpoint temperature.\n\n    Returns:\n        The setpoint temperature, in Celsius.\n    \"\"\"\n    return float(self.query(\"Get_T_Set\", size=6)[2:])\n</code></pre>"},{"location":"resources/raicol/tec/#msl.equipment_resources.raicol.tec.RaicolTEC.off","title":"off","text":"<pre><code>off() -&gt; None\n</code></pre> <p>Turn the TEC off.</p> Source code in <code>packages/resources/src/msl/equipment_resources/raicol/tec.py</code> <pre><code>def off(self) -&gt; None:\n    \"\"\"Turn the TEC off.\"\"\"\n    reply = self.query(\"OFF\", size=4)\n    if reply != \"ofOK\":\n        msg = \"Cannot turn the TEC off\"\n        raise MSLConnectionError(self, msg)\n</code></pre>"},{"location":"resources/raicol/tec/#msl.equipment_resources.raicol.tec.RaicolTEC.on","title":"on","text":"<pre><code>on() -&gt; None\n</code></pre> <p>Turn the TEC on.</p> Source code in <code>packages/resources/src/msl/equipment_resources/raicol/tec.py</code> <pre><code>def on(self) -&gt; None:\n    \"\"\"Turn the TEC on.\"\"\"\n    reply = self.query(\"ON\", size=4)\n    if reply != \"onOK\":\n        msg = \"Cannot turn the TEC on\"\n        raise MSLConnectionError(self, msg)\n</code></pre>"},{"location":"resources/raicol/tec/#msl.equipment_resources.raicol.tec.RaicolTEC.set_setpoint","title":"set_setpoint","text":"<pre><code>set_setpoint(temperature: float) -&gt; None\n</code></pre> <p>Set the setpoint temperature.</p> <p>Parameters:</p> Name Type Description Default <code>temperature</code> <code>float</code> <p>The setpoint temperature, in Celsius. Must be in the range [20.1, 60.0].</p> required Source code in <code>packages/resources/src/msl/equipment_resources/raicol/tec.py</code> <pre><code>def set_setpoint(self, temperature: float) -&gt; None:\n    \"\"\"Set the setpoint temperature.\n\n    Args:\n        temperature: The setpoint temperature, in Celsius. Must be in the range [20.1, 60.0].\n    \"\"\"\n    t = round(temperature, 1)\n    if t &lt; 20.1 or t &gt; 60.0:  # noqa: PLR2004\n        msg = f\"The setpoint temperature must be between 20.1 and 60.0, got {t}\"\n        raise ValueError(msg)\n\n    reply = self.query(f\"Set_T{t:.1f}\", size=4, delay=0.05)\n    if reply != \"stOK\":\n        msg = \"Cannot change the setpoint temperature\"\n        raise MSLConnectionError(self, msg)\n</code></pre>"},{"location":"resources/raicol/tec/#msl.equipment_resources.raicol.tec.RaicolTEC.temperature","title":"temperature","text":"<pre><code>temperature() -&gt; float\n</code></pre> <p>Returns the current temperature of the oven.</p> <p>The temperature is measured by a PT1000 sensor that is located near the crystal in the metallic mount.</p> <p>Returns:</p> Type Description <code>float</code> <p>The temperature of the oven, in Celsius.</p> Source code in <code>packages/resources/src/msl/equipment_resources/raicol/tec.py</code> <pre><code>def temperature(self) -&gt; float:\n    \"\"\"Returns the current temperature of the oven.\n\n    The temperature is measured by a PT1000 sensor that is located near the crystal in the metallic mount.\n\n    Returns:\n        The temperature of the oven, in Celsius.\n    \"\"\"\n    return float(self.query(\"Data_T\", size=7)[2:])\n</code></pre>"},{"location":"resources/thorlabs/fwxx2c/","title":"FW102C/FW212C","text":"<p>Communicate with a FW102C/FW212C Motorized Filter Wheel from Thorlabs.</p>"},{"location":"resources/thorlabs/fwxx2c/#msl.equipment_resources.thorlabs.fwxx2c.FWxx2C","title":"FWxx2C","text":"<pre><code>FWxx2C(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Serial</code></p> <p>Communicate with a FW102C/FW212C Motorized Filter Wheel from Thorlabs.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/thorlabs/fwxx2c.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Communicate with a FW102C/FW212C Motorized Filter Wheel from Thorlabs.\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"\n    assert equipment.connection is not None  # noqa: S101\n    equipment.connection.properties.setdefault(\"baud_rate\", 115200)\n    equipment.connection.properties.setdefault(\"termination\", b\"\\r\")\n    super().__init__(equipment)\n\n    # The communication protocol is designed for a terminal interface\n    # (the command that was written is echoed back). We always need to\n    # do an extra read(), so we use query() where a write() would seem\n    # appropriate and do another read() to get the requested value.\n    _ = self.query(\"pcount?\")\n    self._pcount: int = int(self.read())\n</code></pre>"},{"location":"resources/thorlabs/fwxx2c/#msl.equipment_resources.thorlabs.fwxx2c.FWxx2C.fast_mode","title":"fast_mode  <code>property</code> <code>writable</code>","text":"<pre><code>fast_mode: bool\n</code></pre> <p>Whether the filter wheel speed mode is fast or slow.</p>"},{"location":"resources/thorlabs/fwxx2c/#msl.equipment_resources.thorlabs.fwxx2c.FWxx2C.firmware","title":"firmware  <code>property</code>","text":"<pre><code>firmware: str\n</code></pre> <p>Returns the version number of the firmware.</p>"},{"location":"resources/thorlabs/fwxx2c/#msl.equipment_resources.thorlabs.fwxx2c.FWxx2C.output_mode","title":"output_mode  <code>property</code> <code>writable</code>","text":"<pre><code>output_mode: bool\n</code></pre> <p>Whether the filter wheel trigger mode is an output or input.</p> <p>In output mode, the filter wheel generates an active-high pulse when the position changes. In input mode, the filter wheel responds to an active-low pulse by advancing the position by 1.</p>"},{"location":"resources/thorlabs/fwxx2c/#msl.equipment_resources.thorlabs.fwxx2c.FWxx2C.position","title":"position  <code>property</code> <code>writable</code>","text":"<pre><code>position: int\n</code></pre> <p>Get/Set the filter wheel position.</p>"},{"location":"resources/thorlabs/fwxx2c/#msl.equipment_resources.thorlabs.fwxx2c.FWxx2C.position_count","title":"position_count  <code>property</code>","text":"<pre><code>position_count: int\n</code></pre> <p>Returns the number of positions that the filter wheel supports.</p>"},{"location":"resources/thorlabs/fwxx2c/#msl.equipment_resources.thorlabs.fwxx2c.FWxx2C.sensor_mode","title":"sensor_mode  <code>property</code> <code>writable</code>","text":"<pre><code>sensor_mode: bool\n</code></pre> <p>Whether the filter wheel sensor mode is on or off.</p> <p>If <code>True</code>, sensors remain on; otherwise sensors turn off when the filter wheel is idle to eliminate stray light.</p>"},{"location":"resources/thorlabs/fwxx2c/#msl.equipment_resources.thorlabs.fwxx2c.FWxx2C.save","title":"save","text":"<pre><code>save() -&gt; None\n</code></pre> <p>Save the current settings as default on power up.</p> Source code in <code>packages/resources/src/msl/equipment_resources/thorlabs/fwxx2c.py</code> <pre><code>def save(self) -&gt; None:\n    \"\"\"Save the current settings as default on power up.\"\"\"\n    _ = self.query(\"save\")\n</code></pre>"},{"location":"resources/vaisala/ptb330/","title":"PTB330","text":"<p>Vaisala PTB330 Barometer.</p> <p>The PTB330 barometer is available with one, two, or three barometer modules.</p>"},{"location":"resources/vaisala/ptb330/#msl.equipment_resources.vaisala.ptb330.PTB330","title":"PTB330","text":"<pre><code>PTB330(equipment: Equipment)\n</code></pre> <p>               Bases: <code>PTU300</code></p> <p>Vaisala PTB330 Barometer.</p> <p>The device manual is available here.</p> <p>The default settings for the RS232 connection are:</p> <ul> <li>Baud rate: 4800</li> <li>Data bits: 7</li> <li>Parity: EVEN</li> </ul> <p>Warning</p> <p>Ensure the device is in <code>STOP</code> or <code>SEND</code> mode before initiating communication.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/vaisala/ptb330.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Vaisala PTB330 Barometer.\n\n    The device manual is available [here](https://docs.vaisala.com/r/M210855EN-E/en-US){:target=\"_blank\"}.\n\n    The default settings for the RS232 connection are:\n\n    * Baud rate: 4800\n    * Data bits: 7\n    * Parity: EVEN\n\n    !!! warning\n        Ensure the device is in `STOP` or `SEND` mode before initiating communication.\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"\n    super().__init__(equipment)\n</code></pre>"},{"location":"resources/vaisala/ptb330/#msl.equipment_resources.vaisala.ptb330.PTB330.device_info","title":"device_info  <code>property</code>","text":"<pre><code>device_info: dict[str, str]\n</code></pre> <p>Returns a dictionary of information about the Vaisala device.</p>"},{"location":"resources/vaisala/ptb330/#msl.equipment_resources.vaisala.ptb330.PTB330.units","title":"units  <code>property</code>","text":"<pre><code>units: dict[str, str]\n</code></pre> <p>A dictionary of measured quantities and their associated units.</p> <p>The units are set by set_units.</p>"},{"location":"resources/vaisala/ptb330/#msl.equipment_resources.vaisala.ptb330.PTB330.check_for_errors","title":"check_for_errors","text":"<pre><code>check_for_errors() -&gt; None\n</code></pre> <p>Raise an error, if present.</p> Source code in <code>packages/resources/src/msl/equipment_resources/vaisala/ptu300.py</code> <pre><code>def check_for_errors(self) -&gt; None:\n    \"\"\"Raise an error, if present.\"\"\"\n    err = self.query(\"ERRS\")  # List present transmitter errors\n    # a PASS or FAIL line is returned from PTB330 modules first\n    if err in {\"PASS\", \"FAIL\"}:\n        err = self.read()\n    if err and err != \"No errors\":\n        raise MSLConnectionError(self, err)\n</code></pre>"},{"location":"resources/vaisala/ptb330/#msl.equipment_resources.vaisala.ptb330.PTB330.get_format","title":"get_format","text":"<pre><code>get_format() -&gt; str\n</code></pre> <p>Get the currently active formatter string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The formatter string.</p> Source code in <code>packages/resources/src/msl/equipment_resources/vaisala/ptu300.py</code> <pre><code>def get_format(self) -&gt; str:\n    \"\"\"Get the currently active formatter string.\n\n    Returns:\n        The formatter string.\n    \"\"\"\n    # The hash symbol \"#\" is used to set the format, but then appears as a backslash \"\\\\\" on the device.\n    return self.query(\"FORM ?\")[len(\"Output format  :\") :].replace(\"\\\\\", \"#\")\n</code></pre>"},{"location":"resources/vaisala/ptb330/#msl.equipment_resources.vaisala.ptb330.PTB330.get_reading_str","title":"get_reading_str","text":"<pre><code>get_reading_str() -&gt; str\n</code></pre> <p>Output the reading once.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string that follows the format set by set_format.</p> Source code in <code>packages/resources/src/msl/equipment_resources/vaisala/ptu300.py</code> <pre><code>def get_reading_str(self) -&gt; str:\n    \"\"\"Output the reading once.\n\n    Returns:\n        A string that follows the format set by\n            [set_format][msl.equipment_resources.vaisala.ptu300.PTU300.set_format].\n    \"\"\"\n    return self.query(\"SEND\")\n</code></pre>"},{"location":"resources/vaisala/ptb330/#msl.equipment_resources.vaisala.ptb330.PTB330.set_format","title":"set_format","text":"<pre><code>set_format(fmt: str) -&gt; None\n</code></pre> <p>Set the format of data output to follow the pattern in the format string.</p> <p>For example, in the format string <code>4.3 P \" \" 3.3 T \" \" 3.3 RH \" \" SN \" \" #r #n</code>, <code>x.y</code> is the number of digits and decimal places of the values; <code>P</code>, <code>T</code>, <code>RH</code>, and <code>SN</code> are placeholders for pressure, temperature, relative humidity, and serial number values; and <code>\" \"</code>, <code>#r</code>, and <code>#n</code> represent a string constant, carriage-return, and line-feed respectively. Additional allowed modifiers include <code>ERR</code> for error flags, <code>U5</code> for unit field and (optional) length, <code>TIME</code> for time as [hh:mm:ss], and <code>DATE</code> for date as [yyyy-mm-dd]. For more options, refer to the manual.</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>str</code> <p>String representing desired output format.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/vaisala/ptu300.py</code> <pre><code>def set_format(self, fmt: str) -&gt; None:\n    \"\"\"Set the format of data output to follow the pattern in the format string.\n\n    For example, in the format string `4.3 P \" \" 3.3 T \" \" 3.3 RH \" \" SN \" \" #r #n`, `x.y` is the number\n    of digits and decimal places of the values; `P`, `T`, `RH`, and `SN` are placeholders for pressure,\n    temperature, relative humidity, and serial number values; and `\" \"`, `#r`, and `#n` represent a string\n    constant, carriage-return, and line-feed respectively. Additional allowed modifiers include `ERR` for\n    error flags, `U5` for unit field and (optional) length, `TIME` for time as [hh:mm:ss], and `DATE` for\n    date as [yyyy-mm-dd]. For more options, refer to the manual.\n\n    Args:\n        fmt: String representing desired output format.\n    \"\"\"\n    reply = self.query(f\"FORM {fmt}\")\n    if reply.startswith(\"Output format  :\"):  # format is returned by some devices when set\n        form = reply[len(\"Output format  :\") :].replace(\"\\\\\", \"#\")\n    elif \"ok\" in reply.lower():  # if OK is returned then we need to ask for the format\n        form = self.get_format()\n    else:  # this is not expected so raise an error\n        msg = f\"Unexpected reply={reply!r}\"\n        raise MSLConnectionError(self, msg)\n\n    if form.upper().replace(\" \", \"\") != fmt.upper().replace(\" \", \"\"):\n        # the format was not set as specified\n        self.check_for_errors()\n        msg = f\"Could not set format of output. \\nExpected: {fmt} \\nReceived: {form}.\"\n        raise MSLConnectionError(self, msg)\n\n    self._info[\"Output format\"] = form\n</code></pre>"},{"location":"resources/vaisala/ptb330/#msl.equipment_resources.vaisala.ptb330.PTB330.set_units","title":"set_units","text":"<pre><code>set_units(desired_units: dict[str, str]) -&gt; None\n</code></pre> <p>Set units of specified quantities.</p> <p>Parameters:</p> Name Type Description Default <code>desired_units</code> <code>dict[str, str]</code> <p>Dictionary of quantity (as keys) and their unit (as values) as specified in the instrument manual on pages 12 and 68.</p> <p>These may include the following (available options depend on the barometer components):</p> <ul> <li>Pressure quantity: P, P3h, P1, P2, QNH, QFE, HCP, ...</li> <li>Pressure unit: hPa, psi, inHg, torr, bar, mbar, mmHg, kPa, Pa, mmH2O, inH2O</li> <li>Temperature quantity: T, TP1, TP2, TP3, ...</li> <li>Temperature unit: 'C, 'F, or K (C and F are also supported but are returned as 'C or 'F)</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/vaisala/ptb330.py</code> <pre><code>def set_units(self, desired_units: dict[str, str]) -&gt; None:  # pyright: ignore[reportImplicitOverride]\n    \"\"\"Set units of specified quantities.\n\n    Args:\n        desired_units: Dictionary of *quantity* (as keys) and their *unit* (as values)\n            as specified in the instrument manual on pages 12 and 68.\n\n            These may include the following (available options depend on the barometer components):\n\n            * Pressure *quantity*: P, P3h, P1, P2, QNH, QFE, HCP, ...\n            * Pressure *unit*: hPa, psi, inHg, torr, bar, mbar, mmHg, kPa, Pa, mmH2O, inH2O\n            * Temperature *quantity*: T, TP1, TP2, TP3, ...\n            * Temperature *unit*: 'C, 'F, or K (C and F are also supported but are returned as 'C or 'F)\n    \"\"\"\n    allowed_quantities_units: dict[str, str] = {}\n    _ = self.write(\"UNIT ??\")  # list the available measurement units for the quantities\n    for _ in range(6 + len(self._pressure_modules)):\n        reply = self.read()\n        _q, _u = [qu.strip() for qu in reply.split(\":\")]\n        allowed_quantities_units[_q] = _u\n\n    for quantity, unit in desired_units.items():\n        if quantity not in allowed_quantities_units:\n            msg = (\n                f\"{quantity} is not a known quantity on this {self._info['Model']} device.\\n\"\n                f\"Please select from: {', '.join(allowed_quantities_units)}\"\n            )\n            raise MSLConnectionError(self, msg)\n\n        if unit in allowed_quantities_units[quantity]:\n            if unit in [\"C\", \"F\"]:\n                unit = \"'\" + unit  # noqa: PLW2901\n\n            _ = self.write(f\"UNIT {quantity} {unit}\")\n            for _ in range(6 + len(self._pressure_modules)):\n                reply = self.read()\n                _q, _u = [qu.strip() for qu in reply.split(\":\")]\n                self._units[_q] = _u\n\n            if quantity in self._units:\n                if self._units[quantity] != unit:\n                    msg = f\"{quantity} unit '{unit}' not set correctly. Current units are {self._units}\"\n                    raise MSLConnectionError(self, msg)\n            else:\n                msg = f\"{quantity} unit '{unit}' not set correctly. Current units are {self._units}\"\n                raise MSLConnectionError(self, msg)\n        else:\n            msg = (\n                f\"{unit} is not an allowed unit. \"\n                f\"Please select from: {', '.join(allowed_quantities_units[quantity].split())}\"\n            )\n            raise MSLConnectionError(self, msg)\n</code></pre>"},{"location":"resources/vaisala/ptu300/","title":"PTU300","text":"<p>Vaisala PTU300 series barometer.</p> <p>Supports models PTU300, PTU301, PTU303, PTU307 and PTU30T.</p>"},{"location":"resources/vaisala/ptu300/#msl.equipment_resources.vaisala.ptu300.PTU300","title":"PTU300","text":"<pre><code>PTU300(equipment: Equipment)\n</code></pre> <p>               Bases: <code>Serial</code></p> <p>Vaisala PTU300 series barometer.</p> <p>The device manual is available here.</p> <p>The default settings for the RS232 connection are:</p> <ul> <li>Baud rate: 4800</li> <li>Data bits: 7</li> <li>Parity: EVEN</li> </ul> <p>Warning</p> <p>Ensure the device is in <code>STOP</code> or <code>SEND</code> mode before initiating communication.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>An Equipment instance.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/vaisala/ptu300.py</code> <pre><code>def __init__(self, equipment: Equipment) -&gt; None:\n    \"\"\"Vaisala PTU300 series barometer.\n\n    The device manual is available [here](https://docs.vaisala.com/v/u/M210796EN-J/en-US){:target=\"_blank\"}.\n\n    The default settings for the RS232 connection are:\n\n    * Baud rate: 4800\n    * Data bits: 7\n    * Parity: EVEN\n\n    !!! warning\n        Ensure the device is in `STOP` or `SEND` mode before initiating communication.\n\n    Args:\n        equipment: An [Equipment][] instance.\n    \"\"\"\n    assert equipment.connection is not None  # noqa: S101\n    equipment.connection.properties.setdefault(\"baud_rate\", 4800)\n    equipment.connection.properties.setdefault(\"data_bits\", DataBits.SEVEN)\n    equipment.connection.properties.setdefault(\"parity\", Parity.EVEN)\n    super().__init__(equipment)\n\n    self.rstrip: bool = True\n\n    self._units: dict[str, str] = {}\n    self._pressure_modules: set[str] = set()\n    self._info: dict[str, str] = self._device_info()\n\n    # Get the device ID (serial) number and check it agrees with the equipment record.\n    # Could use `reply = self.query(\"*9900SN\")` but the serial number is also in device_info\n    sn = self._info[\"Serial number\"]\n    if sn != equipment.serial:\n        msg = f\"Inconsistent serial number: expected {equipment.serial} but received {sn}\"\n        raise MSLConnectionError(self, msg)\n</code></pre>"},{"location":"resources/vaisala/ptu300/#msl.equipment_resources.vaisala.ptu300.PTU300.device_info","title":"device_info  <code>property</code>","text":"<pre><code>device_info: dict[str, str]\n</code></pre> <p>Returns a dictionary of information about the Vaisala device.</p>"},{"location":"resources/vaisala/ptu300/#msl.equipment_resources.vaisala.ptu300.PTU300.units","title":"units  <code>property</code>","text":"<pre><code>units: dict[str, str]\n</code></pre> <p>A dictionary of measured quantities and their associated units.</p> <p>The units are set by set_units.</p>"},{"location":"resources/vaisala/ptu300/#msl.equipment_resources.vaisala.ptu300.PTU300.check_for_errors","title":"check_for_errors","text":"<pre><code>check_for_errors() -&gt; None\n</code></pre> <p>Raise an error, if present.</p> Source code in <code>packages/resources/src/msl/equipment_resources/vaisala/ptu300.py</code> <pre><code>def check_for_errors(self) -&gt; None:\n    \"\"\"Raise an error, if present.\"\"\"\n    err = self.query(\"ERRS\")  # List present transmitter errors\n    # a PASS or FAIL line is returned from PTB330 modules first\n    if err in {\"PASS\", \"FAIL\"}:\n        err = self.read()\n    if err and err != \"No errors\":\n        raise MSLConnectionError(self, err)\n</code></pre>"},{"location":"resources/vaisala/ptu300/#msl.equipment_resources.vaisala.ptu300.PTU300.get_format","title":"get_format","text":"<pre><code>get_format() -&gt; str\n</code></pre> <p>Get the currently active formatter string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The formatter string.</p> Source code in <code>packages/resources/src/msl/equipment_resources/vaisala/ptu300.py</code> <pre><code>def get_format(self) -&gt; str:\n    \"\"\"Get the currently active formatter string.\n\n    Returns:\n        The formatter string.\n    \"\"\"\n    # The hash symbol \"#\" is used to set the format, but then appears as a backslash \"\\\\\" on the device.\n    return self.query(\"FORM ?\")[len(\"Output format  :\") :].replace(\"\\\\\", \"#\")\n</code></pre>"},{"location":"resources/vaisala/ptu300/#msl.equipment_resources.vaisala.ptu300.PTU300.get_reading_str","title":"get_reading_str","text":"<pre><code>get_reading_str() -&gt; str\n</code></pre> <p>Output the reading once.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string that follows the format set by set_format.</p> Source code in <code>packages/resources/src/msl/equipment_resources/vaisala/ptu300.py</code> <pre><code>def get_reading_str(self) -&gt; str:\n    \"\"\"Output the reading once.\n\n    Returns:\n        A string that follows the format set by\n            [set_format][msl.equipment_resources.vaisala.ptu300.PTU300.set_format].\n    \"\"\"\n    return self.query(\"SEND\")\n</code></pre>"},{"location":"resources/vaisala/ptu300/#msl.equipment_resources.vaisala.ptu300.PTU300.set_format","title":"set_format","text":"<pre><code>set_format(fmt: str) -&gt; None\n</code></pre> <p>Set the format of data output to follow the pattern in the format string.</p> <p>For example, in the format string <code>4.3 P \" \" 3.3 T \" \" 3.3 RH \" \" SN \" \" #r #n</code>, <code>x.y</code> is the number of digits and decimal places of the values; <code>P</code>, <code>T</code>, <code>RH</code>, and <code>SN</code> are placeholders for pressure, temperature, relative humidity, and serial number values; and <code>\" \"</code>, <code>#r</code>, and <code>#n</code> represent a string constant, carriage-return, and line-feed respectively. Additional allowed modifiers include <code>ERR</code> for error flags, <code>U5</code> for unit field and (optional) length, <code>TIME</code> for time as [hh:mm:ss], and <code>DATE</code> for date as [yyyy-mm-dd]. For more options, refer to the manual.</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>str</code> <p>String representing desired output format.</p> required Source code in <code>packages/resources/src/msl/equipment_resources/vaisala/ptu300.py</code> <pre><code>def set_format(self, fmt: str) -&gt; None:\n    \"\"\"Set the format of data output to follow the pattern in the format string.\n\n    For example, in the format string `4.3 P \" \" 3.3 T \" \" 3.3 RH \" \" SN \" \" #r #n`, `x.y` is the number\n    of digits and decimal places of the values; `P`, `T`, `RH`, and `SN` are placeholders for pressure,\n    temperature, relative humidity, and serial number values; and `\" \"`, `#r`, and `#n` represent a string\n    constant, carriage-return, and line-feed respectively. Additional allowed modifiers include `ERR` for\n    error flags, `U5` for unit field and (optional) length, `TIME` for time as [hh:mm:ss], and `DATE` for\n    date as [yyyy-mm-dd]. For more options, refer to the manual.\n\n    Args:\n        fmt: String representing desired output format.\n    \"\"\"\n    reply = self.query(f\"FORM {fmt}\")\n    if reply.startswith(\"Output format  :\"):  # format is returned by some devices when set\n        form = reply[len(\"Output format  :\") :].replace(\"\\\\\", \"#\")\n    elif \"ok\" in reply.lower():  # if OK is returned then we need to ask for the format\n        form = self.get_format()\n    else:  # this is not expected so raise an error\n        msg = f\"Unexpected reply={reply!r}\"\n        raise MSLConnectionError(self, msg)\n\n    if form.upper().replace(\" \", \"\") != fmt.upper().replace(\" \", \"\"):\n        # the format was not set as specified\n        self.check_for_errors()\n        msg = f\"Could not set format of output. \\nExpected: {fmt} \\nReceived: {form}.\"\n        raise MSLConnectionError(self, msg)\n\n    self._info[\"Output format\"] = form\n</code></pre>"},{"location":"resources/vaisala/ptu300/#msl.equipment_resources.vaisala.ptu300.PTU300.set_units","title":"set_units","text":"<pre><code>set_units(desired_units: dict[str, str]) -&gt; None\n</code></pre> <p>Set unit of specified quantity.</p> <p>Note that only one pressure unit is used at a time for the PTU300 series.</p> <p>Parameters:</p> Name Type Description Default <code>desired_units</code> <code>dict[str, str]</code> <p>Dictionary of quantity (as keys) and their unit (as values) as specified in the instrument manual on pages 24 and 106.</p> <p>These may include the following (available options depend on the barometer components):</p> <ul> <li>Pressure quantity: P, P3h, P1, P2, QNH, QFE, HCP, ...</li> <li>Pressure unit: hPa, psi, inHg, torr, bar, mbar, mmHg, kPa, Pa, mmH2O, inH2O</li> <li>Temperature quantity: T</li> <li>Temperature unit: 'C, 'F (C and F are also supported but are returned as 'C or 'F)</li> <li>Humidity quantity: RH</li> <li>Humidity unit: %RH</li> </ul> required Source code in <code>packages/resources/src/msl/equipment_resources/vaisala/ptu300.py</code> <pre><code>def set_units(self, desired_units: dict[str, str]) -&gt; None:  # noqa: C901, PLR0912\n    \"\"\"Set unit of specified quantity.\n\n    Note that only one pressure unit is used at a time for the PTU300 series.\n\n    Args:\n        desired_units: Dictionary of *quantity* (as keys) and their *unit* (as values)\n            as specified in the instrument manual on pages 24 and 106.\n\n            These may include the following (available options depend on the barometer components):\n\n            * Pressure *quantity*: P, P3h, P1, P2, QNH, QFE, HCP, ...\n            * Pressure *unit*: hPa, psi, inHg, torr, bar, mbar, mmHg, kPa, Pa, mmH2O, inH2O\n            * Temperature *quantity*: T\n            * Temperature *unit*: 'C, 'F (C and F are also supported but are returned as 'C or 'F)\n            * Humidity *quantity*: RH\n            * Humidity *unit*: %RH\n    \"\"\"\n    p_units: list[str] = []\n    allowed_units = [  # for pressure\n        \"hPa\",\n        \"psia\",\n        \"inHg\",\n        \"torr\",\n        \"bara\",\n        \"barg\",\n        \"psig\",\n        \"mbar\",\n        \"mmHg\",\n        \"kPa\",\n        \"Pa\",\n        \"mmH2O\",\n        \"inH2O\",\n    ]\n    old_units = self.query(\"UNIT\")\n    if \"Output units\" not in old_units:  # confirming device is of type PTU300\n        msg = \"Check correct device connected\"\n        raise MSLConnectionError(self, msg)\n\n    for quantity, unit in desired_units.items():\n        if quantity == \"RH\":  # only option is %RH\n            self._units[\"RH\"] = \"%RH\"\n\n        elif \"T\" in quantity:  # options are 'C, 'F\n            if \"F\" in unit:  # Temperature and humidity setting is done via metric or 'non metric'\n                r_m = self.query(\"UNIT N\")\n                if \"non\" not in r_m:\n                    msg = \"Error when setting non-metric unit for temperature\"\n                    raise MSLConnectionError(self, msg)\n                self._units[\"T\"] = \"'F\"\n            elif \"C\" in unit:\n                r_m = self.query(\"UNIT M\")\n                self._units[\"T\"] = \"'C\"\n            else:\n                msg = f\"Unit {unit} is not supported by this device. Please use 'C or 'F.\"\n                raise MSLConnectionError(self, msg)\n\n            if \"metric\" not in r_m:\n                self._units[\"T\"] = \"\"\n                self.check_for_errors()\n\n        elif unit in allowed_units:  # assume this is a pressure quantity based on the unit\n            if p_units and unit not in p_units:\n                msg = \"Only one pressure unit can be set for this barometer\"\n                raise MSLConnectionError(self, msg)\n\n            r_p = self.query(f\"UNIT P {unit}\")\n            if not r_p.endswith(unit):\n                self.check_for_errors()\n            self._units[quantity] = unit\n            p_units.append(unit)\n\n        else:  # quantity is not pressure, temperature or humidity, so ask user to set the unit manually\n            msg = f\"{unit} is not able to be set for {quantity}. Please set this unit manually.\"\n            raise MSLConnectionError(self, msg)\n</code></pre>"},{"location":"schema/","title":"Schema Classes","text":"<p>Class representations of the XML Schema Definition for an equipment register.</p> <p>The primary class is Register which contains a sequence of Equipment classes that are each composed of the following classes:</p> <ul> <li>AcceptanceCriteria</li> <li>Accessories</li> <li>Adjustment</li> <li>Alteration</li> <li>CapitalExpenditure</li> <li>Competency</li> <li>CompletedTask</li> <li>Component</li> <li>Conditions</li> <li>CVDEquation (Callendar-Van Dusen equation, uses the cvdCoefficients)</li> <li>Deserialised (opposite of serialised)</li> <li>DigitalReport</li> <li>Equation</li> <li>File</li> <li>Financial</li> <li>Firmware</li> <li>Maintenance</li> <li>Measurand</li> <li>PerformanceCheck</li> <li>PlannedTask</li> <li>QualityManual</li> <li>ReferenceMaterials</li> <li>Report</li> <li>Specifications</li> <li>SpecifiedRequirements</li> <li>Status</li> <li>Table</li> </ul> <p>The Any class is used as a base class for elements that are currently represented by the any type in the XML Schema Definition.</p>"},{"location":"schema/acceptance_criteria/","title":"AcceptanceCriteria","text":""},{"location":"schema/acceptance_criteria/#msl.equipment.schema.AcceptanceCriteria","title":"AcceptanceCriteria","text":"<pre><code>AcceptanceCriteria(**attributes: str)\n</code></pre> <p>               Bases: <code>Any</code></p> <p>Represents the acceptance criteria in a calibration report.</p> <p>Since this class is currently represented by the any type in the XML Schema Definition, it is simply a subclass of Element. It may be updated to be a more specific class at a later date.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any] type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/acceptance_criteria/#msl.equipment.schema.AcceptanceCriteria.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str = 'acceptanceCriteria'\n</code></pre> <p>The element's name.</p>"},{"location":"schema/acceptance_criteria/#msl.equipment.schema.AcceptanceCriteria.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/accessories/","title":"Accessories","text":""},{"location":"schema/accessories/#msl.equipment.schema.Accessories","title":"Accessories","text":"<pre><code>Accessories(**attributes: str)\n</code></pre> <p>               Bases: <code>Any</code></p> <p>Additional accessories that may be required to use the equipment.</p> <p>Since this class is currently represented by the any type in the XML Schema Definition, it is simply a subclass of Element. It may be updated to be a more specific class at a later date.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any] type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/accessories/#msl.equipment.schema.Accessories.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str = 'accessories'\n</code></pre> <p>The element's name.</p>"},{"location":"schema/accessories/#msl.equipment.schema.Accessories.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/adjustment/","title":"Adjustment","text":""},{"location":"schema/adjustment/#msl.equipment.schema.Adjustment","title":"Adjustment  <code>dataclass</code>","text":"<pre><code>Adjustment(details: str, date: date)\n</code></pre> <p>An adjustment of the equipment.</p> <p>An example of an adjustment is cleaning the equipment (e.g., a spectral filter) and then performing another calibration measurement.</p> <p>This XML element is found in component.</p> <p>Parameters:</p> Name Type Description Default <code>details</code> <code>str</code> <p>The details of the adjustment that was performed.</p> required <code>date</code> <code>date</code> <p>The date that the adjustment was performed.</p> required"},{"location":"schema/adjustment/#msl.equipment.schema.Adjustment.date","title":"date  <code>instance-attribute</code>","text":"<pre><code>date: date\n</code></pre> <p>The date that the adjustment was performed.</p>"},{"location":"schema/adjustment/#msl.equipment.schema.Adjustment.details","title":"details  <code>instance-attribute</code>","text":"<pre><code>details: str\n</code></pre> <p>The details of the adjustment that was performed.</p>"},{"location":"schema/adjustment/#msl.equipment.schema.Adjustment.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Adjustment\n</code></pre> <p>Convert an XML element into a Adjustment instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An <code>&lt;adjustment&gt;</code> XML element from an equipment register (see component).</p> required <p>Returns:</p> Type Description <code>Adjustment</code> <p>The Adjustment instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Adjustment:\n    \"\"\"Convert an XML element into a [Adjustment][msl.equipment.schema.Adjustment] instance.\n\n    Args:\n        element: An `&lt;adjustment&gt;` XML element from an equipment register\n            (see [component][type_component]).\n\n    Returns:\n        The [Adjustment][msl.equipment.schema.Adjustment] instance.\n    \"\"\"\n    return cls(details=element.text or \"\", date=_date.fromisoformat(element.attrib[\"date\"]))\n</code></pre>"},{"location":"schema/adjustment/#msl.equipment.schema.Adjustment.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Adjustment class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Adjustment as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Adjustment][msl.equipment.schema.Adjustment] class into an XML element.\n\n    Returns:\n        The [Adjustment][msl.equipment.schema.Adjustment] as an XML element.\n    \"\"\"\n    e = Element(\"adjustment\", attrib={\"date\": self.date.isoformat()})\n    e.text = self.details\n    return e\n</code></pre>"},{"location":"schema/alteration/","title":"Alteration","text":""},{"location":"schema/alteration/#msl.equipment.schema.Alteration","title":"Alteration  <code>dataclass</code>","text":"<pre><code>Alteration(date: date, details: str, performed_by: str)\n</code></pre> <p>Represents the alteration element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>date</code> <p>The date that the alteration was performed.</p> required <code>details</code> <code>str</code> <p>The details of the alteration.</p> required <code>performed_by</code> <code>str</code> <p>The person or company that performed the alteration.</p> required"},{"location":"schema/alteration/#msl.equipment.schema.Alteration.date","title":"date  <code>instance-attribute</code>","text":"<pre><code>date: date\n</code></pre> <p>The date that the alteration was performed.</p>"},{"location":"schema/alteration/#msl.equipment.schema.Alteration.details","title":"details  <code>instance-attribute</code>","text":"<pre><code>details: str\n</code></pre> <p>The details of the alteration.</p>"},{"location":"schema/alteration/#msl.equipment.schema.Alteration.performed_by","title":"performed_by  <code>instance-attribute</code>","text":"<pre><code>performed_by: str\n</code></pre> <p>The person or company that performed the alteration.</p>"},{"location":"schema/alteration/#msl.equipment.schema.Alteration.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Alteration\n</code></pre> <p>Convert an XML element into an Alteration instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An alteration XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Alteration</code> <p>The Alteration instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Alteration:\n    \"\"\"Convert an XML element into an [Alteration][msl.equipment.schema.Alteration] instance.\n\n    Args:\n        element: An [alteration][type_alteration] XML element from an equipment register.\n\n    Returns:\n        The [Alteration][msl.equipment.schema.Alteration] instance.\n    \"\"\"\n    return cls(\n        date=_date.fromisoformat(element.attrib[\"date\"]),\n        details=element.text or \"\",\n        performed_by=element.attrib[\"performedBy\"],\n    )\n</code></pre>"},{"location":"schema/alteration/#msl.equipment.schema.Alteration.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Alteration class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Alteration as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Alteration][msl.equipment.schema.Alteration] class into an XML element.\n\n    Returns:\n        The [Alteration][msl.equipment.schema.Alteration] as an XML element.\n    \"\"\"\n    e = Element(\"alteration\", attrib={\"date\": self.date.isoformat(), \"performedBy\": self.performed_by})\n    e.text = self.details\n    return e\n</code></pre>"},{"location":"schema/any/","title":"Any","text":""},{"location":"schema/any/#msl.equipment.schema.Any","title":"Any","text":"<pre><code>Any(**attributes: str)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Base class that represents the any type in the XML Schema Definition.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any] type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/any/#msl.equipment.schema.Any.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/capital_expenditure/","title":"CapitalExpenditure","text":""},{"location":"schema/capital_expenditure/#msl.equipment.schema.CapitalExpenditure","title":"CapitalExpenditure  <code>dataclass</code>","text":"<pre><code>CapitalExpenditure(\n    asset_number: str,\n    depreciation_end_year: int,\n    price: float,\n    currency: str,\n)\n</code></pre> <p>Represents the capitalExpenditure element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>asset_number</code> <code>str</code> <p>The asset number in the financial system.</p> required <code>depreciation_end_year</code> <code>int</code> <p>The year (inclusive) that depreciation ends for the asset.</p> required <code>price</code> <code>float</code> <p>The purchase price of the asset.</p> required <code>currency</code> <code>str</code> <p>The currency associated with the <code>price</code>.</p> required"},{"location":"schema/capital_expenditure/#msl.equipment.schema.CapitalExpenditure.asset_number","title":"asset_number  <code>instance-attribute</code>","text":"<pre><code>asset_number: str\n</code></pre> <p>The asset number in the financial system.</p>"},{"location":"schema/capital_expenditure/#msl.equipment.schema.CapitalExpenditure.currency","title":"currency  <code>instance-attribute</code>","text":"<pre><code>currency: str\n</code></pre> <p>The currency associated with the <code>price</code>.</p>"},{"location":"schema/capital_expenditure/#msl.equipment.schema.CapitalExpenditure.depreciation_end_year","title":"depreciation_end_year  <code>instance-attribute</code>","text":"<pre><code>depreciation_end_year: int\n</code></pre> <p>The year (inclusive) that depreciation ends for the asset.</p>"},{"location":"schema/capital_expenditure/#msl.equipment.schema.CapitalExpenditure.price","title":"price  <code>instance-attribute</code>","text":"<pre><code>price: float\n</code></pre> <p>The price of the asset.</p>"},{"location":"schema/capital_expenditure/#msl.equipment.schema.CapitalExpenditure.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; CapitalExpenditure\n</code></pre> <p>Convert an XML element into a CapitalExpenditure instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A capitalExpenditure XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>CapitalExpenditure</code> <p>The CapitalExpenditure instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; CapitalExpenditure:\n    \"\"\"Convert an XML element into a [CapitalExpenditure][msl.equipment.schema.CapitalExpenditure] instance.\n\n    Args:\n        element: A [capitalExpenditure][type_capitalExpenditure] XML element\n            from an equipment register.\n\n    Returns:\n        The [CapitalExpenditure][msl.equipment.schema.CapitalExpenditure] instance.\n    \"\"\"\n    # Schema forces order\n    return cls(\n        asset_number=element[0].text or \"\",\n        depreciation_end_year=int(element[1].text or 0),\n        price=float(element[2].text or 0),\n        currency=element[2].attrib[\"currency\"],\n    )\n</code></pre>"},{"location":"schema/capital_expenditure/#msl.equipment.schema.CapitalExpenditure.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the CapitalExpenditure class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The CapitalExpenditure as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [CapitalExpenditure][msl.equipment.schema.CapitalExpenditure] class into an XML element.\n\n    Returns:\n        The [CapitalExpenditure][msl.equipment.schema.CapitalExpenditure] as an XML element.\n    \"\"\"\n    e = Element(\"capitalExpenditure\")\n\n    an = SubElement(e, \"assetNumber\")\n    an.text = self.asset_number\n\n    dey = SubElement(e, \"depreciationEndYear\")\n    dey.text = str(self.depreciation_end_year)\n\n    p = SubElement(e, \"price\", attrib={\"currency\": self.currency})\n    p.text = f\"{self.price:.14g}\"\n\n    return e\n</code></pre>"},{"location":"schema/competency/","title":"Competency","text":""},{"location":"schema/competency/#msl.equipment.schema.Competency","title":"Competency  <code>dataclass</code>","text":"<pre><code>Competency(\n    worker: str, checker: str, technical_procedure: str\n)\n</code></pre> <p>Represents the competency element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>worker</code> <code>str</code> <p>The competent person who executed the technical procedure to accomplish the performance check.</p> required <code>checker</code> <code>str</code> <p>The competent person who reviewed the work done by the <code>worker</code>.</p> required <code>technical_procedure</code> <code>str</code> <p>The technical procedure that was executed to accomplish the performance check.</p> required"},{"location":"schema/competency/#msl.equipment.schema.Competency.checker","title":"checker  <code>instance-attribute</code>","text":"<pre><code>checker: str\n</code></pre> <p>The competent person who reviewed the work done by the <code>worker</code>.</p>"},{"location":"schema/competency/#msl.equipment.schema.Competency.technical_procedure","title":"technical_procedure  <code>instance-attribute</code>","text":"<pre><code>technical_procedure: str\n</code></pre> <p>The technical procedure that was executed to accomplish the performance check.</p>"},{"location":"schema/competency/#msl.equipment.schema.Competency.worker","title":"worker  <code>instance-attribute</code>","text":"<pre><code>worker: str\n</code></pre> <p>The competent person who executed the technical procedure to accomplish the performance check.</p>"},{"location":"schema/competency/#msl.equipment.schema.Competency.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Competency\n</code></pre> <p>Convert an XML element into a Competency instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A competency XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Competency</code> <p>The Competency instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Competency:\n    \"\"\"Convert an XML element into a [Competency][msl.equipment.schema.Competency] instance.\n\n    Args:\n        element: A [competency][type_competency] XML element from an equipment register.\n\n    Returns:\n        The [Competency][msl.equipment.schema.Competency] instance.\n    \"\"\"\n    # Schema forces order\n    return cls(\n        worker=element[0].text or \"\",\n        checker=element[1].text or \"\",\n        technical_procedure=element[2].text or \"\",\n    )\n</code></pre>"},{"location":"schema/competency/#msl.equipment.schema.Competency.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Competency class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Competency as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Competency][msl.equipment.schema.Competency] class into an XML element.\n\n    Returns:\n        The [Competency][msl.equipment.schema.Competency] as an XML element.\n    \"\"\"\n    e = Element(\"competency\")\n    worker = SubElement(e, \"worker\")\n    worker.text = self.worker\n    checker = SubElement(e, \"checker\")\n    checker.text = self.checker\n    tp = SubElement(e, \"technicalProcedure\")\n    tp.text = self.technical_procedure\n    return e\n</code></pre>"},{"location":"schema/completed_task/","title":"CompletedTask","text":""},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask","title":"CompletedTask  <code>dataclass</code>","text":"<pre><code>CompletedTask(\n    task: str,\n    due_date: date,\n    performed_by: str,\n    completed_date: date,\n)\n</code></pre> <p>Represents the completedTask element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>str</code> <p>A description of the task that was completed.</p> required <code>due_date</code> <code>date</code> <p>The date that the maintenance task was due to be completed.</p> required <code>performed_by</code> <code>str</code> <p>The person or company that performed the maintenance task.</p> required <code>completed_date</code> <code>date</code> <p>The date that the maintenance task was completed.</p> required"},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask.completed_date","title":"completed_date  <code>instance-attribute</code>","text":"<pre><code>completed_date: date\n</code></pre> <p>The date that the maintenance task was completed.</p>"},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask.due_date","title":"due_date  <code>instance-attribute</code>","text":"<pre><code>due_date: date\n</code></pre> <p>The date that the maintenance task was due to be completed.</p>"},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask.performed_by","title":"performed_by  <code>instance-attribute</code>","text":"<pre><code>performed_by: str\n</code></pre> <p>The person or company that performed the maintenance task.</p>"},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask.task","title":"task  <code>instance-attribute</code>","text":"<pre><code>task: str\n</code></pre> <p>A description of the task that was completed.</p>"},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; CompletedTask\n</code></pre> <p>Convert an XML element into a CompletedTask instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A completedTask XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>CompletedTask</code> <p>The CompletedTask instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; CompletedTask:\n    \"\"\"Convert an XML element into a [CompletedTask][msl.equipment.schema.CompletedTask] instance.\n\n    Args:\n        element: A [completedTask][type_completedTask] XML element from an equipment register.\n\n    Returns:\n        The [CompletedTask][msl.equipment.schema.CompletedTask] instance.\n    \"\"\"\n    return cls(\n        task=element.text or \"\",\n        due_date=_date.fromisoformat(element.attrib[\"dueDate\"]),\n        performed_by=element.attrib[\"performedBy\"],\n        completed_date=_date.fromisoformat(element.attrib[\"completedDate\"]),\n    )\n</code></pre>"},{"location":"schema/completed_task/#msl.equipment.schema.CompletedTask.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the CompletedTask class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The CompletedTask as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [CompletedTask][msl.equipment.schema.CompletedTask] class into an XML element.\n\n    Returns:\n        The [CompletedTask][msl.equipment.schema.CompletedTask] as an XML element.\n    \"\"\"\n    attrib = {\n        \"dueDate\": self.due_date.isoformat(),\n        \"completedDate\": self.completed_date.isoformat(),\n        \"performedBy\": self.performed_by,\n    }\n\n    e = Element(\"task\", attrib=attrib)\n    e.text = self.task\n    return e\n</code></pre>"},{"location":"schema/component/","title":"Component","text":""},{"location":"schema/component/#msl.equipment.schema.Component","title":"Component  <code>dataclass</code>","text":"<pre><code>Component(\n    name: str = \"\",\n    adjustments: tuple[Adjustment, ...] = (),\n    digital_reports: tuple[DigitalReport, ...] = (),\n    performance_checks: tuple[PerformanceCheck, ...] = (),\n    reports: tuple[Report, ...] = (),\n)\n</code></pre> <p>Represents the component element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name to associate with this component. The value must be unique amongst the other component elements within the same measurand element. An empty string is permitted.</p> <code>''</code> <code>adjustments</code> <code>tuple[Adjustment, ...]</code> <p>The history of adjustments.</p> <code>()</code> <code>digital_reports</code> <code>tuple[DigitalReport, ...]</code> <p>The history of digital calibration reports.</p> <code>()</code> <code>performance_checks</code> <code>tuple[PerformanceCheck, ...]</code> <p>The history of performance checks.</p> <code>()</code> <code>reports</code> <code>tuple[Report, ...]</code> <p>The history of calibration reports.</p> <code>()</code>"},{"location":"schema/component/#msl.equipment.schema.Component.adjustments","title":"adjustments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>adjustments: tuple[Adjustment, ...] = ()\n</code></pre> <p>The history of adjustments.</p>"},{"location":"schema/component/#msl.equipment.schema.Component.digital_reports","title":"digital_reports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>digital_reports: tuple[DigitalReport, ...] = ()\n</code></pre> <p>The history of digital calibration reports.</p>"},{"location":"schema/component/#msl.equipment.schema.Component.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = ''\n</code></pre> <p>The name associated with this component.</p>"},{"location":"schema/component/#msl.equipment.schema.Component.performance_checks","title":"performance_checks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performance_checks: tuple[PerformanceCheck, ...] = ()\n</code></pre> <p>The history of performance checks.</p>"},{"location":"schema/component/#msl.equipment.schema.Component.reports","title":"reports  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reports: tuple[Report, ...] = ()\n</code></pre> <p>The history of calibration reports.</p>"},{"location":"schema/component/#msl.equipment.schema.Component.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Component\n</code></pre> <p>Convert an XML element into a Component instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A component XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Component</code> <p>The Component instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Component:\n    \"\"\"Convert an XML element into a [Component][msl.equipment.schema.Component] instance.\n\n    Args:\n        element: A [component][type_component] XML element from an equipment register.\n\n    Returns:\n        The [Component][msl.equipment.schema.Component] instance.\n    \"\"\"\n    # Schema defines &lt;component&gt; using xsd:choice, which allows sub-elements to appear (or not appear) in any order\n    # Using str.endswith() allows for ignoring XML namespaces that may be associated with each tag\n    a: list[Adjustment] = []\n    dr: list[DigitalReport] = []\n    pc: list[PerformanceCheck] = []\n    r: list[Report] = []\n    for child in element:\n        tag = child.tag\n        if tag.endswith(\"report\"):\n            r.append(Report.from_xml(child))\n        elif tag.endswith(\"performanceCheck\"):\n            pc.append(PerformanceCheck.from_xml(child))\n        elif tag.endswith(\"adjustment\"):\n            a.append(Adjustment.from_xml(child))\n        else:\n            dr.append(DigitalReport.from_xml(child))\n\n    return cls(\n        name=element.attrib[\"name\"],\n        adjustments=tuple(a),\n        digital_reports=tuple(dr),\n        performance_checks=tuple(pc),\n        reports=tuple(r),\n    )\n</code></pre>"},{"location":"schema/component/#msl.equipment.schema.Component.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Component class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Component as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Component][msl.equipment.schema.Component] class into an XML element.\n\n    Returns:\n        The [Component][msl.equipment.schema.Component] as an XML element.\n    \"\"\"\n    e = Element(\"component\", attrib={\"name\": self.name})\n\n    # the order is not important since xsd:choice is used\n    e.extend(r.to_xml() for r in self.reports)\n    e.extend(p.to_xml() for p in self.performance_checks)\n    e.extend(a.to_xml() for a in self.adjustments)\n    e.extend(d.to_xml() for d in self.digital_reports)\n    return e\n</code></pre>"},{"location":"schema/conditions/","title":"Conditions","text":""},{"location":"schema/conditions/#msl.equipment.schema.Conditions","title":"Conditions","text":"<pre><code>Conditions(**attributes: str)\n</code></pre> <p>               Bases: <code>Any</code></p> <p>Conditions under which a performance check or calibration report is valid.</p> <p>Since this class is currently represented by the any type in the XML Schema Definition, it is simply a subclass of Element. It may be updated to be a more specific class at a later date.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any] type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/conditions/#msl.equipment.schema.Conditions.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str = 'conditions'\n</code></pre> <p>The element's name.</p>"},{"location":"schema/conditions/#msl.equipment.schema.Conditions.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/cvd_equation/","title":"CVDEquation","text":"<p>The Callendar-Van Dusen (CVD) equation describes the relationship between resistance, \\(R\\), and temperature, \\(t\\), of platinum resistance thermometers (PRT). It is defined in two temperature ranges</p> \\[ \\frac{R(t)}{R_0} = \\begin{cases}     1 + A \\cdot t + B \\cdot t^2 + D \\cdot t^3 &amp; R(t) \\geq R_0 \\\\     1 + A \\cdot t + B \\cdot t^2 + C \\cdot t^3 \\cdot (t-100) &amp; R(t) \\lt R_0 \\\\ \\end{cases} \\] <p>where, \\(R_0 = R(0~^{\\circ}\\text{C})\\) is the resistance at \\(t=0~^{\\circ}\\text{C}\\) and \\(A\\), \\(B\\), \\(C\\) and \\(D\\) are the CVD coefficients. The \\(D\\) coefficient is typically zero but may be non-zero if \\(t \\gtrsim 200~^{\\circ}\\text{C}\\).</p> <p>Suppose you have a variable named <code>cvd</code> (which is an instance of CVDEquation) that represents the following information in an equipment register for a PRT</p> <pre><code>&lt;cvdCoefficients&gt;\n  &lt;R0&gt;100.0189&lt;/R0&gt;\n  &lt;A&gt;3.913e-3&lt;/A&gt;\n  &lt;B&gt;-6.056e-7&lt;/B&gt;\n  &lt;C&gt;1.372e-12&lt;/C&gt;\n  &lt;D&gt;0&lt;/D&gt;\n  &lt;uncertainty variables=\"\"&gt;0.0056/2&lt;/uncertainty&gt;\n  &lt;range&gt;\n    &lt;minimum&gt;-10&lt;/minimum&gt;\n    &lt;maximum&gt;70&lt;/maximum&gt;\n  &lt;/range&gt;\n&lt;/cvdCoefficients&gt;\n</code></pre> <p>You can access the CVD coefficients, degrees of freedom and comment as attributes of <code>cvd</code>,</p> <pre><code>&gt;&gt;&gt; cvd.R0\n100.0189\n&gt;&gt;&gt; cvd.A\n0.003913\n&gt;&gt;&gt; cvd.B\n-6.056e-07\n&gt;&gt;&gt; cvd.C\n1.372e-12\n&gt;&gt;&gt; cvd.D\n0.0\n&gt;&gt;&gt; cvd.degree_freedom\ninf\n&gt;&gt;&gt; cvd.comment\n''\n</code></pre> <p>evaluate the uncertainty,</p> <pre><code>&gt;&gt;&gt; print(cvd.uncertainty())\n0.0026\n</code></pre> <p>calculate resistance from temperature,</p> <pre><code>&gt;&gt;&gt; print(cvd.resistance(12.4))\n104.86262358516764\n&gt;&gt;&gt; cvd.resistance([-5, 0, 5, 10, 15, 20, 25])\narray([ 98.06051774, 100.0189    , 101.97425549, 103.92658241,\n       105.87588076, 107.82215054, 109.76539174])\n</code></pre> <p>and calculate temperature from resistance</p> <pre><code>&gt;&gt;&gt; print(cvd.temperature(109.1))\n23.287055698724505\n&gt;&gt;&gt; cvd.temperature([98.7, 99.2, 100.4, 101.7, 103.8])\narray([-3.36816839, -2.09169544,  0.9738958 ,  4.29823964,  9.67558125])\n</code></pre> <p>A number or any sequence of numbers, i.e., a list, tuple or ndarray may be used to calculate the temperature or resistance (tip: using ndarray will improve performance since a copy of the values is not required).</p> <p>When calculating resistance or temperature, the values of the inputs are checked to ensure that the values are within the range that the CVD coefficients are valid for. The XML data above shows that the temperature must be in the range \\(-10~^\\circ\\text{C}\\) to \\(70~^\\circ\\text{C}\\), which has a corresponding resistance range of \\(96.099~\\Omega\\) to \\(127.118~\\Omega\\) from the equation above. If you calculate resistance from \\(t=-10.2~^\\circ\\text{C}\\) or temperature from \\(R=96.0~\\Omega\\) a ValueError is raised, since the value is outside the range.</p> <pre><code>&gt;&gt;&gt; cvd.ranges\n{'t': Range(minimum=-10, maximum=70), 'r': Range(minimum=96.099, maximum=127.118)}\n\n&gt;&gt;&gt; cvd.resistance(-10.2)\nTraceback (most recent call last):\n...\nValueError: The value -10.2 is not within the range [-10, 70]\n\n&gt;&gt;&gt; cvd.temperature(96)\nTraceback (most recent call last):\n...\nValueError: The value 96.0 is not within the range [96.099, 127.118]\n</code></pre> <p>You can bypass range checking by including a <code>check_range=False</code> keyword argument</p> <pre><code>&gt;&gt;&gt; print(cvd.resistance(-10.2, check_range=False))\n96.02059984653798\n&gt;&gt;&gt; print(cvd.temperature(96, check_range=False))\n-10.252469261526016\n</code></pre>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation","title":"CVDEquation  <code>dataclass</code>","text":"<pre><code>CVDEquation(\n    R0: float,\n    A: float,\n    B: float,\n    C: float,\n    D: float,\n    uncertainty: Evaluable,\n    ranges: dict[str, Range] = dict(),\n    degree_freedom: float = float(\"inf\"),\n    comment: str = \"\",\n)\n</code></pre> <p>The Callendar-Van Dusen (CVD) equation based on the cvdCoefficients element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>R0</code> <code>float</code> <p>The value, in \\(\\Omega\\), of the resistance at \\(0~^\\circ\\text{C}\\), \\(R_0\\).</p> required <code>A</code> <code>float</code> <p>The value, in \\((^\\circ\\text{C})^{-1}\\), of the A coefficient, \\(A \\cdot t\\).</p> required <code>B</code> <code>float</code> <p>The value, in \\((^\\circ\\text{C})^{-2}\\), of the B coefficient, \\(B \\cdot t^2\\).</p> required <code>C</code> <code>float</code> <p>The value, in \\((^\\circ\\text{C})^{-4}\\), of the C coefficient, \\(C \\cdot t^3 \\cdot (t-100)\\).</p> required <code>D</code> <code>float</code> <p>The value, in \\((^\\circ\\text{C})^{-3}\\), of the D coefficient, \\(D \\cdot t^3\\). The \\(D\\) coefficient is typically zero but may be non-zero if \\(t \\gtrsim 200~^{\\circ}\\text{C}\\). If a calibration report does not specify the \\(D\\) coefficient, set the value to be 0.</p> required <code>uncertainty</code> <code>Evaluable</code> <p>The equation to evaluate to calculate the standard uncertainty.</p> required <code>ranges</code> <code>dict[str, Range]</code> <p>The temperature range, in \\((^\\circ)\\text{C}\\), and the resistance range, in \\(\\Omega\\), that the CVD coefficients are valid. The temperature key must be <code>\"t\"</code> and the resistance key <code>\"r\"</code>.</p> <code>dict()</code> <code>degree_freedom</code> <code>float</code> <p>The degrees of freedom.</p> <code>float('inf')</code> <code>comment</code> <code>str</code> <p>A comment to associate with the CVD equation.</p> <code>''</code>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.A","title":"A  <code>instance-attribute</code>","text":"<pre><code>A: float\n</code></pre> <p>The value, in \\((^\\circ\\text{C})^{-1}\\), of the A coefficient, \\(A \\cdot t\\).</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.B","title":"B  <code>instance-attribute</code>","text":"<pre><code>B: float\n</code></pre> <p>The value, in \\((^\\circ\\text{C})^{-2}\\), of the B coefficient, \\(B \\cdot t^2\\).</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.C","title":"C  <code>instance-attribute</code>","text":"<pre><code>C: float\n</code></pre> <p>The value, in \\((^\\circ\\text{C})^{-4}\\), of the C coefficient, \\(C \\cdot t^3 \\cdot (t-100)\\).</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.D","title":"D  <code>instance-attribute</code>","text":"<pre><code>D: float\n</code></pre> <p>The value, in \\((^\\circ\\text{C})^{-3}\\), of the D coefficient, \\(D \\cdot t^3\\).</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.R0","title":"R0  <code>instance-attribute</code>","text":"<pre><code>R0: float\n</code></pre> <p>The value, in \\(\\Omega\\), of the resistance at \\(0~^\\circ\\text{C}\\), \\(R_0\\).</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.comment","title":"comment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comment: str = ''\n</code></pre> <p>A comment associated with the Callendar-Van Dusen equation.</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.degree_freedom","title":"degree_freedom  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>degree_freedom: float = float('inf')\n</code></pre> <p>The degrees of freedom.</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.ranges","title":"ranges  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ranges: dict[str, Range] = field(default_factory=dict)\n</code></pre> <p>The temperature range, in \\(^\\circ\\text{C}\\), and the resistance range, in \\(\\Omega\\), that the Callendar-Van Dusen coefficients are valid.</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.uncertainty","title":"uncertainty  <code>instance-attribute</code>","text":"<pre><code>uncertainty: Evaluable\n</code></pre> <p>The equation to evaluate to calculate the standard uncertainty.</p>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; CVDEquation\n</code></pre> <p>Convert an XML element into a CVDEquation instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A cvdCoefficients XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>CVDEquation</code> <p>The CVDEquation instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; CVDEquation:\n    \"\"\"Convert an XML element into a [CVDEquation][msl.equipment.schema.CVDEquation] instance.\n\n    Args:\n        element: A [cvdCoefficients][type_cvdCoefficients] XML element\n            from an equipment register.\n\n    Returns:\n        The [CVDEquation][msl.equipment.schema.CVDEquation] instance.\n    \"\"\"\n    # Schema forces order\n    r0 = float(element[0].text or 0)\n    a = float(element[1].text or 0)\n    b = float(element[2].text or 0)\n    c = float(element[3].text or 0)\n    d = float(element[4].text or 0)\n\n    r = element[6]\n    _range = Range(float(r[0].text or -200), float(r[1].text or 661))\n    ranges = {\n        \"t\": _range,\n        \"r\": Range(\n            minimum=round(float(_cvd_resistance(_range.minimum, r0, a, b, c, d)), 3),\n            maximum=round(float(_cvd_resistance(_range.maximum, r0, a, b, c, d)), 3),\n        ),\n    }\n\n    u = element[5]\n    uncertainty = Evaluable(\n        equation=u.text or \"\",\n        variables=tuple(u.attrib[\"variables\"].split()),\n        ranges=ranges,\n    )\n\n    return cls(\n        R0=r0,\n        A=a,\n        B=b,\n        C=c,\n        D=d,\n        uncertainty=uncertainty,\n        ranges=ranges,\n        degree_freedom=float(element[7].text or np.inf) if len(element) &gt; 7 else np.inf,  # noqa: PLR2004\n        comment=element.attrib.get(\"comment\", \"\"),\n    )\n</code></pre>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.resistance","title":"resistance","text":"<pre><code>resistance(\n    temperature: ArrayLike, *, check_range: bool = True\n) -&gt; NDArray[float64]\n</code></pre> <p>Calculate resistance from temperature.</p> <p>Parameters:</p> Name Type Description Default <code>temperature</code> <code>ArrayLike</code> <p>The temperature values, in \\(^\\circ\\text{C}\\).</p> required <code>check_range</code> <code>bool</code> <p>Whether to check that the temperature values are within the allowed range.</p> <code>True</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The resistance values.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def resistance(self, temperature: ArrayLike, *, check_range: bool = True) -&gt; NDArray[np.float64]:\n    r\"\"\"Calculate resistance from temperature.\n\n    Args:\n        temperature: The temperature values, in $^\\circ\\text{C}$.\n        check_range: Whether to check that the temperature values are within the allowed range.\n\n    Returns:\n        The resistance values.\n    \"\"\"\n    array = np.asarray(temperature, dtype=float)\n    if check_range and self.ranges[\"t\"].check_within_range(array):\n        pass  # check_within_range() will raise an error, if one occurred\n\n    return _cvd_resistance(array, self.R0, self.A, self.B, self.C, self.D)\n</code></pre>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.temperature","title":"temperature","text":"<pre><code>temperature(\n    resistance: ArrayLike, *, check_range: bool = True\n) -&gt; NDArray[float64]\n</code></pre> <p>Calculate temperature from resistance.</p> <p>Parameters:</p> Name Type Description Default <code>resistance</code> <code>ArrayLike</code> <p>The resistance values, in \\(\\Omega\\).</p> required <code>check_range</code> <code>bool</code> <p>Whether to check that the resistance values are within the allowed range.</p> <code>True</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The temperature values.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def temperature(self, resistance: ArrayLike, *, check_range: bool = True) -&gt; NDArray[np.float64]:\n    r\"\"\"Calculate temperature from resistance.\n\n    Args:\n        resistance: The resistance values, in $\\Omega$.\n        check_range: Whether to check that the resistance values are within the allowed range.\n\n    Returns:\n        The temperature values.\n    \"\"\"\n    array: NDArray[np.float64] = np.asarray(resistance, dtype=float)\n    if check_range and self.ranges[\"r\"].check_within_range(array):\n        pass  # check_within_range raised an error, if one occurred\n\n    def positive_quadratic(r: NDArray[np.float64]) -&gt; NDArray[np.float64]:\n        # rearrange CVD equation to be: a*x^2 + b*x + c = 0\n        #   a -&gt; B, b -&gt; A, c -&gt; 1 - R/R0\n        # then use the quadratic formula\n        return (-self.A + np.sqrt(self.A**2 - 4.0 * self.B * (1.0 - r / self.R0))) / (2.0 * self.B)\n\n    def positive_cubic(r: NDArray[np.float64]) -&gt; NDArray[np.float64]:\n        # rearrange CVD equation to be: a*x^3 + b*x^2 + c*x + d = 0\n        a = self.D\n        b = self.B\n        c = self.A\n        d = 1.0 - (r / self.R0)\n\n        # then use Cardano's Formula\n        # https://proofwiki.org/wiki/Cardano's_Formula#Real_Coefficients\n        Q: float = (3.0 * a * c - b**2) / (9.0 * a**2)  # noqa: N806\n        R: NDArray[np.float64] = (9.0 * a * b * c - 27.0 * a**2 * d - 2.0 * b**3) / (54.0 * a**3)  # noqa: N806\n        sqrt: NDArray[np.float64] = np.sqrt(Q**3 + R**2)\n        S: NDArray[np.float64] = np.cbrt(R + sqrt)  # noqa: N806\n        T: NDArray[np.float64] = np.cbrt(R - sqrt)  # noqa: N806\n        return S + T - (b / (3.0 * a))  # x1 equation\n\n    def negative(r: NDArray[np.float64]) -&gt; NDArray[np.float64]:\n        # rearrange CVD equation to be: a*x^4 + b*x^3 + c*x^2 + d*x + e = 0\n        a = self.C\n        b = -100.0 * self.C\n        c = self.B\n        d = self.A\n        e = 1.0 - (r / self.R0)\n\n        # https://en.wikipedia.org/wiki/Quartic_function#Solving_a_quartic_equation]\n        # See Section \"General formula for roots\" for the definitions of these variables\n        p = (8 * a * c - 3 * b**2) / (8 * a**2)\n        q = (b**3 - 4 * a * b * c + 8 * a**2 * d) / (8 * a**3)\n        delta_0 = c**2 - 3 * b * d + 12 * a * e\n        delta_1 = 2 * c**3 - 9 * b * c * d + 27 * b**2 * e + 27 * a * d**2 - 72 * a * c * e\n        Q = np.cbrt((delta_1 + np.sqrt(delta_1**2 - 4 * delta_0**3)) / 2)  # noqa: N806\n        S = 0.5 * np.sqrt(-2 * p / 3 + 1 / (3 * a) * (Q + delta_0 / Q))  # noqa: N806\n\n        # decide which root of the quartic to use by looking at the value under the\n        # square root in the x1,2 and x3,4 equations\n        t1 = -4 * S**2 - 2 * p\n        t2 = q / S\n        t3 = t1 - t2\n        return np.piecewise(\n            t3,\n            [t3 &gt;= 0, t3 &lt; 0],\n            [\n                lambda x: -b / (4.0 * a) + S - 0.5 * np.sqrt(x),  # x4 equation\n                lambda x: -b / (4.0 * a) - S + 0.5 * np.sqrt(x + 2.0 * t2),  # x1 equation\n            ],\n        )\n\n    positive = positive_quadratic if self.D == 0 else positive_cubic\n    return np.piecewise(array, [array &lt; self.R0, array &gt;= self.R0], [negative, positive])\n</code></pre>"},{"location":"schema/cvd_equation/#msl.equipment.schema.CVDEquation.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the CVDEquation class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The CVDEquation as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [CVDEquation][msl.equipment.schema.CVDEquation] class into an XML element.\n\n    Returns:\n        The [CVDEquation][msl.equipment.schema.CVDEquation] as an XML element.\n    \"\"\"\n    attrib = {\"comment\": self.comment} if self.comment else {}\n    e = Element(\"cvdCoefficients\", attrib=attrib)\n\n    r0 = SubElement(e, \"R0\")\n    r0.text = str(self.R0)\n\n    a = SubElement(e, \"A\")\n    a.text = str(self.A)\n\n    b = SubElement(e, \"B\")\n    b.text = str(self.B)\n\n    c = SubElement(e, \"C\")\n    c.text = str(self.C)\n\n    d = SubElement(e, \"D\")\n    d.text = str(self.D)\n\n    u = SubElement(e, \"uncertainty\", attrib={\"variables\": \" \".join(self.uncertainty.variables)})\n    u.text = str(self.uncertainty.equation)\n\n    rng = SubElement(e, \"range\")\n    mn = SubElement(rng, \"minimum\")\n    mn.text = str(self.ranges[\"t\"].minimum)\n    mx = SubElement(rng, \"maximum\")\n    mx.text = str(self.ranges[\"t\"].maximum)\n\n    if not isinf(self.degree_freedom):\n        dof = SubElement(e, \"degreeFreedom\")\n        dof.text = str(self.degree_freedom)\n\n    return e\n</code></pre>"},{"location":"schema/deserialised/","title":"Deserialised","text":""},{"location":"schema/deserialised/#msl.equipment.schema.Deserialised","title":"Deserialised  <code>dataclass</code>","text":"<pre><code>Deserialised(value: Any, comment: str = '')\n</code></pre> <p>Represents the opposite of the serialised element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value of the deserialised object.</p> required <code>comment</code> <code>str</code> <p>A comment to associate with the (de)serialised object.</p> <code>''</code>"},{"location":"schema/deserialised/#msl.equipment.schema.Deserialised.comment","title":"comment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comment: str = ''\n</code></pre> <p>A comment associated with the (de)serialised object.</p>"},{"location":"schema/deserialised/#msl.equipment.schema.Deserialised.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: Any\n</code></pre> <p>The value of the deserialised object. For example, an Archive object from GTC.</p>"},{"location":"schema/deserialised/#msl.equipment.schema.Deserialised.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Deserialised\n</code></pre> <p>Convert a serialised XML element into a Deserialised instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A serialised XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Deserialised</code> <p>The Deserialised instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Deserialised:\n    \"\"\"Convert a [serialised][type_serialised] XML element into a [Deserialised][msl.equipment.schema.Deserialised] instance.\n\n    Args:\n        element: A [serialised][type_serialised] XML element from an equipment register.\n\n    Returns:\n        The [Deserialised][msl.equipment.schema.Deserialised] instance.\n    \"\"\"  # noqa: E501\n    e = element[0]\n    comment = element.attrib.get(\"comment\", \"\")\n\n    # GTC is not required for msl-equipment, so we import it here\n    if e.tag.endswith(\"gtcArchive\"):\n        from GTC.xml_format import (  # type: ignore[import-untyped]  # pyright: ignore[reportMissingTypeStubs]  # noqa: PLC0415\n            xml_to_archive,  # pyright: ignore[reportUnknownVariableType]\n        )\n\n        return cls(value=xml_to_archive(e), comment=comment)\n\n    if e.tag.endswith(\"gtcArchiveJSON\"):\n        from GTC import (  # type: ignore[import-untyped]  # pyright: ignore[reportMissingTypeStubs]  # noqa: PLC0415\n            pr,  # pyright: ignore[reportUnknownVariableType]\n        )\n\n        return cls(value=pr.loads_json(e.text), comment=comment)  # pyright: ignore[reportUnknownMemberType]\n\n    # Use the Element object rather than raising an exception that the deserializer has not been implemented yet\n    return cls(value=e, comment=comment)\n</code></pre>"},{"location":"schema/deserialised/#msl.equipment.schema.Deserialised.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Deserialised class into a serialised XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The serialised XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Deserialised][msl.equipment.schema.Deserialised] class into a [serialised][type_serialised] XML element.\n\n    Returns:\n        The [serialised][type_serialised] XML element.\n    \"\"\"  # noqa: E501\n    attrib = {\"comment\": self.comment} if self.comment else {}\n    e = Element(\"serialised\", attrib=attrib)\n\n    if isinstance(self.value, Element):\n        e.append(self.value)  # pyright: ignore[reportUnknownMemberType, reportUnknownArgumentType]\n        return e\n\n    # Currently, only a GTC Archive is supported so we don't need to check how to serialise it\n    # GTC is not required for msl-equipment, so we import it here\n    from GTC.persistence import (  # type: ignore[import-untyped]  # pyright: ignore[reportMissingTypeStubs]  # noqa: PLC0415\n        Archive,  # pyright: ignore[reportUnknownVariableType]\n    )\n    from GTC.xml_format import (  # pyright: ignore[reportMissingTypeStubs]  # noqa: PLC0415\n        archive_to_xml,  # pyright: ignore[reportUnknownVariableType]\n    )\n\n    e.append(archive_to_xml(Archive.copy(self.value)))  # pyright: ignore[reportUnknownArgumentType, reportUnknownMemberType]\n    return e\n</code></pre>"},{"location":"schema/digital_report/","title":"DigitalReport","text":""},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport","title":"DigitalReport  <code>dataclass</code>","text":"<pre><code>DigitalReport(\n    url: str,\n    format: DigitalFormat,\n    id: str,\n    sha256: str,\n    attributes: dict[str, str] = dict(),\n    comment: str = \"\",\n)\n</code></pre> <p>Represents the digitalReport element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The location of the digital report. The syntax follows RFC 1738 <code>scheme:scheme-specific-part</code>. If <code>scheme:</code> is not specified, it is assumed to be <code>file:</code>.</p> required <code>format</code> <code>DigitalFormat</code> <p>The format of the digital calibration report.</p> required <code>id</code> <code>str</code> <p>The report identification number.</p> required <code>sha256</code> <code>str</code> <p>The SHA-256 checksum of the digital report.</p> required <code>attributes</code> <code>dict[str, str]</code> <p>XML attributes associated with the <code>&lt;url&gt;</code> element.</p> <code>dict()</code> <code>comment</code> <code>str</code> <p>A comment to associate with the digital report.</p> <code>''</code>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.attributes","title":"attributes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attributes: dict[str, str] = field(default_factory=dict)\n</code></pre> <p>XML attributes associated with the <code>&lt;url&gt;</code> element.</p>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.comment","title":"comment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comment: str = ''\n</code></pre> <p>A comment associated with the digital report.</p>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.format","title":"format  <code>instance-attribute</code>","text":"<pre><code>format: DigitalFormat\n</code></pre> <p>The format of the digital calibration report.</p>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>The report identification number.</p>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.scheme","title":"scheme  <code>property</code>","text":"<pre><code>scheme: str\n</code></pre> <p>Returns the scheme component that is specified in the url (see RFC 1738 for more details).</p> <p>If a <code>&lt;scheme&gt;</code> is not specified, an empty string is returned (which shall be treated as the <code>file</code> scheme). Drive letters on Windows are not considered as a scheme.</p>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.sha256","title":"sha256  <code>instance-attribute</code>","text":"<pre><code>sha256: str\n</code></pre> <p>The SHA-256 checksum of the digital report.</p>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: str\n</code></pre> <p>The location of the digital report.</p> <p>The syntax follows RFC 1738 <code>&lt;scheme&gt;:&lt;scheme-specific-part&gt;</code>. If <code>&lt;scheme&gt;</code> is not specified, it shall be treated as the <code>file</code> scheme.</p> <p>See Also</p> <p>scheme</p>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; DigitalReport\n</code></pre> <p>Convert an XML element into a DigitalReport instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A digitalReport XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>DigitalReport</code> <p>The DigitalReport instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; DigitalReport:\n    \"\"\"Convert an XML element into a [DigitalReport][msl.equipment.schema.DigitalReport] instance.\n\n    Args:\n        element: A [digitalReport][type_digitalReport] XML element from an equipment register.\n\n    Returns:\n        The [DigitalReport][msl.equipment.schema.DigitalReport] instance.\n    \"\"\"\n    # Schema forces order\n    return cls(\n        url=element[0].text or \"\",\n        format=DigitalFormat(element.attrib[\"format\"]),\n        id=element.attrib[\"id\"],\n        sha256=element[1].text or \"\",\n        attributes=element[0].attrib,\n        comment=element.attrib.get(\"comment\", \"\"),\n    )\n</code></pre>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalReport.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the DigitalReport class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The DigitalReport as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [DigitalReport][msl.equipment.schema.DigitalReport] class into an XML element.\n\n    Returns:\n        The [DigitalReport][msl.equipment.schema.DigitalReport] as an XML element.\n    \"\"\"\n    attrib = {\"format\": self.format.value, \"id\": self.id}\n    if self.comment:\n        attrib[\"comment\"] = self.comment\n    e = Element(\"digitalReport\", attrib=attrib)\n    url = SubElement(e, \"url\", attrib=self.attributes)\n    url.text = self.url\n    sha256 = SubElement(e, \"sha256\")\n    sha256.text = self.sha256\n    return e\n</code></pre>"},{"location":"schema/digital_report/#msl.equipment.schema.DigitalFormat","title":"DigitalFormat","text":"<p>               Bases: <code>Enum</code></p> <p>Represents the digitalFormatEnumerationString enumeration in an equipment register.</p> <p>Attributes:</p> Name Type Description <code>MSL_PDF</code> <code>str</code> <p><code>\"MSL PDF/A-3\"</code> (MSL's PDF/A-3 format).</p> <code>PTB_DCC</code> <code>str</code> <p><code>\"PTB DCC\"</code> (PTB's Digital Calibration Certificate).</p>"},{"location":"schema/equation/","title":"Equation","text":"<p>Suppose you have a variable named <code>equation</code> (which is an instance of Equation) that represents the following information in an equipment register for equipment that measures relative humidity. The corrected value depends on two variables (<code>r</code> and <code>t</code>) and the standard uncertainty is a constant.</p> <pre><code>&lt;equation&gt;\n  &lt;value variables=\"r t\"&gt;r-0.71-0.04*r+3.4e-4*pow(r,2)+2.4e-3*t+1.3e-3*r*t&lt;/value&gt;\n  &lt;uncertainty variables=\"\"&gt;0.355&lt;/uncertainty&gt;\n  &lt;unit&gt;%rh&lt;/unit&gt;\n  &lt;ranges&gt;\n    &lt;range variable=\"r\"&gt;\n      &lt;minimum&gt;30&lt;/minimum&gt;\n      &lt;maximum&gt;80&lt;/maximum&gt;\n    &lt;/range&gt;\n    &lt;range variable=\"t\"&gt;\n      &lt;minimum&gt;15&lt;/minimum&gt;\n      &lt;maximum&gt;25&lt;/maximum&gt;\n    &lt;/range&gt;\n  &lt;/ranges&gt;\n&lt;/equation&gt;\n</code></pre> <p>You can access the unit, degrees of freedom and comment as attributes of <code>equation</code>.</p> <pre><code>&gt;&gt;&gt; equation.unit\n'%rh'\n&gt;&gt;&gt; equation.degree_freedom\ninf\n&gt;&gt;&gt; equation.comment\n''\n</code></pre> <p>To evaluate an equation, call the appropriate attribute with the variable(s) that are required to evaluate the equation.</p> <pre><code>&gt;&gt;&gt; equation.value.variables\n('r', 't')\n&gt;&gt;&gt; equation.uncertainty.variables\n()\n&gt;&gt;&gt; assert equation.value(r=50.3, t=20.4) == 49.8211466\n&gt;&gt;&gt; assert equation.uncertainty() == 0.355\n</code></pre> <p>Tip</p> <p>If the equation contains a single variable, you do not need to specify the variable name as a keyword argument. For example, if the above equation only depended on <code>t</code> you could evaluate it using <code>equation.value(20.4)</code> or <code>equation.value(t=20.4)</code> since these function calls are equivalent.</p> <p>A variable can have multiple values. Any sequence of numbers, i.e., a list, tuple, ndarray, etc., may be used (tip: using ndarray will improve performance since a copy of the values is not required),</p> <pre><code>&gt;&gt;&gt; equation.value(r=[50.3, 52.1, 48.7], t=[20.4, 19.7, 20.0])\narray([49.8211466, 51.6104604, 48.1625746])\n</code></pre> <p>the values of the variables do not need to be 1-dimensional arrays,</p> <pre><code>&gt;&gt;&gt; equation.value(r=[(50.3, 52.1), (48.7, 47.9)], t=[(20.4, 19.7), (20.0, 19.6)])\narray([[49.8211466, 51.6104604],\n       [48.1625746, 47.3216314]])\n</code></pre> <p>and the array broadcasting rules of numpy also apply, i.e., multiple <code>r</code> values and a single <code>t</code> value.</p> <pre><code>&gt;&gt;&gt; equation.value(r=(50.3, 52.1, 48.7), t=20.4)\narray([49.8211466, 51.6595514, 48.1888586])\n</code></pre> <p>If you forget to specify a variable (in the following case, <code>t</code>) a NameError will be raised,</p> <pre><code>&gt;&gt;&gt; equation.value(r=50.3)\nTraceback (most recent call last):\n...\nNameError: name 't' is not defined\n</code></pre> <p>however, if you specify more variables than are required to evaluate the equation, the additional variables are ignored.</p> <pre><code>&gt;&gt;&gt; equation.uncertainty(r=50.3, t=20.4)\narray(0.355)\n</code></pre> <p>Notice in the last returned value that the result was printed as <code>array(0.355)</code> even though a single <code>r</code> and <code>t</code> value was specified (although these variables were ignored in this particular example, since the standard uncertainty is a constant, the principle remains the same if they were not ignored). All evaluated returned types are an instance of a numpy ndarray even if a single value is specified. These particular returned array instances are referred to as 0-dimensional array scalars in numpy terminology.</p> <p>When evaluating an equation, the value(s) of the input variables are checked to ensure that the value(s) are within the ranges that the equation is valid for. The XML data above shows that the temperature, <code>t</code>, value must be in the range <code>15</code> to <code>25</code>. If you evaluate the corrected value at <code>t=30</code> a ValueError is raised.</p> <pre><code>&gt;&gt;&gt; equation.value.ranges\n{'r': Range(minimum=30, maximum=80), 't': Range(minimum=15, maximum=25)}\n&gt;&gt;&gt; equation.value(r=50.3, t=30)\nTraceback (most recent call last):\n...\nValueError: The value 30.0 is not within the range [15, 25]\n</code></pre> <p>You can bypass range checking by including a <code>check_range=False</code> keyword argument</p> <pre><code>&gt;&gt;&gt; equation.value(r=50.3, t=30, check_range=False)\narray(50.4719306)\n</code></pre>"},{"location":"schema/equation/#msl.equipment.schema.Equation","title":"Equation  <code>dataclass</code>","text":"<pre><code>Equation(\n    value: Evaluable,\n    uncertainty: Evaluable,\n    unit: str,\n    degree_freedom: float = float(\"inf\"),\n    comment: str = \"\",\n)\n</code></pre> <p>Represents the equation element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Evaluable</code> <p>The equation to evaluate to calculate the corrected value.</p> required <code>uncertainty</code> <code>Evaluable</code> <p>The equation to evaluate to calculate the standard uncertainty.</p> required <code>unit</code> <code>str</code> <p>The unit of the measured quantity.</p> required <code>degree_freedom</code> <code>float</code> <p>The degrees of freedom.</p> <code>float('inf')</code> <code>comment</code> <code>str</code> <p>A comment to associate with the equation.</p> <code>''</code>"},{"location":"schema/equation/#msl.equipment.schema.Equation.comment","title":"comment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comment: str = ''\n</code></pre> <p>A comment associated with the equation.</p>"},{"location":"schema/equation/#msl.equipment.schema.Equation.degree_freedom","title":"degree_freedom  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>degree_freedom: float = float('inf')\n</code></pre> <p>The degrees of freedom.</p>"},{"location":"schema/equation/#msl.equipment.schema.Equation.uncertainty","title":"uncertainty  <code>instance-attribute</code>","text":"<pre><code>uncertainty: Evaluable\n</code></pre> <p>The equation to evaluate to calculate the standard uncertainty.</p>"},{"location":"schema/equation/#msl.equipment.schema.Equation.unit","title":"unit  <code>instance-attribute</code>","text":"<pre><code>unit: str\n</code></pre> <p>The unit of the measured quantity.</p>"},{"location":"schema/equation/#msl.equipment.schema.Equation.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: Evaluable\n</code></pre> <p>The equation to evaluate to calculate the corrected value.</p>"},{"location":"schema/equation/#msl.equipment.schema.Equation.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Equation\n</code></pre> <p>Convert an XML element into an Equation instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An equation XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Equation</code> <p>The Equation instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Equation:\n    \"\"\"Convert an XML element into an [Equation][msl.equipment.schema.Equation] instance.\n\n    Args:\n        element: An [equation][type_equation] XML element from an equipment register.\n\n    Returns:\n        The [Equation][msl.equipment.schema.Equation] instance.\n    \"\"\"\n    # Schema forces order\n    value = element[0]\n    uncertainty = element[1]\n    ranges = {\n        r.attrib[\"variable\"]: Range(minimum=float(r[0].text or -np.inf), maximum=float(r[1].text or np.inf))\n        for r in element[3]\n    }\n\n    return cls(\n        value=Evaluable(\n            equation=value.text or \"\", variables=tuple(value.attrib[\"variables\"].split()), ranges=ranges\n        ),\n        uncertainty=Evaluable(\n            equation=uncertainty.text or \"\", variables=tuple(uncertainty.attrib[\"variables\"].split()), ranges=ranges\n        ),\n        unit=element[2].text or \"\",\n        degree_freedom=float(element[4].text or np.inf) if len(element) &gt; 4 else np.inf,  # noqa: PLR2004\n        comment=element.attrib.get(\"comment\", \"\"),\n    )\n</code></pre>"},{"location":"schema/equation/#msl.equipment.schema.Equation.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Equation class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Equation as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Equation][msl.equipment.schema.Equation] class into an XML element.\n\n    Returns:\n        The [Equation][msl.equipment.schema.Equation] as an XML element.\n    \"\"\"\n    attrib = {\"comment\": self.comment} if self.comment else {}\n    e = Element(\"equation\", attrib=attrib)\n    value = SubElement(e, \"value\", attrib={\"variables\": \" \".join(self.value.variables)})\n    value.text = self.value.equation\n    uncertainty = SubElement(e, \"uncertainty\", attrib={\"variables\": \" \".join(self.uncertainty.variables)})\n    uncertainty.text = self.uncertainty.equation\n    unit = SubElement(e, \"unit\")\n    unit.text = self.unit\n\n    ranges = SubElement(e, \"ranges\")\n    for name, _range in self.value.ranges.items():  # self.value.ranges and self.uncertainty.ranges are the same\n        rng = SubElement(ranges, \"range\", attrib={\"variable\": name})\n        mn = SubElement(rng, \"minimum\")\n        mn.text = str(_range.minimum)\n        mx = SubElement(rng, \"maximum\")\n        mx.text = str(_range.maximum)\n\n    if not isinf(self.degree_freedom):\n        dof = SubElement(e, \"degreeFreedom\")\n        dof.text = str(self.degree_freedom)\n\n    return e\n</code></pre>"},{"location":"schema/equation/#msl.equipment.schema.Evaluable","title":"Evaluable  <code>dataclass</code>","text":"<pre><code>Evaluable(\n    equation: str,\n    variables: tuple[str, ...] = (),\n    ranges: dict[str, Range] = dict(),\n)\n</code></pre> <p>Represents the <code>&lt;value&gt;</code> and <code>&lt;uncertainty&gt;</code> XML elements in an equation.</p> <p>Parameters:</p> Name Type Description Default <code>equation</code> <code>str</code> <p>The string representation of the equation to evaluate.</p> required <code>variables</code> <code>tuple[str, ...]</code> <p>The names of the variables in the equation.</p> <code>()</code> <code>ranges</code> <code>dict[str, Range]</code> <p>The numeric range for a variable that the <code>equation</code> is valid for. The keys are the variable names. A range does not need to be defined for every variable. If a range is not defined then a range of \\([-\\infty, +\\infty]\\) is assumed.</p> <code>dict()</code>"},{"location":"schema/equation/#msl.equipment.schema.Evaluable.equation","title":"equation  <code>instance-attribute</code>","text":"<pre><code>equation: str\n</code></pre> <p>The string representation of the equation to evaluate.</p>"},{"location":"schema/equation/#msl.equipment.schema.Evaluable.ranges","title":"ranges  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ranges: dict[str, Range] = field(default_factory=dict)\n</code></pre> <p>The numeric range for each variable that the <code>equation</code> is valid for. The keys are the variable names.</p>"},{"location":"schema/equation/#msl.equipment.schema.Evaluable.variables","title":"variables  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variables: tuple[str, ...] = ()\n</code></pre> <p>The names of the variables in the equation.</p>"},{"location":"schema/equation/#msl.equipment.schema.Range","title":"Range","text":"<p>               Bases: <code>NamedTuple</code></p> <p>The numeric range of a variable that an equation is valid for.</p> <p>Parameters:</p> Name Type Description <code>minimum</code> <code>float</code> <p>Minimum value in range.</p> <code>maximum</code> <code>float</code> <p>Maximum value in range.</p>"},{"location":"schema/equation/#msl.equipment.schema.Range.maximum","title":"maximum  <code>instance-attribute</code>","text":"<pre><code>maximum: float\n</code></pre> <p>Maximum value in range.</p>"},{"location":"schema/equation/#msl.equipment.schema.Range.minimum","title":"minimum  <code>instance-attribute</code>","text":"<pre><code>minimum: float\n</code></pre> <p>Minimum value in range.</p>"},{"location":"schema/equation/#msl.equipment.schema.Range.check_within_range","title":"check_within_range","text":"<pre><code>check_within_range(\n    value: float | ArrayLike,\n) -&gt; Literal[True]\n</code></pre> <p>Check that the values are within the range.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float | ArrayLike</code> <p>The values to check, raises</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>Always returns <code>True</code>. Raises ValueError if <code>value</code> is not within the range.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def check_within_range(self, value: float | ArrayLike) -&gt; Literal[True]:\n    \"\"\"Check that the values are within the range.\n\n    Args:\n        value: The values to check, raises\n\n    Returns:\n        Always returns `True`. Raises [ValueError][] if\n            `value` is not within the range.\n    \"\"\"\n    if isinstance(value, (int, float)) or (isinstance(value, np.ndarray) and value.ndim == 0):\n        if value &lt; self.minimum or value &gt; self.maximum:\n            msg = f\"The value {value} is not within the range [{self.minimum}, {self.maximum}]\"\n            raise ValueError(msg)\n    elif np.any(np.less(value, self.minimum)) or np.any(np.greater(value, self.maximum)):  # pyright: ignore[reportUnknownArgumentType]\n        msg = f\"A value in the sequence is not within the range [{self.minimum}, {self.maximum}]\"\n        raise ValueError(msg)\n    return True\n</code></pre>"},{"location":"schema/equipment/","title":"Equipment","text":""},{"location":"schema/equipment/#msl.equipment.schema.Equipment","title":"Equipment  <code>dataclass</code>","text":"<pre><code>Equipment(\n    entered_by: str = \"\",\n    checked_by: str = \"\",\n    checked_date: date | None = None,\n    alias: str = \"\",\n    keywords: tuple[str, ...] = (),\n    id: str = \"\",\n    manufacturer: str = \"\",\n    model: str = \"\",\n    serial: str = \"\",\n    description: str = \"\",\n    specifications: Specifications = Specifications(),\n    location: str = \"\",\n    status: Status = Active,\n    loggable: bool = False,\n    traceable: bool = False,\n    calibrations: tuple[Measurand, ...] = (),\n    maintenance: Maintenance = Maintenance(),\n    alterations: tuple[Alteration, ...] = (),\n    firmware: tuple[Firmware, ...] = (),\n    specified_requirements: SpecifiedRequirements = SpecifiedRequirements(),\n    reference_materials: ReferenceMaterials = ReferenceMaterials(),\n    quality_manual: QualityManual = QualityManual(),\n    connection: Connection | None = None,\n)\n</code></pre> <p>Represents the equipment element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>entered_by</code> <code>str</code> <p>The name of the person who initially entered the <code>&lt;equipment&gt;</code> element in the register.</p> <code>''</code> <code>checked_by</code> <code>str</code> <p>The name of the person who checked the information in the <code>&lt;equipment&gt;</code> element.</p> <code>''</code> <code>checked_date</code> <code>date | None</code> <p>The date that the information in the <code>&lt;equipment&gt;</code> element was last checked.</p> <code>None</code> <code>alias</code> <code>str</code> <p>An alternative name to associate with the equipment.</p> <code>''</code> <code>keywords</code> <code>tuple[str, ...]</code> <p>Keywords that describe the equipment.</p> <code>()</code> <code>id</code> <code>str</code> <p>Identity in an equipment register.</p> <code>''</code> <code>manufacturer</code> <code>str</code> <p>Name of manufacturer.</p> <code>''</code> <code>model</code> <code>str</code> <p>Manufacturer's model number (or type identification).</p> <code>''</code> <code>serial</code> <code>str</code> <p>Manufacturer's serial number (or other unique identification).</p> <code>''</code> <code>description</code> <code>str</code> <p>A short description about the equipment.</p> <code>''</code> <code>specifications</code> <code>Specifications</code> <p>Specifications provided by the manufacturer of the equipment.</p> <code>Specifications()</code> <code>location</code> <code>str</code> <p>The usual location (laboratory) that the equipment is found in.</p> <code>''</code> <code>status</code> <code>Status</code> <p>The status of the equipment is an indication of whether the equipment is active (in use) or inactive (not in use).</p> <code>Active</code> <code>loggable</code> <code>bool</code> <p>Whether measurements from the equipment should be logged. Equipment that monitor (for example) pressure, temperature or humidity of a laboratory environment are considered as loggable.</p> <code>False</code> <code>traceable</code> <code>bool</code> <p>Whether the equipment is used for a traceable measurement.</p> <code>False</code> <code>calibrations</code> <code>tuple[Measurand, ...]</code> <p>The calibration history.</p> <code>()</code> <code>maintenance</code> <code>Maintenance</code> <p>The maintenance history and maintenance plan.</p> <code>Maintenance()</code> <code>alterations</code> <code>tuple[Alteration, ...]</code> <p>The alteration history.</p> <code>()</code> <code>firmware</code> <code>tuple[Firmware, ...]</code> <p>The firmware version history.</p> <code>()</code> <code>specified_requirements</code> <code>SpecifiedRequirements</code> <p>Verification that equipment conforms with specified requirements before being placed or returned into service.</p> <code>SpecifiedRequirements()</code> <code>reference_materials</code> <code>ReferenceMaterials</code> <p>Documentation of reference materials, results, acceptance criteria, relevant dates and the period of validity.</p> <code>ReferenceMaterials()</code> <code>quality_manual</code> <code>QualityManual</code> <p>Information that is specified in Section 4.3.6 of the MSL Quality Manual.</p> <code>QualityManual()</code> <code>connection</code> <code>Connection | None</code> <p>The connection to the equipment for computer control.</p> <code>None</code>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.alias","title":"alias  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alias: str = ''\n</code></pre> <p>An alternative name to associate with the equipment.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.alterations","title":"alterations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alterations: tuple[Alteration, ...] = ()\n</code></pre> <p>The alteration history.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.calibrations","title":"calibrations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>calibrations: tuple[Measurand, ...] = ()\n</code></pre> <p>The calibration history.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.checked_by","title":"checked_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_by: str = ''\n</code></pre> <p>The name of the person who checked the information in the <code>&lt;equipment&gt;</code> element.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.checked_date","title":"checked_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_date: date | None = None\n</code></pre> <p>The date that the information in the <code>&lt;equipment&gt;</code> element was last checked.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.connection","title":"connection  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>connection: Connection | None = None\n</code></pre> <p>The connection to use for computer control.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = ''\n</code></pre> <p>A short description about the equipment.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.entered_by","title":"entered_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entered_by: str = ''\n</code></pre> <p>The name of the person who initially entered the <code>&lt;equipment&gt;</code> element in the register.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.firmware","title":"firmware  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>firmware: tuple[Firmware, ...] = ()\n</code></pre> <p>The firmware version history.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = ''\n</code></pre> <p>Identity in an equipment register.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.keywords","title":"keywords  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keywords: tuple[str, ...] = ()\n</code></pre> <p>Keywords that describe the equipment.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.location","title":"location  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>location: str = ''\n</code></pre> <p>The usual location (laboratory) that the equipment is found in.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.loggable","title":"loggable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>loggable: bool = False\n</code></pre> <p>Whether measurements from the equipment should be logged.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.maintenance","title":"maintenance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>maintenance: Maintenance = field(\n    default_factory=Maintenance\n)\n</code></pre> <p>The maintenance history and maintenance plan.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.manufacturer","title":"manufacturer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>manufacturer: str = ''\n</code></pre> <p>Name of manufacturer.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.model","title":"model  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model: str = ''\n</code></pre> <p>Manufacturer's model number (or type identification).</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.quality_manual","title":"quality_manual  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quality_manual: QualityManual = field(\n    default_factory=QualityManual\n)\n</code></pre> <p>Information that is specified in Section 4.3.6 of the MSL Quality Manual.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.reference_materials","title":"reference_materials  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reference_materials: ReferenceMaterials = field(\n    default_factory=ReferenceMaterials\n)\n</code></pre> <p>Documentation of reference materials, results, acceptance criteria, relevant dates and the period of validity.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.serial","title":"serial  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>serial: str = ''\n</code></pre> <p>Manufacturer's serial number (or other unique identification).</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.specifications","title":"specifications  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>specifications: Specifications = field(\n    default_factory=Specifications\n)\n</code></pre> <p>Specifications provided by the manufacturer of the equipment.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.specified_requirements","title":"specified_requirements  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>specified_requirements: SpecifiedRequirements = field(\n    default_factory=SpecifiedRequirements\n)\n</code></pre> <p>Verification that equipment conforms with specified requirements before being placed or returned into service.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.status","title":"status  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>status: Status = Active\n</code></pre> <p>The status of the equipment is an indication of whether the equipment is active (in use) or inactive (not in use).</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.traceable","title":"traceable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traceable: bool = False\n</code></pre> <p>Whether the equipment is used for a traceable measurement.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.connect","title":"connect","text":"<pre><code>connect() -&gt; Any\n</code></pre> <p>Connect to the equipment for computer control.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def connect(self) -&gt; _Any:  # noqa: ANN401\n    \"\"\"Connect to the equipment for computer control.\"\"\"\n    if self.connection is None:\n        # Cannot simply call super(). Must specify (type, object) since the dataclass uses slots=True\n        super(Equipment, self).__setattr__(\"connection\", connections[self.id])  # noqa: UP008\n        assert self.connection is not None  # noqa: S101\n\n    for backend in backends:\n        if backend.handles(self.connection):\n            return backend.cls(self)\n\n    for resource in resources:\n        if resource.handles(self):\n            return resource.cls(self)\n\n    address = self.connection.address\n    for interface in interfaces:\n        if interface.handles(address):\n            return interface.cls(self)\n\n    msg = f\"Cannot determine the interface from the address {address!r}\"\n    raise ValueError(msg)\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Equipment\n</code></pre> <p>Convert an XML element into an Equipment instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An equipment XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Equipment</code> <p>The Equipment instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Equipment:\n    \"\"\"Convert an XML element into an [Equipment][msl.equipment.schema.Equipment] instance.\n\n    Args:\n        element: An [equipment][type_equipment] XML element from an equipment register.\n\n    Returns:\n        The [Equipment][msl.equipment.schema.Equipment] instance.\n    \"\"\"\n    # Schema forces order\n    a = element.attrib\n    return cls(\n        entered_by=a[\"enteredBy\"],\n        checked_by=a.get(\"checkedBy\", \"\"),\n        checked_date=None if not a.get(\"checkedDate\") else _date.fromisoformat(a[\"checkedDate\"]),\n        alias=a.get(\"alias\", \"\"),\n        keywords=tuple(a.get(\"keywords\", \"\").split()),\n        id=element[0].text or \"\",\n        manufacturer=element[1].text or \"\",\n        model=element[2].text or \"\",\n        serial=element[3].text or \"\",\n        description=element[4].text or \"\",\n        specifications=Specifications.from_xml(element[5]),\n        location=element[6].text or \"\",\n        status=Status(element[7].text),\n        loggable=element[8].text in {\"1\", \"true\"},\n        traceable=element[9].text in {\"1\", \"true\"},\n        calibrations=tuple(Measurand.from_xml(e) for e in element[10]),\n        maintenance=Maintenance.from_xml(element[11]),\n        alterations=tuple(Alteration.from_xml(e) for e in element[12]),\n        firmware=tuple(Firmware.from_xml(e) for e in element[13]),\n        specified_requirements=SpecifiedRequirements.from_xml(element[14]),\n        reference_materials=ReferenceMaterials.from_xml(element[15]),\n        quality_manual=QualityManual.from_xml(element[16]),\n    )\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.latest_performance_check","title":"latest_performance_check","text":"<pre><code>latest_performance_check(\n    *, quantity: str = \"\", name: str = \"\"\n) -&gt; LatestPerformanceCheck | None\n</code></pre> <p>Returns the latest performance check.</p> <p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>str</code> <p>The measurand quantity.</p> <code>''</code> <code>name</code> <code>str</code> <p>The component name.</p> <code>''</code> <p>Returns:</p> Type Description <code>LatestPerformanceCheck | None</code> <p>The LatestPerformanceCheck for the specified <code>quantity</code> and <code>name</code>. If the equipment has only one measurand and only one component then you do not need to specify a value for the <code>quantity</code> and <code>name</code>. Returns <code>None</code> if there are no performance checks that match the <code>quantity</code> and <code>name</code> criteria or if the equipment does not have performance checks entered in the register.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def latest_performance_check(self, *, quantity: str = \"\", name: str = \"\") -&gt; LatestPerformanceCheck | None:\n    \"\"\"Returns the latest performance check.\n\n    Args:\n        quantity: The measurand [quantity][msl.equipment.schema.Measurand.quantity].\n        name: The component [name][msl.equipment.schema.Component.name].\n\n    Returns:\n        The [LatestPerformanceCheck][msl.equipment.schema.LatestPerformanceCheck] for the specified\n            `quantity` and `name`. If the equipment has only one _measurand_ and only one _component_\n            then you do not need to specify a value for the `quantity` and `name`. Returns `None` if\n            there are no performance checks that match the `quantity` and `name` criteria or if\n            the equipment does not have performance checks entered in the register.\n    \"\"\"\n    return _latest(items=list(self.latest_performance_checks()), quantity=quantity, name=name)\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.latest_performance_checks","title":"latest_performance_checks","text":"<pre><code>latest_performance_checks() -&gt; (\n    Iterator[LatestPerformanceCheck]\n)\n</code></pre> <p>Yields the latest performance check for every measurand and component.</p> <p>Yields:</p> Type Description <code>LatestPerformanceCheck</code> <p>The latest performance check.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def latest_performance_checks(self) -&gt; Iterator[LatestPerformanceCheck]:\n    \"\"\"Yields the latest performance check for every _measurand_ and _component_.\n\n    Yields:\n        The latest performance check.\n    \"\"\"\n    default = _date(1875, 5, 20)\n    for m in self.calibrations:\n        for c in m.components:\n            latest = default\n            check: PerformanceCheck | None = None\n            for pc in c.performance_checks:\n                if pc.completed_date &gt; latest:\n                    check = pc\n                    latest = pc.completed_date\n\n            if check is not None:\n                yield LatestPerformanceCheck(\n                    calibration_interval=m.calibration_interval,\n                    name=c.name,\n                    next_calibration_date=_future_date(latest, m.calibration_interval),\n                    quantity=m.quantity,\n                    completed_date=check.completed_date,\n                    competency=check.competency,\n                    entered_by=check.entered_by,\n                    checked_by=check.checked_by,\n                    checked_date=check.checked_date,\n                    conditions=check.conditions,\n                    cvd_equations=check.cvd_equations,\n                    deserialisers=check.deserialisers,\n                    equations=check.equations,\n                    files=check.files,\n                    tables=check.tables,\n                )\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.latest_report","title":"latest_report","text":"<pre><code>latest_report(\n    *,\n    quantity: str = \"\",\n    name: str = \"\",\n    date: Literal[\"issue\", \"start\", \"stop\"] = \"stop\"\n) -&gt; LatestReport | None\n</code></pre> <p>Returns the latest calibration report.</p> <p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>str</code> <p>The measurand quantity.</p> <code>''</code> <code>name</code> <code>str</code> <p>The component name.</p> <code>''</code> <code>date</code> <code>Literal['issue', 'start', 'stop']</code> <p>Which date in a report to use to determine what latest refers to:</p> <ul> <li><code>issue</code>: Report issue date</li> <li><code>start</code>: Measurement start date</li> <li><code>stop</code>: Measurement stop date</li> </ul> <code>'stop'</code> <p>Returns:</p> Type Description <code>LatestReport | None</code> <p>The LatestReport for the specified <code>quantity</code> and <code>name</code>. If the equipment has only one measurand and only one component then you do not need to specify a value for the <code>quantity</code> and <code>name</code>. Returns <code>None</code> if there are no calibration reports that match the <code>quantity</code> and <code>name</code> criteria or if the equipment does not have calibration reports entered in the register.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def latest_report(\n    self, *, quantity: str = \"\", name: str = \"\", date: Literal[\"issue\", \"start\", \"stop\"] = \"stop\"\n) -&gt; LatestReport | None:\n    \"\"\"Returns the latest calibration report.\n\n    Args:\n        quantity: The measurand [quantity][msl.equipment.schema.Measurand.quantity].\n        name: The component [name][msl.equipment.schema.Component.name].\n        date: Which date in a report to use to determine what _latest_ refers to:\n\n            * `issue`: Report issue date\n            * `start`: Measurement start date\n            * `stop`: Measurement stop date\n\n    Returns:\n        The [LatestReport][msl.equipment.schema.LatestReport] for the specified `quantity` and `name`.\n            If the equipment has only one _measurand_ and only one _component_ then you do not need\n            to specify a value for the `quantity` and `name`. Returns `None` if there are no calibration\n            reports that match the `quantity` and `name` criteria or if the equipment does not have\n            calibration reports entered in the register.\n    \"\"\"\n    return _latest(items=list(self.latest_reports(date=date)), quantity=quantity, name=name)\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.latest_reports","title":"latest_reports","text":"<pre><code>latest_reports(\n    date: Literal[\"issue\", \"start\", \"stop\"] = \"stop\",\n) -&gt; Iterator[LatestReport]\n</code></pre> <p>Yields the latest calibration report for every measurand and component.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>Literal['issue', 'start', 'stop']</code> <p>Which date in a report to use to determine what latest refers to:</p> <ul> <li><code>issue</code>: Report issue date</li> <li><code>start</code>: Measurement start date</li> <li><code>stop</code>: Measurement stop date</li> </ul> <code>'stop'</code> <p>Yields:</p> Type Description <code>LatestReport</code> <p>The latest calibration report.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def latest_reports(self, date: Literal[\"issue\", \"start\", \"stop\"] = \"stop\") -&gt; Iterator[LatestReport]:\n    \"\"\"Yields the latest calibration report for every _measurand_ and _component_.\n\n    Args:\n        date: Which date in a report to use to determine what _latest_ refers to:\n\n            * `issue`: Report issue date\n            * `start`: Measurement start date\n            * `stop`: Measurement stop date\n\n    Yields:\n        The latest calibration report.\n    \"\"\"\n    default = _date(1875, 5, 20)\n    for m in self.calibrations:\n        for c in m.components:\n            latest = default\n            report: Report | None = None\n            for r in c.reports:\n                if date == \"stop\":\n                    if r.measurement_stop_date &gt; latest:\n                        report = r\n                        latest = r.measurement_stop_date\n                elif date == \"start\":\n                    if r.measurement_start_date &gt; latest:\n                        report = r\n                        latest = r.measurement_start_date\n                elif r.report_issue_date &gt; latest:\n                    report = r\n                    latest = r.report_issue_date\n\n            if report is not None:\n                yield LatestReport(\n                    calibration_interval=m.calibration_interval,\n                    name=c.name,\n                    next_calibration_date=_future_date(latest, m.calibration_interval),\n                    quantity=m.quantity,\n                    id=report.id,\n                    report_issue_date=report.report_issue_date,\n                    measurement_start_date=report.measurement_start_date,\n                    measurement_stop_date=report.measurement_stop_date,\n                    issuing_laboratory=report.issuing_laboratory,\n                    technical_procedure=report.technical_procedure,\n                    entered_by=report.entered_by,\n                    checked_by=report.checked_by,\n                    checked_date=report.checked_date,\n                    conditions=report.conditions,\n                    acceptance_criteria=report.acceptance_criteria,\n                    cvd_equations=report.cvd_equations,\n                    deserialisers=report.deserialisers,\n                    equations=report.equations,\n                    files=report.files,\n                    tables=report.tables,\n                )\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Equipment.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Equipment class into an XML element.</p> <p>The connection attribute is not included as an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Equipment as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Equipment][msl.equipment.schema.Equipment] class into an XML element.\n\n    The [connection][msl.equipment.schema.Equipment.connection] attribute is not included\n    as an XML element.\n\n    Returns:\n        The [Equipment][msl.equipment.schema.Equipment] as an XML element.\n    \"\"\"\n    a = {\"enteredBy\": self.entered_by}\n    if self.checked_by:\n        a[\"checkedBy\"] = self.checked_by\n    if self.checked_date is not None:\n        a[\"checkedDate\"] = self.checked_date.isoformat()\n    if self.alias:\n        a[\"alias\"] = self.alias\n    if self.keywords:\n        a[\"keywords\"] = \" \".join(self.keywords)\n\n    e = Element(\"equipment\", attrib=a)\n\n    _id = SubElement(e, \"id\")\n    _id.text = self.id\n\n    manufacturer = SubElement(e, \"manufacturer\")\n    manufacturer.text = self.manufacturer\n\n    model = SubElement(e, \"model\")\n    model.text = self.model\n\n    serial = SubElement(e, \"serial\")\n    serial.text = self.serial\n\n    description = SubElement(e, \"description\")\n    description.text = self.description\n\n    e.append(self.specifications)\n\n    location = SubElement(e, \"location\")\n    location.text = self.location\n\n    status = SubElement(e, \"status\")\n    status.text = self.status.value\n\n    loggable = SubElement(e, \"loggable\")\n    loggable.text = \"true\" if self.loggable else \"false\"\n\n    traceable = SubElement(e, \"traceable\")\n    traceable.text = \"true\" if self.traceable else \"false\"\n\n    calibrations = SubElement(e, \"calibrations\")\n    calibrations.extend(c.to_xml() for c in self.calibrations)\n\n    e.append(self.maintenance.to_xml())\n\n    alterations = SubElement(e, \"alterations\")\n    alterations.extend(a.to_xml() for a in self.alterations)\n\n    firmware = SubElement(e, \"firmware\")\n    firmware.extend(f.to_xml() for f in self.firmware)\n\n    e.append(self.specified_requirements)\n    e.append(self.reference_materials)\n    e.append(self.quality_manual.to_xml())\n    return e\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.Latest","title":"Latest  <code>dataclass</code>","text":"<pre><code>Latest(\n    calibration_interval: float = 0.0,\n    name: str = \"\",\n    next_calibration_date: date = date(1875, 5, 20),\n    quantity: str = \"\",\n)\n</code></pre> <p>Base class for LatestReport and LatestPerformanceCheck.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Latest.calibration_interval","title":"calibration_interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>calibration_interval: float = 0.0\n</code></pre> <p>The number of years that may pass between a calibration or a performance check.</p> <p>For equipment that do not have a required and periodic interval, but are calibrated on demand, the value is <code>0</code>.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Latest.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = ''\n</code></pre> <p>The Component name.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Latest.next_calibration_date","title":"next_calibration_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_calibration_date: date = date(1875, 5, 20)\n</code></pre> <p>The date that the equipment is due for a re-calibration.</p> <p>If the calibration_interval is <code>0</code>, i.e., the equipment is calibrated on demand, this date is equal to the date that the equipment was last calibrated.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Latest.quantity","title":"quantity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quantity: str = ''\n</code></pre> <p>The Measurand quantity.</p>"},{"location":"schema/equipment/#msl.equipment.schema.Latest.is_calibration_due","title":"is_calibration_due","text":"<pre><code>is_calibration_due(months: int = 0) -&gt; bool\n</code></pre> <p>Determine if the equipment needs to be re-calibrated.</p> <p>Parameters:</p> Name Type Description Default <code>months</code> <code>int</code> <p>The number of months to add to today's date to determine if the equipment needs to be re-calibrated.</p> <code>0</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether a calibration is due within the specified number of <code>months</code>.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def is_calibration_due(self, months: int = 0) -&gt; bool:\n    \"\"\"Determine if the equipment needs to be re-calibrated.\n\n    Args:\n        months: The number of months to add to today's date to determine if\n            the equipment needs to be re-calibrated.\n\n    Returns:\n        Whether a calibration is due within the specified number of `months`.\n    \"\"\"\n    if self.calibration_interval &lt;= 0:\n        return False  # calibrate on-demand\n\n    ask_date = _future_date(_date.today(), max(0.0, months / 12.0))  # noqa: DTZ011\n    return ask_date &gt;= self.next_calibration_date\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck","title":"LatestPerformanceCheck  <code>dataclass</code>","text":"<pre><code>LatestPerformanceCheck(\n    completed_date: date,\n    competency: Competency,\n    entered_by: str = \"\",\n    checked_by: str = \"\",\n    checked_date: date | None = None,\n    conditions: Conditions = Conditions(),\n    cvd_equations: tuple[CVDEquation, ...] = (),\n    deserialisers: tuple[Deserialised, ...] = (),\n    equations: tuple[Equation, ...] = (),\n    files: tuple[File, ...] = (),\n    tables: tuple[Table, ...] = (),\n    calibration_interval: float = 0.0,\n    name: str = \"\",\n    next_calibration_date: date = date(1875, 5, 20),\n    quantity: str = \"\",\n)\n</code></pre> <p>               Bases: <code>Latest</code>, <code>PerformanceCheck</code></p> <p>Latest performance check.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.calibration_interval","title":"calibration_interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>calibration_interval: float = 0.0\n</code></pre> <p>The number of years that may pass between a calibration or a performance check.</p> <p>For equipment that do not have a required and periodic interval, but are calibrated on demand, the value is <code>0</code>.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.checked_by","title":"checked_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_by: str = ''\n</code></pre> <p>The name of the person who checked the information in the <code>&lt;performanceCheck&gt;</code> element.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.checked_date","title":"checked_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_date: date | None = None\n</code></pre> <p>The date that the information in the <code>&lt;performanceCheck&gt;</code> element was last checked.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.competency","title":"competency  <code>instance-attribute</code>","text":"<pre><code>competency: Competency\n</code></pre> <p>The competent people who accomplished the performance check and the technical procedure that was executed.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.completed_date","title":"completed_date  <code>instance-attribute</code>","text":"<pre><code>completed_date: date\n</code></pre> <p>The date that the performance check was completed.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.conditions","title":"conditions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>conditions: Conditions = field(default_factory=Conditions)\n</code></pre> <p>The conditions under which the performance check is valid.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.cvd_equation","title":"cvd_equation  <code>property</code>","text":"<pre><code>cvd_equation: CVDEquation\n</code></pre> <p>Returns the first item in the cvd_equations tuple.</p> <p>Raises IndexError if the performance check does not contain Callendar-Van Dusen equations.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.cvd_equations","title":"cvd_equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cvd_equations: tuple[CVDEquation, ...] = ()\n</code></pre> <p>Performance-check data is expressed as Callendar-Van Dusen equations.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.deserialised","title":"deserialised  <code>property</code>","text":"<pre><code>deserialised: Deserialised\n</code></pre> <p>Returns the first item in the deserialisers tuple.</p> <p>Raises IndexError if the performance check does not contain serialised data.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.deserialisers","title":"deserialisers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>deserialisers: tuple[Deserialised, ...] = ()\n</code></pre> <p>Performance-check data is stored in serialised formats and deserialised.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.entered_by","title":"entered_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entered_by: str = ''\n</code></pre> <p>The name of the person who initially entered the <code>&lt;performanceCheck&gt;</code> element in the register.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.equation","title":"equation  <code>property</code>","text":"<pre><code>equation: Equation\n</code></pre> <p>Returns the first item in the equations tuple.</p> <p>Raises IndexError if the performance check does not contain equations.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.equations","title":"equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>equations: tuple[Equation, ...] = ()\n</code></pre> <p>Performance-check data is expressed as equations.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.file","title":"file  <code>property</code>","text":"<pre><code>file: File\n</code></pre> <p>Returns the first item in the files tuple.</p> <p>Raises IndexError if the performance check does not contain files.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.files","title":"files  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>files: tuple[File, ...] = ()\n</code></pre> <p>Performance-check data is stored in other files (not in the equipment register).</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = ''\n</code></pre> <p>The Component name.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.next_calibration_date","title":"next_calibration_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_calibration_date: date = date(1875, 5, 20)\n</code></pre> <p>The date that the equipment is due for a re-calibration.</p> <p>If the calibration_interval is <code>0</code>, i.e., the equipment is calibrated on demand, this date is equal to the date that the equipment was last calibrated.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.quantity","title":"quantity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quantity: str = ''\n</code></pre> <p>The Measurand quantity.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.table","title":"table  <code>property</code>","text":"<pre><code>table: Table\n</code></pre> <p>Returns the first item in the tables tuple.</p> <p>Raises IndexError if the performance check does not contain tables.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.tables","title":"tables  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tables: tuple[Table, ...] = ()\n</code></pre> <p>Performance-check data is stored as Comma Separated Values (CSV) tables.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; PerformanceCheck\n</code></pre> <p>Convert an XML element into a PerformanceCheck instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A performanceCheck XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>PerformanceCheck</code> <p>The PerformanceCheck instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; PerformanceCheck:\n    \"\"\"Convert an XML element into a [PerformanceCheck][msl.equipment.schema.PerformanceCheck] instance.\n\n    Args:\n        element: A [performanceCheck][type_performanceCheck] XML element from an\n            equipment register.\n\n    Returns:\n        The [PerformanceCheck][msl.equipment.schema.PerformanceCheck] instance.\n    \"\"\"\n    # Schema forces order for `competency` and `conditions` but uses xsd:choice,\n    # which allows sub-elements to appear (or not appear) in any order, for the data elements.\n    # Using str.endswith() allows for ignoring XML namespaces that may be associated with each tag\n    cvd_equations: list[CVDEquation] = []\n    equations: list[Equation] = []\n    files: list[File] = []\n    deserialisers: list[Deserialised] = []\n    tables: list[Table] = []\n    for child in element[2:]:\n        tag = child.tag\n        if tag.endswith(\"equation\"):\n            equations.append(Equation.from_xml(child))\n        elif tag.endswith(\"table\"):\n            tables.append(Table.from_xml(child))\n        elif tag.endswith(\"cvdCoefficients\"):\n            cvd_equations.append(CVDEquation.from_xml(child))\n        elif tag.endswith(\"file\"):\n            files.append(File.from_xml(child))\n        else:\n            deserialisers.append(Deserialised.from_xml(child))\n\n    a = element.attrib\n    return cls(\n        completed_date=_date.fromisoformat(a[\"completedDate\"] or \"\"),\n        entered_by=a[\"enteredBy\"] or \"\",\n        checked_by=a.get(\"checkedBy\", \"\"),\n        checked_date=None if not a.get(\"checkedDate\") else _date.fromisoformat(a[\"checkedDate\"]),\n        competency=Competency.from_xml(element[0]),\n        conditions=Conditions.from_xml(element[1]),\n        cvd_equations=tuple(cvd_equations),\n        deserialisers=tuple(deserialisers),\n        equations=tuple(equations),\n        files=tuple(files),\n        tables=tuple(tables),\n    )\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.is_calibration_due","title":"is_calibration_due","text":"<pre><code>is_calibration_due(months: int = 0) -&gt; bool\n</code></pre> <p>Determine if the equipment needs to be re-calibrated.</p> <p>Parameters:</p> Name Type Description Default <code>months</code> <code>int</code> <p>The number of months to add to today's date to determine if the equipment needs to be re-calibrated.</p> <code>0</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether a calibration is due within the specified number of <code>months</code>.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def is_calibration_due(self, months: int = 0) -&gt; bool:\n    \"\"\"Determine if the equipment needs to be re-calibrated.\n\n    Args:\n        months: The number of months to add to today's date to determine if\n            the equipment needs to be re-calibrated.\n\n    Returns:\n        Whether a calibration is due within the specified number of `months`.\n    \"\"\"\n    if self.calibration_interval &lt;= 0:\n        return False  # calibrate on-demand\n\n    ask_date = _future_date(_date.today(), max(0.0, months / 12.0))  # noqa: DTZ011\n    return ask_date &gt;= self.next_calibration_date\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.LatestPerformanceCheck.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the PerformanceCheck class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The PerformanceCheck as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [PerformanceCheck][msl.equipment.schema.PerformanceCheck] class into an XML element.\n\n    Returns:\n        The [PerformanceCheck][msl.equipment.schema.PerformanceCheck] as an XML element.\n    \"\"\"\n    a = {\"completedDate\": self.completed_date.isoformat(), \"enteredBy\": self.entered_by}\n    if self.checked_by:\n        a[\"checkedBy\"] = self.checked_by\n    if self.checked_date is not None:\n        a[\"checkedDate\"] = self.checked_date.isoformat()\n\n    e = Element(\"performanceCheck\", attrib=a)\n    e.append(self.competency.to_xml())\n    e.append(self.conditions)\n    e.extend(equation.to_xml() for equation in self.equations)\n    e.extend(table.to_xml() for table in self.tables)\n    e.extend(cvd.to_xml() for cvd in self.cvd_equations)\n    e.extend(file.to_xml() for file in self.files)\n    e.extend(deserialised.to_xml() for deserialised in self.deserialisers)\n    return e\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport","title":"LatestReport  <code>dataclass</code>","text":"<pre><code>LatestReport(\n    id: str,\n    report_issue_date: date,\n    measurement_start_date: date,\n    measurement_stop_date: date,\n    issuing_laboratory: IssuingLaboratory = IssuingLaboratory(),\n    technical_procedure: str = \"\",\n    entered_by: str = \"\",\n    checked_by: str = \"\",\n    checked_date: date | None = None,\n    conditions: Conditions = Conditions(),\n    acceptance_criteria: AcceptanceCriteria = AcceptanceCriteria(),\n    cvd_equations: tuple[CVDEquation, ...] = (),\n    deserialisers: tuple[Deserialised, ...] = (),\n    equations: tuple[Equation, ...] = (),\n    files: tuple[File, ...] = (),\n    tables: tuple[Table, ...] = (),\n    calibration_interval: float = 0.0,\n    name: str = \"\",\n    next_calibration_date: date = date(1875, 5, 20),\n    quantity: str = \"\",\n)\n</code></pre> <p>               Bases: <code>Latest</code>, <code>Report</code></p> <p>Latest calibration report.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.acceptance_criteria","title":"acceptance_criteria  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acceptance_criteria: AcceptanceCriteria = field(\n    default_factory=AcceptanceCriteria\n)\n</code></pre> <p>Acceptance criteria for the calibration report.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.calibration_interval","title":"calibration_interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>calibration_interval: float = 0.0\n</code></pre> <p>The number of years that may pass between a calibration or a performance check.</p> <p>For equipment that do not have a required and periodic interval, but are calibrated on demand, the value is <code>0</code>.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.checked_by","title":"checked_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_by: str = ''\n</code></pre> <p>The name of the person who checked the information in the <code>&lt;report&gt;</code> element.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.checked_date","title":"checked_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_date: date | None = None\n</code></pre> <p>The date that the information in the <code>&lt;report&gt;</code> element was last checked.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.conditions","title":"conditions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>conditions: Conditions = field(default_factory=Conditions)\n</code></pre> <p>The conditions under which the report is valid.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.cvd_equation","title":"cvd_equation  <code>property</code>","text":"<pre><code>cvd_equation: CVDEquation\n</code></pre> <p>Returns the first item in the cvd_equations tuple.</p> <p>Raises IndexError if the report does not contain Callendar-Van Dusen equations.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.cvd_equations","title":"cvd_equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cvd_equations: tuple[CVDEquation, ...] = ()\n</code></pre> <p>Calibration data is expressed as Callendar-Van Dusen equations.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.deserialised","title":"deserialised  <code>property</code>","text":"<pre><code>deserialised: Deserialised\n</code></pre> <p>Returns the first item in the deserialisers tuple.</p> <p>Raises IndexError if the report does not contain serialised data.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.deserialisers","title":"deserialisers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>deserialisers: tuple[Deserialised, ...] = ()\n</code></pre> <p>Calibration data is stored in serialised formats and deserialised.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.entered_by","title":"entered_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entered_by: str = ''\n</code></pre> <p>The name of the person who initially entered the <code>&lt;report&gt;</code> element in the register.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.equation","title":"equation  <code>property</code>","text":"<pre><code>equation: Equation\n</code></pre> <p>Returns the first item in the equations tuple.</p> <p>Raises IndexError if the report does not contain equations.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.equations","title":"equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>equations: tuple[Equation, ...] = ()\n</code></pre> <p>Calibration data is expressed as equations.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.file","title":"file  <code>property</code>","text":"<pre><code>file: File\n</code></pre> <p>Returns the first item in the files tuple.</p> <p>Raises IndexError if the report does not contain files.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.files","title":"files  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>files: tuple[File, ...] = ()\n</code></pre> <p>Calibration data is stored in other files (not in the equipment register).</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>The report identification number.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.issuing_laboratory","title":"issuing_laboratory  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>issuing_laboratory: IssuingLaboratory = field(\n    default_factory=IssuingLaboratory\n)\n</code></pre> <p>Information about the laboratory that issued the calibration report.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.measurement_start_date","title":"measurement_start_date  <code>instance-attribute</code>","text":"<pre><code>measurement_start_date: date\n</code></pre> <p>The date that the calibration measurement started.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.measurement_stop_date","title":"measurement_stop_date  <code>instance-attribute</code>","text":"<pre><code>measurement_stop_date: date\n</code></pre> <p>The date that the calibration measurement stopped.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = ''\n</code></pre> <p>The Component name.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.next_calibration_date","title":"next_calibration_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_calibration_date: date = date(1875, 5, 20)\n</code></pre> <p>The date that the equipment is due for a re-calibration.</p> <p>If the calibration_interval is <code>0</code>, i.e., the equipment is calibrated on demand, this date is equal to the date that the equipment was last calibrated.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.quantity","title":"quantity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quantity: str = ''\n</code></pre> <p>The Measurand quantity.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.report_issue_date","title":"report_issue_date  <code>instance-attribute</code>","text":"<pre><code>report_issue_date: date\n</code></pre> <p>The date that the report was issued.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.table","title":"table  <code>property</code>","text":"<pre><code>table: Table\n</code></pre> <p>Returns the first item in the tables tuple.</p> <p>Raises IndexError if the report does not contain tables.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.tables","title":"tables  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tables: tuple[Table, ...] = ()\n</code></pre> <p>Calibration data is stored as Comma Separated Values (CSV) tables.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.technical_procedure","title":"technical_procedure  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>technical_procedure: str = ''\n</code></pre> <p>The technical procedure(s) that was(were) followed to perform the calibration.</p>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Report\n</code></pre> <p>Convert an XML element into a Report instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A report XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Report</code> <p>The Report instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Report:\n    \"\"\"Convert an XML element into a [Report][msl.equipment.schema.Report] instance.\n\n    Args:\n        element: A [report][type_report] XML element from an equipment register.\n\n    Returns:\n        The [Report][msl.equipment.schema.Report] instance.\n    \"\"\"\n    # Schema forces order until `acceptanceCriteria` and then uses xsd:choice, which\n    # allows sub-elements to appear (or not appear) in any order, for the data elements.\n    # Using str.endswith() allows for ignoring XML namespaces that may be associated with each tag\n    cvd_equations: list[CVDEquation] = []\n    deserialisers: list[Deserialised] = []\n    equations: list[Equation] = []\n    files: list[File] = []\n    tables: list[Table] = []\n    for child in element[7:]:\n        tag = child.tag\n        if tag.endswith(\"equation\"):\n            equations.append(Equation.from_xml(child))\n        elif tag.endswith(\"table\"):\n            tables.append(Table.from_xml(child))\n        elif tag.endswith(\"cvdCoefficients\"):\n            cvd_equations.append(CVDEquation.from_xml(child))\n        elif tag.endswith(\"file\"):\n            files.append(File.from_xml(child))\n        else:\n            deserialisers.append(Deserialised.from_xml(child))\n\n    a = element.attrib\n    return cls(\n        id=a[\"id\"] or \"\",\n        entered_by=a[\"enteredBy\"] or \"\",\n        checked_by=a.get(\"checkedBy\", \"\"),\n        checked_date=None if not a.get(\"checkedDate\") else _date.fromisoformat(a[\"checkedDate\"]),\n        report_issue_date=_date.fromisoformat(element[0].text or \"\"),\n        measurement_start_date=_date.fromisoformat(element[1].text or \"\"),\n        measurement_stop_date=_date.fromisoformat(element[2].text or \"\"),\n        issuing_laboratory=IssuingLaboratory.from_xml(element[3]),\n        technical_procedure=element[4].text or \"\",\n        conditions=Conditions.from_xml(element[5]),\n        acceptance_criteria=AcceptanceCriteria.from_xml(element[6]),\n        cvd_equations=tuple(cvd_equations),\n        deserialisers=tuple(deserialisers),\n        equations=tuple(equations),\n        files=tuple(files),\n        tables=tuple(tables),\n    )\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.is_calibration_due","title":"is_calibration_due","text":"<pre><code>is_calibration_due(months: int = 0) -&gt; bool\n</code></pre> <p>Determine if the equipment needs to be re-calibrated.</p> <p>Parameters:</p> Name Type Description Default <code>months</code> <code>int</code> <p>The number of months to add to today's date to determine if the equipment needs to be re-calibrated.</p> <code>0</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether a calibration is due within the specified number of <code>months</code>.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def is_calibration_due(self, months: int = 0) -&gt; bool:\n    \"\"\"Determine if the equipment needs to be re-calibrated.\n\n    Args:\n        months: The number of months to add to today's date to determine if\n            the equipment needs to be re-calibrated.\n\n    Returns:\n        Whether a calibration is due within the specified number of `months`.\n    \"\"\"\n    if self.calibration_interval &lt;= 0:\n        return False  # calibrate on-demand\n\n    ask_date = _future_date(_date.today(), max(0.0, months / 12.0))  # noqa: DTZ011\n    return ask_date &gt;= self.next_calibration_date\n</code></pre>"},{"location":"schema/equipment/#msl.equipment.schema.LatestReport.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Report class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Report as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Report][msl.equipment.schema.Report] class into an XML element.\n\n    Returns:\n        The [Report][msl.equipment.schema.Report] as an XML element.\n    \"\"\"\n    a = {\"id\": self.id, \"enteredBy\": self.entered_by}\n    if self.checked_by:\n        a[\"checkedBy\"] = self.checked_by\n    if self.checked_date is not None:\n        a[\"checkedDate\"] = self.checked_date.isoformat()\n\n    e = Element(\"report\", attrib=a)\n\n    rid = SubElement(e, \"reportIssueDate\")\n    rid.text = self.report_issue_date.isoformat()\n\n    start = SubElement(e, \"measurementStartDate\")\n    start.text = self.measurement_start_date.isoformat()\n\n    stop = SubElement(e, \"measurementStopDate\")\n    stop.text = self.measurement_stop_date.isoformat()\n\n    e.append(self.issuing_laboratory.to_xml())\n\n    tp = SubElement(e, \"technicalProcedure\")\n    tp.text = self.technical_procedure\n\n    e.append(self.conditions)\n    e.append(self.acceptance_criteria)\n    e.extend(equation.to_xml() for equation in self.equations)\n    e.extend(table.to_xml() for table in self.tables)\n    e.extend(cvd.to_xml() for cvd in self.cvd_equations)\n    e.extend(file.to_xml() for file in self.files)\n    e.extend(deserialised.to_xml() for deserialised in self.deserialisers)\n    return e\n</code></pre>"},{"location":"schema/file/","title":"File","text":"<p>Suppose you have a variable named <code>file</code> (which is an instance of File) that represents the following information in an equipment register for data that is stored in a Spreadsheet</p> <pre><code>&lt;file comment=\"FEL T647\"&gt;\n  &lt;url sheet=\"2024-May\" cells=\"A1:C11\"&gt;tests\\resources\\irradiance.xlsx&lt;/url&gt;\n  &lt;sha256&gt;7a91267cfb529388a99762b891ee4b7a12463e83b5d55809f76a0c8e76c71886&lt;/sha256&gt;\n&lt;/file&gt;\n</code></pre> <p>You can access sha256 and comment as attributes of <code>file</code></p> <pre><code>&gt;&gt;&gt; file.sha256\n'7a91267cfb529388a99762b891ee4b7a12463e83b5d55809f76a0c8e76c71886'\n&gt;&gt;&gt; file.comment\n'FEL T647'\n</code></pre> <p>The url and attributes attributes of <code>file</code> can be used with the read_table function of msl-io to read the Spreadsheet data</p> <pre><code>&gt;&gt;&gt; from msl.io import read_table\n&gt;&gt;&gt; table = read_table(file.url, **file.attributes)\n&gt;&gt;&gt; print(table.metadata.header)\n['Wavelength' 'Irradiance' 'u(Irradiance)']\n&gt;&gt;&gt; table\n&lt;Dataset 'irradiance.xlsx' shape=(10, 3) dtype='&lt;f8' (1 metadata)&gt;\n&gt;&gt;&gt; print(table)\narray([[2.500000e+02, 1.818000e-02, 2.033000e-02],\n       [3.000000e+02, 1.847800e-01, 1.755000e-02],\n       [3.500000e+02, 8.084500e-01, 1.606000e-02],\n       [4.000000e+02, 2.213550e+00, 1.405000e-02],\n       [4.500000e+02, 4.490040e+00, 1.250000e-02],\n       [5.000000e+02, 7.451350e+00, 1.200000e-02],\n       [5.500000e+02, 1.075753e+01, 1.152000e-02],\n       [6.000000e+02, 1.403809e+01, 1.102000e-02],\n       [6.500000e+02, 1.699469e+01, 1.103000e-02],\n       [7.000000e+02, 1.944093e+01, 1.077000e-02]])\n</code></pre> <p>Note</p> <p>Passing <code>**file.attributes</code> to read_table works as expected provided that the XML attributes of the <code>&lt;url&gt;</code> element are valid keyword arguments to read_table. See Read a table for more examples from msl-io, in particular, specifying <code>dtype=\"header\"</code> will return a structured dataset which would behave similar to the Table example in <code>msl-equipment</code> (i.e., accessing columns by header name).</p>"},{"location":"schema/file/#msl.equipment.schema.File","title":"File  <code>dataclass</code>","text":"<pre><code>File(\n    url: str,\n    sha256: str,\n    attributes: dict[str, str] = dict(),\n    comment: str = \"\",\n)\n</code></pre> <p>Represents the file element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The location of the file. The syntax follows RFC 1738 <code>scheme:scheme-specific-part</code>. If <code>scheme:</code> is not specified, it is assumed to be <code>file:</code>.</p> required <code>sha256</code> <code>str</code> <p>The SHA-256 checksum of the file.</p> required <code>attributes</code> <code>dict[str, str]</code> <p>XML attributes associated with the <code>&lt;url&gt;</code> element.</p> <code>dict()</code> <code>comment</code> <code>str</code> <p>A comment to associate with the file.</p> <code>''</code>"},{"location":"schema/file/#msl.equipment.schema.File.attributes","title":"attributes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attributes: dict[str, str] = field(default_factory=dict)\n</code></pre> <p>XML attributes associated with the <code>&lt;url&gt;</code> element.</p>"},{"location":"schema/file/#msl.equipment.schema.File.comment","title":"comment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comment: str = ''\n</code></pre> <p>A comment associated with the file.</p>"},{"location":"schema/file/#msl.equipment.schema.File.scheme","title":"scheme  <code>property</code>","text":"<pre><code>scheme: str\n</code></pre> <p>Returns the scheme component that is specified in the url (see RFC 1738 for more details).</p> <p>If a <code>&lt;scheme&gt;</code> is not specified, an empty string is returned (which shall be treated as the <code>file</code> scheme). Drive letters on Windows are not considered as a scheme.</p>"},{"location":"schema/file/#msl.equipment.schema.File.sha256","title":"sha256  <code>instance-attribute</code>","text":"<pre><code>sha256: str\n</code></pre> <p>The SHA-256 checksum of the file.</p>"},{"location":"schema/file/#msl.equipment.schema.File.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: str\n</code></pre> <p>The location of the file.</p> <p>The syntax follows RFC 1738 <code>&lt;scheme&gt;:&lt;scheme-specific-part&gt;</code>. If <code>&lt;scheme&gt;</code> is not specified, it shall be treated as the <code>file</code> scheme.</p> <p>See Also</p> <p>scheme</p>"},{"location":"schema/file/#msl.equipment.schema.File.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; File\n</code></pre> <p>Convert an XML element into a File instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A file XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>File</code> <p>The File instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; File:\n    \"\"\"Convert an XML element into a [File][msl.equipment.schema.File] instance.\n\n    Args:\n        element: A [file][type_file] XML element from an equipment register.\n\n    Returns:\n        The [File][msl.equipment.schema.File] instance.\n    \"\"\"\n    # Schema forces order\n    return cls(\n        url=element[0].text or \"\",\n        sha256=element[1].text or \"\",\n        attributes=element[0].attrib,\n        comment=element.attrib.get(\"comment\", \"\"),\n    )\n</code></pre>"},{"location":"schema/file/#msl.equipment.schema.File.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the File class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The File as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [File][msl.equipment.schema.File] class into an XML element.\n\n    Returns:\n        The [File][msl.equipment.schema.File] as an XML element.\n    \"\"\"\n    attrib = {\"comment\": self.comment} if self.comment else {}\n    e = Element(\"file\", attrib=attrib)\n    url = SubElement(e, \"url\", attrib=self.attributes)\n    url.text = self.url\n    sha256 = SubElement(e, \"sha256\")\n    sha256.text = self.sha256\n    return e\n</code></pre>"},{"location":"schema/financial/","title":"Financial","text":""},{"location":"schema/financial/#msl.equipment.schema.Financial","title":"Financial  <code>dataclass</code>","text":"<pre><code>Financial(\n    capital_expenditure: CapitalExpenditure | None = None,\n    purchase_year: int = 0,\n    warranty_expiration_date: date | None = None,\n)\n</code></pre> <p>Represents the financial element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>capital_expenditure</code> <code>CapitalExpenditure | None</code> <p>The equipment is a capital expenditure.</p> <code>None</code> <code>purchase_year</code> <code>int</code> <p>The (approximate) year that the equipment was purchased. A value of <code>0</code> represents that the year is unknown.</p> <code>0</code> <code>warranty_expiration_date</code> <code>date | None</code> <p>Approximate date that the warranty expires.</p> <code>None</code>"},{"location":"schema/financial/#msl.equipment.schema.Financial.capital_expenditure","title":"capital_expenditure  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>capital_expenditure: CapitalExpenditure | None = None\n</code></pre> <p>The equipment is a capital expenditure.</p>"},{"location":"schema/financial/#msl.equipment.schema.Financial.purchase_year","title":"purchase_year  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>purchase_year: int = 0\n</code></pre> <p>The (approximate) year that the equipment was purchased. A value of <code>0</code> represents that the year is unknown.</p>"},{"location":"schema/financial/#msl.equipment.schema.Financial.warranty_expiration_date","title":"warranty_expiration_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>warranty_expiration_date: date | None = None\n</code></pre> <p>Approximate date that the warranty expires.</p>"},{"location":"schema/financial/#msl.equipment.schema.Financial.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Financial\n</code></pre> <p>Convert an XML element into a Financial instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A financial XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Financial</code> <p>The Financial instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Financial:\n    \"\"\"Convert an XML element into a [Financial][msl.equipment.schema.Financial] instance.\n\n    Args:\n        element: A [financial][type_financial] XML element from an equipment register.\n\n    Returns:\n        The [Financial][msl.equipment.schema.Financial] instance.\n    \"\"\"\n    # Schema defines &lt;financial&gt; using xsd:all, which allows sub-elements to appear (or not appear) in any order\n    # Using str.endswith() allows for ignoring XML namespaces that may be associated with each tag\n    cap_ex, warranty, year = None, None, 0\n    for child in element:\n        if child.tag.endswith(\"capitalExpenditure\"):\n            cap_ex = CapitalExpenditure.from_xml(child)\n        elif child.tag.endswith(\"warrantyExpirationDate\"):\n            warranty = _date.fromisoformat(child.text or \"\")\n        else:\n            year = int(child.text or 0)\n    return cls(capital_expenditure=cap_ex, purchase_year=year, warranty_expiration_date=warranty)\n</code></pre>"},{"location":"schema/financial/#msl.equipment.schema.Financial.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Financial class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Financial as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Financial][msl.equipment.schema.Financial] class into an XML element.\n\n    Returns:\n        The [Financial][msl.equipment.schema.Financial] as an XML element.\n    \"\"\"\n    e = Element(\"financial\")\n\n    if self.capital_expenditure is not None:\n        e.append(self.capital_expenditure.to_xml())\n\n    if self.purchase_year &gt; 0:\n        py = SubElement(e, \"purchaseYear\")\n        py.text = str(self.purchase_year)\n\n    if self.warranty_expiration_date is not None:\n        wed = SubElement(e, \"warrantyExpirationDate\")\n        wed.text = self.warranty_expiration_date.isoformat()\n\n    return e\n</code></pre>"},{"location":"schema/firmware/","title":"Firmware","text":""},{"location":"schema/firmware/#msl.equipment.schema.Firmware","title":"Firmware  <code>dataclass</code>","text":"<pre><code>Firmware(version: str, date: date)\n</code></pre> <p>Represents a firmware <code>&lt;version&gt;</code> sub-element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>Firmware version number.</p> required <code>date</code> <code>date</code> <p>The date that the firmware was initially at or changed to <code>version</code>.</p> required"},{"location":"schema/firmware/#msl.equipment.schema.Firmware.date","title":"date  <code>instance-attribute</code>","text":"<pre><code>date: date\n</code></pre> <p>The date that the firmware was initially at or changed to <code>version</code>.</p>"},{"location":"schema/firmware/#msl.equipment.schema.Firmware.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str\n</code></pre> <p>Firmware version number.</p>"},{"location":"schema/firmware/#msl.equipment.schema.Firmware.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Firmware\n</code></pre> <p>Convert an XML element into a Firmware instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A firmware <code>&lt;version&gt;</code> XML sub-element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Firmware</code> <p>The Firmware instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Firmware:\n    \"\"\"Convert an XML element into a [Firmware][msl.equipment.schema.Firmware] instance.\n\n    Args:\n        element: A [firmware][type_firmware] `&lt;version&gt;` XML sub-element\n            from an equipment register.\n\n    Returns:\n        The [Firmware][msl.equipment.schema.Firmware] instance.\n    \"\"\"\n    return cls(version=element.text or \"\", date=_date.fromisoformat(element.attrib[\"date\"]))\n</code></pre>"},{"location":"schema/firmware/#msl.equipment.schema.Firmware.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Firmware class into a <code>&lt;version&gt;</code> XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Firmware as a <code>&lt;version&gt;</code> XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Firmware][msl.equipment.schema.Firmware] class into a `&lt;version&gt;` XML element.\n\n    Returns:\n        The [Firmware][msl.equipment.schema.Firmware] as a `&lt;version&gt;` XML element.\n    \"\"\"\n    e = Element(\"version\", attrib={\"date\": self.date.isoformat()})\n    e.text = self.version\n    return e\n</code></pre>"},{"location":"schema/maintenance/","title":"Maintenance","text":""},{"location":"schema/maintenance/#msl.equipment.schema.Maintenance","title":"Maintenance  <code>dataclass</code>","text":"<pre><code>Maintenance(\n    planned: tuple[PlannedTask, ...] = (),\n    completed: tuple[CompletedTask, ...] = (),\n)\n</code></pre> <p>Represents the maintenance element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>planned</code> <code>tuple[PlannedTask, ...]</code> <p>Maintenance tasks that are planned to be performed.</p> <code>()</code> <code>completed</code> <code>tuple[CompletedTask, ...]</code> <p>Maintenance tasks that have been completed.</p> <code>()</code>"},{"location":"schema/maintenance/#msl.equipment.schema.Maintenance.completed","title":"completed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>completed: tuple[CompletedTask, ...] = ()\n</code></pre> <p>Maintenance tasks that have been completed.</p>"},{"location":"schema/maintenance/#msl.equipment.schema.Maintenance.planned","title":"planned  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>planned: tuple[PlannedTask, ...] = ()\n</code></pre> <p>Maintenance tasks that are planned to be performed.</p>"},{"location":"schema/maintenance/#msl.equipment.schema.Maintenance.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Maintenance\n</code></pre> <p>Convert an XML element into a Maintenance instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A maintenance XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Maintenance</code> <p>The Maintenance instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Maintenance:\n    \"\"\"Convert an XML element into a [Maintenance][msl.equipment.schema.Maintenance] instance.\n\n    Args:\n        element: A [maintenance][type_maintenance] XML element from an equipment register.\n\n    Returns:\n        The [Maintenance][msl.equipment.schema.Maintenance] instance.\n    \"\"\"\n    if len(element) == 0:\n        return cls()\n\n    # Schema forces order, planned tasks then completed tasks (and both sub-elements must exist)\n    return cls(\n        planned=tuple(PlannedTask.from_xml(e) for e in element[0]),\n        completed=tuple(CompletedTask.from_xml(e) for e in element[1]),\n    )\n</code></pre>"},{"location":"schema/maintenance/#msl.equipment.schema.Maintenance.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Maintenance class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Maintenance as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Maintenance][msl.equipment.schema.Maintenance] class into an XML element.\n\n    Returns:\n        The [Maintenance][msl.equipment.schema.Maintenance] as an XML element.\n    \"\"\"\n    e = Element(\"maintenance\")\n    if not (self.planned or self.completed):\n        return e  # no maintenance plan\n\n    # planned must come before completed\n    planned = SubElement(e, \"planned\")\n    planned.extend(p.to_xml() for p in self.planned)\n    completed = SubElement(e, \"completed\")\n    completed.extend(c.to_xml() for c in self.completed)\n    return e\n</code></pre>"},{"location":"schema/measurand/","title":"Measurand","text":""},{"location":"schema/measurand/#msl.equipment.schema.Measurand","title":"Measurand  <code>dataclass</code>","text":"<pre><code>Measurand(\n    quantity: str,\n    calibration_interval: float,\n    components: tuple[Component, ...] = (),\n)\n</code></pre> <p>Represents the measurand element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>str</code> <p>The kind of quantity that is measured.</p> required <code>calibration_interval</code> <code>float</code> <p>The number of years that may pass between a calibration or a performance check. For equipment that do not have a required and periodic interval, but are calibrated on demand, set the value to <code>0</code>.</p> required <code>components</code> <code>tuple[Component, ...]</code> <p>The components of the equipment that measure the <code>quantity</code>.</p> <code>()</code>"},{"location":"schema/measurand/#msl.equipment.schema.Measurand.calibration_interval","title":"calibration_interval  <code>instance-attribute</code>","text":"<pre><code>calibration_interval: float\n</code></pre> <p>The number of years that may pass between a calibration or a performance check.</p> <p>For equipment that do not have a required and periodic interval, but are calibrated on demand, the value is <code>0</code>.</p>"},{"location":"schema/measurand/#msl.equipment.schema.Measurand.components","title":"components  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>components: tuple[Component, ...] = ()\n</code></pre> <p>The components of the equipment that measure the <code>quantity</code>.</p>"},{"location":"schema/measurand/#msl.equipment.schema.Measurand.quantity","title":"quantity  <code>instance-attribute</code>","text":"<pre><code>quantity: str\n</code></pre> <p>The kind of quantity that is measured.</p>"},{"location":"schema/measurand/#msl.equipment.schema.Measurand.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Measurand\n</code></pre> <p>Convert an XML element into a Measurand instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A measurand XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Measurand</code> <p>The Measurand instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Measurand:\n    \"\"\"Convert an XML element into a [Measurand][msl.equipment.schema.Measurand] instance.\n\n    Args:\n        element: A [measurand][type_measurand] XML element from an equipment register.\n\n    Returns:\n        The [Measurand][msl.equipment.schema.Measurand] instance.\n    \"\"\"\n    return cls(\n        quantity=element.attrib[\"quantity\"],\n        calibration_interval=float(element.attrib[\"calibrationInterval\"]),\n        components=tuple(Component.from_xml(c) for c in element),\n    )\n</code></pre>"},{"location":"schema/measurand/#msl.equipment.schema.Measurand.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Measurand class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Measurand as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Measurand][msl.equipment.schema.Measurand] class into an XML element.\n\n    Returns:\n        The [Measurand][msl.equipment.schema.Measurand] as an XML element.\n    \"\"\"\n    attrib = {\"quantity\": self.quantity, \"calibrationInterval\": str(self.calibration_interval)}\n    e = Element(\"measurand\", attrib=attrib)\n    e.extend(c.to_xml() for c in self.components)\n    return e\n</code></pre>"},{"location":"schema/performance_check/","title":"PerformanceCheck","text":""},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck","title":"PerformanceCheck  <code>dataclass</code>","text":"<pre><code>PerformanceCheck(\n    completed_date: date,\n    competency: Competency,\n    entered_by: str = \"\",\n    checked_by: str = \"\",\n    checked_date: date | None = None,\n    conditions: Conditions = Conditions(),\n    cvd_equations: tuple[CVDEquation, ...] = (),\n    deserialisers: tuple[Deserialised, ...] = (),\n    equations: tuple[Equation, ...] = (),\n    files: tuple[File, ...] = (),\n    tables: tuple[Table, ...] = (),\n)\n</code></pre> <p>Represents the performanceCheck element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>completed_date</code> <code>date</code> <p>The date that the performance check was completed.</p> required <code>competency</code> <code>Competency</code> <p>The competent people who accomplished the performance check and the technical procedure that was executed.</p> required <code>entered_by</code> <code>str</code> <p>The name of the person who initially entered the <code>&lt;performanceCheck&gt;</code> element in the register.</p> <code>''</code> <code>checked_by</code> <code>str</code> <p>The name of the person who checked the information in the <code>&lt;performanceCheck&gt;</code> element.</p> <code>''</code> <code>checked_date</code> <code>date | None</code> <p>The date that the information in the <code>&lt;performanceCheck&gt;</code> element was last checked.</p> <code>None</code> <code>conditions</code> <code>Conditions</code> <p>The conditions under which the performance check is valid.</p> <code>Conditions()</code> <code>cvd_equations</code> <code>tuple[CVDEquation, ...]</code> <p>Performance-check data is expressed as Callendar-Van Dusen equations.</p> <code>()</code> <code>deserialisers</code> <code>tuple[Deserialised, ...]</code> <p>Performance-check data is stored in serialised formats and deserialised.</p> <code>()</code> <code>equations</code> <code>tuple[Equation, ...]</code> <p>Performance-check data is expressed as equations.</p> <code>()</code> <code>files</code> <code>tuple[File, ...]</code> <p>Performance-check data is stored in other files (not in the equipment register).</p> <code>()</code> <code>tables</code> <code>tuple[Table, ...]</code> <p>Performance-check data is stored as Comma Separated Values (CSV) tables.</p> <code>()</code>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.checked_by","title":"checked_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_by: str = ''\n</code></pre> <p>The name of the person who checked the information in the <code>&lt;performanceCheck&gt;</code> element.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.checked_date","title":"checked_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_date: date | None = None\n</code></pre> <p>The date that the information in the <code>&lt;performanceCheck&gt;</code> element was last checked.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.competency","title":"competency  <code>instance-attribute</code>","text":"<pre><code>competency: Competency\n</code></pre> <p>The competent people who accomplished the performance check and the technical procedure that was executed.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.completed_date","title":"completed_date  <code>instance-attribute</code>","text":"<pre><code>completed_date: date\n</code></pre> <p>The date that the performance check was completed.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.conditions","title":"conditions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>conditions: Conditions = field(default_factory=Conditions)\n</code></pre> <p>The conditions under which the performance check is valid.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.cvd_equation","title":"cvd_equation  <code>property</code>","text":"<pre><code>cvd_equation: CVDEquation\n</code></pre> <p>Returns the first item in the cvd_equations tuple.</p> <p>Raises IndexError if the performance check does not contain Callendar-Van Dusen equations.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.cvd_equations","title":"cvd_equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cvd_equations: tuple[CVDEquation, ...] = ()\n</code></pre> <p>Performance-check data is expressed as Callendar-Van Dusen equations.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.deserialised","title":"deserialised  <code>property</code>","text":"<pre><code>deserialised: Deserialised\n</code></pre> <p>Returns the first item in the deserialisers tuple.</p> <p>Raises IndexError if the performance check does not contain serialised data.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.deserialisers","title":"deserialisers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>deserialisers: tuple[Deserialised, ...] = ()\n</code></pre> <p>Performance-check data is stored in serialised formats and deserialised.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.entered_by","title":"entered_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entered_by: str = ''\n</code></pre> <p>The name of the person who initially entered the <code>&lt;performanceCheck&gt;</code> element in the register.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.equation","title":"equation  <code>property</code>","text":"<pre><code>equation: Equation\n</code></pre> <p>Returns the first item in the equations tuple.</p> <p>Raises IndexError if the performance check does not contain equations.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.equations","title":"equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>equations: tuple[Equation, ...] = ()\n</code></pre> <p>Performance-check data is expressed as equations.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.file","title":"file  <code>property</code>","text":"<pre><code>file: File\n</code></pre> <p>Returns the first item in the files tuple.</p> <p>Raises IndexError if the performance check does not contain files.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.files","title":"files  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>files: tuple[File, ...] = ()\n</code></pre> <p>Performance-check data is stored in other files (not in the equipment register).</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.table","title":"table  <code>property</code>","text":"<pre><code>table: Table\n</code></pre> <p>Returns the first item in the tables tuple.</p> <p>Raises IndexError if the performance check does not contain tables.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.tables","title":"tables  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tables: tuple[Table, ...] = ()\n</code></pre> <p>Performance-check data is stored as Comma Separated Values (CSV) tables.</p>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; PerformanceCheck\n</code></pre> <p>Convert an XML element into a PerformanceCheck instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A performanceCheck XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>PerformanceCheck</code> <p>The PerformanceCheck instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; PerformanceCheck:\n    \"\"\"Convert an XML element into a [PerformanceCheck][msl.equipment.schema.PerformanceCheck] instance.\n\n    Args:\n        element: A [performanceCheck][type_performanceCheck] XML element from an\n            equipment register.\n\n    Returns:\n        The [PerformanceCheck][msl.equipment.schema.PerformanceCheck] instance.\n    \"\"\"\n    # Schema forces order for `competency` and `conditions` but uses xsd:choice,\n    # which allows sub-elements to appear (or not appear) in any order, for the data elements.\n    # Using str.endswith() allows for ignoring XML namespaces that may be associated with each tag\n    cvd_equations: list[CVDEquation] = []\n    equations: list[Equation] = []\n    files: list[File] = []\n    deserialisers: list[Deserialised] = []\n    tables: list[Table] = []\n    for child in element[2:]:\n        tag = child.tag\n        if tag.endswith(\"equation\"):\n            equations.append(Equation.from_xml(child))\n        elif tag.endswith(\"table\"):\n            tables.append(Table.from_xml(child))\n        elif tag.endswith(\"cvdCoefficients\"):\n            cvd_equations.append(CVDEquation.from_xml(child))\n        elif tag.endswith(\"file\"):\n            files.append(File.from_xml(child))\n        else:\n            deserialisers.append(Deserialised.from_xml(child))\n\n    a = element.attrib\n    return cls(\n        completed_date=_date.fromisoformat(a[\"completedDate\"] or \"\"),\n        entered_by=a[\"enteredBy\"] or \"\",\n        checked_by=a.get(\"checkedBy\", \"\"),\n        checked_date=None if not a.get(\"checkedDate\") else _date.fromisoformat(a[\"checkedDate\"]),\n        competency=Competency.from_xml(element[0]),\n        conditions=Conditions.from_xml(element[1]),\n        cvd_equations=tuple(cvd_equations),\n        deserialisers=tuple(deserialisers),\n        equations=tuple(equations),\n        files=tuple(files),\n        tables=tuple(tables),\n    )\n</code></pre>"},{"location":"schema/performance_check/#msl.equipment.schema.PerformanceCheck.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the PerformanceCheck class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The PerformanceCheck as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [PerformanceCheck][msl.equipment.schema.PerformanceCheck] class into an XML element.\n\n    Returns:\n        The [PerformanceCheck][msl.equipment.schema.PerformanceCheck] as an XML element.\n    \"\"\"\n    a = {\"completedDate\": self.completed_date.isoformat(), \"enteredBy\": self.entered_by}\n    if self.checked_by:\n        a[\"checkedBy\"] = self.checked_by\n    if self.checked_date is not None:\n        a[\"checkedDate\"] = self.checked_date.isoformat()\n\n    e = Element(\"performanceCheck\", attrib=a)\n    e.append(self.competency.to_xml())\n    e.append(self.conditions)\n    e.extend(equation.to_xml() for equation in self.equations)\n    e.extend(table.to_xml() for table in self.tables)\n    e.extend(cvd.to_xml() for cvd in self.cvd_equations)\n    e.extend(file.to_xml() for file in self.files)\n    e.extend(deserialised.to_xml() for deserialised in self.deserialisers)\n    return e\n</code></pre>"},{"location":"schema/planned_task/","title":"PlannedTask","text":""},{"location":"schema/planned_task/#msl.equipment.schema.PlannedTask","title":"PlannedTask  <code>dataclass</code>","text":"<pre><code>PlannedTask(\n    task: str, due_date: date, performed_by: str = \"\"\n)\n</code></pre> <p>Represents the plannedTask element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>str</code> <p>A description of the task that is planned.</p> required <code>due_date</code> <code>date</code> <p>The date that the planned maintenance task is due to be completed.</p> required <code>performed_by</code> <code>str</code> <p>The person or company that will perform the planned maintenance task.</p> <code>''</code>"},{"location":"schema/planned_task/#msl.equipment.schema.PlannedTask.due_date","title":"due_date  <code>instance-attribute</code>","text":"<pre><code>due_date: date\n</code></pre> <p>The date that the planned maintenance task is due to be completed.</p>"},{"location":"schema/planned_task/#msl.equipment.schema.PlannedTask.performed_by","title":"performed_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>performed_by: str = ''\n</code></pre> <p>The person or company that will perform the planned maintenance task.</p>"},{"location":"schema/planned_task/#msl.equipment.schema.PlannedTask.task","title":"task  <code>instance-attribute</code>","text":"<pre><code>task: str\n</code></pre> <p>A description of the task that is planned.</p>"},{"location":"schema/planned_task/#msl.equipment.schema.PlannedTask.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; PlannedTask\n</code></pre> <p>Convert an XML element into a PlannedTask instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A plannedTask XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>PlannedTask</code> <p>The PlannedTask instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; PlannedTask:\n    \"\"\"Convert an XML element into a [PlannedTask][msl.equipment.schema.PlannedTask] instance.\n\n    Args:\n        element: A [plannedTask][type_plannedTask] XML element from an equipment register.\n\n    Returns:\n        The [PlannedTask][msl.equipment.schema.PlannedTask] instance.\n    \"\"\"\n    return cls(\n        task=element.text or \"\",\n        due_date=_date.fromisoformat(element.attrib[\"dueDate\"]),\n        performed_by=element.get(\"performedBy\", \"\"),\n    )\n</code></pre>"},{"location":"schema/planned_task/#msl.equipment.schema.PlannedTask.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the PlannedTask class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The PlannedTask as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [PlannedTask][msl.equipment.schema.PlannedTask] class into an XML element.\n\n    Returns:\n        The [PlannedTask][msl.equipment.schema.PlannedTask] as an XML element.\n    \"\"\"\n    attrib = {\"dueDate\": self.due_date.isoformat()}\n    if self.performed_by:\n        attrib[\"performedBy\"] = self.performed_by\n\n    e = Element(\"task\", attrib=attrib)\n    e.text = self.task\n    return e\n</code></pre>"},{"location":"schema/quality_manual/","title":"QualityManual","text":""},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual","title":"QualityManual  <code>dataclass</code>","text":"<pre><code>QualityManual(\n    accessories: Accessories = Accessories(),\n    documentation: str = \"\",\n    financial: Financial = Financial(),\n    personnel_restrictions: str = \"\",\n    service_agent: str = \"\",\n    technical_procedures: tuple[str, ...] = (),\n)\n</code></pre> <p>Represents the qualityManual element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>accessories</code> <code>Accessories</code> <p>Additional accessories that may be required to use the equipment.</p> <code>Accessories()</code> <code>documentation</code> <code>str</code> <p>Information (such as URLs) about the manuals, datasheets, etc. for the equipment.</p> <code>''</code> <code>financial</code> <code>Financial</code> <p>Financial information about the equipment.</p> <code>Financial()</code> <code>personnel_restrictions</code> <code>str</code> <p>Information about the people (or team) who are qualified to use the equipment.</p> <code>''</code> <code>service_agent</code> <code>str</code> <p>Information about the people or company that are qualified to perform alterations and/or maintenance to the equipment.</p> <code>''</code> <code>technical_procedures</code> <code>tuple[str, ...]</code> <p>The technical procedures that depend on this equipment.</p> <code>()</code>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.accessories","title":"accessories  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>accessories: Accessories = field(\n    default_factory=Accessories\n)\n</code></pre> <p>Additional accessories that may be required to use the equipment.</p>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.documentation","title":"documentation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>documentation: str = ''\n</code></pre> <p>Information (such as URLs) about the manuals, datasheets, etc. for the equipment.</p>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.financial","title":"financial  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>financial: Financial = field(default_factory=Financial)\n</code></pre> <p>Financial information about the equipment.</p>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.personnel_restrictions","title":"personnel_restrictions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>personnel_restrictions: str = ''\n</code></pre> <p>Information about the people (or team) who are qualified to use the equipment.</p>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.service_agent","title":"service_agent  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>service_agent: str = ''\n</code></pre> <p>Information about the people or company that are qualified to perform alterations and/or maintenance to the equipment.</p>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.technical_procedures","title":"technical_procedures  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>technical_procedures: tuple[str, ...] = ()\n</code></pre> <p>The technical procedures that depend on this equipment.</p>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; QualityManual\n</code></pre> <p>Convert an XML element into an QualityManual instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A qualityManual XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>QualityManual</code> <p>The QualityManual instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; QualityManual:\n    \"\"\"Convert an XML element into an [QualityManual][msl.equipment.schema.QualityManual] instance.\n\n    Args:\n        element: A [qualityManual][type_qualityManual] XML element from an equipment register.\n\n    Returns:\n        The [QualityManual][msl.equipment.schema.QualityManual] instance.\n    \"\"\"\n    # Schema defines &lt;qualityManual&gt; using xsd:all, which allows sub-elements to appear (or not appear) in any order\n    # Using str.endswith() allows for ignoring XML namespaces that may be associated with each tag\n    tp: tuple[str, ...] = ()\n    a, d, f, pr, sa = Accessories(), \"\", Financial(), \"\", \"\"\n    for child in element:\n        if child.tag.endswith(\"accessories\"):\n            a = Accessories.from_xml(child)\n        elif child.tag.endswith(\"documentation\"):\n            d = child.text or \"\"\n        elif child.tag.endswith(\"financial\"):\n            f = Financial.from_xml(child)\n        elif child.tag.endswith(\"personnelRestrictions\"):\n            pr = child.text or \"\"\n        elif child.tag.endswith(\"serviceAgent\"):\n            sa = child.text or \"\"\n        else:\n            tp = tuple(i.text for i in child if i.text)\n\n    return cls(\n        accessories=a,\n        documentation=d,\n        financial=f,\n        personnel_restrictions=pr,\n        service_agent=sa,\n        technical_procedures=tp,\n    )\n</code></pre>"},{"location":"schema/quality_manual/#msl.equipment.schema.QualityManual.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the QualityManual class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The QualityManual as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [QualityManual][msl.equipment.schema.QualityManual] class into an XML element.\n\n    Returns:\n        The [QualityManual][msl.equipment.schema.QualityManual] as an XML element.\n    \"\"\"\n    e = Element(\"qualityManual\")\n\n    if len(self.accessories) or len(self.accessories.attrib):\n        e.append(self.accessories)\n\n    if self.documentation:\n        d = SubElement(e, \"documentation\")\n        d.text = self.documentation\n\n    if self.financial != Financial():\n        e.append(self.financial.to_xml())\n\n    if self.personnel_restrictions:\n        pr = SubElement(e, \"personnelRestrictions\")\n        pr.text = self.personnel_restrictions\n\n    if self.service_agent:\n        sa = SubElement(e, \"serviceAgent\")\n        sa.text = self.service_agent\n\n    if self.technical_procedures:\n        tp = SubElement(e, \"technicalProcedures\")\n        for procedure in self.technical_procedures:\n            sub = SubElement(tp, \"id\")\n            sub.text = procedure\n\n    return e\n</code></pre>"},{"location":"schema/reference_materials/","title":"ReferenceMaterials","text":""},{"location":"schema/reference_materials/#msl.equipment.schema.ReferenceMaterials","title":"ReferenceMaterials","text":"<pre><code>ReferenceMaterials(**attributes: str)\n</code></pre> <p>               Bases: <code>Any</code></p> <p>Documentation of reference materials, results, acceptance criteria, relevant dates and the period of validity.</p> <p>Since this class is currently represented by the any type in the XML Schema Definition, it is simply a subclass of Element. It may be updated to be a more specific class at a later date.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any] type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/reference_materials/#msl.equipment.schema.ReferenceMaterials.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str = 'referenceMaterials'\n</code></pre> <p>The element's name.</p>"},{"location":"schema/reference_materials/#msl.equipment.schema.ReferenceMaterials.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/register/","title":"Register","text":"<p>An equipment register can be stored in a single XML file or distributed across multiple XML files. In this example we load a single XML file.</p> <pre><code>&gt;&gt;&gt; from msl.equipment import Register\n&gt;&gt;&gt; register = Register(\"tests/resources/mass/register.xml\")\n</code></pre> <p>Printing the <code>register</code> object shows the name of the team that is responsible for the equipment register and the number of Equipment items that are in the register.</p> <pre><code>&gt;&gt;&gt; register\nRegister(team='Mass' (2 equipment))\n&gt;&gt;&gt; register.team\n'Mass'\n</code></pre> <p>A register behaves like a sequence of Equipment items. You can get the number of items in the sequence and iterate over the sequence,</p> <pre><code>&gt;&gt;&gt; len(register)\n2\n&gt;&gt;&gt; for equipment in register:\n...     print(equipment.id)\n...\nMSLE.M.001\nMSLE.M.092\n</code></pre> <p>access equipment by its index, its equipment id or its alias.</p> <pre><code>&gt;&gt;&gt; register[1].id  # index\n'MSLE.M.092'\n&gt;&gt;&gt; register[\"MSLE.M.092\"].id  # equipment id\n'MSLE.M.092'\n&gt;&gt;&gt; register[\"Bob\"].id  # alias\n'MSLE.M.092'\n</code></pre> <p>The get method will attempt to get the Equipment at the specified index, id or alias, but will return <code>None</code> (instead of raising an exception) if the Equipment cannot be found in the register.</p> <pre><code>&gt;&gt;&gt; assert register.get(4) is None  # invalid index\n&gt;&gt;&gt; assert register.get(\"MSLE.M.999\") is None  # invalid equipment id\n&gt;&gt;&gt; register.get(\"Bob\")  # valid alias\nEquipment(id='MSLE.M.092', manufacturer='XYZ', model='A', serial='b' (4 reports))\n</code></pre> <p>The find method searches the register to find equipment that contain certain text. You may use a regular-expression pattern to find matching equipment items. Here we find all equipment that have the text <code>Hygrometer</code> in one of the Equipment attribute values that are considered in the search.</p> <pre><code>&gt;&gt;&gt; for hygrometer in register.find(\"Hygrometer\"):\n...    print(hygrometer)\nEquipment(id='MSLE.M.092', manufacturer='XYZ', model='A', serial='b' (4 reports))\n</code></pre> <p>We see that one equipment was found and that there are four calibration reports associated with the equipment. From the Equipment instance, we can get the latest calibration report for a certain Component name and Measurand quantity.</p> <p>Tip</p> <p>If the equipment contains only one Measurand and one Component you do not need to specify the name and quantity keyword arguments.</p> <pre><code>&gt;&gt;&gt; report = hygrometer.latest_report(name=\"Probe 1\", quantity=\"Humidity\")\n&gt;&gt;&gt; report\nLatestReport(name='Probe 1', quantity='Humidity', id='Humidity/2023/583' (1 equation))\n</code></pre> <p>We see that the calibration report contains one Equation. We can use the equation to apply a correction to measured values and to calculate the uncertainty.</p> <pre><code>&gt;&gt;&gt; value = report.equation.value\n&gt;&gt;&gt; value.equation\n'R - 7.131e-2 - 3.951e-2*R + 3.412e-4*pow(R,2) + 2.465e-3*t + 1.034e-3*R*t - 5.297e-6*pow(R,2)*t'\n&gt;&gt;&gt; value(R=[45.5, 46.1], t=[20.1, 20.0])\narray([45.1121266, 45.7099039])\n&gt;&gt;&gt; report.equation.uncertainty(R=[45.5, 46.1], t=[20.1, 20.0])\narray([0.355, 0.355])\n&gt;&gt;&gt; report.equation.unit\n'%rh'\n</code></pre> <p>From the LatestReport instance, we can, for example, get the date when the next calibration is due.</p> <pre><code>&gt;&gt;&gt; report.next_calibration_date\ndatetime.date(2028, 8, 14)\n</code></pre>"},{"location":"schema/register/#msl.equipment.schema.Register","title":"Register","text":"<pre><code>Register(*sources: XMLSource | Element[str])\n</code></pre> <p>Represents the register element in an equipment register.</p> <p>Specifying multiple sources allows for storing an equipment register across multiple files for the same team. Not specifying a source creates a new (empty) register.</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>XMLSource | Element[str]</code> <p>The path-like, file-like or Element objects that represent an equipment register.</p> <code>()</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, *sources: XMLSource | Element[str]) -&gt; None:\n    \"\"\"Represents the [register][element_register] element in an equipment register.\n\n    Specifying multiple sources allows for storing an equipment register across multiple\n    files for the same team. Not specifying a source creates a new (empty) register.\n\n    Args:\n        sources: The [path-like][path-like object], [file-like][file-like object] or\n            [Element][xml.etree.ElementTree.Element] objects that represent an equipment register.\n    \"\"\"\n    team = \"\"\n    self._elements: list[Element[str]] = []\n    for source in sources:\n        root = source if isinstance(source, Element) else ElementTree().parse(source)\n        t = root.attrib.get(\"team\", \"\")\n        if not team:\n            team = t\n\n        if team != t:\n            msg = f\"Cannot merge equipment registers from different teams, {team!r} != {t!r}\"\n            raise ValueError(msg)\n\n        self._elements.extend(root)\n\n    self._team: str = team\n    self._equipment: list[Equipment | None] = [None] * len(self._elements)\n\n    # a mapping between the alias/id and the index number in the register\n    self._index_map: dict[str, int] = {str(e[0].text): i for i, e in enumerate(self._elements)}  # e[0] is the ID\n    self._index_map.update({e.attrib[\"alias\"]: i for i, e in enumerate(self._elements) if e.attrib.get(\"alias\")})\n</code></pre>"},{"location":"schema/register/#msl.equipment.schema.Register.NAMESPACE","title":"NAMESPACE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NAMESPACE: str = (\n    \"https://measurement.govt.nz/equipment-register\"\n)\n</code></pre> <p>Default XML namespace.</p>"},{"location":"schema/register/#msl.equipment.schema.Register.team","title":"team  <code>property</code> <code>writable</code>","text":"<pre><code>team: str\n</code></pre> <p>str \u2014 The name of the team that is responsible for the equipment register.</p>"},{"location":"schema/register/#msl.equipment.schema.Register.add","title":"add","text":"<pre><code>add(equipment: Equipment) -&gt; None\n</code></pre> <p>Add equipment to the register.</p> <p>Parameters:</p> Name Type Description Default <code>equipment</code> <code>Equipment</code> <p>The equipment to add.</p> required Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def add(self, equipment: Equipment) -&gt; None:\n    \"\"\"Add equipment to the register.\n\n    Args:\n        equipment: The equipment to add.\n    \"\"\"\n    if equipment.id:\n        self._index_map[equipment.id] = len(self._equipment)\n    if equipment.alias:\n        self._index_map[equipment.alias] = len(self._equipment)\n    self._equipment.append(equipment)\n</code></pre>"},{"location":"schema/register/#msl.equipment.schema.Register.find","title":"find","text":"<pre><code>find(\n    pattern: str | Pattern[str], *, flags: int = 0\n) -&gt; Iterator[Equipment]\n</code></pre> <p>Find equipment in the register.</p> <p>The following attributes are used in the search:</p> <ul> <li>keywords: Equipment</li> <li>description: Equipment</li> <li>manufacturer: Equipment</li> <li>model: Equipment</li> <li>serial: Equipment</li> <li>id: Equipment, Report, DigitalReport</li> <li>location: Equipment</li> <li>quantity: Measurand</li> <li>name: Component</li> <li>entered_by: Equipment, PerformanceCheck, Report</li> <li>checked_by: Equipment, PerformanceCheck, Report</li> <li>performed_by: Alteration, CompletedTask, PlannedTask</li> <li>comment: CVDEquation, Equation, File, Table, Deserialised, DigitalReport</li> <li>format: DigitalReport</li> <li>details: Alteration, Adjustment</li> <li>task: CompletedTask, PlannedTask</li> <li>asset_number: CapitalExpenditure</li> <li>service_agent: QualityManual</li> <li>technical_procedures: QualityManual</li> </ul> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str | Pattern[str]</code> <p>A regular-expression pattern to use to find equipment.</p> required <code>flags</code> <code>int</code> <p>The flags to use to compile the <code>pattern</code>. See re.compile for more details.</p> <code>0</code> <p>Yields:</p> Type Description <code>Equipment</code> <p>Equipment that match the <code>pattern</code>.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def find(self, pattern: str | re.Pattern[str], *, flags: int = 0) -&gt; Iterator[Equipment]:  # noqa: C901\n    \"\"\"Find equipment in the register.\n\n    The following attributes are used in the search:\n\n    * keywords: [Equipment][msl.equipment.schema.Equipment]\n    * description: [Equipment][msl.equipment.schema.Equipment]\n    * manufacturer: [Equipment][msl.equipment.schema.Equipment]\n    * model: [Equipment][msl.equipment.schema.Equipment]\n    * serial: [Equipment][msl.equipment.schema.Equipment]\n    * id: [Equipment][msl.equipment.schema.Equipment], [Report][msl.equipment.schema.Report], [DigitalReport][msl.equipment.schema.DigitalReport]\n    * location: [Equipment][msl.equipment.schema.Equipment]\n    * quantity: [Measurand][msl.equipment.schema.Measurand]\n    * name: [Component][msl.equipment.schema.Component]\n    * entered_by: [Equipment][msl.equipment.schema.Equipment], [PerformanceCheck][msl.equipment.schema.PerformanceCheck], [Report][msl.equipment.schema.Report]\n    * checked_by: [Equipment][msl.equipment.schema.Equipment], [PerformanceCheck][msl.equipment.schema.PerformanceCheck], [Report][msl.equipment.schema.Report]\n    * performed_by: [Alteration][msl.equipment.schema.Alteration], [CompletedTask][msl.equipment.schema.CompletedTask], [PlannedTask][msl.equipment.schema.PlannedTask]\n    * comment: [CVDEquation][msl.equipment.schema.CVDEquation], [Equation][msl.equipment.schema.Equation], [File][msl.equipment.schema.File], [Table][msl.equipment.schema.Table], [Deserialised][msl.equipment.schema.Deserialised], [DigitalReport][msl.equipment.schema.DigitalReport]\n    * format: [DigitalReport][msl.equipment.schema.DigitalReport]\n    * details: [Alteration][msl.equipment.schema.Alteration], [Adjustment][msl.equipment.schema.Adjustment]\n    * task: [CompletedTask][msl.equipment.schema.CompletedTask], [PlannedTask][msl.equipment.schema.PlannedTask]\n    * asset_number: [CapitalExpenditure][msl.equipment.schema.CapitalExpenditure]\n    * service_agent: [QualityManual][msl.equipment.schema.QualityManual]\n    * technical_procedures: [QualityManual][msl.equipment.schema.QualityManual]\n\n    Args:\n        pattern: A [regular-expression pattern](https://regexr.com/) to use to find equipment.\n        flags: The flags to use to compile the `pattern`. See [re.compile][] for more details.\n\n    Yields:\n        Equipment that match the `pattern`.\n    \"\"\"  # noqa: E501\n\n    def comment_search(item: Report | PerformanceCheck) -&gt; bool:\n        for cvd_equation in item.cvd_equations:\n            if regex.search(cvd_equation.comment) is not None:\n                return True\n        for equation in item.equations:\n            if regex.search(equation.comment) is not None:\n                return True\n        for file in item.files:\n            if regex.search(file.comment) is not None:\n                return True\n        for table in item.tables:\n            if regex.search(table.comment) is not None:\n                return True\n        return any(regex.search(deserialised.comment) is not None for deserialised in item.deserialisers)\n\n    def task_search(m: Maintenance) -&gt; bool:\n        for c in m.completed:\n            if regex.search(c.task) is not None:\n                return True\n            if regex.search(c.performed_by) is not None:\n                return True\n        for p in m.planned:\n            if regex.search(p.task) is not None:\n                return True\n            if regex.search(p.performed_by) is not None:\n                return True\n        return False\n\n    def alteration_search(alterations: tuple[Alteration, ...]) -&gt; bool:\n        for a in alterations:\n            if regex.search(a.details) is not None:\n                return True\n            if regex.search(a.performed_by) is not None:\n                return True\n        return False\n\n    def calibrations_search(e: Equipment) -&gt; bool:  # noqa: C901, PLR0911, PLR0912\n        for m in e.calibrations:\n            if regex.search(m.quantity) is not None:\n                return True\n            for c in m.components:\n                if regex.search(c.name) is not None:\n                    return True\n                for r in c.reports:\n                    if regex.search(r.entered_by) is not None:\n                        return True\n                    if regex.search(r.checked_by) is not None:\n                        return True\n                    if comment_search(r):\n                        return True\n                    if regex.search(r.id) is not None:\n                        return True\n                for pc in c.performance_checks:\n                    if regex.search(pc.entered_by) is not None:\n                        return True\n                    if regex.search(pc.checked_by) is not None:\n                        return True\n                    if comment_search(pc):\n                        return True\n                for a in c.adjustments:\n                    if regex.search(a.details) is not None:\n                        return True\n                for dr in c.digital_reports:\n                    if regex.search(dr.format.value) is not None:\n                        return True\n                    if regex.search(dr.id) is not None:\n                        return True\n                    if regex.search(dr.comment) is not None:\n                        return True\n        return False\n\n    def asset_number_search(f: Financial) -&gt; bool:\n        if f.capital_expenditure is None:\n            return False\n        return regex.search(f.capital_expenditure.asset_number) is not None\n\n    regex = re.compile(pattern, flags=flags)\n    for equipment in self:\n        if (\n            regex.search(\" \".join(equipment.keywords)) is not None\n            or regex.search(equipment.description) is not None\n            or regex.search(equipment.manufacturer) is not None\n            or regex.search(equipment.model) is not None\n            or regex.search(equipment.serial) is not None\n            or regex.search(equipment.id) is not None\n            or regex.search(equipment.location) is not None\n            or regex.search(equipment.entered_by) is not None\n            or regex.search(equipment.checked_by) is not None\n            or calibrations_search(equipment)\n            or alteration_search(equipment.alterations)\n            or task_search(equipment.maintenance)\n            or asset_number_search(equipment.quality_manual.financial)\n            or regex.search(equipment.quality_manual.service_agent) is not None\n            or regex.search(\" \".join(equipment.quality_manual.technical_procedures)) is not None\n        ):\n            yield equipment\n</code></pre>"},{"location":"schema/register/#msl.equipment.schema.Register.get","title":"get","text":"<pre><code>get(item: int | str) -&gt; Equipment | None\n</code></pre> <p>Get an Equipment item from the register.</p> <p>This method will ignore all errors if the register does not contain the requested Equipment item.</p> <p>Tip</p> <p>You can also treat a register instance as a sequence of Equipment items.</p> <p>Using the indexable notation on a register instance to access an Equipment item by using the alias of the equipment or the index within the register could raise an exception</p> <pre><code>&gt;&gt;&gt; register[\"unknown-alias\"]\nTraceback (most recent call last):\n...\nValueError: No equipment exists with the alias or id 'unknown-alias'\n\n&gt;&gt;&gt; register[243]\nTraceback (most recent call last):\n...\nIndexError: list index out of range\n</code></pre> <p>whereas these errors can be silenced by using the get method</p> <pre><code>&gt;&gt;&gt; assert register.get(\"unknown\") is None\n&gt;&gt;&gt; assert register.get(243) is None\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>int | str</code> <p>The index number, equipment id value or the equipment alias value in the register.</p> required <p>Returns:</p> Type Description <code>Equipment | None</code> <p>The Equipment item if <code>item</code> is valid, otherwise <code>None</code>.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def get(self, item: int | str) -&gt; Equipment | None:\n    \"\"\"Get an [Equipment][msl.equipment.schema.Equipment] item from the register.\n\n    This method will ignore all errors if the register does not contain the requested\n    [Equipment][msl.equipment.schema.Equipment] item.\n\n    !!! tip\n        You can also treat a _register_ instance as a sequence of [Equipment][msl.equipment.schema.Equipment] items.\n\n    &lt;!--\n    &gt;&gt;&gt; from msl.equipment import Register\n    &gt;&gt;&gt; register = Register(\"tests/resources/mass/register.xml\")\n\n    --&gt;\n\n    Using the _indexable_ notation on a _register_ instance to access an [Equipment][msl.equipment.schema.Equipment]\n    item by using the alias of the equipment or the index within the register could raise an exception\n\n    ```pycon\n    &gt;&gt;&gt; register[\"unknown-alias\"]\n    Traceback (most recent call last):\n    ...\n    ValueError: No equipment exists with the alias or id 'unknown-alias'\n\n    &gt;&gt;&gt; register[243]\n    Traceback (most recent call last):\n    ...\n    IndexError: list index out of range\n\n    ```\n\n    whereas these errors can be silenced by using the [get][msl.equipment.schema.Register.get] method\n\n    ```pycon\n    &gt;&gt;&gt; assert register.get(\"unknown\") is None\n    &gt;&gt;&gt; assert register.get(243) is None\n\n    ```\n\n    Args:\n        item: The index number, equipment id value or the equipment alias value in the register.\n\n    Returns:\n        The [Equipment][msl.equipment.schema.Equipment] item if `item` is valid, otherwise `None`.\n    \"\"\"\n    try:\n        return self[item]\n    except (ValueError, IndexError):\n        return None\n</code></pre>"},{"location":"schema/register/#msl.equipment.schema.Register.tree","title":"tree","text":"<pre><code>tree(\n    namespace: str | None = \"DEFAULT\", indent: int = 4\n) -&gt; ElementTree[Element[str]]\n</code></pre> <p>Convert the Register class into an XML element tree.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str | None</code> <p>The namespace to associate with the root element. If the value is <code>DEFAULT</code>, uses the value of NAMESPACE as the namespace. If <code>None</code>, or an empty string, no namespace is associated with the root element.</p> <code>'DEFAULT'</code> <code>indent</code> <code>int</code> <p>The number of spaces to indent sub elements. The value must be \u2265 0. This parameter is ignored if the version of Python is &lt; 3.9.</p> <code>4</code> <p>Returns:</p> Type Description <code>ElementTree[Element[str]]</code> <p>The Register as an ElementTree.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def tree(self, namespace: str | None = \"DEFAULT\", indent: int = 4) -&gt; ElementTree[Element[str]]:\n    \"\"\"Convert the [Register][msl.equipment.schema.Register] class into an XML element tree.\n\n    Args:\n        namespace: The namespace to associate with the root element. If the value is\n            `DEFAULT`, uses the value of [NAMESPACE][msl.equipment.schema.Register.NAMESPACE]\n            as the namespace. If `None`, or an empty string, no namespace is associated\n            with the root element.\n        indent: The number of spaces to indent sub elements. The value must be &amp;ge; 0.\n            This parameter is ignored if the version of Python is &amp;lt; 3.9.\n\n    Returns:\n        The [Register][msl.equipment.schema.Register] as an\n            [ElementTree][xml.etree.ElementTree.ElementTree].\n    \"\"\"\n    if indent &lt; 0:\n        msg = f\"Indentation must be &gt;= 0, got {indent}\"\n        raise ValueError(msg)\n\n    attrib = {\"team\": self.team}\n    if namespace:\n        if namespace == \"DEFAULT\":\n            namespace = self.NAMESPACE\n        attrib[\"xmlns\"] = namespace\n\n    # The &lt;table&gt;&lt;data&gt; element is 7 levels deep from &lt;register&gt;\n    _Indent.table_data = (7 * indent) + len(\"&lt;data&gt;\")\n\n    e = Element(\"register\", attrib=attrib)\n    e.extend(equipment.to_xml() for equipment in self)\n    tree: ElementTree[Element[str]] = ElementTree(element=e)\n\n    if indent &gt; 0 and sys.version_info &gt;= (3, 9):\n        from xml.etree.ElementTree import indent as pretty  # noqa: PLC0415\n\n        pretty(tree, space=\" \" * indent)\n\n    return tree\n</code></pre>"},{"location":"schema/report/","title":"Report","text":""},{"location":"schema/report/#msl.equipment.schema.Report","title":"Report  <code>dataclass</code>","text":"<pre><code>Report(\n    id: str,\n    report_issue_date: date,\n    measurement_start_date: date,\n    measurement_stop_date: date,\n    issuing_laboratory: IssuingLaboratory = IssuingLaboratory(),\n    technical_procedure: str = \"\",\n    entered_by: str = \"\",\n    checked_by: str = \"\",\n    checked_date: date | None = None,\n    conditions: Conditions = Conditions(),\n    acceptance_criteria: AcceptanceCriteria = AcceptanceCriteria(),\n    cvd_equations: tuple[CVDEquation, ...] = (),\n    deserialisers: tuple[Deserialised, ...] = (),\n    equations: tuple[Equation, ...] = (),\n    files: tuple[File, ...] = (),\n    tables: tuple[Table, ...] = (),\n)\n</code></pre> <p>Represents the report element in an equipment register.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The report identification number.</p> required <code>report_issue_date</code> <code>date</code> <p>The date that the report was issued.</p> required <code>measurement_start_date</code> <code>date</code> <p>The date that the calibration measurement started.</p> required <code>measurement_stop_date</code> <code>date</code> <p>The date that the calibration measurement stopped.</p> required <code>issuing_laboratory</code> <code>IssuingLaboratory</code> <p>Information about the laboratory that issued the calibration report.</p> <code>IssuingLaboratory()</code> <code>technical_procedure</code> <code>str</code> <p>The technical procedure(s) that was(were) followed to perform the calibration.</p> <code>''</code> <code>entered_by</code> <code>str</code> <p>The name of the person who initially entered the <code>&lt;report&gt;</code> element in the register.</p> <code>''</code> <code>checked_by</code> <code>str</code> <p>The name of the person who checked the information in the <code>&lt;report&gt;</code> element.</p> <code>''</code> <code>checked_date</code> <code>date | None</code> <p>The date that the information in the <code>&lt;report&gt;</code> element was last checked.</p> <code>None</code> <code>conditions</code> <code>Conditions</code> <p>The conditions under which the report is valid.</p> <code>Conditions()</code> <code>acceptance_criteria</code> <code>AcceptanceCriteria</code> <p>Acceptance criteria for the calibration report.</p> <code>AcceptanceCriteria()</code> <code>cvd_equations</code> <code>tuple[CVDEquation, ...]</code> <p>Calibration data is expressed as Callendar-Van Dusen equations.</p> <code>()</code> <code>deserialisers</code> <code>tuple[Deserialised, ...]</code> <p>Calibration data is stored in serialised formats and deserialised.</p> <code>()</code> <code>equations</code> <code>tuple[Equation, ...]</code> <p>Calibration data is expressed as equations.</p> <code>()</code> <code>files</code> <code>tuple[File, ...]</code> <p>Calibration data is stored in other files (not in the equipment register).</p> <code>()</code> <code>tables</code> <code>tuple[Table, ...]</code> <p>Calibration data is stored as Comma Separated Values (CSV) tables.</p> <code>()</code>"},{"location":"schema/report/#msl.equipment.schema.Report.acceptance_criteria","title":"acceptance_criteria  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acceptance_criteria: AcceptanceCriteria = field(\n    default_factory=AcceptanceCriteria\n)\n</code></pre> <p>Acceptance criteria for the calibration report.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.checked_by","title":"checked_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_by: str = ''\n</code></pre> <p>The name of the person who checked the information in the <code>&lt;report&gt;</code> element.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.checked_date","title":"checked_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>checked_date: date | None = None\n</code></pre> <p>The date that the information in the <code>&lt;report&gt;</code> element was last checked.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.conditions","title":"conditions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>conditions: Conditions = field(default_factory=Conditions)\n</code></pre> <p>The conditions under which the report is valid.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.cvd_equation","title":"cvd_equation  <code>property</code>","text":"<pre><code>cvd_equation: CVDEquation\n</code></pre> <p>Returns the first item in the cvd_equations tuple.</p> <p>Raises IndexError if the report does not contain Callendar-Van Dusen equations.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.cvd_equations","title":"cvd_equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cvd_equations: tuple[CVDEquation, ...] = ()\n</code></pre> <p>Calibration data is expressed as Callendar-Van Dusen equations.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.deserialised","title":"deserialised  <code>property</code>","text":"<pre><code>deserialised: Deserialised\n</code></pre> <p>Returns the first item in the deserialisers tuple.</p> <p>Raises IndexError if the report does not contain serialised data.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.deserialisers","title":"deserialisers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>deserialisers: tuple[Deserialised, ...] = ()\n</code></pre> <p>Calibration data is stored in serialised formats and deserialised.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.entered_by","title":"entered_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entered_by: str = ''\n</code></pre> <p>The name of the person who initially entered the <code>&lt;report&gt;</code> element in the register.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.equation","title":"equation  <code>property</code>","text":"<pre><code>equation: Equation\n</code></pre> <p>Returns the first item in the equations tuple.</p> <p>Raises IndexError if the report does not contain equations.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.equations","title":"equations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>equations: tuple[Equation, ...] = ()\n</code></pre> <p>Calibration data is expressed as equations.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.file","title":"file  <code>property</code>","text":"<pre><code>file: File\n</code></pre> <p>Returns the first item in the files tuple.</p> <p>Raises IndexError if the report does not contain files.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.files","title":"files  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>files: tuple[File, ...] = ()\n</code></pre> <p>Calibration data is stored in other files (not in the equipment register).</p>"},{"location":"schema/report/#msl.equipment.schema.Report.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>The report identification number.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.issuing_laboratory","title":"issuing_laboratory  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>issuing_laboratory: IssuingLaboratory = field(\n    default_factory=IssuingLaboratory\n)\n</code></pre> <p>Information about the laboratory that issued the calibration report.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.measurement_start_date","title":"measurement_start_date  <code>instance-attribute</code>","text":"<pre><code>measurement_start_date: date\n</code></pre> <p>The date that the calibration measurement started.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.measurement_stop_date","title":"measurement_stop_date  <code>instance-attribute</code>","text":"<pre><code>measurement_stop_date: date\n</code></pre> <p>The date that the calibration measurement stopped.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.report_issue_date","title":"report_issue_date  <code>instance-attribute</code>","text":"<pre><code>report_issue_date: date\n</code></pre> <p>The date that the report was issued.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.table","title":"table  <code>property</code>","text":"<pre><code>table: Table\n</code></pre> <p>Returns the first item in the tables tuple.</p> <p>Raises IndexError if the report does not contain tables.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.tables","title":"tables  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tables: tuple[Table, ...] = ()\n</code></pre> <p>Calibration data is stored as Comma Separated Values (CSV) tables.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.technical_procedure","title":"technical_procedure  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>technical_procedure: str = ''\n</code></pre> <p>The technical procedure(s) that was(were) followed to perform the calibration.</p>"},{"location":"schema/report/#msl.equipment.schema.Report.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Report\n</code></pre> <p>Convert an XML element into a Report instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A report XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Report</code> <p>The Report instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Report:\n    \"\"\"Convert an XML element into a [Report][msl.equipment.schema.Report] instance.\n\n    Args:\n        element: A [report][type_report] XML element from an equipment register.\n\n    Returns:\n        The [Report][msl.equipment.schema.Report] instance.\n    \"\"\"\n    # Schema forces order until `acceptanceCriteria` and then uses xsd:choice, which\n    # allows sub-elements to appear (or not appear) in any order, for the data elements.\n    # Using str.endswith() allows for ignoring XML namespaces that may be associated with each tag\n    cvd_equations: list[CVDEquation] = []\n    deserialisers: list[Deserialised] = []\n    equations: list[Equation] = []\n    files: list[File] = []\n    tables: list[Table] = []\n    for child in element[7:]:\n        tag = child.tag\n        if tag.endswith(\"equation\"):\n            equations.append(Equation.from_xml(child))\n        elif tag.endswith(\"table\"):\n            tables.append(Table.from_xml(child))\n        elif tag.endswith(\"cvdCoefficients\"):\n            cvd_equations.append(CVDEquation.from_xml(child))\n        elif tag.endswith(\"file\"):\n            files.append(File.from_xml(child))\n        else:\n            deserialisers.append(Deserialised.from_xml(child))\n\n    a = element.attrib\n    return cls(\n        id=a[\"id\"] or \"\",\n        entered_by=a[\"enteredBy\"] or \"\",\n        checked_by=a.get(\"checkedBy\", \"\"),\n        checked_date=None if not a.get(\"checkedDate\") else _date.fromisoformat(a[\"checkedDate\"]),\n        report_issue_date=_date.fromisoformat(element[0].text or \"\"),\n        measurement_start_date=_date.fromisoformat(element[1].text or \"\"),\n        measurement_stop_date=_date.fromisoformat(element[2].text or \"\"),\n        issuing_laboratory=IssuingLaboratory.from_xml(element[3]),\n        technical_procedure=element[4].text or \"\",\n        conditions=Conditions.from_xml(element[5]),\n        acceptance_criteria=AcceptanceCriteria.from_xml(element[6]),\n        cvd_equations=tuple(cvd_equations),\n        deserialisers=tuple(deserialisers),\n        equations=tuple(equations),\n        files=tuple(files),\n        tables=tuple(tables),\n    )\n</code></pre>"},{"location":"schema/report/#msl.equipment.schema.Report.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Report class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Report as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Report][msl.equipment.schema.Report] class into an XML element.\n\n    Returns:\n        The [Report][msl.equipment.schema.Report] as an XML element.\n    \"\"\"\n    a = {\"id\": self.id, \"enteredBy\": self.entered_by}\n    if self.checked_by:\n        a[\"checkedBy\"] = self.checked_by\n    if self.checked_date is not None:\n        a[\"checkedDate\"] = self.checked_date.isoformat()\n\n    e = Element(\"report\", attrib=a)\n\n    rid = SubElement(e, \"reportIssueDate\")\n    rid.text = self.report_issue_date.isoformat()\n\n    start = SubElement(e, \"measurementStartDate\")\n    start.text = self.measurement_start_date.isoformat()\n\n    stop = SubElement(e, \"measurementStopDate\")\n    stop.text = self.measurement_stop_date.isoformat()\n\n    e.append(self.issuing_laboratory.to_xml())\n\n    tp = SubElement(e, \"technicalProcedure\")\n    tp.text = self.technical_procedure\n\n    e.append(self.conditions)\n    e.append(self.acceptance_criteria)\n    e.extend(equation.to_xml() for equation in self.equations)\n    e.extend(table.to_xml() for table in self.tables)\n    e.extend(cvd.to_xml() for cvd in self.cvd_equations)\n    e.extend(file.to_xml() for file in self.files)\n    e.extend(deserialised.to_xml() for deserialised in self.deserialisers)\n    return e\n</code></pre>"},{"location":"schema/report/#msl.equipment.schema.IssuingLaboratory","title":"IssuingLaboratory  <code>dataclass</code>","text":"<pre><code>IssuingLaboratory(lab: str = '', person: str = '')\n</code></pre> <p>Information about the laboratory that issued a calibration report.</p> <p>Parameters:</p> Name Type Description Default <code>lab</code> <code>str</code> <p>The name of the laboratory that issued the calibration report.</p> <code>''</code> <code>person</code> <code>str</code> <p>The name of a person at the <code>laboratory</code> that authorised the report.</p> <code>''</code>"},{"location":"schema/report/#msl.equipment.schema.IssuingLaboratory.lab","title":"lab  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lab: str = ''\n</code></pre> <p>The name of the laboratory that issued the calibration report.</p>"},{"location":"schema/report/#msl.equipment.schema.IssuingLaboratory.person","title":"person  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>person: str = ''\n</code></pre> <p>The name of a person at the laboratory that authorised the report.</p>"},{"location":"schema/report/#msl.equipment.schema.IssuingLaboratory.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; IssuingLaboratory\n</code></pre> <p>Convert an XML element into a IssuingLaboratory instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An <code>&lt;issuingLaboratory&gt;</code> element from a report element in an equipment register.</p> required <p>Returns:</p> Type Description <code>IssuingLaboratory</code> <p>The IssuingLaboratory instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; IssuingLaboratory:\n    \"\"\"Convert an XML element into a [IssuingLaboratory][msl.equipment.schema.IssuingLaboratory] instance.\n\n    Args:\n        element: An `&lt;issuingLaboratory&gt;` element from a [report][type_report] element\n            in an equipment register.\n\n    Returns:\n        The [IssuingLaboratory][msl.equipment.schema.IssuingLaboratory] instance.\n    \"\"\"\n    return cls(\n        lab=element.text or \"\",\n        person=element.attrib.get(\"person\", \"\"),\n    )\n</code></pre>"},{"location":"schema/report/#msl.equipment.schema.IssuingLaboratory.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the IssuingLaboratory class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The IssuingLaboratory as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [IssuingLaboratory][msl.equipment.schema.IssuingLaboratory] class into an XML element.\n\n    Returns:\n        The [IssuingLaboratory][msl.equipment.schema.IssuingLaboratory] as an XML element.\n    \"\"\"\n    a = {\"person\": self.person} if self.person else {}\n    e = Element(\"issuingLaboratory\", attrib=a)\n    e.text = self.lab\n    return e\n</code></pre>"},{"location":"schema/specifications/","title":"Specifications","text":""},{"location":"schema/specifications/#msl.equipment.schema.Specifications","title":"Specifications","text":"<pre><code>Specifications(**attributes: str)\n</code></pre> <p>               Bases: <code>Any</code></p> <p>Specifications provided by the manufacturer of the equipment.</p> <p>Typically, the specifications are specified on the website, datasheet and/or technical notes that a manufacturer provides.</p> <p>Since this class is currently represented by the any type in the XML Schema Definition, it is simply a subclass of Element. It may be updated to be a more specific class at a later date.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any] type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/specifications/#msl.equipment.schema.Specifications.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str = 'specifications'\n</code></pre> <p>The element's name.</p>"},{"location":"schema/specifications/#msl.equipment.schema.Specifications.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/specified_requirements/","title":"SpecifiedRequirements","text":""},{"location":"schema/specified_requirements/#msl.equipment.schema.SpecifiedRequirements","title":"SpecifiedRequirements","text":"<pre><code>SpecifiedRequirements(**attributes: str)\n</code></pre> <p>               Bases: <code>Any</code></p> <p>Verification that equipment conforms with specified requirements before being placed or returned into service.</p> <p>Since this class is currently represented by the any type in the XML Schema Definition, it is simply a subclass of Element. It may be updated to be a more specific class at a later date.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>str</code> <p>All keyword arguments are used as the element's attributes.</p> <code>{}</code> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def __init__(self, **attributes: str) -&gt; None:\n    \"\"\"Base class that represents the [any][type_any] type in the XML Schema Definition.\n\n    Args:\n        attributes: All keyword arguments are used as the element's attributes.\n    \"\"\"\n    super().__init__(self.tag, attrib={}, **attributes)\n</code></pre>"},{"location":"schema/specified_requirements/#msl.equipment.schema.SpecifiedRequirements.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str = 'specifiedRequirements'\n</code></pre> <p>The element's name.</p>"},{"location":"schema/specified_requirements/#msl.equipment.schema.SpecifiedRequirements.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; A\n</code></pre> <p>Copies an XML element into the Any subclass.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>An XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>A</code> <p>The subclass instance.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls: type[A], element: Element[str]) -&gt; A:  # noqa: PYI019\n    \"\"\"Copies an XML element into the [Any][msl.equipment.schema.Any] subclass.\n\n    Args:\n        element: An XML element from an equipment register.\n\n    Returns:\n        The subclass instance.\n    \"\"\"\n    prefix = f\"{{{Register.NAMESPACE}}}\"\n    for e in element.iter():\n        if e.tag.startswith(prefix):  # str.removeprefix() was added in Python 3.9\n            e.tag = e.tag[len(prefix) :]\n\n    c = cls(**element.attrib)\n    c.tail = element.tail\n    c.text = element.text\n    c.extend(element)\n    return c\n</code></pre>"},{"location":"schema/status/","title":"Status","text":""},{"location":"schema/status/#msl.equipment.schema.Status","title":"Status","text":"<p>               Bases: <code>Enum</code></p> <p>Represents the status enumeration in an equipment register.</p> <p>Attributes:</p> Name Type Description <code>Active</code> <code>str</code> <p>The equipment is operable and may be used.</p> <code>Damaged</code> <code>str</code> <p>The equipment is damaged and is no longer usable.</p> <code>Disposed</code> <code>str</code> <p>The equipment has been disposed of and is no longer at available (e.g., the equipment was sent to the landfill or to be recycled).</p> <code>Dormant</code> <code>str</code> <p>The equipment is still operable, it is no longer in use but may be used again (e.g., the equipment was replaced with a newer model, and it is kept as a backup).</p> <code>Lost</code> <code>str</code> <p>The equipment is lost, but if found may be put back into service.</p> <code>Retired</code> <code>str</code> <p>The equipment is still operable, but there are no intentions of using it again (e.g., the equipment depends on other equipment that is not available or is no longer manufactured).</p>"},{"location":"schema/table/","title":"Table","text":"<p>Suppose you have a variable named <code>table</code> (which is an instance of Table) that represents the following information in an equipment register for equipment that measures spectral irradiance</p> <pre><code>&lt;table comment=\"Spectral\"&gt;\n  &lt;type&gt;   int       ,    double ,    double     &lt;/type&gt;\n  &lt;unit&gt;   nm        ,    W/m^2  ,    W/m^2      &lt;/unit&gt;\n  &lt;header&gt; Wavelength, Irradiance, u(Irradiance) &lt;/header&gt;\n  &lt;data&gt;   250       ,    0.01818,   0.02033\n           300       ,    0.18478,   0.01755\n           350       ,    0.80845,   0.01606\n           400       ,    2.21355,   0.01405\n           450       ,    4.49004,   0.01250\n           500       ,    7.45135,   0.01200\n           550       ,   10.75753,   0.01152\n           600       ,   14.03809,   0.01102\n           650       ,   16.99469,   0.01103\n           700       ,   19.44093,   0.01077\n  &lt;/data&gt;\n&lt;/table&gt;\n</code></pre> <p>The <code>table</code> instance is a numpy structured array that has the header values as the field name of each column</p> <pre><code>&gt;&gt;&gt; table.header\narray(['Wavelength', 'Irradiance', 'u(Irradiance)'], dtype='&lt;U13')\n&gt;&gt;&gt; table[\"Wavelength\"]\nTable([250, 300, 350, 400, 450, 500, 550, 600, 650, 700])\n&gt;&gt;&gt; table.types[\"Irradiance\"]\narray(dtype('float64'), dtype=object)\n&gt;&gt;&gt; assert table.units[\"u(Irradiance)\"] == \"W/m^2\"\n</code></pre> <p>Since <code>table</code> is a numpy array, you can index it</p> <pre><code>&gt;&gt;&gt; print(table[0])\n(250, 0.01818, 0.02033)\n&gt;&gt;&gt; sliced=table[:3]\n&gt;&gt;&gt; print(sliced)\n[(250, 0.01818, 0.02033) (300, 0.18478, 0.01755) (350, 0.80845, 0.01606)]\n</code></pre> <p>and since <code>sliced</code> is another Table instance, the attributes of the original <code>table</code> are available</p> <pre><code>&gt;&gt;&gt; sliced.comment\n'Spectral'\n&gt;&gt;&gt; sliced.header\narray(['Wavelength', 'Irradiance', 'u(Irradiance)'], dtype='&lt;U13')\n</code></pre> <p>You can also perform mathematical operations and call numpy functions directly with the <code>table</code> instance</p> <pre><code>&gt;&gt;&gt; np.cos(1 + table[\"Irradiance\"])\nTable([ 0.52491592,  0.37650087, -0.2354229 , -0.99741219,  0.70160756,\n       -0.56246854,  0.6903377 , -0.78390036,  0.65631968, -0.0205763 ])\n</code></pre> <p>Suppose you wanted to get all Irradiance values in the table that are for UV light (i.e., wavelengths &lt; 400 nm)</p> <pre><code>&gt;&gt;&gt; table[\"Irradiance\"][ table[\"Wavelength\"] &lt; 400 ]\nTable([0.01818, 0.18478, 0.80845])\n</code></pre> <p>If you prefer to work with unstructured data, you can convert the <code>table</code> by calling the unstructured method</p> <pre><code>&gt;&gt;&gt; unstructured = table.unstructured()\n&gt;&gt;&gt; unstructured\nTable([[2.500000e+02, 1.818000e-02, 2.033000e-02],\n       [3.000000e+02, 1.847800e-01, 1.755000e-02],\n       [3.500000e+02, 8.084500e-01, 1.606000e-02],\n       [4.000000e+02, 2.213550e+00, 1.405000e-02],\n       [4.500000e+02, 4.490040e+00, 1.250000e-02],\n       [5.000000e+02, 7.451350e+00, 1.200000e-02],\n       [5.500000e+02, 1.075753e+01, 1.152000e-02],\n       [6.000000e+02, 1.403809e+01, 1.102000e-02],\n       [6.500000e+02, 1.699469e+01, 1.103000e-02],\n       [7.000000e+02, 1.944093e+01, 1.077000e-02]])\n&gt;&gt;&gt; print(unstructured[0, 0])\n250.0\n</code></pre>"},{"location":"schema/table/#msl.equipment.schema.Table","title":"Table","text":"<p>               Bases: <code>ndarray</code></p> <p>Represents the table element in an equipment register.</p>"},{"location":"schema/table/#msl.equipment.schema.Table.comment","title":"comment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>comment: str = ''\n</code></pre> <p>A comment that is associated with the table.</p>"},{"location":"schema/table/#msl.equipment.schema.Table.header","title":"header  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>header: NDArray[void] = empty(0, dtype=object)\n</code></pre> <p>The header value of each column.</p>"},{"location":"schema/table/#msl.equipment.schema.Table.types","title":"types  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>types: NDArray[void] = empty(0, dtype=object)\n</code></pre> <p>The data type of each column.</p>"},{"location":"schema/table/#msl.equipment.schema.Table.units","title":"units  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>units: NDArray[void] = empty(0, dtype=object)\n</code></pre> <p>The unit of each column.</p>"},{"location":"schema/table/#msl.equipment.schema.Table.from_xml","title":"from_xml  <code>classmethod</code>","text":"<pre><code>from_xml(element: Element[str]) -&gt; Table\n</code></pre> <p>Convert an XML element into a Table instance.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element[str]</code> <p>A table XML element from an equipment register.</p> required <p>Returns:</p> Type Description <code>Table</code> <p>A Table is an subclass of a numpy structured array, where the <code>header</code> is used as the field names. This allows for accessing a column by the header value rather than by the index of a column. If you prefer to work with unstructured data, call unstructured on the returned object.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>@classmethod\ndef from_xml(cls, element: Element[str]) -&gt; Table:\n    \"\"\"Convert an XML element into a [Table][msl.equipment.schema.Table] instance.\n\n    Args:\n        element: A [table][type_table] XML element from an equipment register.\n\n    Returns:\n        A [Table][msl.equipment.schema.Table] is an subclass of a numpy\n            [structured array][structured_arrays], where the `header` is used as\n            the *field names*. This allows for accessing a column by the header value rather than by\n            the index of a column. If you prefer to work with unstructured data, call\n            [unstructured][msl.equipment.schema.Table.unstructured] on the returned object.\n    \"\"\"\n    booleans = {\"True\", \"true\", \"TRUE\", \"1\", b\"True\", b\"true\", b\"TRUE\", b\"1\"}\n\n    def convert_bool(value: str | bytes) -&gt; bool:\n        # the value can be of type bytes for numpy &lt; 2.0\n        return value.strip() in booleans\n\n    def strip_string(value: str | bytes) -&gt; str:\n        # the value can be of type bytes for numpy &lt; 2.0\n        stripped = value.strip()\n        if isinstance(stripped, bytes):\n            return stripped.decode()  # pragma: no cover\n        return stripped\n\n    # Schema forces order\n    _type = [s.strip() for s in (element[0].text or \"\").split(\",\")]\n    _unit = [s.strip() for s in (element[1].text or \"\").split(\",\")]\n    _header = [s.strip() for s in (element[2].text or \"\").split(\",\")]\n    _file = StringIO((element[3].text or \"\").strip())\n\n    # must handle boolean column and string column separately\n    conv: dict[int, Callable[[str | bytes], str | bool]] = {\n        i: convert_bool for i, v in enumerate(_type) if v == \"bool\"\n    }\n    conv.update({i: strip_string for i, v in enumerate(_type) if v == \"string\"})\n\n    dtype = np.dtype([(h, schema_numpy_map[t]) for h, t in zip(_header, _type)])\n    data = np.loadtxt(_file, dtype=dtype, delimiter=\",\", converters=conv)  # type: ignore[arg-type]  # pyright: ignore[reportCallIssue, reportArgumentType, reportUnknownVariableType]\n    data.setflags(write=False)  # pyright: ignore[reportUnknownMemberType]\n\n    header = np.asarray(_header)\n    header.setflags(write=False)  # make it readonly by default\n\n    units = np.asarray(tuple(_unit), np.dtype([(h, object) for h in _header]))\n    units.setflags(write=False)  # make it readonly by default\n\n    assert data.dtype.fields is not None  # pyright: ignore[reportUnknownMemberType]  # noqa: S101\n    types = np.asarray(tuple(v[0] for v in data.dtype.fields.values()), dtype=[(h, object) for h in _header])  # pyright: ignore[reportUnknownMemberType, reportUnknownVariableType, reportUnknownArgumentType]\n    types.setflags(write=False)  # make it readonly by default\n\n    return cls(types=types, units=units, header=header, data=data, comment=element.attrib.get(\"comment\", \"\"))  # pyright: ignore[reportUnknownArgumentType]\n</code></pre>"},{"location":"schema/table/#msl.equipment.schema.Table.to_xml","title":"to_xml","text":"<pre><code>to_xml() -&gt; Element[str]\n</code></pre> <p>Convert the Table class into an XML element.</p> <p>Returns:</p> Type Description <code>Element[str]</code> <p>The Table as an XML element.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def to_xml(self) -&gt; Element[str]:\n    \"\"\"Convert the [Table][msl.equipment.schema.Table] class into an XML element.\n\n    Returns:\n        The [Table][msl.equipment.schema.Table] as an XML element.\n    \"\"\"\n    attrib = {\"comment\": self.comment} if self.comment else {}\n    e = Element(\"table\", attrib=attrib)\n\n    types = SubElement(e, \"type\")\n    dtypes = [numpy_schema_map[t.char] for t in self.types.tolist()]\n    types.text = \",\".join(dtypes)\n\n    units = SubElement(e, \"unit\")\n    units.text = \",\".join(self.units.tolist())\n\n    header = SubElement(e, \"header\")\n    header.text = \",\".join(self.header)\n\n    buffer = StringIO()\n    newline = \"\\n\" + \" \" * _Indent.table_data\n    np.savetxt(buffer, self, fmt=\"%s\", delimiter=\",\", newline=newline)\n    data = SubElement(e, \"data\")\n    data.text = buffer.getvalue().rstrip() + \"\\n\" + \" \" * max(0, _Indent.table_data - len(\"&lt;data&gt;\"))\n\n    return e\n</code></pre>"},{"location":"schema/table/#msl.equipment.schema.Table.unstructured","title":"unstructured","text":"<pre><code>unstructured(\n    *,\n    dtype: DTypeLike = None,\n    copy: bool = False,\n    casting: Literal[\n        \"no\", \"equiv\", \"safe\", \"same_kind\", \"unsafe\"\n    ] = \"unsafe\"\n) -&gt; NDArray[Any]\n</code></pre> <p>Converts the structured array into an unstructured array.</p> <p>See structured_to_unstructured for more details.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>DTypeLike</code> <p>The dtype of the output unstructured array.</p> <code>None</code> <code>copy</code> <code>bool</code> <p>If <code>True</code>, always return a copy. If <code>False</code>, a view is returned if possible.</p> <code>False</code> <code>casting</code> <code>Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe']</code> <p>Controls what kind of data casting may occur. See the casting argument of astype for more details.</p> <code>'unsafe'</code> <p>Returns:</p> Type Description <code>NDArray[Any]</code> <p>The unstructured array. This method may return a numpy ndarray instance instead of a Table instance if the table consists of numbers and strings and the appropriate <code>dtype</code> is not specified.</p> Source code in <code>src/msl/equipment/schema.py</code> <pre><code>def unstructured(\n    self,\n    *,\n    dtype: DTypeLike = None,\n    copy: bool = False,\n    casting: Literal[\"no\", \"equiv\", \"safe\", \"same_kind\", \"unsafe\"] = \"unsafe\",\n) -&gt; NDArray[_Any]:\n    \"\"\"Converts the structured array into an unstructured array.\n\n    See [structured_to_unstructured][numpy.lib.recfunctions.structured_to_unstructured]\n    for more details.\n\n    Args:\n        dtype: The _dtype_ of the output unstructured array.\n        copy: If `True`, always return a copy. If `False`, a view is returned if possible.\n        casting: Controls what kind of data casting may occur. See the *casting* argument of\n            [astype][numpy.ndarray.astype] for more details.\n\n    Returns:\n        The unstructured array. This method may return a numpy [ndarray][numpy.ndarray] instance\n            instead of a [Table][msl.equipment.schema.Table] instance if the table consists of\n            numbers and strings and the appropriate `dtype` is not specified.\n    \"\"\"\n    from numpy.lib.recfunctions import structured_to_unstructured  # noqa: PLC0415\n\n    try:\n        return structured_to_unstructured(self, dtype=dtype, copy=copy, casting=casting)\n    except (TypeError, ValueError):\n        return np.array(self.tolist(), dtype=object)\n</code></pre>"}]}